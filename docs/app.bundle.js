/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@babel/runtime/helpers/OverloadYield.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/OverloadYield.js ***!
  \**************************************************************/
/***/ ((module) => {

function _OverloadYield(e, d) {
  this.v = e, this.k = d;
}
module.exports = _OverloadYield, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _arrayLikeToArray)
/* harmony export */ });
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _arrayWithHoles)
/* harmony export */ });
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _arrayWithoutHoles)
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(r);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _assertThisInitialized)
/* harmony export */ });
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _asyncToGenerator)
/* harmony export */ });
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _classCallCheck)
/* harmony export */ });
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _createClass)
/* harmony export */ });
/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js");

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _defineProperty)
/* harmony export */ });
/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js");

function _defineProperty(e, r, t) {
  return (r = (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__["default"])(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/get.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/get.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _get)
/* harmony export */ });
/* harmony import */ var _superPropBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./superPropBase.js */ "./node_modules/@babel/runtime/helpers/esm/superPropBase.js");

function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {
    var p = (0,_superPropBase_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, _get.apply(null, arguments);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _getPrototypeOf)
/* harmony export */ });
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/inherits.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inherits.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _inherits)
/* harmony export */ });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(t, e);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _iterableToArray)
/* harmony export */ });
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _iterableToArrayLimit)
/* harmony export */ });
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _nonIterableRest)
/* harmony export */ });
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _nonIterableSpread)
/* harmony export */ });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _possibleConstructorReturn)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assertThisInitialized.js */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");


function _possibleConstructorReturn(t, e) {
  if (e && ("object" == (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return (0,_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__["default"])(t);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _setPrototypeOf)
/* harmony export */ });
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _slicedToArray)
/* harmony export */ });
/* harmony import */ var _arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithHoles.js */ "./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js");
/* harmony import */ var _iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArrayLimit.js */ "./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableRest.js */ "./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js");




function _slicedToArray(r, e) {
  return (0,_arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__["default"])(r) || (0,_iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__["default"])(r, e) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(r, e) || (0,_nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/superPropBase.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/superPropBase.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _superPropBase)
/* harmony export */ });
/* harmony import */ var _getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");

function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = (0,_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(t)););
  return t;
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _toConsumableArray)
/* harmony export */ });
/* harmony import */ var _arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");




function _toConsumableArray(r) {
  return (0,_arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__["default"])(r) || (0,_iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(r) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(r) || (0,_nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toPrimitive)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");

function toPrimitive(t, r) {
  if ("object" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toPropertyKey)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPrimitive.js */ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js");


function toPropertyKey(t) {
  var i = (0,_toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__["default"])(t, "string");
  return "symbol" == (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(i) ? i : i + "";
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _typeof)
/* harmony export */ });
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _unsupportedIterableToArray)
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(r, a) : void 0;
  }
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/regenerator.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/regenerator.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var regeneratorDefine = __webpack_require__(/*! ./regeneratorDefine.js */ "./node_modules/@babel/runtime/helpers/regeneratorDefine.js");
function _regenerator() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
  var e,
    t,
    r = "function" == typeof Symbol ? Symbol : {},
    n = r.iterator || "@@iterator",
    o = r.toStringTag || "@@toStringTag";
  function i(r, n, o, i) {
    var c = n && n.prototype instanceof Generator ? n : Generator,
      u = Object.create(c.prototype);
    return regeneratorDefine(u, "_invoke", function (r, n, o) {
      var i,
        c,
        u,
        f = 0,
        p = o || [],
        y = !1,
        G = {
          p: 0,
          n: 0,
          v: e,
          a: d,
          f: d.bind(e, 4),
          d: function d(t, r) {
            return i = t, c = 0, u = e, G.n = r, a;
          }
        };
      function d(r, n) {
        for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) {
          var o,
            i = p[t],
            d = G.p,
            l = i[2];
          r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0));
        }
        if (o || r > 1) return a;
        throw y = !0, n;
      }
      return function (o, p, l) {
        if (f > 1) throw TypeError("Generator is already running");
        for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) {
          i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u);
          try {
            if (f = 2, i) {
              if (c || (o = "next"), t = i[o]) {
                if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object");
                if (!t.done) return t;
                u = t.value, c < 2 && (c = 0);
              } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1);
              i = e;
            } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break;
          } catch (t) {
            i = e, c = 1, u = t;
          } finally {
            f = 1;
          }
        }
        return {
          value: t,
          done: y
        };
      };
    }(r, o, i), !0), u;
  }
  var a = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  t = Object.getPrototypeOf;
  var c = [][n] ? t(t([][n]())) : (regeneratorDefine(t = {}, n, function () {
      return this;
    }), t),
    u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
  function f(e) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, regeneratorDefine(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e;
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), regeneratorDefine(u), regeneratorDefine(u, o, "Generator"), regeneratorDefine(u, n, function () {
    return this;
  }), regeneratorDefine(u, "toString", function () {
    return "[object Generator]";
  }), (module.exports = _regenerator = function _regenerator() {
    return {
      w: i,
      m: f
    };
  }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
}
module.exports = _regenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/regeneratorAsync.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/regeneratorAsync.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var regeneratorAsyncGen = __webpack_require__(/*! ./regeneratorAsyncGen.js */ "./node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js");
function _regeneratorAsync(n, e, r, t, o) {
  var a = regeneratorAsyncGen(n, e, r, t, o);
  return a.next().then(function (n) {
    return n.done ? n.value : a.next();
  });
}
module.exports = _regeneratorAsync, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var regenerator = __webpack_require__(/*! ./regenerator.js */ "./node_modules/@babel/runtime/helpers/regenerator.js");
var regeneratorAsyncIterator = __webpack_require__(/*! ./regeneratorAsyncIterator.js */ "./node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js");
function _regeneratorAsyncGen(r, e, t, o, n) {
  return new regeneratorAsyncIterator(regenerator().w(r, e, t, o), n || Promise);
}
module.exports = _regeneratorAsyncGen, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var OverloadYield = __webpack_require__(/*! ./OverloadYield.js */ "./node_modules/@babel/runtime/helpers/OverloadYield.js");
var regeneratorDefine = __webpack_require__(/*! ./regeneratorDefine.js */ "./node_modules/@babel/runtime/helpers/regeneratorDefine.js");
function AsyncIterator(t, e) {
  function n(r, o, i, f) {
    try {
      var c = t[r](o),
        u = c.value;
      return u instanceof OverloadYield ? e.resolve(u.v).then(function (t) {
        n("next", t, i, f);
      }, function (t) {
        n("throw", t, i, f);
      }) : e.resolve(u).then(function (t) {
        c.value = t, i(c);
      }, function (t) {
        return n("throw", t, i, f);
      });
    } catch (t) {
      f(t);
    }
  }
  var r;
  this.next || (regeneratorDefine(AsyncIterator.prototype), regeneratorDefine(AsyncIterator.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function () {
    return this;
  })), regeneratorDefine(this, "_invoke", function (t, o, i) {
    function f() {
      return new e(function (e, r) {
        n(t, i, e, r);
      });
    }
    return r = r ? r.then(f, f) : f();
  }, !0);
}
module.exports = AsyncIterator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/regeneratorDefine.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/regeneratorDefine.js ***!
  \******************************************************************/
/***/ ((module) => {

function _regeneratorDefine(e, r, n, t) {
  var i = Object.defineProperty;
  try {
    i({}, "", {});
  } catch (e) {
    i = 0;
  }
  module.exports = _regeneratorDefine = function regeneratorDefine(e, r, n, t) {
    function o(r, n) {
      _regeneratorDefine(e, r, function (e) {
        return this._invoke(r, n, e);
      });
    }
    r ? i ? i(e, r, {
      value: n,
      enumerable: !t,
      configurable: !t,
      writable: !t
    }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2));
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _regeneratorDefine(e, r, n, t);
}
module.exports = _regeneratorDefine, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/regeneratorKeys.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/regeneratorKeys.js ***!
  \****************************************************************/
/***/ ((module) => {

function _regeneratorKeys(e) {
  var n = Object(e),
    r = [];
  for (var t in n) r.unshift(t);
  return function e() {
    for (; r.length;) if ((t = r.pop()) in n) return e.value = t, e.done = !1, e;
    return e.done = !0, e;
  };
}
module.exports = _regeneratorKeys, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/regeneratorRuntime.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/regeneratorRuntime.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var OverloadYield = __webpack_require__(/*! ./OverloadYield.js */ "./node_modules/@babel/runtime/helpers/OverloadYield.js");
var regenerator = __webpack_require__(/*! ./regenerator.js */ "./node_modules/@babel/runtime/helpers/regenerator.js");
var regeneratorAsync = __webpack_require__(/*! ./regeneratorAsync.js */ "./node_modules/@babel/runtime/helpers/regeneratorAsync.js");
var regeneratorAsyncGen = __webpack_require__(/*! ./regeneratorAsyncGen.js */ "./node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js");
var regeneratorAsyncIterator = __webpack_require__(/*! ./regeneratorAsyncIterator.js */ "./node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js");
var regeneratorKeys = __webpack_require__(/*! ./regeneratorKeys.js */ "./node_modules/@babel/runtime/helpers/regeneratorKeys.js");
var regeneratorValues = __webpack_require__(/*! ./regeneratorValues.js */ "./node_modules/@babel/runtime/helpers/regeneratorValues.js");
function _regeneratorRuntime() {
  "use strict";

  var r = regenerator(),
    e = r.m(_regeneratorRuntime),
    t = (Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.__proto__).constructor;
  function n(r) {
    var e = "function" == typeof r && r.constructor;
    return !!e && (e === t || "GeneratorFunction" === (e.displayName || e.name));
  }
  var o = {
    "throw": 1,
    "return": 2,
    "break": 3,
    "continue": 3
  };
  function a(r) {
    var e, t;
    return function (n) {
      e || (e = {
        stop: function stop() {
          return t(n.a, 2);
        },
        "catch": function _catch() {
          return n.v;
        },
        abrupt: function abrupt(r, e) {
          return t(n.a, o[r], e);
        },
        delegateYield: function delegateYield(r, o, a) {
          return e.resultName = o, t(n.d, regeneratorValues(r), a);
        },
        finish: function finish(r) {
          return t(n.f, r);
        }
      }, t = function t(r, _t, o) {
        n.p = e.prev, n.n = e.next;
        try {
          return r(_t, o);
        } finally {
          e.next = n.n;
        }
      }), e.resultName && (e[e.resultName] = n.v, e.resultName = void 0), e.sent = n.v, e.next = n.n;
      try {
        return r.call(this, e);
      } finally {
        n.p = e.prev, n.n = e.next;
      }
    };
  }
  return (module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
    return {
      wrap: function wrap(e, t, n, o) {
        return r.w(a(e), t, n, o && o.reverse());
      },
      isGeneratorFunction: n,
      mark: r.m,
      awrap: function awrap(r, e) {
        return new OverloadYield(r, e);
      },
      AsyncIterator: regeneratorAsyncIterator,
      async: function async(r, e, t, o, u) {
        return (n(e) ? regeneratorAsyncGen : regeneratorAsync)(a(r), e, t, o, u);
      },
      keys: regeneratorKeys,
      values: regeneratorValues
    };
  }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
}
module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/regeneratorValues.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/regeneratorValues.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"]);
function _regeneratorValues(e) {
  if (null != e) {
    var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"],
      r = 0;
    if (t) return t.call(e);
    if ("function" == typeof e.next) return e;
    if (!isNaN(e.length)) return {
      next: function next() {
        return e && r >= e.length && (e = void 0), {
          value: e && e[r++],
          done: !e
        };
      }
    };
  }
  throw new TypeError(_typeof(e) + " is not iterable");
}
module.exports = _regeneratorValues, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ ((module) => {

function _typeof(o) {
  "@babel/helpers - typeof";

  return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// TODO(Babel 8): Remove this file.

var runtime = __webpack_require__(/*! ../helpers/regeneratorRuntime */ "./node_modules/@babel/runtime/helpers/regeneratorRuntime.js")();
module.exports = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ "./node_modules/axios/lib/adapters/adapters.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/adapters/adapters.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _http_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./http.js */ "./node_modules/axios/lib/helpers/null.js");
/* harmony import */ var _xhr_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./xhr.js */ "./node_modules/axios/lib/adapters/xhr.js");
/* harmony import */ var _fetch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fetch.js */ "./node_modules/axios/lib/adapters/fetch.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");






/**
 * Known adapters mapping.
 * Provides environment-specific adapters for Axios:
 * - `http` for Node.js
 * - `xhr` for browsers
 * - `fetch` for fetch API-based requests
 * 
 * @type {Object<string, Function|Object>}
 */
const knownAdapters = {
  http: _http_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  xhr: _xhr_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  fetch: {
    get: _fetch_js__WEBPACK_IMPORTED_MODULE_3__.getFetch,
  }
};

// Assign adapter names for easier debugging and identification
_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', { value });
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', { value });
  }
});

/**
 * Render a rejection reason string for unknown or unsupported adapters
 * 
 * @param {string} reason
 * @returns {string}
 */
const renderReason = (reason) => `- ${reason}`;

/**
 * Check if the adapter is resolved (function, null, or false)
 * 
 * @param {Function|null|false} adapter
 * @returns {boolean}
 */
const isResolvedHandle = (adapter) => _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(adapter) || adapter === null || adapter === false;

/**
 * Get the first suitable adapter from the provided list.
 * Tries each adapter in order until a supported one is found.
 * Throws an AxiosError if no adapter is suitable.
 * 
 * @param {Array<string|Function>|string|Function} adapters - Adapter(s) by name or function.
 * @param {Object} config - Axios request configuration
 * @throws {AxiosError} If no suitable adapter is available
 * @returns {Function} The resolved adapter function
 */
function getAdapter(adapters, config) {
  adapters = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(adapters) ? adapters : [adapters];

  const { length } = adapters;
  let nameOrAdapter;
  let adapter;

  const rejectedReasons = {};

  for (let i = 0; i < length; i++) {
    nameOrAdapter = adapters[i];
    let id;

    adapter = nameOrAdapter;

    if (!isResolvedHandle(nameOrAdapter)) {
      adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

      if (adapter === undefined) {
        throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__["default"](`Unknown adapter '${id}'`);
      }
    }

    if (adapter && (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(adapter) || (adapter = adapter.get(config)))) {
      break;
    }

    rejectedReasons[id || '#' + i] = adapter;
  }

  if (!adapter) {
    const reasons = Object.entries(rejectedReasons)
      .map(([id, state]) => `adapter ${id} ` +
        (state === false ? 'is not supported by the environment' : 'is not available in the build')
      );

    let s = length ?
      (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
      'as no adapter specified';

    throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__["default"](
      `There is no suitable adapter to dispatch the request ` + s,
      'ERR_NOT_SUPPORT'
    );
  }

  return adapter;
}

/**
 * Exports Axios adapters and utility to resolve an adapter
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Resolve an adapter from a list of adapter names or functions.
   * @type {Function}
   */
  getAdapter,

  /**
   * Exposes all known adapters
   * @type {Object<string, Function|Object>}
   */
  adapters: knownAdapters
});


/***/ }),

/***/ "./node_modules/axios/lib/adapters/fetch.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/adapters/fetch.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getFetch: () => (/* binding */ getFetch)
/* harmony export */ });
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _helpers_composeSignals_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/composeSignals.js */ "./node_modules/axios/lib/helpers/composeSignals.js");
/* harmony import */ var _helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/trackStream.js */ "./node_modules/axios/lib/helpers/trackStream.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/progressEventReducer.js */ "./node_modules/axios/lib/helpers/progressEventReducer.js");
/* harmony import */ var _helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/resolveConfig.js */ "./node_modules/axios/lib/helpers/resolveConfig.js");
/* harmony import */ var _core_settle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/settle.js */ "./node_modules/axios/lib/core/settle.js");










const DEFAULT_CHUNK_SIZE = 64 * 1024;

const {isFunction} = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"];

const globalFetchAPI = (({Request, Response}) => ({
  Request, Response
}))(_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].global);

const {
  ReadableStream, TextEncoder
} = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].global;


const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false
  }
}

const factory = (env) => {
  env = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].merge.call({
    skipUndefined: true
  }, globalFetchAPI, env);

  const {fetch: envFetch, Request, Response} = env;
  const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === 'function';
  const isRequestSupported = isFunction(Request);
  const isResponseSupported = isFunction(Response);

  if (!isFetchSupported) {
    return false;
  }

  const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream);

  const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
      ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
      async (str) => new Uint8Array(await new Request(str).arrayBuffer())
  );

  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
    let duplexAccessed = false;

    const hasContentType = new Request(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin, {
      body: new ReadableStream(),
      method: 'POST',
      get duplex() {
        duplexAccessed = true;
        return 'half';
      },
    }).headers.has('Content-Type');

    return duplexAccessed && !hasContentType;
  });

  const supportsResponseStream = isResponseSupported && isReadableStreamSupported &&
    test(() => _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isReadableStream(new Response('').body));

  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };

  isFetchSupported && ((() => {
    ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
      !resolvers[type] && (resolvers[type] = (res, config) => {
        let method = res && res[type];

        if (method) {
          return method.call(res);
        }

        throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"](`Response type '${type}' is not supported`, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERR_NOT_SUPPORT, config);
      })
    });
  })());

  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isBlob(body)) {
      return body.size;
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isSpecCompliantForm(body)) {
      const _request = new Request(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin, {
        method: 'POST',
        body,
      });
      return (await _request.arrayBuffer()).byteLength;
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isArrayBufferView(body) || _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isArrayBuffer(body)) {
      return body.byteLength;
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isURLSearchParams(body)) {
      body = body + '';
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  }

  const resolveBodyLength = async (headers, body) => {
    const length = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].toFiniteNumber(headers.getContentLength());

    return length == null ? getBodyLength(body) : length;
  }

  return async (config) => {
    let {
      url,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = 'same-origin',
      fetchOptions
    } = (0,_helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_7__["default"])(config);

    let _fetch = envFetch || fetch;

    responseType = responseType ? (responseType + '').toLowerCase() : 'text';

    let composedSignal = (0,_helpers_composeSignals_js__WEBPACK_IMPORTED_MODULE_3__["default"])([signal, cancelToken && cancelToken.toAbortSignal()], timeout);

    let request = null;

    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });

    let requestContentLength;

    try {
      if (
        onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
        (requestContentLength = await resolveBodyLength(headers, data)) !== 0
      ) {
        let _request = new Request(url, {
          method: 'POST',
          body: data,
          duplex: "half"
        });

        let contentTypeHeader;

        if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
          headers.setContentType(contentTypeHeader)
        }

        if (_request.body) {
          const [onProgress, flush] = (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__.progressEventDecorator)(
            requestContentLength,
            (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__.progressEventReducer)((0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__.asyncDecorator)(onUploadProgress))
          );

          data = (0,_helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_4__.trackStream)(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }

      if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isString(withCredentials)) {
        withCredentials = withCredentials ? 'include' : 'omit';
      }

      // Cloudflare Workers throws when credentials are defined
      // see https://github.com/cloudflare/workerd/issues/902
      const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;

      const resolvedOptions = {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : undefined
      };

      request = isRequestSupported && new Request(url, resolvedOptions);

      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));

      const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

      if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
        const options = {};

        ['status', 'statusText', 'headers'].forEach(prop => {
          options[prop] = response[prop];
        });

        const responseContentLength = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].toFiniteNumber(response.headers.get('content-length'));

        const [onProgress, flush] = onDownloadProgress && (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__.progressEventDecorator)(
          responseContentLength,
          (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__.progressEventReducer)((0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__.asyncDecorator)(onDownloadProgress), true)
        ) || [];

        response = new Response(
          (0,_helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_4__.trackStream)(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }

      responseType = responseType || 'text';

      let responseData = await resolvers[_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].findKey(resolvers, responseType) || 'text'](response, config);

      !isStreamResponse && unsubscribe && unsubscribe();

      return await new Promise((resolve, reject) => {
        (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_8__["default"])(resolve, reject, {
          data: responseData,
          headers: _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_5__["default"].from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        })
      })
    } catch (err) {
      unsubscribe && unsubscribe();

      if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"]('Network Error', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERR_NETWORK, config, request),
          {
            cause: err.cause || err
          }
        )
      }

      throw _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].from(err, err && err.code, config, request);
    }
  }
}

const seedCache = new Map();

const getFetch = (config) => {
  let env = (config && config.env) || {};
  const {fetch, Request, Response} = env;
  const seeds = [
    Request, Response, fetch
  ];

  let len = seeds.length, i = len,
    seed, target, map = seedCache;

  while (i--) {
    seed = seeds[i];
    target = map.get(seed);

    target === undefined && map.set(seed, target = (i ? new Map() : factory(env)))

    map = target;
  }

  return target;
};

const adapter = getFetch();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (adapter);


/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_settle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../core/settle.js */ "./node_modules/axios/lib/core/settle.js");
/* harmony import */ var _defaults_transitional_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../defaults/transitional.js */ "./node_modules/axios/lib/defaults/transitional.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _helpers_parseProtocol_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/parseProtocol.js */ "./node_modules/axios/lib/helpers/parseProtocol.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/progressEventReducer.js */ "./node_modules/axios/lib/helpers/progressEventReducer.js");
/* harmony import */ var _helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../helpers/resolveConfig.js */ "./node_modules/axios/lib/helpers/resolveConfig.js");











const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = (0,_helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_9__["default"])(config);
    let requestData = _config.data;
    const requestHeaders = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_7__["default"].from(_config.headers).normalize();
    let {responseType, onUploadProgress, onDownloadProgress} = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;

    function done() {
      flushUpload && flushUpload(); // flush events
      flushDownload && flushDownload(); // flush events

      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
    }

    let request = new XMLHttpRequest();

    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_7__["default"].from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"]('Request aborted', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
  request.onerror = function handleError(event) {
       // Browsers deliver a ProgressEvent in XHR onerror
       // (message may be empty; when present, surface it)
       // See https://developer.mozilla.org/docs/Web/API/XMLHttpRequest/error_event
       const msg = event && event.message ? event.message : 'Network Error';
       const err = new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"](msg, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERR_NETWORK, config, request);
       // attach the underlying event for consumers who want details
       err.event = event || null;
       reject(err);
       request = null;
    };
    
    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || _defaults_transitional_js__WEBPACK_IMPORTED_MODULE_2__["default"];
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"](
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ETIMEDOUT : _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (onDownloadProgress) {
      ([downloadThrottled, flushDownload] = (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_8__.progressEventReducer)(onDownloadProgress, true));
      request.addEventListener('progress', downloadThrottled);
    }

    // Not all browsers support upload events
    if (onUploadProgress && request.upload) {
      ([uploadThrottled, flushUpload] = (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_8__.progressEventReducer)(onUploadProgress));

      request.upload.addEventListener('progress', uploadThrottled);

      request.upload.addEventListener('loadend', flushUpload);
    }

    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_4__["default"](null, config, request) : cancel);
        request.abort();
        request = null;
      };

      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = (0,_helpers_parseProtocol_js__WEBPACK_IMPORTED_MODULE_5__["default"])(_config.url);

    if (protocol && _platform_index_js__WEBPACK_IMPORTED_MODULE_6__["default"].protocols.indexOf(protocol) === -1) {
      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"]('Unsupported protocol ' + protocol + ':', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
});


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _helpers_bind_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/bind.js */ "./node_modules/axios/lib/helpers/bind.js");
/* harmony import */ var _core_Axios_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/Axios.js */ "./node_modules/axios/lib/core/Axios.js");
/* harmony import */ var _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/mergeConfig.js */ "./node_modules/axios/lib/core/mergeConfig.js");
/* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./defaults/index.js */ "./node_modules/axios/lib/defaults/index.js");
/* harmony import */ var _helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helpers/formDataToJSON.js */ "./node_modules/axios/lib/helpers/formDataToJSON.js");
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _cancel_CancelToken_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cancel/CancelToken.js */ "./node_modules/axios/lib/cancel/CancelToken.js");
/* harmony import */ var _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cancel/isCancel.js */ "./node_modules/axios/lib/cancel/isCancel.js");
/* harmony import */ var _env_data_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./env/data.js */ "./node_modules/axios/lib/env/data.js");
/* harmony import */ var _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./helpers/toFormData.js */ "./node_modules/axios/lib/helpers/toFormData.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _helpers_spread_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./helpers/spread.js */ "./node_modules/axios/lib/helpers/spread.js");
/* harmony import */ var _helpers_isAxiosError_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./helpers/isAxiosError.js */ "./node_modules/axios/lib/helpers/isAxiosError.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./adapters/adapters.js */ "./node_modules/axios/lib/adapters/adapters.js");
/* harmony import */ var _helpers_HttpStatusCode_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./helpers/HttpStatusCode.js */ "./node_modules/axios/lib/helpers/HttpStatusCode.js");




















/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new _core_Axios_js__WEBPACK_IMPORTED_MODULE_2__["default"](defaultConfig);
  const instance = (0,_helpers_bind_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_core_Axios_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.request, context);

  // Copy axios.prototype to instance
  _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].extend(instance, _core_Axios_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype, context, {allOwnKeys: true});

  // Copy context to instance
  _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance((0,_core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__["default"])(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(_defaults_index_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

// Expose Axios class to allow class inheritance
axios.Axios = _core_Axios_js__WEBPACK_IMPORTED_MODULE_2__["default"];

// Expose Cancel & CancelToken
axios.CanceledError = _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_6__["default"];
axios.CancelToken = _cancel_CancelToken_js__WEBPACK_IMPORTED_MODULE_7__["default"];
axios.isCancel = _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_8__["default"];
axios.VERSION = _env_data_js__WEBPACK_IMPORTED_MODULE_9__.VERSION;
axios.toFormData = _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_10__["default"];

// Expose AxiosError class
axios.AxiosError = _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_11__["default"];

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = _helpers_spread_js__WEBPACK_IMPORTED_MODULE_12__["default"];

// Expose isAxiosError
axios.isAxiosError = _helpers_isAxiosError_js__WEBPACK_IMPORTED_MODULE_13__["default"];

// Expose mergeConfig
axios.mergeConfig = _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__["default"];

axios.AxiosHeaders = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_14__["default"];

axios.formToJSON = thing => (0,_helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_5__["default"])(_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isHTMLForm(thing) ? new FormData(thing) : thing);

axios.getAdapter = _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_15__["default"].getAdapter;

axios.HttpStatusCode = _helpers_HttpStatusCode_js__WEBPACK_IMPORTED_MODULE_16__["default"];

axios.default = axios;

// this module should only have a default export
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (axios);


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CanceledError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");




/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new _CanceledError_js__WEBPACK_IMPORTED_MODULE_0__["default"](message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  toAbortSignal() {
    const controller = new AbortController();

    const abort = (err) => {
      controller.abort(err);
    };

    this.subscribe(abort);

    controller.signal.unsubscribe = () => this.unsubscribe(abort);

    return controller.signal;
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CancelToken);


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CanceledError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CanceledError.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");





/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].call(this, message == null ? 'canceled' : message, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].inherits(CanceledError, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"], {
  __CANCEL__: true
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanceledError);


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isCancel)
/* harmony export */ });


function isCancel(value) {
  return !!(value && value.__CANCEL__);
}


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _helpers_buildURL_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/buildURL.js */ "./node_modules/axios/lib/helpers/buildURL.js");
/* harmony import */ var _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InterceptorManager.js */ "./node_modules/axios/lib/core/InterceptorManager.js");
/* harmony import */ var _dispatchRequest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dispatchRequest.js */ "./node_modules/axios/lib/core/dispatchRequest.js");
/* harmony import */ var _mergeConfig_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mergeConfig.js */ "./node_modules/axios/lib/core/mergeConfig.js");
/* harmony import */ var _buildFullPath_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./buildFullPath.js */ "./node_modules/axios/lib/core/buildFullPath.js");
/* harmony import */ var _helpers_validator_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/validator.js */ "./node_modules/axios/lib/helpers/validator.js");
/* harmony import */ var _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");











const validators = _helpers_validator_js__WEBPACK_IMPORTED_MODULE_6__["default"].validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_2__["default"](),
      response: new _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_2__["default"]()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};

        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = (0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_4__["default"])(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      _helpers_validator_js__WEBPACK_IMPORTED_MODULE_6__["default"].assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        }
      } else {
        _helpers_validator_js__WEBPACK_IMPORTED_MODULE_6__["default"].assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.allowAbsoluteUrls
    if (config.allowAbsoluteUrls !== undefined) {
      // do nothing
    } else if (this.defaults.allowAbsoluteUrls !== undefined) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }

    _helpers_validator_js__WEBPACK_IMPORTED_MODULE_6__["default"].assertOptions(config, {
      baseUrl: validators.spelling('baseURL'),
      withXsrfToken: validators.spelling('withXSRFToken')
    }, true);

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].merge(
      headers.common,
      headers[config.method]
    );

    headers && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_7__["default"].concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [_dispatchRequest_js__WEBPACK_IMPORTED_MODULE_3__["default"].bind(this), undefined];
      chain.unshift(...requestInterceptorChain);
      chain.push(...responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = _dispatchRequest_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = (0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_4__["default"])(this.defaults, config);
    const fullPath = (0,_buildFullPath_js__WEBPACK_IMPORTED_MODULE_5__["default"])(config.baseURL, config.url, config.allowAbsoluteUrls);
    return (0,_helpers_buildURL_js__WEBPACK_IMPORTED_MODULE_1__["default"])(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request((0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_4__["default"])(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request((0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_4__["default"])(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Axios);


/***/ }),

/***/ "./node_modules/axios/lib/core/AxiosError.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/core/AxiosError.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");




/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}

_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});

const prototype = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);

  _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  const msg = error && error.message ? error.message : 'Error';

  // Prefer explicit code; otherwise copy the low-level error's code (e.g. ECONNREFUSED)
  const errCode = code == null && error ? error.code : code;
  AxiosError.call(axiosError, msg, errCode, config, request, response);

  // Chain the original error on the standard field; non-enumerable to avoid JSON noise
  if (error && axiosError.cause == null) {
    Object.defineProperty(axiosError, 'cause', { value: error, configurable: true });
  }

  axiosError.name = (error && error.name) || 'Error';

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxiosError);


/***/ }),

/***/ "./node_modules/axios/lib/core/AxiosHeaders.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/AxiosHeaders.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _helpers_parseHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/parseHeaders.js */ "./node_modules/axios/lib/helpers/parseHeaders.js");





const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(value)) return;

  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite)
    } else if(_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders((0,_helpers_parseHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"])(header), valueOrRewrite);
    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(header) && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(entry)) {
          throw TypeError('Object iterator must return a key-value pair');
        }

        obj[key = entry[0]] = (dest = obj[key]) ?
          (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];
      }

      setHeaders(obj, valueOrRewrite)
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(this, (value, header) => {
      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  getSetCookie() {
    return this.get("set-cookie") || [];
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  }
});

_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].freezeMethods(AxiosHeaders);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxiosHeaders);


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");




class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {void}
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InterceptorManager);


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildFullPath)
/* harmony export */ });
/* harmony import */ var _helpers_isAbsoluteURL_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/isAbsoluteURL.js */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
/* harmony import */ var _helpers_combineURLs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/combineURLs.js */ "./node_modules/axios/lib/helpers/combineURLs.js");





/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !(0,_helpers_isAbsoluteURL_js__WEBPACK_IMPORTED_MODULE_0__["default"])(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return (0,_helpers_combineURLs_js__WEBPACK_IMPORTED_MODULE_1__["default"])(baseURL, requestedURL);
  }
  return requestedURL;
}


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ dispatchRequest)
/* harmony export */ });
/* harmony import */ var _transformData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transformData.js */ "./node_modules/axios/lib/core/transformData.js");
/* harmony import */ var _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cancel/isCancel.js */ "./node_modules/axios/lib/cancel/isCancel.js");
/* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../defaults/index.js */ "./node_modules/axios/lib/defaults/index.js");
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../adapters/adapters.js */ "./node_modules/axios/lib/adapters/adapters.js");









/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_3__["default"](null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_4__["default"].from(config.headers);

  // Transform request data
  config.data = _transformData_js__WEBPACK_IMPORTED_MODULE_0__["default"].call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_5__["default"].getAdapter(config.adapter || _defaults_index_js__WEBPACK_IMPORTED_MODULE_2__["default"].adapter, config);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = _transformData_js__WEBPACK_IMPORTED_MODULE_0__["default"].call(
      config,
      config.transformResponse,
      response
    );

    response.headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_4__["default"].from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!(0,_cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_1__["default"])(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = _transformData_js__WEBPACK_IMPORTED_MODULE_0__["default"].call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_4__["default"].from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergeConfig)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");





const headersToObject = (thing) => thing instanceof _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"] ? { ...thing } : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, prop, caseless) {
    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isPlainObject(target) && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isPlainObject(source)) {
      return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].merge.call({caseless}, target, source);
    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isPlainObject(source)) {
      return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].merge({}, source);
    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(a)) {
      return getMergedValue(undefined, a, prop, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };

  _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(Object.keys({...config1, ...config2}), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ settle)
/* harmony export */ });
/* harmony import */ var _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");




/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"](
      'Request failed with status code ' + response.status,
      [_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERR_BAD_REQUEST, _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ transformData)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../defaults/index.js */ "./node_modules/axios/lib/defaults/index.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");






/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || _defaults_index_js__WEBPACK_IMPORTED_MODULE_1__["default"];
  const context = response || config;
  const headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_2__["default"].from(context.headers);
  let data = context.data;

  _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}


/***/ }),

/***/ "./node_modules/axios/lib/defaults/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/defaults/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _transitional_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transitional.js */ "./node_modules/axios/lib/defaults/transitional.js");
/* harmony import */ var _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/toFormData.js */ "./node_modules/axios/lib/helpers/toFormData.js");
/* harmony import */ var _helpers_toURLEncodedForm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/toURLEncodedForm.js */ "./node_modules/axios/lib/helpers/toURLEncodedForm.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/formDataToJSON.js */ "./node_modules/axios/lib/helpers/formDataToJSON.js");










/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: _transitional_js__WEBPACK_IMPORTED_MODULE_2__["default"],

  adapter: ['xhr', 'http', 'fetch'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(data);

    if (isObjectPayload && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify((0,_helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_6__["default"])(data)) : data;
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArrayBuffer(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBuffer(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isStream(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFile(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBlob(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isReadableStream(data)
    ) {
      return data;
    }
    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArrayBufferView(data)) {
      return data.buffer;
    }
    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return (0,_helpers_toURLEncodedForm_js__WEBPACK_IMPORTED_MODULE_4__["default"])(data, this.formSerializer).toString();
      }

      if ((isFileList = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return (0,_helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isResponse(data) || _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isReadableStream(data)) {
      return data;
    }

    if (data && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data, this.parseReviver);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(e, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: _platform_index_js__WEBPACK_IMPORTED_MODULE_5__["default"].classes.FormData,
    Blob: _platform_index_js__WEBPACK_IMPORTED_MODULE_5__["default"].classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};

_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
  defaults.headers[method] = {};
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defaults);


/***/ }),

/***/ "./node_modules/axios/lib/defaults/transitional.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/defaults/transitional.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
});


/***/ }),

/***/ "./node_modules/axios/lib/env/data.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/env/data.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VERSION: () => (/* binding */ VERSION)
/* harmony export */ });
const VERSION = "1.13.1";

/***/ }),

/***/ "./node_modules/axios/lib/helpers/AxiosURLSearchParams.js":
/*!****************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toFormData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toFormData.js */ "./node_modules/axios/lib/helpers/toFormData.js");




/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && (0,_toFormData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxiosURLSearchParams);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/HttpStatusCode.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/HttpStatusCode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
  WebServerIsDown: 521,
  ConnectionTimedOut: 522,
  OriginIsUnreachable: 523,
  TimeoutOccurred: 524,
  SslHandshakeFailed: 525,
  InvalidSslCertificate: 526,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HttpStatusCode);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ bind)
/* harmony export */ });


/**
 * Create a bound version of a function with a specified `this` context
 *
 * @param {Function} fn - The function to bind
 * @param {*} thisArg - The value to be passed as the `this` parameter
 * @returns {Function} A new function that will call the original function with the specified `this` context
 */
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildURL)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/AxiosURLSearchParams.js */ "./node_modules/axios/lib/helpers/AxiosURLSearchParams.js");





/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?(object|Function)} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode;

  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(options)) {
    options = {
      serialize: options
    };
  } 

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isURLSearchParams(params) ?
      params.toString() :
      new _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_1__["default"](params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ combineURLs)
/* harmony export */ });


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/composeSignals.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/composeSignals.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");




const composeSignals = (signals, timeout) => {
  const {length} = (signals = signals ? signals.filter(Boolean) : []);

  if (timeout || length) {
    let controller = new AbortController();

    let aborted;

    const onabort = function (reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"] ? err : new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_0__["default"](err instanceof Error ? err.message : err));
      }
    }

    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"](`timeout ${timeout} of ms exceeded`, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ETIMEDOUT))
    }, timeout)

    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach(signal => {
          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
        });
        signals = null;
      }
    }

    signals.forEach((signal) => signal.addEventListener('abort', onabort));

    const {signal} = controller;

    signal.unsubscribe = () => _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].asap(unsubscribe);

    return signal;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (composeSignals);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_platform_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure, sameSite) {
      if (typeof document === 'undefined') return;

      const cookie = [`${name}=${encodeURIComponent(value)}`];

      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isNumber(expires)) {
        cookie.push(`expires=${new Date(expires).toUTCString()}`);
      }
      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(path)) {
        cookie.push(`path=${path}`);
      }
      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(domain)) {
        cookie.push(`domain=${domain}`);
      }
      if (secure === true) {
        cookie.push('secure');
      }
      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(sameSite)) {
        cookie.push(`SameSite=${sameSite}`);
      }

      document.cookie = cookie.join('; ');
    },

    read(name) {
      if (typeof document === 'undefined') return null;
      const match = document.cookie.match(new RegExp('(?:^|; )' + name + '=([^;]*)'));
      return match ? decodeURIComponent(match[1]) : null;
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000, '/');
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  });



/***/ }),

/***/ "./node_modules/axios/lib/helpers/formDataToJSON.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/formDataToJSON.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");




/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];

    if (name === '__proto__') return true;

    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(target) ? target.length : name;

    if (isLast) {
      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFormData(formData) && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(formData.entries)) {
    const obj = {};

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formDataToJSON);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isAbsoluteURL)
/* harmony export */ });


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isAxiosError)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");




/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(payload) && (payload.isAxiosError === true);
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {
  url = new URL(url, _platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin);

  return (
    origin.protocol === url.protocol &&
    origin.host === url.host &&
    (isMSIE || origin.port === url.port)
  );
})(
  new URL(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin),
  _platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].navigator && /(msie|trident)/i.test(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].navigator.userAgent)
) : () => true);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/null.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/null.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// eslint-disable-next-line strict
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (null);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");




// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
});


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseProtocol.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseProtocol.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ parseProtocol)
/* harmony export */ });


function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/progressEventReducer.js":
/*!****************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/progressEventReducer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asyncDecorator: () => (/* binding */ asyncDecorator),
/* harmony export */   progressEventDecorator: () => (/* binding */ progressEventDecorator),
/* harmony export */   progressEventReducer: () => (/* binding */ progressEventReducer)
/* harmony export */ });
/* harmony import */ var _speedometer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./speedometer.js */ "./node_modules/axios/lib/helpers/speedometer.js");
/* harmony import */ var _throttle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./throttle.js */ "./node_modules/axios/lib/helpers/throttle.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");




const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = (0,_speedometer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(50, 250);

  return (0,_throttle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? 'download' : 'upload']: true
    };

    listener(data);
  }, freq);
}

const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;

  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
}

const asyncDecorator = (fn) => (...args) => _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].asap(() => fn(...args));


/***/ }),

/***/ "./node_modules/axios/lib/helpers/resolveConfig.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/resolveConfig.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _isURLSameOrigin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isURLSameOrigin.js */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
/* harmony import */ var _cookies_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cookies.js */ "./node_modules/axios/lib/helpers/cookies.js");
/* harmony import */ var _core_buildFullPath_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/buildFullPath.js */ "./node_modules/axios/lib/core/buildFullPath.js");
/* harmony import */ var _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/mergeConfig.js */ "./node_modules/axios/lib/core/mergeConfig.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _buildURL_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./buildURL.js */ "./node_modules/axios/lib/helpers/buildURL.js");









/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((config) => {
  const newConfig = (0,_core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_5__["default"])({}, config);

  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;

  newConfig.headers = headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_6__["default"].from(headers);

  newConfig.url = (0,_buildURL_js__WEBPACK_IMPORTED_MODULE_7__["default"])((0,_core_buildFullPath_js__WEBPACK_IMPORTED_MODULE_4__["default"])(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' +
      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
    );
  }

  if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isFormData(data)) {
    if (_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasStandardBrowserEnv || _platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // browser handles it
    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isFunction(data.getHeaders)) {
      // Node.js FormData (like form-data package)
      const formHeaders = data.getHeaders();
      // Only set safe headers to avoid overwriting security headers
      const allowedHeaders = ['content-type', 'content-length'];
      Object.entries(formHeaders).forEach(([key, val]) => {
        if (allowedHeaders.includes(key.toLowerCase())) {
          headers.set(key, val);
        }
      });
    }
  }  

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasStandardBrowserEnv) {
    withXSRFToken && _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

    if (withXSRFToken || (withXSRFToken !== false && (0,_isURLSameOrigin_js__WEBPACK_IMPORTED_MODULE_2__["default"])(newConfig.url))) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && _cookies_js__WEBPACK_IMPORTED_MODULE_3__["default"].read(xsrfCookieName);

      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }

  return newConfig;
});



/***/ }),

/***/ "./node_modules/axios/lib/helpers/speedometer.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/speedometer.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (speedometer);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ spread)
/* harmony export */ });


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/throttle.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/throttle.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;

  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn(...args);
  }

  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if ( passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs)
        }, threshold - passed);
      }
    }
  }

  const flush = () => lastArgs && invoke(lastArgs);

  return [throttled, flush];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (throttle);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/toFormData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/toFormData.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _platform_node_classes_FormData_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/node/classes/FormData.js */ "./node_modules/axios/lib/helpers/null.js");




// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored


/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isPlainObject(thing) || _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(arr) && !arr.some(isVisitable);
}

const predicates = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toFlatObject(_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"], {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (_platform_node_classes_FormData_js__WEBPACK_IMPORTED_MODULE_2__["default"] || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isSpecCompliantForm(formData);

  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isDate(value)) {
      return value.toISOString();
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBoolean(value)) {
      return value.toString();
    }

    if (!useBlob && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBlob(value)) {
      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"]('Blob is not supported. Use a Buffer instead.');
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArrayBuffer(value) || _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(value) && isFlatArray(value)) ||
        ((_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFileList(value) || _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].endsWith(key, '[]')) && (arr = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(value, function each(el, key) {
      const result = !(_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(el) || el === null) && visitor.call(
        formData, el, _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toFormData);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/toURLEncodedForm.js":
/*!************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/toURLEncodedForm.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toURLEncodedForm)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _toFormData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toFormData.js */ "./node_modules/axios/lib/helpers/toFormData.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");






function toURLEncodedForm(data, options) {
  return (0,_toFormData_js__WEBPACK_IMPORTED_MODULE_1__["default"])(data, new _platform_index_js__WEBPACK_IMPORTED_MODULE_2__["default"].classes.URLSearchParams(), {
    visitor: function(value, key, path, helpers) {
      if (_platform_index_js__WEBPACK_IMPORTED_MODULE_2__["default"].isNode && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/trackStream.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/trackStream.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readBytes: () => (/* binding */ readBytes),
/* harmony export */   streamChunk: () => (/* binding */ streamChunk),
/* harmony export */   trackStream: () => (/* binding */ trackStream)
/* harmony export */ });

const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;

  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }

  let pos = 0;
  let end;

  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
}

const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
}

const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }

  const reader = stream.getReader();
  try {
    for (;;) {
      const {done, value} = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
}

const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);

  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  }

  return new ReadableStream({
    async pull(controller) {
      try {
        const {done, value} = await iterator.next();

        if (done) {
         _onFinish();
          controller.close();
          return;
        }

        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  })
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _env_data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env/data.js */ "./node_modules/axios/lib/env/data.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");





const validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + _env_data_js__WEBPACK_IMPORTED_MODULE_0__.VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"](
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    // eslint-disable-next-line no-console
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  }
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"]('options must be an object', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"]('option ' + opt + ' must be ' + result, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"]('Unknown option ' + opt, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERR_BAD_OPTION);
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  assertOptions,
  validators
});


/***/ }),

/***/ "./node_modules/axios/lib/platform/browser/classes/Blob.js":
/*!*****************************************************************!*\
  !*** ./node_modules/axios/lib/platform/browser/classes/Blob.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (typeof Blob !== 'undefined' ? Blob : null);


/***/ }),

/***/ "./node_modules/axios/lib/platform/browser/classes/FormData.js":
/*!*********************************************************************!*\
  !*** ./node_modules/axios/lib/platform/browser/classes/FormData.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (typeof FormData !== 'undefined' ? FormData : null);


/***/ }),

/***/ "./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js":
/*!****************************************************************************!*\
  !*** ./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../helpers/AxiosURLSearchParams.js */ "./node_modules/axios/lib/helpers/AxiosURLSearchParams.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (typeof URLSearchParams !== 'undefined' ? URLSearchParams : _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/axios/lib/platform/browser/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/platform/browser/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _classes_URLSearchParams_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classes/URLSearchParams.js */ "./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js");
/* harmony import */ var _classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/FormData.js */ "./node_modules/axios/lib/platform/browser/classes/FormData.js");
/* harmony import */ var _classes_Blob_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/Blob.js */ "./node_modules/axios/lib/platform/browser/classes/Blob.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  isBrowser: true,
  classes: {
    URLSearchParams: _classes_URLSearchParams_js__WEBPACK_IMPORTED_MODULE_0__["default"],
    FormData: _classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__["default"],
    Blob: _classes_Blob_js__WEBPACK_IMPORTED_MODULE_2__["default"]
  },
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
});


/***/ }),

/***/ "./node_modules/axios/lib/platform/common/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/platform/common/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hasBrowserEnv: () => (/* binding */ hasBrowserEnv),
/* harmony export */   hasStandardBrowserEnv: () => (/* binding */ hasStandardBrowserEnv),
/* harmony export */   hasStandardBrowserWebWorkerEnv: () => (/* binding */ hasStandardBrowserWebWorkerEnv),
/* harmony export */   navigator: () => (/* binding */ _navigator),
/* harmony export */   origin: () => (/* binding */ origin)
/* harmony export */ });
const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

const _navigator = typeof navigator === 'object' && navigator || undefined;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = hasBrowserEnv &&
  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();

const origin = hasBrowserEnv && window.location.href || 'http://localhost';




/***/ }),

/***/ "./node_modules/axios/lib/platform/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/platform/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node/index.js */ "./node_modules/axios/lib/platform/browser/index.js");
/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common/utils.js */ "./node_modules/axios/lib/platform/common/utils.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  ..._common_utils_js__WEBPACK_IMPORTED_MODULE_1__,
  ..._node_index_js__WEBPACK_IMPORTED_MODULE_0__["default"]
});


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_bind_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/bind.js */ "./node_modules/axios/lib/helpers/bind.js");




// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;
const {iterator, toStringTag} = Symbol;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
}

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
}

/**
 * Determine if a value is an empty object (safely handles Buffers)
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an empty object, otherwise false
 */
const isEmptyObject = (val) => {
  // Early return for non-objects or Buffers to prevent RangeError
  if (!isObject(val) || isBuffer(val)) {
    return false;
  }

  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e) {
    // Fallback for any other objects that might cause RangeError with Object.keys()
    return false;
  }
}

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Buffer check
    if (isBuffer(obj)) {
      return;
    }

    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  if (isBuffer(obj)){
    return null;
  }

  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless, skipUndefined} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  }

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = (0,_helpers_bind_js__WEBPACK_IMPORTED_MODULE_0__["default"])(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];

  const _iterator = generator.call(obj);

  let result;

  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
}

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
}

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
}

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  }

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
}

const noop = () => {}

const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
}



/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      //Buffer check
      if (isBuffer(source)) {
        return source;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  }

  return visit(obj, 0);
}

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }

  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({source, data}) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);

    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    }
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === 'function',
  isFunction(_global.postMessage)
);

const asap = typeof queueMicrotask !== 'undefined' ?
  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);

// *********************


const isIterable = (thing) => thing != null && isFunction(thing[iterator]);


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isEmptyObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
});


/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/App.vue?vue&type=script&lang=js":
/*!**********************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/App.vue?vue&type=script&lang=js ***!
  \**********************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _components_Bio__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/Bio */ "./src/components/Bio.vue");
/* harmony import */ var _components_Banner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/Banner */ "./src/components/Banner.vue");
/* harmony import */ var _components_Geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/Geometry */ "./src/components/Geometry.vue");
/* harmony import */ var _components_PortfolioList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/PortfolioList */ "./src/components/PortfolioList.vue");
/* harmony import */ var _components_Contact__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/Contact */ "./src/components/Contact.vue");
/* harmony import */ var _gsap_CustomEase__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! _gsap_/CustomEase */ "./src/assets/scripts/gsap/CustomEase.js");





// import 'babel-polyfill';

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'app',
  components: {
    Bio: _components_Bio__WEBPACK_IMPORTED_MODULE_0__["default"],
    Banner: _components_Banner__WEBPACK_IMPORTED_MODULE_1__["default"],
    Contact: _components_Contact__WEBPACK_IMPORTED_MODULE_4__["default"],
    Geometry: _components_Geometry__WEBPACK_IMPORTED_MODULE_2__["default"],
    PortfolioList: _components_PortfolioList__WEBPACK_IMPORTED_MODULE_3__["default"]
  },
  data: function data() {
    return {
      bioAnimation: null,
      bioTrigger: {
        trigger: "#bio",
        scrub: 1,
        start: "top top",
        end: "bottom top",
        snap: {
          snapTo: "labels",
          duration: {
            min: 0.6,
            max: 0.6
          },
          delay: 0.2
        }
      },
      content: 'portfolio',
      /*
      	contentPlaceholder allows for the desired content to be set/saved, while waiting for the leave animation
      	of the currently displayed html. When complete, the callback from the vue
      	transition element will update the this.content value to that of the placeholder, triggering the
      	animation to display the intended html.
      */
      contentPlaceHolder: ''
    };
  },
  computed: {},
  mounted: function mounted() {
    this.bioAnimation = new this.$data._gsap.TimelineMax({
      scrollTrigger: this.bioTrigger
    }).addLabel('in').fromTo('#bio-container .bio-animation-wrapper', {
      opacity: 1,
      rotationX: 0,
      scale: 1,
      y: 0,
      z: 0,
      transformOrigin: "50% 50% -100px"
    }, {
      opacity: 1,
      rotationX: 90,
      y: 100,
      z: -100,
      ease: _gsap_CustomEase__WEBPACK_IMPORTED_MODULE_5__["default"].create("custom", "M0,0 C0.126,0.382 0.216,0.692 0.374,0.84 0.566,1.02 0.818,1.001 1,1")
    }).fromTo('#bio-container .bio-animation-wrapper', {
      height: '160'
    }, {
      height: '0px',
      ease: _gsap_CustomEase__WEBPACK_IMPORTED_MODULE_5__["default"].create("custom", "M0,0 C0.172,0 0.288,0.154 0.34,0.222 0.756,0.768 0.604,0.988 1,1")
    }, '-=.5').addLabel('out');
  },
  methods: {
    updateCurrentContent: function updateCurrentContent() {
      console.log('The content has updated to: ', this.contentPlaceHolder);
      this.content = this.contentPlaceHolder;
    },
    setContent: function setContent(val) {
      console.log('content is gone and placeholder is: ', val);
      this.content = '';
      this.contentPlaceHolder = val;
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Banner.vue?vue&type=script&lang=js":
/*!************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Banner.vue?vue&type=script&lang=js ***!
  \************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/debounce.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/throttle.js");
/* harmony import */ var _mixins_cssVariables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! _mixins_/cssVariables */ "./src/mixins/cssVariables.vue");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'banner',
  mixins: [_mixins_cssVariables__WEBPACK_IMPORTED_MODULE_2__["default"]],
  data: function data() {
    return {
      clickHandler: (0,lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])(this.toggleMode, 300, {
        'leading': true,
        'trailing': false
      }),
      windowResizeScaleHandler: (0,lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])(this.setScale, 300, {
        'leading': false,
        'trailing': true
      }),
      mousemoveHandler: (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])(this.mouseAvoidAnimationHandler, 100),
      activeMode: 'dark',
      inactiveMode: 'light'
    };
  },
  beforeMount: function beforeMount() {
    window.addEventListener('resize', this.windowResizeScaleHandler);
    window.addEventListener('mousemove', this.mousemoveHandler);
  },
  mounted: function mounted() {
    this.setScale();
  },
  methods: {
    toggleMode: function toggleMode() {
      /*
      this.isLight = !this.isLight;
      let styles = document.getElementById('app').style;
      if (this.activeMode == 'light') {
      	this.activeMode = 'dark';
      	this.inactiveMode = 'light';
      }
      else if (this.activeMode == 'dark') {
      	this.activeMode = 'light';
      	this.inactiveMode = 'dark';
      }
      this.active.forEach(activeStyle => {
      	/*
      		if there is a css variable for the current mode, that matches the name of the active variable, update to that value
      		for example if the active variable is "--active-background-color" and the mode is "dark", look for "--dark-background-color"
      		via this['dark']["--dark-background-color"]
      	/
      	let currentModeColorValue = this[this.activeMode][activeStyle.replace('active', this.activeMode)];
      	if (currentModeColorValue) {
      		styles.setProperty(activeStyle, currentModeColorValue);
      	} 
      	/*
      		If there is not variable/value for the current mode matching the active variable name, then check if there is an inactive and swap to that
      		This allows for a 
      	/
      });
      this.inactive.forEach(inactiveStyle => {
      	styles.setProperty(inactiveStyle, this[this.inactiveMode][inactiveStyle.replace('inactive', this.inactiveMode)]);
      });
      */
      if (this.activeMode == 'light') {
        this.activeMode = 'dark';
        this.inactiveMode = 'light';
      } else if (this.activeMode == 'dark') {
        this.activeMode = 'light';
        this.inactiveMode = 'dark';
      }
      document.body.setAttribute('data-mode', this.activeMode);
      Array.from(document.querySelectorAll('.light')).forEach(function (el) {
        return el.classList.toggle('visible');
      });
      Array.from(document.querySelectorAll('.dark')).forEach(function (el) {
        return el.classList.toggle('visible');
      });
    },
    map: function map(x, in_min, in_max, out_min, out_max) {
      return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    },
    setScale: function setScale() {
      var styles = document.getElementById('app').style;
      var globalScale = Math.min(window.innerWidth, 1000) / 1000;
      styles.setProperty('--global-scale-to-window-width', globalScale);
      var bioScale = Math.min(window.innerWidth * 0.2, 100);
      styles.setProperty('--bio-placement', "".concat(bioScale, "px"));
    },
    mouseAvoidAnimationHandler: function mouseAvoidAnimationHandler(event) {
      var _this = this;
      //The tiny square at the top
      var square2DStyles = document.querySelectorAll('.square-2-d');
      var rightValue = this.map(event.clientX, 0, window.innerWidth, 240, 265);
      var curve1CStyles;
      var curve1CRotateValue;
      var square2CStyles;
      var square2CRotateXValue;
      var square2CTranslateYValue;
      if (!this.isInternetExplorer) {
        //the bottom left curve use in everything but IE
        curve1CStyles = document.querySelector('#curve-1-c').style;
        curve1CRotateValue = this.map(event.clientX, 0, window.innerWidth, 204, 123);
      } else {
        //The bottom left colored square used as a fallback for IE
        square2CStyles = document.querySelectorAll('.square-2-c');
        square2CRotateXValue = this.map(event.clientY, 0, window.innerHeight, -20, 28);
        square2CTranslateYValue = this.map(event.clientY, 0, window.innerHeight, -5, 20);
      }
      //The medium sized square on the right
      var square1BStyles = document.querySelectorAll('.square-1-b');
      var square1BRotateValue = this.map(event.clientX, 0, window.innerWidth, -45, 10);
      window.requestAnimationFrame(function () {
        //set both light and dark instance of the square
        square2DStyles[0].style.setProperty('--right', "".concat(rightValue, "px"));
        square2DStyles[1].style.setProperty('--right', "".concat(rightValue, "px"));
        if (!_this.isInternetExplorer) {
          curve1CStyles.setProperty('--rotate', "".concat(curve1CRotateValue, "deg"));
        } else {
          square2CStyles[0].style.setProperty('--rotateX', "".concat(square2CRotateXValue, "deg"));
          square2CStyles[1].style.setProperty('--translateY', "".concat(square2CTranslateYValue, "px"));
        }
        square1BStyles[0].style.setProperty('--rotate', "".concat(square1BRotateValue, "deg"));
        square1BStyles[1].style.setProperty('--rotate', "".concat(square1BRotateValue, "deg"));
      });
    }
  },
  watch: {}
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Bio.vue?vue&type=script&lang=js":
/*!*********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Bio.vue?vue&type=script&lang=js ***!
  \*********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'bio',
  data: function data() {
    return {
      topOfPageTimeline: null
    };
  },
  props: {
    setContent: {
      type: Function
    }
  },
  computed: {},
  mounted: function mounted() {},
  methods: {}
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Contact.vue?vue&type=script&lang=js":
/*!*************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Contact.vue?vue&type=script&lang=js ***!
  \*************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'contact',
  data: function data() {
    return {};
  },
  props: {},
  computed: {},
  mounted: function mounted() {},
  methods: {}
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Geometry.vue?vue&type=script&lang=js":
/*!**************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Geometry.vue?vue&type=script&lang=js ***!
  \**************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'geometryContainer',
  data: function data() {
    return {
      path: '',
      curveElements: [{
        id: 'curve-1-a',
        degree: 80,
        startDegree: 0
      }, {
        id: 'curve-1-b',
        degree: 80,
        startDegree: 45
      }, {
        id: 'curve-1-c',
        degree: 80,
        startDegree: 75
      }, {
        id: 'curve-2-a',
        degree: 130,
        startDegree: 20
      }, {
        id: 'curve-2-b',
        degree: 130,
        startDegree: 20
      }]
    };
  },
  mounted: function mounted() {},
  methods: {
    setClipPath: function setClipPath(degree, startDegree) {
      //start at center
      var path = '50% 50%';
      //add first point that matches the starting degree (0 = bottom, 90 = right, 180 = top, 270 = left, 360 = bottom)
      path += ",".concat(Math.floor(this.x(startDegree, 50)) + 50, "% ").concat(Math.floor(this.y(startDegree, 50)) + 50, "%");
      //add the corner points between the start and end degree, this prevents the arc from being cut off if it exceeds 180 degrees
      var closurePoints = [', 100% 100%', ', 100% 0%', ', 0% 0%', ', 0% 100%'];
      path += closurePoints.slice(Math.floor(startDegree / 90), Math.floor((degree + startDegree) / 90) + 1).join('');
      //add the final point
      path += ",".concat(Math.floor(this.x(degree + startDegree, 50)) + 50, "% ").concat(Math.floor(this.y(degree + startDegree, 50)) + 50, "%");
      return "clip-path: polygon(".concat(path, ")");
    },
    setClipPathSVG: function setClipPathSVG(degree, startDegree, asClipPathOnly) {
      // return '.5 .5, 0.5 1, 1 1, 1 .5, .5 .5';

      //start at center
      var path = '.5 .5';
      //add first point that matches the starting degree (0 = bottom, 90 = right, 180 = top, 270 = left, 360 = bottom)
      path += ",".concat(this.x(startDegree, .5) + .5, " ").concat(this.y(startDegree, .5) + .5);
      //add the corner points between the start and end degree, this prevents the arc from being cut off if it exceeds 180 degrees
      var closurePoints = [', 1 1', ', 1 0', ', 0 0', ', 0 1'];
      path += closurePoints.slice(Math.floor(startDegree / 90), Math.floor((degree + startDegree) / 90) + 1).join('');
      //add the final point
      path += ",".concat(this.x(degree + startDegree, .5) + .5, " ").concat(this.y(degree + startDegree, .5) + .5, ", 0.5 0.5");
      return path.replace(/\%/g, '');
    },
    x: function x(degree, radius) {
      return Math.sin(degree * (Math.PI / 180)) * radius;
    },
    y: function y(degree, radius) {
      return Math.cos(degree * (Math.PI / 180)) * radius;
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/PortfolioList.vue?vue&type=script&lang=js":
/*!*******************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/PortfolioList.vue?vue&type=script&lang=js ***!
  \*******************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _portfolio_CodePenCard_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./portfolio/CodePenCard.vue */ "./src/components/portfolio/CodePenCard.vue");
/* harmony import */ var _images_AnimationDemo_PNG__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! _images_/AnimationDemo.PNG */ "./src/assets/image/AnimationDemo.PNG");
/* harmony import */ var _images_brightland_jpg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! _images_/brightland.jpg */ "./src/assets/image/brightland.jpg");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'portfolio-list',
  components: {
    'CodePenCard': _portfolio_CodePenCard_vue__WEBPACK_IMPORTED_MODULE_0__["default"]
  },
  props: {
    summaryTrigger: {
      //The scroll trigger for the text at the beginning is the same as the bio trigger.
      //Both the bio and the portfolio summary text should animation from the same trigger.
      type: Object
    }
  },
  data: function data() {
    return {
      codePenCards: [{
        module: _portfolio_CodePenCard_vue__WEBPACK_IMPORTED_MODULE_0__["default"],
        url: 'https://brightlandlights.com/',
        imgUrl: _images_brightland_jpg__WEBPACK_IMPORTED_MODULE_2__,
        title: 'Brightland',
        id: 'brightland',
        description: 'A client project to promote their lighting decoration business.'
      }, {
        module: _portfolio_CodePenCard_vue__WEBPACK_IMPORTED_MODULE_0__["default"],
        url: 'https://jordanklaers.github.io/animationDemonstration/',
        imgUrl: _images_AnimationDemo_PNG__WEBPACK_IMPORTED_MODULE_1__,
        title: 'Animation Demo',
        id: 'animation-demo',
        description: 'A Collection of animations; transitions, keyframe, and requestAnimationFrame. For use in a knowledge share presentation.'
      }, {
        module: _portfolio_CodePenCard_vue__WEBPACK_IMPORTED_MODULE_0__["default"],
        url: 'https://codepen.io/jordanklaers/pen/xxKLReZ',
        imgUrl: 'https://assets.codepen.io/1379941/internal/screenshots/pens/xxKLReZ.default.png?fit=cover&format=auto&ha=false&height=540&quality=75&v=2&version=1587057955&width=960',
        title: 'Notification Widget',
        id: 'notification-widget',
        description: "A CSS challenge to create content from an image. Implemented a canvas animation to add some extra flair."
      }, {
        module: _portfolio_CodePenCard_vue__WEBPACK_IMPORTED_MODULE_0__["default"],
        url: 'https://codepen.io/jordanklaers/pen/qBWRgjP',
        imgUrl: 'https://assets.codepen.io/1379941/internal/screenshots/pens/qBWRgjP.default.png?fit=cover&format=auto&ha=false&height=540&quality=75&v=2&version=1624748014&width=960',
        title: 'Thermostat',
        id: 'thermostat',
        description: "A CSS challenge to create a thermostat."
      }, {
        module: _portfolio_CodePenCard_vue__WEBPACK_IMPORTED_MODULE_0__["default"],
        url: 'https://cdpn.io/jordanklaers/fullcpgrid/agVGjR',
        imgUrl: 'https://assets.codepen.io/1379941/internal/screenshots/pens/agVGjR.default.png?fit=cover&format=auto&ha=true&height=540&quality=75&v=2&version=1587058875&width=960',
        title: 'Hover Rotation Animations',
        id: 'hover-rotation-animation',
        description: "A CSS challenge to create content from an image. Added some 3D animation to add some flair."
      }
      // {
      // 	module: '',
      // 	url: ''
      // 	imgUrl: '',
      // 	title: '',
      // 	id: ''
      // }
      ],
      scrollTriggers: []
    };
  },
  mounted: function mounted() {
    var _this = this;
    //The scroll triggers associated to each section, wrapping the content, are generated here, and passed to the CodePenCard module, so each module generates its own animation
    //The animations of the arrows and dot that track the scroll progress are created here, and use the same scroll trigger passed to each card
    var lightTracerSquares = document.querySelectorAll('#scroll-reference .light.tracer-square');
    var darkTracerSquares = document.querySelectorAll('#scroll-reference .dark.tracer-square');
    var upArrows = document.querySelectorAll('#scroll-reference .arrow-up');
    var downArrows = document.querySelectorAll('#scroll-reference .arrow-down');
    this.$refs.sections.forEach(function (section, index) {
      _this.scrollTriggers.push({
        trigger: section,
        start: "top top",
        end: "bottom top",
        scrub: 0.7,
        snap: {
          snapTo: "labels",
          duration: {
            min: 0.6,
            max: 0.6
          },
          delay: 0.2
        }
      });
      _this.createScrollTracerAnimation(lightTracerSquares[index], index);
      _this.createScrollTracerAnimation(darkTracerSquares[index], index);
      //upArrow indexing would result in scroll trigger for the second card to use the first upArrow element.
      //Down arrows would result in no element to associate to the last scrolTrigger (because there is no more to scroll down)
      _this.createArrowIndicatorAnimation(upArrows[index - 1] || null, downArrows[index] || null, index);
    });
    //--same note from the props--
    //The scroll trigger for the text at the beginning is the same as the bio trigger.
    //Both the bio and the portfolio summary text should animation from the same trigger.
    new this.$data._gsap.TimelineMax({
      scrollTrigger: this.summaryTrigger
    }).addLabel('in').fromTo('#scroll-reference .portfolio-summary', {
      opacity: 1
    }, {
      opacity: 0
    }).fromTo('#scroll-reference .arrow-down-indicator', {
      y: '0rem',
      opacity: 1
    }, {
      y: '-7.125rem',
      opacity: 0
    }, '<').addLabel('out');
  },
  methods: {
    createScrollTracerAnimation: function createScrollTracerAnimation(el, index) {
      //This is the animation and trigger for the blue square
      var timeline = new this.$data._gsap.TimelineMax({
        scrollTrigger: this.scrollTriggers[index]
      }).addLabel('topOut').fromTo(el, {
        y: '14.25rem',
        opacity: 0
      }, {
        y: '7.125rem',
        opacity: 1,
        duration: 2
      }).addLabel('topIn').to(el, {
        y: '7.125rem',
        opacity: 1,
        duration: 1.5
      }).addLabel('middleIn').to(el, {
        y: '7.125rem',
        opacity: 1,
        duration: 1.5
      }).addLabel('bottomIn');
      if (index == this.$refs.sections.length - 1) timeline.to(el, {
        y: '7.125rem',
        opacity: 1,
        duration: 2
      });else timeline.to(el, {
        y: '0rem',
        opacity: 0,
        duration: 2
      });
      // .addLabel('bottomOut')
    },
    createArrowIndicatorAnimation: function createArrowIndicatorAnimation(topArrowEl, bottomArrowEl, index) {
      if (bottomArrowEl) {
        var bottomArrowTimeline = new this.$data._gsap.TimelineMax({
          scrollTrigger: this.scrollTriggers[index]
        });
        bottomArrowTimeline.fromTo(bottomArrowEl, {
          y: '16.25rem',
          opacity: 0
        }, {
          y: '9.125rem',
          opacity: 1,
          duration: 2
        }).addLabel('topIn').to(bottomArrowEl, {
          y: '9.125rem',
          opacity: 1,
          duration: 1.5
        }).addLabel('middleIn').to(bottomArrowEl, {
          y: '9.125rem',
          opacity: 1,
          duration: 1.5
        }).addLabel('bottomIn').to(bottomArrowEl, {
          y: '2rem',
          opacity: 0,
          duration: 2
        });
      }
      // if any card other then the first, then an arrow to scroll up should exist
      if (index != 0) {
        var topArrowTimeline = new this.$data._gsap.TimelineMax({
          scrollTrigger: this.scrollTriggers[index]
        });
        topArrowTimeline.fromTo(topArrowEl, {
          y: '12.25rem',
          opacity: 0
        }, {
          y: '5.125rem',
          opacity: 1,
          duration: 2
        }).addLabel('topIn').to(topArrowEl, {
          y: '5.125rem',
          opacity: 1,
          duration: 1.5
        }).addLabel('middleIn').to(topArrowEl, {
          y: '5.125rem',
          opacity: 1,
          duration: 1.5
        }).addLabel('bottomIn').to(topArrowEl, {
          y: '-2rem',
          opacity: 0,
          duration: 2
        });
      }
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/portfolio/CodePenCard.vue?vue&type=script&lang=js":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/portfolio/CodePenCard.vue?vue&type=script&lang=js ***!
  \***************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/throttle.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'CodePenCard',
  props: {
    url: {
      type: String
    },
    imgUrl: {
      type: String
    },
    title: {
      type: String
    },
    id: {
      type: String
    },
    trigger: {
      type: Object
    },
    description: {
      type: String
    },
    isLastModule: {
      type: Boolean
    }
  },
  data: function data() {
    return {
      scrollDirection: null,
      toggleActivClassHandler: (0,lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])(this.toggleActiveClass, 100)
    };
  },
  mounted: function mounted() {
    var tl = new this.$data._gsap.TimelineMax({
      paused: true
    });
    var descriptionHeight = this.convertPixelsToRem(window.getComputedStyle(document.querySelector("#".concat(this.id, " .description"))).height);
    var backgroundHeight = this.convertPixelsToRem(window.getComputedStyle(document.querySelector("#".concat(this.id, " .background"))).height);
    var hoverScale = tl.to("#".concat(this.id, " .background"), {
      //add 2 rem to the top and 1 to the bottom for the description text space, plus the height of the description text
      height: "".concat(backgroundHeight + 4 + descriptionHeight, "rem"),
      width: '24rem',
      top: '-2rem',
      duration: 0.3,
      ease: "power2.out"
    }).to("#".concat(this.id, " .description"), {
      opacity: 1,
      duration: 0.3,
      ease: "power2.out"
    });
    this.$el.addEventListener('mouseenter', function () {
      return hoverScale.play();
    });
    this.$el.addEventListener('mouseleave', function () {
      return hoverScale.reverse();
    });
  },
  methods: {
    toggleActiveClass: function toggleActiveClass(self) {
      //There are 7 units divided amongst the 4 stages of the animation. 2 units are given to the intro and outro.
      //If the progress is within the middle 3 units, the card is technically in view, therfore active
      if (self.progress >= 2 / 7 - 0.01 && self.progress <= 5 / 7 + 0.01) {
        this.$el.classList.add('active');
      } else {
        this.$el.classList.remove('active');
      }
    }
  },
  watch: {
    trigger: function trigger(val) {
      val['onUpdate'] = (0,lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])(this.toggleActiveClass, 100);
      var timeline = new this.$data._gsap.TimelineMax({
        scrollTrigger: val
      })
      // .addLabel('topOut')
      .fromTo(this.$el, {
        opacity: 0,
        rotationX: -45,
        y: 200,
        z: -100,
        transformOrigin: "50% 50% -100px"
      }, {
        opacity: 1,
        rotationX: 0,
        y: 0,
        z: 0,
        duration: 2
      }).addLabel('topIn').to(this.$el, {
        opacity: 1,
        duration: 1.5
      }).addLabel('middleIn').to(this.$el, {
        opacity: 1,
        duration: 1.5
      }).addLabel('bottomIn');
      if (this.isLastModule) timeline.to(this.$el, {
        opacity: 1,
        duration: 2
      });else timeline.to(this.$el, {
        y: -100,
        opacity: 0,
        duration: 2
      });
      // .addLabel('bottomOut')
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/mixins/Gsap.vue?vue&type=script&lang=js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/mixins/Gsap.vue?vue&type=script&lang=js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _gsap___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! _gsap_ */ "./src/assets/scripts/gsap/index.js");
/* harmony import */ var _gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! _gsap_/ScrollTrigger */ "./src/assets/scripts/gsap/ScrollTrigger.js");
/* harmony import */ var _gsap_CustomEase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! _gsap_/CustomEase */ "./src/assets/scripts/gsap/CustomEase.js");
/* harmony import */ var _gsap_CSSRulePlugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! _gsap_/CSSRulePlugin */ "./src/assets/scripts/gsap/CSSRulePlugin.js");
/* harmony import */ var _gsap_CSSPlugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! _gsap_/CSSPlugin */ "./src/assets/scripts/gsap/CSSPlugin.js");

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'Gsap',
  data: function data() {
    _gsap___WEBPACK_IMPORTED_MODULE_1__.gsap.registerPlugin(_gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__["default"]);
    _gsap___WEBPACK_IMPORTED_MODULE_1__.gsap.registerPlugin(_gsap_CustomEase__WEBPACK_IMPORTED_MODULE_3__["default"]);
    _gsap___WEBPACK_IMPORTED_MODULE_1__.gsap.registerPlugin(_gsap_CSSPlugin__WEBPACK_IMPORTED_MODULE_5__["default"]);
    _gsap___WEBPACK_IMPORTED_MODULE_1__.gsap.registerPlugin(_gsap_CSSRulePlugin__WEBPACK_IMPORTED_MODULE_4__["default"]);
    //get just the base values and remove the nested gsap
    var gsap = _objectSpread({}, _gsap___WEBPACK_IMPORTED_MODULE_1__);
    // delete gsap.gsap
    return {
      //combine the base values and the nested gsap values into a single object
      _gsap: _objectSpread(_objectSpread({}, gsap), _gsap___WEBPACK_IMPORTED_MODULE_1__.gsap),
      _scrollTrigger: _gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__["default"],
      _customEase: _gsap_CustomEase__WEBPACK_IMPORTED_MODULE_3__["default"],
      _cssRulePlugin: _gsap_CSSRulePlugin__WEBPACK_IMPORTED_MODULE_4__["default"]
    };
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/mixins/cssVariables.vue?vue&type=script&lang=js":
/*!**************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/mixins/cssVariables.vue?vue&type=script&lang=js ***!
  \**************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'css-variables',
  data: function data() {
    return {
      //contains the light/dark variables and their values
      light: {},
      dark: {},
      //contains just the css variables that have the name active or inactive in it
      active: [],
      inactive: []
    };
  },
  mounted: function mounted() {
    /*
    	console.log("start", this.isInternetExplorer);
    	const properties = this.isInternetExplorer ? this.getCSSCustomPropIndexFallBack() : this.getCSSCustomPropIndex();
    	console.log("css properties: ", properties);
    	properties && properties.forEach(variable => {
    		if (variable[0].includes('--light-')) this.light[variable[0]] = variable[1];
    		if (variable[0].includes('--dark-')) this.dark[variable[0]] = variable[1];
    		if (variable[0].includes('--active-') && !this.active.includes(variable[0])) this.active.push(variable[0]);
    		if (variable[0].includes('--inactive-') && !this.inactive.includes(variable[0])) this.inactive.push(variable[0]);
    	});
    	console.log("light: ", this.light);
    	console.log("dark :", this.dark);
    	console.log("active: ", this.active);
    	console.log("inactive: ", this.inactive);
    */
  },
  methods: {
    isSameDomain: function isSameDomain(styleSheet) {
      // Internal style blocks won't have an href value
      if (!styleSheet.href) {
        return true;
      }
      return styleSheet.href.indexOf(window.location.origin) === 0;
    },
    /**
     * Get all custom properties on a page
     * @return array<array[string, string]>
     * ex; [["--color-accent", "#b9f500"], ["--color-text", "#252525"], ...]
     */
    getCSSCustomPropIndex: function getCSSCustomPropIndex() {
      // styleSheets is array-like, so we convert it to an array.
      // Filter out any stylesheets not on this domain
      var that = this;
      return (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(document.styleSheets).filter(that.isSameDomain).reduce(function (finalArr, sheet) {
        return finalArr.concat(
        // cssRules is array-like, so we convert it to an array
        (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(sheet.cssRules).reduce(function (propValArr, rule) {
          //if the rule doesnt have style, it wont have the css variable
          if (!rule.style) return propValArr;
          var props = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(rule.style).map(function (propName) {
            return [propName.trim(), rule.style.getPropertyValue(propName).trim()];
          })
          // Discard any props that don't start with "--". Custom props are required to.
          .filter(function (_ref) {
            var _ref2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_ref, 1),
              propName = _ref2[0];
            return propName.indexOf("--") === 0 || propName.indexOf("-ieVar-") === 0 || propName.indexOf("-ie-") === 0 || propName.indexOf("iecp") === 0;
          });
          return [].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(propValArr), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(props));
        }, []));
      }, []);
    },
    getCSSCustomPropIndexFallBack: function getCSSCustomPropIndexFallBack() {}
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/mixins/utils.vue?vue&type=script&lang=js":
/*!*******************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/mixins/utils.vue?vue&type=script&lang=js ***!
  \*******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'browser-check',
  computed: {
    isInternetExplorer: function isInternetExplorer() {
      var ua = window.navigator.userAgent;
      var msie = ua.indexOf('MSIE ');
      if (msie > 0) {
        // IE 10 or older => return version number
        return true; //parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
      }
      var trident = ua.indexOf('Trident/');
      if (trident > 0) {
        // IE 11 => return version number
        var rv = ua.indexOf('rv:');
        return true; //parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
      }

      //to check if edge
      // var edge = ua.indexOf('Edge/');
      // if (edge > 0) {
      // 	// Edge => return version number
      // 	return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
      // }

      // other browser
      return false;
    }
  },
  methods: {
    convertRemToPixels: function convertRemToPixels(rem) {
      return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
    },
    convertPixelsToRem: function convertPixelsToRem(px) {
      if (typeof px == 'string' && px.includes('px')) {
        px.replace('px', '');
        px = parseInt(px, 10);
      }
      return px / parseFloat(getComputedStyle(document.documentElement).fontSize);
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/App.vue?vue&type=template&id=7ba5bd90":
/*!*********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/App.vue?vue&type=template&id=7ba5bd90 ***!
  \*********************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render),
/* harmony export */   staticRenderFns: () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function render() {
  var _vm = this,
    _c = _vm._self._c;
  return _c("div", {
    staticClass: "ie-fallback",
    attrs: {
      id: "app"
    }
  }, [_c("banner"), _vm._v(" "), _c("geometry"), _vm._v(" "), _c("section", {
    attrs: {
      id: "bio"
    }
  }, [_c("bio", {
    attrs: {
      setContent: _vm.setContent
    }
  })], 1), _vm._v(" "), _c("transition", {
    attrs: {
      name: "content-fade"
    },
    on: {
      "after-leave": _vm.updateCurrentContent
    }
  }, [_vm.content == "contact" ? _c("contact") : _vm._e()], 1), _vm._v(" "), _c("transition", {
    attrs: {
      name: "content-fade"
    },
    on: {
      "after-leave": _vm.updateCurrentContent
    }
  }, [_vm.content == "portfolio" ? _c("portfolio-list", {
    attrs: {
      summaryTrigger: _vm.bioTrigger
    }
  }) : _vm._e()], 1)], 1);
};
var staticRenderFns = [];
render._withStripped = true;


/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Banner.vue?vue&type=template&id=a2fea148":
/*!***********************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Banner.vue?vue&type=template&id=a2fea148 ***!
  \***********************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render),
/* harmony export */   staticRenderFns: () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function render() {
  var _vm = this,
    _c = _vm._self._c;
  return _c("div", {
    staticClass: "p-30",
    attrs: {
      id: "banner"
    }
  }, [_c("span", {
    staticClass: "ft-normal m-rgt-auto ft-sz-18 dark-mode",
    on: {
      click: _vm.clickHandler
    }
  }, [_c("i", {
    staticClass: "icon-moon-stroke ft-sz-16 p-rgt-15"
  }), _vm._v(_vm._s(_vm.inactiveMode) + " Mode\n\t")])]);
};
var staticRenderFns = [];
render._withStripped = true;


/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Bio.vue?vue&type=template&id=0fae41f0":
/*!********************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Bio.vue?vue&type=template&id=0fae41f0 ***!
  \********************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render),
/* harmony export */   staticRenderFns: () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function render() {
  var _vm = this,
    _c = _vm._self._c;
  return _c("div", {
    attrs: {
      id: "bio-container"
    }
  }, [_c("h1", [_vm._v("Jordan Klaers")]), _vm._v(" "), _c("div", {
    staticClass: "bio-animation-wrapper"
  }, [_c("h1", [_vm._v("Front-End Web Developer")]), _vm._v(" "), _c("div", {
    ref: "sub-text",
    staticClass: "sub-text"
  }, [_vm._v("Full stack web developer since 2017 with a passion for front end development and design")])]), _vm._v(" "), _c("button", {
    staticClass: "m-rgt-20 m-top-20",
    on: {
      click: function click() {
        return _vm.setContent("portfolio");
      }
    }
  }, [_vm._v("Portfolio")]), _vm._v(" "), _c("button", {
    staticClass: "m-top-20",
    on: {
      click: function click() {
        return _vm.setContent("contact");
      }
    }
  }, [_vm._v("Contact")])]);
};
var staticRenderFns = [];
render._withStripped = true;


/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Contact.vue?vue&type=template&id=cf6573c0":
/*!************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Contact.vue?vue&type=template&id=cf6573c0 ***!
  \************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render),
/* harmony export */   staticRenderFns: () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function render() {
  var _vm = this,
    _c = _vm._self._c;
  return _c("div", {
    attrs: {
      id: "contact-container"
    }
  }, [_c("ul", [_c("li", [_c("svg", {
    attrs: {
      viewBox: "0 0 100 100",
      id: "code-pen-logo"
    }
  }, [_c("path", {
    attrs: {
      stroke: "white",
      fill: "currentColor",
      d: "M100 34.2c-.4-2.6-3.3-4-5.3-5.3-3.6-2.4-7.1-4.7-10.7-7.1-8.5-5.7-17.1-11.4-25.6-17.1-2-1.3-4-2.7-6-4-1.4-1-3.3-1-4.8 0-5.7 3.8-11.5 7.7-17.2 11.5L5.2 29C3 30.4.1 31.8 0 34.8c-.1 3.3 0 6.7 0 10v16c0 2.9-.6 6.3 2.1 8.1 6.4 4.4 12.9 8.6 19.4 12.9 8 5.3 16 10.7 24 16 2.2 1.5 4.4 3.1 7.1 1.3 2.3-1.5 4.5-3 6.8-4.5 8.9-5.9 17.8-11.9 26.7-17.8l9.9-6.6c.6-.4 1.3-.8 1.9-1.3 1.4-1 2-2.4 2-4.1V37.3c.1-1.1.2-2.1.1-3.1 0-.1 0 .2 0 0zM54.3 12.3L88 34.8 73 44.9 54.3 32.4V12.3zm-8.6 0v20L27.1 44.8 12 34.8l33.7-22.5zM8.6 42.8L19.3 50 8.6 57.2V42.8zm37.1 44.9L12 65.2l15-10.1 18.6 12.5v20.1zM50 60.2L34.8 50 50 39.8 65.2 50 50 60.2zm4.3 27.5v-20l18.6-12.5 15 10.1-33.6 22.4zm37.1-30.5L80.7 50l10.8-7.2-.1 14.4z"
    }
  })]), _vm._v(" "), _c("a", {
    attrs: {
      href: "https://codepen.io/jordanklaers",
      target: "blank"
    }
  }, [_vm._v("\n                    Code Pen\n                ")])]), _vm._v(" "), _c("li", [_c("svg", {
    staticClass: "global-nav__logo",
    attrs: {
      id: "linked-in-logo",
      xmlns: "http://www.w3.org/2000/svg",
      width: "34",
      height: "34",
      viewBox: "0 0 34 34"
    }
  }, [_c("g", [_c("path", {
    attrs: {
      d: "M34,2.5v29A2.5,2.5,0,0,1,31.5,34H2.5A2.5,2.5,0,0,1,0,31.5V2.5A2.5,2.5,0,0,1,2.5,0h29A2.5,2.5,0,0,1,34,2.5ZM10,13H5V29h5Zm.45-5.5A2.88,2.88,0,0,0,7.59,4.6H7.5a2.9,2.9,0,0,0,0,5.8h0a2.88,2.88,0,0,0,2.95-2.81ZM29,19.28c0-4.81-3.06-6.68-6.1-6.68a5.7,5.7,0,0,0-5.06,2.58H17.7V13H13V29h5V20.49a3.32,3.32,0,0,1,3-3.58h.19c1.59,0,2.77,1,2.77,3.52V29h5Z",
      fill: "currentColor"
    }
  })])]), _vm._v(" "), _c("a", {
    attrs: {
      href: "https://www.linkedin.com/in/jordan-klaers/",
      target: "blank"
    }
  }, [_vm._v("Linked In")])]), _vm._v(" "), _vm._m(0)])]);
};
var staticRenderFns = [function () {
  var _vm = this,
    _c = _vm._self._c;
  return _c("li", [_c("img", {
    staticClass: "gb_tc",
    attrs: {
      src: "https://ssl.gstatic.com/ui/v1/icons/mail/rfr/logo_gmail_lockup_default_1x_r2.png",
      srcset: "https://ssl.gstatic.com/ui/v1/icons/mail/rfr/logo_gmail_lockup_default_1x_r2.png" + " 1x, " + "https://ssl.gstatic.com/ui/v1/icons/mail/rfr/logo_gmail_lockup_default_2x_r2.png" + " 2x",
      alt: "",
      "aria-hidden": "true"
    }
  }), _vm._v("\n                email: Jordan.Klaers@gmail.com\n            ")]);
}];
render._withStripped = true;


/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Geometry.vue?vue&type=template&id=6dfac0bc":
/*!*************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Geometry.vue?vue&type=template&id=6dfac0bc ***!
  \*************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render),
/* harmony export */   staticRenderFns: () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function render() {
  var _vm = this,
    _c = _vm._self._c;
  return _c("div", {
    attrs: {
      id: "geometry-container"
    }
  }, [_c("span", {
    staticClass: "dark visible shape square-1-a"
  }), _vm._v(" "), _c("span", {
    staticClass: "light shape square-1-a"
  }), _vm._v(" "), _c("span", {
    staticClass: "dark visible shape square-1-b"
  }), _vm._v(" "), _c("span", {
    staticClass: "light shape square-1-b"
  }), _vm._v(" "), _c("span", {
    staticClass: "dark visible shape square-2-a"
  }), _vm._v(" "), _c("span", {
    staticClass: "light shape square-2-a"
  }), _vm._v(" "), _c("span", {
    staticClass: "dark visible shape square-2-b"
  }), _vm._v(" "), _c("span", {
    staticClass: "light shape square-2-b"
  }), _vm._v(" "), _c("span", {
    staticClass: "dark visible shape square-2-c"
  }), _vm._v(" "), _c("span", {
    staticClass: "light shape square-2-c"
  }), _vm._v(" "), _c("span", {
    staticClass: "dark visible shape square-2-d"
  }), _vm._v(" "), _c("span", {
    staticClass: "light shape square-2-d"
  }), _vm._v(" "), _c("span", {
    staticClass: "shape square-3-a"
  }), _vm._v(" "), _c("span", {
    staticClass: "shape square-3-b"
  }), _vm._v(" "), _c("span", {
    staticClass: "shape square-3-c"
  }), _vm._v(" "), !_vm.isInternetExplorer ? _vm._l(_vm.curveElements, function (curve) {
    return _c("span", {
      key: curve["class"],
      staticClass: "shape",
      style: _vm.setClipPath(curve.degree, curve.startDegree),
      attrs: {
        id: curve.id
      }
    });
  }) : _vm._e()], 2);
};
var staticRenderFns = [];
render._withStripped = true;


/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/PortfolioList.vue?vue&type=template&id=13a0d706":
/*!******************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/PortfolioList.vue?vue&type=template&id=13a0d706 ***!
  \******************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render),
/* harmony export */   staticRenderFns: () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function render() {
  var _vm = this,
    _c = _vm._self._c;
  return _c("div", [_c("div", {
    attrs: {
      id: "scroll-reference"
    }
  }, [_vm._l(_vm.codePenCards, function (card, index) {
    return [_c("span", {
      key: "dark-square-".concat(index),
      staticClass: "dark visible location-tracer tracer-square"
    }), _vm._v(" "), _c("span", {
      key: "light-square-".concat(index),
      staticClass: "light location-tracer tracer-square"
    })];
  }), _vm._v(" "), _c("div", {
    staticClass: "arrow-down-indicator"
  }), _vm._v(" "), _vm._l(Array.apply(null, {
    length: _vm.codePenCards.length - 1
  }), function (card, index) {
    return [_c("div", {
      key: "down-".concat(index),
      staticClass: "arrow-up"
    }), _vm._v(" "), _c("div", {
      key: "up-".concat(index),
      staticClass: "arrow-down"
    })];
  }), _vm._v(" "), _c("div", {
    staticClass: "portfolio-summary"
  }, [_vm._v("\n\t\t\tA collection of work briefly demonstrating some of my capabilities in front end development.\n\t\t")])], 2), _vm._v(" "), _vm._l(_vm.codePenCards, function (card, index) {
    return [_c("section", {
      key: index,
      ref: "sections",
      refInFor: true,
      staticClass: "code-example"
    }, [_c(card.module, {
      tag: "component",
      attrs: {
        title: card.title,
        id: card.id,
        url: card.url,
        imgUrl: card.imgUrl,
        trigger: _vm.scrollTriggers[index],
        description: card.description,
        isLastModule: _vm.codePenCards.length - 1 == index
      }
    })], 1), _vm._v(" "), _c("div", {
      key: "spacer-".concat(index),
      staticClass: "spacer"
    })];
  }), _vm._v(" "), _c("div", {
    staticStyle: {
      height: "100vh"
    }
  })], 2);
};
var staticRenderFns = [];
render._withStripped = true;


/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/portfolio/CodePenCard.vue?vue&type=template&id=1b12f855":
/*!**************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/portfolio/CodePenCard.vue?vue&type=template&id=1b12f855 ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render),
/* harmony export */   staticRenderFns: () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function render() {
  var _vm = this,
    _c = _vm._self._c;
  return _c("a", {
    staticClass: "code-pen-card",
    attrs: {
      id: _vm.id,
      href: _vm.url,
      target: "_blank",
      rel: "noopener noreferrer"
    }
  }, [_c("img", {
    attrs: {
      src: _vm.imgUrl
    }
  }), _vm._v(" "), _c("div", {
    staticClass: "background"
  }), _vm._v(" "), _c("span", {
    staticClass: "title"
  }, [_vm._v(_vm._s(_vm.title))]), _vm._v(" "), _c("span", {
    staticClass: "description"
  }, [_vm._v(_vm._s(_vm.description))])]);
};
var staticRenderFns = [];
render._withStripped = true;


/***/ }),

/***/ "./node_modules/lodash-es/_Symbol.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/_Symbol.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");


/** Built-in value references. */
var Symbol = _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Symbol;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Symbol);


/***/ }),

/***/ "./node_modules/lodash-es/_baseGetTag.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseGetTag.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js");
/* harmony import */ var _getRawTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getRawTag.js */ "./node_modules/lodash-es/_getRawTag.js");
/* harmony import */ var _objectToString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_objectToString.js */ "./node_modules/lodash-es/_objectToString.js");




/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? (0,_getRawTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)
    : (0,_objectToString_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseGetTag);


/***/ }),

/***/ "./node_modules/lodash-es/_baseTrim.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_baseTrim.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _trimmedEndIndex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_trimmedEndIndex.js */ "./node_modules/lodash-es/_trimmedEndIndex.js");


/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, (0,_trimmedEndIndex_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string) + 1).replace(reTrimStart, '')
    : string;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseTrim);


/***/ }),

/***/ "./node_modules/lodash-es/_freeGlobal.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_freeGlobal.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (freeGlobal);


/***/ }),

/***/ "./node_modules/lodash-es/_getRawTag.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_getRawTag.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js");


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getRawTag);


/***/ }),

/***/ "./node_modules/lodash-es/_objectToString.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_objectToString.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (objectToString);


/***/ }),

/***/ "./node_modules/lodash-es/_root.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/_root.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_freeGlobal.js */ "./node_modules/lodash-es/_freeGlobal.js");


/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__["default"] || freeSelf || Function('return this')();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (root);


/***/ }),

/***/ "./node_modules/lodash-es/_trimmedEndIndex.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_trimmedEndIndex.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (trimmedEndIndex);


/***/ }),

/***/ "./node_modules/lodash-es/debounce.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/debounce.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./now.js */ "./node_modules/lodash-es/now.js");
/* harmony import */ var _toNumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./toNumber.js */ "./node_modules/lodash-es/toNumber.js");




/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = (0,_toNumber_js__WEBPACK_IMPORTED_MODULE_2__["default"])(wait) || 0;
  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax((0,_toNumber_js__WEBPACK_IMPORTED_MODULE_2__["default"])(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = (0,_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge((0,_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])());
  }

  function debounced() {
    var time = (0,_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (debounce);


/***/ }),

/***/ "./node_modules/lodash-es/isObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isObject.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isObject);


/***/ }),

/***/ "./node_modules/lodash-es/isObjectLike.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/isObjectLike.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isObjectLike);


/***/ }),

/***/ "./node_modules/lodash-es/isSymbol.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isSymbol.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");



/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    ((0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) && (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) == symbolTag);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isSymbol);


/***/ }),

/***/ "./node_modules/lodash-es/now.js":
/*!***************************************!*\
  !*** ./node_modules/lodash-es/now.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");


/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Date.now();
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (now);


/***/ }),

/***/ "./node_modules/lodash-es/throttle.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/throttle.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _debounce_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./debounce.js */ "./node_modules/lodash-es/debounce.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");



/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return (0,_debounce_js__WEBPACK_IMPORTED_MODULE_0__["default"])(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (throttle);


/***/ }),

/***/ "./node_modules/lodash-es/toNumber.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/toNumber.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseTrim_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseTrim.js */ "./node_modules/lodash-es/_baseTrim.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/lodash-es/isSymbol.js");




/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if ((0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value)) {
    return NAN;
  }
  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = (0,_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = (0,_baseTrim_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toNumber);


/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/App.vue?vue&type=style&index=0&id=7ba5bd90&lang=scss":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/App.vue?vue&type=style&index=0&id=7ba5bd90&lang=scss ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/App.vue?vue&type=style&index=1&id=7ba5bd90&lang=css":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/App.vue?vue&type=style&index=1&id=7ba5bd90&lang=css ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Banner.vue?vue&type=style&index=0&id=a2fea148&lang=scss":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Banner.vue?vue&type=style&index=0&id=a2fea148&lang=scss ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Bio.vue?vue&type=style&index=0&id=0fae41f0&lang=scss":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Bio.vue?vue&type=style&index=0&id=0fae41f0&lang=scss ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Contact.vue?vue&type=style&index=0&id=cf6573c0&lang=scss":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Contact.vue?vue&type=style&index=0&id=cf6573c0&lang=scss ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Geometry.vue?vue&type=style&index=0&id=6dfac0bc&lang=scss":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Geometry.vue?vue&type=style&index=0&id=6dfac0bc&lang=scss ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/PortfolioList.vue?vue&type=style&index=0&id=13a0d706&lang=scss":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/PortfolioList.vue?vue&type=style&index=0&id=13a0d706&lang=scss ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/portfolio/CodePenCard.vue?vue&type=style&index=0&id=1b12f855&lang=scss":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/portfolio/CodePenCard.vue?vue&type=style&index=0&id=1b12f855&lang=scss ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ normalizeComponent)
/* harmony export */ });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent(
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */,
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options =
    typeof scriptExports === 'function' ? scriptExports.options : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) {
    // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
          injectStyles.call(
            this,
            (options.functional ? this.parent : this).$root.$options.shadowRoot
          )
        }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "./node_modules/vue/dist/vue.runtime.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/vue/dist/vue.runtime.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EffectScope: () => (/* binding */ EffectScope),
/* harmony export */   computed: () => (/* binding */ computed),
/* harmony export */   customRef: () => (/* binding */ customRef),
/* harmony export */   "default": () => (/* binding */ Vue),
/* harmony export */   defineAsyncComponent: () => (/* binding */ defineAsyncComponent),
/* harmony export */   defineComponent: () => (/* binding */ defineComponent),
/* harmony export */   del: () => (/* binding */ del),
/* harmony export */   effectScope: () => (/* binding */ effectScope),
/* harmony export */   getCurrentInstance: () => (/* binding */ getCurrentInstance),
/* harmony export */   getCurrentScope: () => (/* binding */ getCurrentScope),
/* harmony export */   h: () => (/* binding */ h),
/* harmony export */   inject: () => (/* binding */ inject),
/* harmony export */   isProxy: () => (/* binding */ isProxy),
/* harmony export */   isReactive: () => (/* binding */ isReactive),
/* harmony export */   isReadonly: () => (/* binding */ isReadonly),
/* harmony export */   isRef: () => (/* binding */ isRef),
/* harmony export */   isShallow: () => (/* binding */ isShallow),
/* harmony export */   markRaw: () => (/* binding */ markRaw),
/* harmony export */   mergeDefaults: () => (/* binding */ mergeDefaults),
/* harmony export */   nextTick: () => (/* binding */ nextTick),
/* harmony export */   onActivated: () => (/* binding */ onActivated),
/* harmony export */   onBeforeMount: () => (/* binding */ onBeforeMount),
/* harmony export */   onBeforeUnmount: () => (/* binding */ onBeforeUnmount),
/* harmony export */   onBeforeUpdate: () => (/* binding */ onBeforeUpdate),
/* harmony export */   onDeactivated: () => (/* binding */ onDeactivated),
/* harmony export */   onErrorCaptured: () => (/* binding */ onErrorCaptured),
/* harmony export */   onMounted: () => (/* binding */ onMounted),
/* harmony export */   onRenderTracked: () => (/* binding */ onRenderTracked),
/* harmony export */   onRenderTriggered: () => (/* binding */ onRenderTriggered),
/* harmony export */   onScopeDispose: () => (/* binding */ onScopeDispose),
/* harmony export */   onServerPrefetch: () => (/* binding */ onServerPrefetch),
/* harmony export */   onUnmounted: () => (/* binding */ onUnmounted),
/* harmony export */   onUpdated: () => (/* binding */ onUpdated),
/* harmony export */   provide: () => (/* binding */ provide),
/* harmony export */   proxyRefs: () => (/* binding */ proxyRefs),
/* harmony export */   reactive: () => (/* binding */ reactive),
/* harmony export */   readonly: () => (/* binding */ readonly),
/* harmony export */   ref: () => (/* binding */ ref$1),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   shallowReactive: () => (/* binding */ shallowReactive),
/* harmony export */   shallowReadonly: () => (/* binding */ shallowReadonly),
/* harmony export */   shallowRef: () => (/* binding */ shallowRef),
/* harmony export */   toRaw: () => (/* binding */ toRaw),
/* harmony export */   toRef: () => (/* binding */ toRef),
/* harmony export */   toRefs: () => (/* binding */ toRefs),
/* harmony export */   triggerRef: () => (/* binding */ triggerRef),
/* harmony export */   unref: () => (/* binding */ unref),
/* harmony export */   useAttrs: () => (/* binding */ useAttrs),
/* harmony export */   useCssModule: () => (/* binding */ useCssModule),
/* harmony export */   useCssVars: () => (/* binding */ useCssVars),
/* harmony export */   useListeners: () => (/* binding */ useListeners),
/* harmony export */   useSlots: () => (/* binding */ useSlots),
/* harmony export */   version: () => (/* binding */ version),
/* harmony export */   watch: () => (/* binding */ watch),
/* harmony export */   watchEffect: () => (/* binding */ watchEffect),
/* harmony export */   watchPostEffect: () => (/* binding */ watchPostEffect),
/* harmony export */   watchSyncEffect: () => (/* binding */ watchSyncEffect)
/* harmony export */ });
/*!
 * Vue.js v2.7.16
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
var emptyObject = Object.freeze({});
var isArray = Array.isArray;
// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef(v) {
    return v === undefined || v === null;
}
function isDef(v) {
    return v !== undefined && v !== null;
}
function isTrue(v) {
    return v === true;
}
function isFalse(v) {
    return v === false;
}
/**
 * Check if value is primitive.
 */
function isPrimitive(value) {
    return (typeof value === 'string' ||
        typeof value === 'number' ||
        // $flow-disable-line
        typeof value === 'symbol' ||
        typeof value === 'boolean');
}
function isFunction(value) {
    return typeof value === 'function';
}
/**
 * Quick object check - this is primarily used to tell
 * objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
    return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */
var _toString = Object.prototype.toString;
function toRawType(value) {
    return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject(obj) {
    return _toString.call(obj) === '[object Object]';
}
function isRegExp(v) {
    return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex(val) {
    var n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val);
}
function isPromise(val) {
    return (isDef(val) &&
        typeof val.then === 'function' &&
        typeof val.catch === 'function');
}
/**
 * Convert a value to a string that is actually rendered.
 */
function toString(val) {
    return val == null
        ? ''
        : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
            ? JSON.stringify(val, replacer, 2)
            : String(val);
}
function replacer(_key, val) {
    // avoid circular deps from v3
    if (val && val.__v_isRef) {
        return val.value;
    }
    return val;
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
    var map = Object.create(null);
    var list = str.split(',');
    for (var i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? function (val) { return map[val.toLowerCase()]; } : function (val) { return map[val]; };
}
/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */
function remove$2(arr, item) {
    var len = arr.length;
    if (len) {
        // fast path for the only / last item
        if (item === arr[len - 1]) {
            arr.length = len - 1;
            return;
        }
        var index = arr.indexOf(item);
        if (index > -1) {
            return arr.splice(index, 1);
        }
    }
}
/**
 * Check whether an object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
    return hasOwnProperty.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
    var cache = Object.create(null);
    return function cachedFn(str) {
        var hit = cache[str];
        return hit || (cache[str] = fn(str));
    };
}
/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
    return str.replace(camelizeRE, function (_, c) { return (c ? c.toUpperCase() : ''); });
});
/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
    return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */
/* istanbul ignore next */
function polyfillBind(fn, ctx) {
    function boundFn(a) {
        var l = arguments.length;
        return l
            ? l > 1
                ? fn.apply(ctx, arguments)
                : fn.call(ctx, a)
            : fn.call(ctx);
    }
    boundFn._length = fn.length;
    return boundFn;
}
function nativeBind(fn, ctx) {
    return fn.bind(ctx);
}
// @ts-expect-error bind cannot be `undefined`
var bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
    start = start || 0;
    var i = list.length - start;
    var ret = new Array(i);
    while (i--) {
        ret[i] = list[i + start];
    }
    return ret;
}
/**
 * Mix properties into target object.
 */
function extend(to, _from) {
    for (var key in _from) {
        to[key] = _from[key];
    }
    return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
    var res = {};
    for (var i = 0; i < arr.length; i++) {
        if (arr[i]) {
            extend(res, arr[i]);
        }
    }
    return res;
}
/* eslint-disable no-unused-vars */
/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop(a, b, c) { }
/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };
/* eslint-enable no-unused-vars */
/**
 * Return the same value.
 */
var identity = function (_) { return _; };
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
    if (a === b)
        return true;
    var isObjectA = isObject(a);
    var isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
        try {
            var isArrayA = Array.isArray(a);
            var isArrayB = Array.isArray(b);
            if (isArrayA && isArrayB) {
                return (a.length === b.length &&
                    a.every(function (e, i) {
                        return looseEqual(e, b[i]);
                    }));
            }
            else if (a instanceof Date && b instanceof Date) {
                return a.getTime() === b.getTime();
            }
            else if (!isArrayA && !isArrayB) {
                var keysA = Object.keys(a);
                var keysB = Object.keys(b);
                return (keysA.length === keysB.length &&
                    keysA.every(function (key) {
                        return looseEqual(a[key], b[key]);
                    }));
            }
            else {
                /* istanbul ignore next */
                return false;
            }
        }
        catch (e) {
            /* istanbul ignore next */
            return false;
        }
    }
    else if (!isObjectA && !isObjectB) {
        return String(a) === String(b);
    }
    else {
        return false;
    }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf(arr, val) {
    for (var i = 0; i < arr.length; i++) {
        if (looseEqual(arr[i], val))
            return i;
    }
    return -1;
}
/**
 * Ensure a function is called only once.
 */
function once(fn) {
    var called = false;
    return function () {
        if (!called) {
            called = true;
            fn.apply(this, arguments);
        }
    };
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill
function hasChanged(x, y) {
    if (x === y) {
        return x === 0 && 1 / x !== 1 / y;
    }
    else {
        return x === x || y === y;
    }
}

var SSR_ATTR = 'data-server-rendered';
var ASSET_TYPES = ['component', 'directive', 'filter'];
var LIFECYCLE_HOOKS = [
    'beforeCreate',
    'created',
    'beforeMount',
    'mounted',
    'beforeUpdate',
    'updated',
    'beforeDestroy',
    'destroyed',
    'activated',
    'deactivated',
    'errorCaptured',
    'serverPrefetch',
    'renderTracked',
    'renderTriggered'
];

var config = {
    /**
     * Option merge strategies (used in core/util/options)
     */
    // $flow-disable-line
    optionMergeStrategies: Object.create(null),
    /**
     * Whether to suppress warnings.
     */
    silent: false,
    /**
     * Show production mode tip message on boot?
     */
    productionTip: "development" !== 'production',
    /**
     * Whether to enable devtools
     */
    devtools: "development" !== 'production',
    /**
     * Whether to record perf
     */
    performance: false,
    /**
     * Error handler for watcher errors
     */
    errorHandler: null,
    /**
     * Warn handler for watcher warns
     */
    warnHandler: null,
    /**
     * Ignore certain custom elements
     */
    ignoredElements: [],
    /**
     * Custom user key aliases for v-on
     */
    // $flow-disable-line
    keyCodes: Object.create(null),
    /**
     * Check if a tag is reserved so that it cannot be registered as a
     * component. This is platform-dependent and may be overwritten.
     */
    isReservedTag: no,
    /**
     * Check if an attribute is reserved so that it cannot be used as a component
     * prop. This is platform-dependent and may be overwritten.
     */
    isReservedAttr: no,
    /**
     * Check if a tag is an unknown element.
     * Platform-dependent.
     */
    isUnknownElement: no,
    /**
     * Get the namespace of an element
     */
    getTagNamespace: noop,
    /**
     * Parse the real tag name for the specific platform.
     */
    parsePlatformTagName: identity,
    /**
     * Check if an attribute must be bound using property, e.g. value
     * Platform-dependent.
     */
    mustUseProp: no,
    /**
     * Perform updates asynchronously. Intended to be used by Vue Test Utils
     * This will significantly reduce performance if set to false.
     */
    async: true,
    /**
     * Exposed for legacy reasons
     */
    _lifecycleHooks: LIFECYCLE_HOOKS
};

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
    var c = (str + '').charCodeAt(0);
    return c === 0x24 || c === 0x5f;
}
/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
        value: val,
        enumerable: !!enumerable,
        writable: true,
        configurable: true
    });
}
/**
 * Parse simple path.
 */
var bailRE = new RegExp("[^".concat(unicodeRegExp.source, ".$_\\d]"));
function parsePath(path) {
    if (bailRE.test(path)) {
        return;
    }
    var segments = path.split('.');
    return function (obj) {
        for (var i = 0; i < segments.length; i++) {
            if (!obj)
                return;
            obj = obj[segments[i]];
        }
        return obj;
    };
}

// can we use __proto__?
var hasProto = '__proto__' in {};
// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
UA && /chrome\/\d+/.test(UA) && !isEdge;
UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);
// Firefox has a "watch" function on Object.prototype...
// @ts-expect-error firebox support
var nativeWatch = {}.watch;
var supportsPassive = false;
if (inBrowser) {
    try {
        var opts = {};
        Object.defineProperty(opts, 'passive', {
            get: function () {
                /* istanbul ignore next */
                supportsPassive = true;
            }
        }); // https://github.com/facebook/flow/issues/285
        window.addEventListener('test-passive', null, opts);
    }
    catch (e) { }
}
// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
    if (_isServer === undefined) {
        /* istanbul ignore if */
        if (!inBrowser && typeof __webpack_require__.g !== 'undefined') {
            // detect presence of vue-server-renderer and avoid
            // Webpack shimming the process
            _isServer =
                __webpack_require__.g['process'] && __webpack_require__.g['process'].env.VUE_ENV === 'server';
        }
        else {
            _isServer = false;
        }
    }
    return _isServer;
};
// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */
function isNative(Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}
var hasSymbol = typeof Symbol !== 'undefined' &&
    isNative(Symbol) &&
    typeof Reflect !== 'undefined' &&
    isNative(Reflect.ownKeys);
var _Set; // $flow-disable-line
/* istanbul ignore if */ if (typeof Set !== 'undefined' && isNative(Set)) {
    // use native Set when available.
    _Set = Set;
}
else {
    // a non-standard Set polyfill that only works with primitive keys.
    _Set = /** @class */ (function () {
        function Set() {
            this.set = Object.create(null);
        }
        Set.prototype.has = function (key) {
            return this.set[key] === true;
        };
        Set.prototype.add = function (key) {
            this.set[key] = true;
        };
        Set.prototype.clear = function () {
            this.set = Object.create(null);
        };
        return Set;
    }());
}

var currentInstance = null;
/**
 * This is exposed for compatibility with v3 (e.g. some functions in VueUse
 * relies on it). Do not use this internally, just use `currentInstance`.
 *
 * @internal this function needs manual type declaration because it relies
 * on previously manually authored types from Vue 2
 */
function getCurrentInstance() {
    return currentInstance && { proxy: currentInstance };
}
/**
 * @internal
 */
function setCurrentInstance(vm) {
    if (vm === void 0) { vm = null; }
    if (!vm)
        currentInstance && currentInstance._scope.off();
    currentInstance = vm;
    vm && vm._scope.on();
}

/**
 * @internal
 */
var VNode = /** @class */ (function () {
    function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
        this.tag = tag;
        this.data = data;
        this.children = children;
        this.text = text;
        this.elm = elm;
        this.ns = undefined;
        this.context = context;
        this.fnContext = undefined;
        this.fnOptions = undefined;
        this.fnScopeId = undefined;
        this.key = data && data.key;
        this.componentOptions = componentOptions;
        this.componentInstance = undefined;
        this.parent = undefined;
        this.raw = false;
        this.isStatic = false;
        this.isRootInsert = true;
        this.isComment = false;
        this.isCloned = false;
        this.isOnce = false;
        this.asyncFactory = asyncFactory;
        this.asyncMeta = undefined;
        this.isAsyncPlaceholder = false;
    }
    Object.defineProperty(VNode.prototype, "child", {
        // DEPRECATED: alias for componentInstance for backwards compat.
        /* istanbul ignore next */
        get: function () {
            return this.componentInstance;
        },
        enumerable: false,
        configurable: true
    });
    return VNode;
}());
var createEmptyVNode = function (text) {
    if (text === void 0) { text = ''; }
    var node = new VNode();
    node.text = text;
    node.isComment = true;
    return node;
};
function createTextVNode(val) {
    return new VNode(undefined, undefined, undefined, String(val));
}
// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode) {
    var cloned = new VNode(vnode.tag, vnode.data, 
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.fnContext = vnode.fnContext;
    cloned.fnOptions = vnode.fnOptions;
    cloned.fnScopeId = vnode.fnScopeId;
    cloned.asyncMeta = vnode.asyncMeta;
    cloned.isCloned = true;
    return cloned;
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var uid$2 = 0;
var pendingCleanupDeps = [];
var cleanupDeps = function () {
    for (var i = 0; i < pendingCleanupDeps.length; i++) {
        var dep = pendingCleanupDeps[i];
        dep.subs = dep.subs.filter(function (s) { return s; });
        dep._pending = false;
    }
    pendingCleanupDeps.length = 0;
};
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 * @internal
 */
var Dep = /** @class */ (function () {
    function Dep() {
        // pending subs cleanup
        this._pending = false;
        this.id = uid$2++;
        this.subs = [];
    }
    Dep.prototype.addSub = function (sub) {
        this.subs.push(sub);
    };
    Dep.prototype.removeSub = function (sub) {
        // #12696 deps with massive amount of subscribers are extremely slow to
        // clean up in Chromium
        // to workaround this, we unset the sub for now, and clear them on
        // next scheduler flush.
        this.subs[this.subs.indexOf(sub)] = null;
        if (!this._pending) {
            this._pending = true;
            pendingCleanupDeps.push(this);
        }
    };
    Dep.prototype.depend = function (info) {
        if (Dep.target) {
            Dep.target.addDep(this);
            if ( true && info && Dep.target.onTrack) {
                Dep.target.onTrack(__assign({ effect: Dep.target }, info));
            }
        }
    };
    Dep.prototype.notify = function (info) {
        // stabilize the subscriber list first
        var subs = this.subs.filter(function (s) { return s; });
        if ( true && !config.async) {
            // subs aren't sorted in scheduler if not running async
            // we need to sort them now to make sure they fire in correct
            // order
            subs.sort(function (a, b) { return a.id - b.id; });
        }
        for (var i = 0, l = subs.length; i < l; i++) {
            var sub = subs[i];
            if ( true && info) {
                sub.onTrigger &&
                    sub.onTrigger(__assign({ effect: subs[i] }, info));
            }
            sub.update();
        }
    };
    return Dep;
}());
// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null;
var targetStack = [];
function pushTarget(target) {
    targetStack.push(target);
    Dep.target = target;
}
function popTarget() {
    targetStack.pop();
    Dep.target = targetStack[targetStack.length - 1];
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */
var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);
var methodsToPatch = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
];
/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
    // cache original method
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var result = original.apply(this, args);
        var ob = this.__ob__;
        var inserted;
        switch (method) {
            case 'push':
            case 'unshift':
                inserted = args;
                break;
            case 'splice':
                inserted = args.slice(2);
                break;
        }
        if (inserted)
            ob.observeArray(inserted);
        // notify change
        if (true) {
            ob.dep.notify({
                type: "array mutation" /* TriggerOpTypes.ARRAY_MUTATION */,
                target: this,
                key: method
            });
        }
        else // removed by dead control flow
{}
        return result;
    });
});

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
var NO_INITIAL_VALUE = {};
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;
function toggleObserving(value) {
    shouldObserve = value;
}
// ssr mock dep
var mockDep = {
    notify: noop,
    depend: noop,
    addSub: noop,
    removeSub: noop
};
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = /** @class */ (function () {
    function Observer(value, shallow, mock) {
        if (shallow === void 0) { shallow = false; }
        if (mock === void 0) { mock = false; }
        this.value = value;
        this.shallow = shallow;
        this.mock = mock;
        // this.value = value
        this.dep = mock ? mockDep : new Dep();
        this.vmCount = 0;
        def(value, '__ob__', this);
        if (isArray(value)) {
            if (!mock) {
                if (hasProto) {
                    value.__proto__ = arrayMethods;
                    /* eslint-enable no-proto */
                }
                else {
                    for (var i = 0, l = arrayKeys.length; i < l; i++) {
                        var key = arrayKeys[i];
                        def(value, key, arrayMethods[key]);
                    }
                }
            }
            if (!shallow) {
                this.observeArray(value);
            }
        }
        else {
            /**
             * Walk through all properties and convert them into
             * getter/setters. This method should only be called when
             * value type is Object.
             */
            var keys = Object.keys(value);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                defineReactive(value, key, NO_INITIAL_VALUE, undefined, shallow, mock);
            }
        }
    }
    /**
     * Observe a list of Array items.
     */
    Observer.prototype.observeArray = function (value) {
        for (var i = 0, l = value.length; i < l; i++) {
            observe(value[i], false, this.mock);
        }
    };
    return Observer;
}());
// helpers
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, shallow, ssrMockReactivity) {
    if (value && hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
        return value.__ob__;
    }
    if (shouldObserve &&
        (ssrMockReactivity || !isServerRendering()) &&
        (isArray(value) || isPlainObject(value)) &&
        Object.isExtensible(value) &&
        !value.__v_skip /* ReactiveFlags.SKIP */ &&
        !isRef(value) &&
        !(value instanceof VNode)) {
        return new Observer(value, shallow, ssrMockReactivity);
    }
}
/**
 * Define a reactive property on an Object.
 */
function defineReactive(obj, key, val, customSetter, shallow, mock, observeEvenIfShallow) {
    if (observeEvenIfShallow === void 0) { observeEvenIfShallow = false; }
    var dep = new Dep();
    var property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
        return;
    }
    // cater for pre-defined getter/setters
    var getter = property && property.get;
    var setter = property && property.set;
    if ((!getter || setter) &&
        (val === NO_INITIAL_VALUE || arguments.length === 2)) {
        val = obj[key];
    }
    var childOb = shallow ? val && val.__ob__ : observe(val, false, mock);
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter() {
            var value = getter ? getter.call(obj) : val;
            if (Dep.target) {
                if (true) {
                    dep.depend({
                        target: obj,
                        type: "get" /* TrackOpTypes.GET */,
                        key: key
                    });
                }
                else // removed by dead control flow
{}
                if (childOb) {
                    childOb.dep.depend();
                    if (isArray(value)) {
                        dependArray(value);
                    }
                }
            }
            return isRef(value) && !shallow ? value.value : value;
        },
        set: function reactiveSetter(newVal) {
            var value = getter ? getter.call(obj) : val;
            if (!hasChanged(value, newVal)) {
                return;
            }
            if ( true && customSetter) {
                customSetter();
            }
            if (setter) {
                setter.call(obj, newVal);
            }
            else if (getter) {
                // #7981: for accessor properties without setter
                return;
            }
            else if (!shallow && isRef(value) && !isRef(newVal)) {
                value.value = newVal;
                return;
            }
            else {
                val = newVal;
            }
            childOb = shallow ? newVal && newVal.__ob__ : observe(newVal, false, mock);
            if (true) {
                dep.notify({
                    type: "set" /* TriggerOpTypes.SET */,
                    target: obj,
                    key: key,
                    newValue: newVal,
                    oldValue: value
                });
            }
            else // removed by dead control flow
{}
        }
    });
    return dep;
}
function set(target, key, val) {
    if ( true && (isUndef(target) || isPrimitive(target))) {
        warn("Cannot set reactive property on undefined, null, or primitive value: ".concat(target));
    }
    if (isReadonly(target)) {
         true && warn("Set operation on key \"".concat(key, "\" failed: target is readonly."));
        return;
    }
    var ob = target.__ob__;
    if (isArray(target) && isValidArrayIndex(key)) {
        target.length = Math.max(target.length, key);
        target.splice(key, 1, val);
        // when mocking for SSR, array methods are not hijacked
        if (ob && !ob.shallow && ob.mock) {
            observe(val, false, true);
        }
        return val;
    }
    if (key in target && !(key in Object.prototype)) {
        target[key] = val;
        return val;
    }
    if (target._isVue || (ob && ob.vmCount)) {
         true &&
            warn('Avoid adding reactive properties to a Vue instance or its root $data ' +
                'at runtime - declare it upfront in the data option.');
        return val;
    }
    if (!ob) {
        target[key] = val;
        return val;
    }
    defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);
    if (true) {
        ob.dep.notify({
            type: "add" /* TriggerOpTypes.ADD */,
            target: target,
            key: key,
            newValue: val,
            oldValue: undefined
        });
    }
    else // removed by dead control flow
{}
    return val;
}
function del(target, key) {
    if ( true && (isUndef(target) || isPrimitive(target))) {
        warn("Cannot delete reactive property on undefined, null, or primitive value: ".concat(target));
    }
    if (isArray(target) && isValidArrayIndex(key)) {
        target.splice(key, 1);
        return;
    }
    var ob = target.__ob__;
    if (target._isVue || (ob && ob.vmCount)) {
         true &&
            warn('Avoid deleting properties on a Vue instance or its root $data ' +
                '- just set it to null.');
        return;
    }
    if (isReadonly(target)) {
         true &&
            warn("Delete operation on key \"".concat(key, "\" failed: target is readonly."));
        return;
    }
    if (!hasOwn(target, key)) {
        return;
    }
    delete target[key];
    if (!ob) {
        return;
    }
    if (true) {
        ob.dep.notify({
            type: "delete" /* TriggerOpTypes.DELETE */,
            target: target,
            key: key
        });
    }
    else // removed by dead control flow
{}
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
    for (var e = void 0, i = 0, l = value.length; i < l; i++) {
        e = value[i];
        if (e && e.__ob__) {
            e.__ob__.dep.depend();
        }
        if (isArray(e)) {
            dependArray(e);
        }
    }
}

function reactive(target) {
    makeReactive(target, false);
    return target;
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */
function shallowReactive(target) {
    makeReactive(target, true);
    def(target, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, true);
    return target;
}
function makeReactive(target, shallow) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (!isReadonly(target)) {
        if (true) {
            if (isArray(target)) {
                warn("Avoid using Array as root value for ".concat(shallow ? "shallowReactive()" : "reactive()", " as it cannot be tracked in watch() or watchEffect(). Use ").concat(shallow ? "shallowRef()" : "ref()", " instead. This is a Vue-2-only limitation."));
            }
            var existingOb = target && target.__ob__;
            if (existingOb && existingOb.shallow !== shallow) {
                warn("Target is already a ".concat(existingOb.shallow ? "" : "non-", "shallow reactive object, and cannot be converted to ").concat(shallow ? "" : "non-", "shallow."));
            }
        }
        var ob = observe(target, shallow, isServerRendering() /* ssr mock reactivity */);
        if ( true && !ob) {
            if (target == null || isPrimitive(target)) {
                warn("value cannot be made reactive: ".concat(String(target)));
            }
            if (isCollectionType(target)) {
                warn("Vue 2 does not support reactive collection types such as Map or Set.");
            }
        }
    }
}
function isReactive(value) {
    if (isReadonly(value)) {
        return isReactive(value["__v_raw" /* ReactiveFlags.RAW */]);
    }
    return !!(value && value.__ob__);
}
function isShallow(value) {
    return !!(value && value.__v_isShallow);
}
function isReadonly(value) {
    return !!(value && value.__v_isReadonly);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    var raw = observed && observed["__v_raw" /* ReactiveFlags.RAW */];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    // non-extensible objects won't be observed anyway
    if (Object.isExtensible(value)) {
        def(value, "__v_skip" /* ReactiveFlags.SKIP */, true);
    }
    return value;
}
/**
 * @internal
 */
function isCollectionType(value) {
    var type = toRawType(value);
    return (type === 'Map' || type === 'WeakMap' || type === 'Set' || type === 'WeakSet');
}

/**
 * @internal
 */
var RefFlag = "__v_isRef";
function isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function ref$1(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
        return rawValue;
    }
    var ref = {};
    def(ref, RefFlag, true);
    def(ref, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, shallow);
    def(ref, 'dep', defineReactive(ref, 'value', rawValue, null, shallow, isServerRendering()));
    return ref;
}
function triggerRef(ref) {
    if ( true && !ref.dep) {
        warn("received object is not a triggerable ref.");
    }
    if (true) {
        ref.dep &&
            ref.dep.notify({
                type: "set" /* TriggerOpTypes.SET */,
                target: ref,
                key: 'value'
            });
    }
    else // removed by dead control flow
{}
}
function unref(ref) {
    return isRef(ref) ? ref.value : ref;
}
function proxyRefs(objectWithRefs) {
    if (isReactive(objectWithRefs)) {
        return objectWithRefs;
    }
    var proxy = {};
    var keys = Object.keys(objectWithRefs);
    for (var i = 0; i < keys.length; i++) {
        proxyWithRefUnwrap(proxy, objectWithRefs, keys[i]);
    }
    return proxy;
}
function proxyWithRefUnwrap(target, source, key) {
    Object.defineProperty(target, key, {
        enumerable: true,
        configurable: true,
        get: function () {
            var val = source[key];
            if (isRef(val)) {
                return val.value;
            }
            else {
                var ob = val && val.__ob__;
                if (ob)
                    ob.dep.depend();
                return val;
            }
        },
        set: function (value) {
            var oldValue = source[key];
            if (isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
            }
            else {
                source[key] = value;
            }
        }
    });
}
function customRef(factory) {
    var dep = new Dep();
    var _a = factory(function () {
        if (true) {
            dep.depend({
                target: ref,
                type: "get" /* TrackOpTypes.GET */,
                key: 'value'
            });
        }
        else // removed by dead control flow
{}
    }, function () {
        if (true) {
            dep.notify({
                target: ref,
                type: "set" /* TriggerOpTypes.SET */,
                key: 'value'
            });
        }
        else // removed by dead control flow
{}
    }), get = _a.get, set = _a.set;
    var ref = {
        get value() {
            return get();
        },
        set value(newVal) {
            set(newVal);
        }
    };
    def(ref, RefFlag, true);
    return ref;
}
function toRefs(object) {
    if ( true && !isReactive(object)) {
        warn("toRefs() expects a reactive object but received a plain one.");
    }
    var ret = isArray(object) ? new Array(object.length) : {};
    for (var key in object) {
        ret[key] = toRef(object, key);
    }
    return ret;
}
function toRef(object, key, defaultValue) {
    var val = object[key];
    if (isRef(val)) {
        return val;
    }
    var ref = {
        get value() {
            var val = object[key];
            return val === undefined ? defaultValue : val;
        },
        set value(newVal) {
            object[key] = newVal;
        }
    };
    def(ref, RefFlag, true);
    return ref;
}

var rawToReadonlyFlag = "__v_rawToReadonly";
var rawToShallowReadonlyFlag = "__v_rawToShallowReadonly";
function readonly(target) {
    return createReadonly(target, false);
}
function createReadonly(target, shallow) {
    if (!isPlainObject(target)) {
        if (true) {
            if (isArray(target)) {
                warn("Vue 2 does not support readonly arrays.");
            }
            else if (isCollectionType(target)) {
                warn("Vue 2 does not support readonly collection types such as Map or Set.");
            }
            else {
                warn("value cannot be made readonly: ".concat(typeof target));
            }
        }
        return target;
    }
    if ( true && !Object.isExtensible(target)) {
        warn("Vue 2 does not support creating readonly proxy for non-extensible object.");
    }
    // already a readonly object
    if (isReadonly(target)) {
        return target;
    }
    // already has a readonly proxy
    var existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;
    var existingProxy = target[existingFlag];
    if (existingProxy) {
        return existingProxy;
    }
    var proxy = Object.create(Object.getPrototypeOf(target));
    def(target, existingFlag, proxy);
    def(proxy, "__v_isReadonly" /* ReactiveFlags.IS_READONLY */, true);
    def(proxy, "__v_raw" /* ReactiveFlags.RAW */, target);
    if (isRef(target)) {
        def(proxy, RefFlag, true);
    }
    if (shallow || isShallow(target)) {
        def(proxy, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, true);
    }
    var keys = Object.keys(target);
    for (var i = 0; i < keys.length; i++) {
        defineReadonlyProperty(proxy, target, keys[i], shallow);
    }
    return proxy;
}
function defineReadonlyProperty(proxy, target, key, shallow) {
    Object.defineProperty(proxy, key, {
        enumerable: true,
        configurable: true,
        get: function () {
            var val = target[key];
            return shallow || !isPlainObject(val) ? val : readonly(val);
        },
        set: function () {
             true &&
                warn("Set operation on key \"".concat(key, "\" failed: target is readonly."));
        }
    });
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */
function shallowReadonly(target) {
    return createReadonly(target, true);
}

function computed(getterOrOptions, debugOptions) {
    var getter;
    var setter;
    var onlyGetter = isFunction(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter =  true
            ? function () {
                warn('Write operation failed: computed value is readonly');
            }
            : 0;
    }
    else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    var watcher = isServerRendering()
        ? null
        : new Watcher(currentInstance, getter, noop, { lazy: true });
    if ( true && watcher && debugOptions) {
        watcher.onTrack = debugOptions.onTrack;
        watcher.onTrigger = debugOptions.onTrigger;
    }
    var ref = {
        // some libs rely on the presence effect for checking computed refs
        // from normal refs, but the implementation doesn't matter
        effect: watcher,
        get value() {
            if (watcher) {
                if (watcher.dirty) {
                    watcher.evaluate();
                }
                if (Dep.target) {
                    if ( true && Dep.target.onTrack) {
                        Dep.target.onTrack({
                            effect: Dep.target,
                            target: ref,
                            type: "get" /* TrackOpTypes.GET */,
                            key: 'value'
                        });
                    }
                    watcher.depend();
                }
                return watcher.value;
            }
            else {
                return getter();
            }
        },
        set value(newVal) {
            setter(newVal);
        }
    };
    def(ref, RefFlag, true);
    def(ref, "__v_isReadonly" /* ReactiveFlags.IS_READONLY */, onlyGetter);
    return ref;
}

var WATCHER = "watcher";
var WATCHER_CB = "".concat(WATCHER, " callback");
var WATCHER_GETTER = "".concat(WATCHER, " getter");
var WATCHER_CLEANUP = "".concat(WATCHER, " cleanup");
// Simple effect.
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
    return doWatch(effect, null, ( true
        ? __assign(__assign({}, options), { flush: 'post' }) : 0));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, ( true
        ? __assign(__assign({}, options), { flush: 'sync' }) : 0));
}
// initial value for watchers to trigger on undefined initial values
var INITIAL_WATCHER_VALUE = {};
// implementation
function watch(source, cb, options) {
    if ( true && typeof cb !== 'function') {
        warn("`watch(fn, options?)` signature has been moved to a separate API. " +
            "Use `watchEffect(fn, options?)` instead. `watch` now only " +
            "supports `watch(source, cb, options?) signature.");
    }
    return doWatch(source, cb, options);
}
function doWatch(source, cb, _a) {
    var _b = _a === void 0 ? emptyObject : _a, immediate = _b.immediate, deep = _b.deep, _c = _b.flush, flush = _c === void 0 ? 'pre' : _c, onTrack = _b.onTrack, onTrigger = _b.onTrigger;
    if ( true && !cb) {
        if (immediate !== undefined) {
            warn("watch() \"immediate\" option is only respected when using the " +
                "watch(source, callback, options?) signature.");
        }
        if (deep !== undefined) {
            warn("watch() \"deep\" option is only respected when using the " +
                "watch(source, callback, options?) signature.");
        }
    }
    var warnInvalidSource = function (s) {
        warn("Invalid watch source: ".concat(s, ". A watch source can only be a getter/effect ") +
            "function, a ref, a reactive object, or an array of these types.");
    };
    var instance = currentInstance;
    var call = function (fn, type, args) {
        if (args === void 0) { args = null; }
        var res = invokeWithErrorHandling(fn, null, args, instance, type);
        if (deep && res && res.__ob__)
            res.__ob__.dep.depend();
        return res;
    };
    var getter;
    var forceTrigger = false;
    var isMultiSource = false;
    if (isRef(source)) {
        getter = function () { return source.value; };
        forceTrigger = isShallow(source);
    }
    else if (isReactive(source)) {
        getter = function () {
            source.__ob__.dep.depend();
            return source;
        };
        deep = true;
    }
    else if (isArray(source)) {
        isMultiSource = true;
        forceTrigger = source.some(function (s) { return isReactive(s) || isShallow(s); });
        getter = function () {
            return source.map(function (s) {
                if (isRef(s)) {
                    return s.value;
                }
                else if (isReactive(s)) {
                    s.__ob__.dep.depend();
                    return traverse(s);
                }
                else if (isFunction(s)) {
                    return call(s, WATCHER_GETTER);
                }
                else {
                     true && warnInvalidSource(s);
                }
            });
        };
    }
    else if (isFunction(source)) {
        if (cb) {
            // getter with cb
            getter = function () { return call(source, WATCHER_GETTER); };
        }
        else {
            // no cb -> simple effect
            getter = function () {
                if (instance && instance._isDestroyed) {
                    return;
                }
                if (cleanup) {
                    cleanup();
                }
                return call(source, WATCHER, [onCleanup]);
            };
        }
    }
    else {
        getter = noop;
         true && warnInvalidSource(source);
    }
    if (cb && deep) {
        var baseGetter_1 = getter;
        getter = function () { return traverse(baseGetter_1()); };
    }
    var cleanup;
    var onCleanup = function (fn) {
        cleanup = watcher.onStop = function () {
            call(fn, WATCHER_CLEANUP);
        };
    };
    // in SSR there is no need to setup an actual effect, and it should be noop
    // unless it's eager
    if (isServerRendering()) {
        // we will also not call the invalidate callback (+ runner is not set up)
        onCleanup = noop;
        if (!cb) {
            getter();
        }
        else if (immediate) {
            call(cb, WATCHER_CB, [
                getter(),
                isMultiSource ? [] : undefined,
                onCleanup
            ]);
        }
        return noop;
    }
    var watcher = new Watcher(currentInstance, getter, noop, {
        lazy: true
    });
    watcher.noRecurse = !cb;
    var oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
    // overwrite default run
    watcher.run = function () {
        if (!watcher.active) {
            return;
        }
        if (cb) {
            // watch(source, cb)
            var newValue = watcher.get();
            if (deep ||
                forceTrigger ||
                (isMultiSource
                    ? newValue.some(function (v, i) {
                        return hasChanged(v, oldValue[i]);
                    })
                    : hasChanged(newValue, oldValue))) {
                // cleanup before running cb again
                if (cleanup) {
                    cleanup();
                }
                call(cb, WATCHER_CB, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        }
        else {
            // watchEffect
            watcher.get();
        }
    };
    if (flush === 'sync') {
        watcher.update = watcher.run;
    }
    else if (flush === 'post') {
        watcher.post = true;
        watcher.update = function () { return queueWatcher(watcher); };
    }
    else {
        // pre
        watcher.update = function () {
            if (instance && instance === currentInstance && !instance._isMounted) {
                // pre-watcher triggered before
                var buffer = instance._preWatchers || (instance._preWatchers = []);
                if (buffer.indexOf(watcher) < 0)
                    buffer.push(watcher);
            }
            else {
                queueWatcher(watcher);
            }
        };
    }
    if (true) {
        watcher.onTrack = onTrack;
        watcher.onTrigger = onTrigger;
    }
    // initial run
    if (cb) {
        if (immediate) {
            watcher.run();
        }
        else {
            oldValue = watcher.get();
        }
    }
    else if (flush === 'post' && instance) {
        instance.$once('hook:mounted', function () { return watcher.get(); });
    }
    else {
        watcher.get();
    }
    return function () {
        watcher.teardown();
    };
}

var activeEffectScope;
var EffectScope = /** @class */ (function () {
    function EffectScope(detached) {
        if (detached === void 0) { detached = false; }
        this.detached = detached;
        /**
         * @internal
         */
        this.active = true;
        /**
         * @internal
         */
        this.effects = [];
        /**
         * @internal
         */
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
            this.index =
                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
        }
    }
    EffectScope.prototype.run = function (fn) {
        if (this.active) {
            var currentEffectScope = activeEffectScope;
            try {
                activeEffectScope = this;
                return fn();
            }
            finally {
                activeEffectScope = currentEffectScope;
            }
        }
        else if (true) {
            warn("cannot run an inactive effect scope.");
        }
    };
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    EffectScope.prototype.on = function () {
        activeEffectScope = this;
    };
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    EffectScope.prototype.off = function () {
        activeEffectScope = this.parent;
    };
    EffectScope.prototype.stop = function (fromParent) {
        if (this.active) {
            var i = void 0, l = void 0;
            for (i = 0, l = this.effects.length; i < l; i++) {
                this.effects[i].teardown();
            }
            for (i = 0, l = this.cleanups.length; i < l; i++) {
                this.cleanups[i]();
            }
            if (this.scopes) {
                for (i = 0, l = this.scopes.length; i < l; i++) {
                    this.scopes[i].stop(true);
                }
            }
            // nested scope, dereference from parent to avoid memory leaks
            if (!this.detached && this.parent && !fromParent) {
                // optimized O(1) removal
                var last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.parent = undefined;
            this.active = false;
        }
    };
    return EffectScope;
}());
function effectScope(detached) {
    return new EffectScope(detached);
}
/**
 * @internal
 */
function recordEffectScope(effect, scope) {
    if (scope === void 0) { scope = activeEffectScope; }
    if (scope && scope.active) {
        scope.effects.push(effect);
    }
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn) {
    if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
    }
    else if (true) {
        warn("onScopeDispose() is called when there is no active effect scope" +
            " to be associated with.");
    }
}

function provide(key, value) {
    if (!currentInstance) {
        if (true) {
            warn("provide() can only be used inside setup().");
        }
    }
    else {
        // TS doesn't allow symbol as index type
        resolveProvided(currentInstance)[key] = value;
    }
}
function resolveProvided(vm) {
    // by default an instance inherits its parent's provides object
    // but when it needs to provide values of its own, it creates its
    // own provides object using parent provides object as prototype.
    // this way in `inject` we can simply look up injections from direct
    // parent and let the prototype chain do the work.
    var existing = vm._provided;
    var parentProvides = vm.$parent && vm.$parent._provided;
    if (parentProvides === existing) {
        return (vm._provided = Object.create(parentProvides));
    }
    else {
        return existing;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory) {
    if (treatDefaultAsFactory === void 0) { treatDefaultAsFactory = false; }
    // fallback to `currentRenderingInstance` so that this can be called in
    // a functional component
    var instance = currentInstance;
    if (instance) {
        // #2400
        // to support `app.use` plugins,
        // fallback to appContext's `provides` if the instance is at root
        var provides = instance.$parent && instance.$parent._provided;
        if (provides && key in provides) {
            // TS doesn't allow symbol as index type
            return provides[key];
        }
        else if (arguments.length > 1) {
            return treatDefaultAsFactory && isFunction(defaultValue)
                ? defaultValue.call(instance)
                : defaultValue;
        }
        else if (true) {
            warn("injection \"".concat(String(key), "\" not found."));
        }
    }
    else if (true) {
        warn("inject() can only be used inside setup() or functional components.");
    }
}

var normalizeEvent = cached(function (name) {
    var passive = name.charAt(0) === '&';
    name = passive ? name.slice(1) : name;
    var once = name.charAt(0) === '~'; // Prefixed last, checked first
    name = once ? name.slice(1) : name;
    var capture = name.charAt(0) === '!';
    name = capture ? name.slice(1) : name;
    return {
        name: name,
        once: once,
        capture: capture,
        passive: passive
    };
});
function createFnInvoker(fns, vm) {
    function invoker() {
        var fns = invoker.fns;
        if (isArray(fns)) {
            var cloned = fns.slice();
            for (var i = 0; i < cloned.length; i++) {
                invokeWithErrorHandling(cloned[i], null, arguments, vm, "v-on handler");
            }
        }
        else {
            // return handler return value for single handlers
            return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
        }
    }
    invoker.fns = fns;
    return invoker;
}
function updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {
    var name, cur, old, event;
    for (name in on) {
        cur = on[name];
        old = oldOn[name];
        event = normalizeEvent(name);
        if (isUndef(cur)) {
             true &&
                warn("Invalid handler for event \"".concat(event.name, "\": got ") + String(cur), vm);
        }
        else if (isUndef(old)) {
            if (isUndef(cur.fns)) {
                cur = on[name] = createFnInvoker(cur, vm);
            }
            if (isTrue(event.once)) {
                cur = on[name] = createOnceHandler(event.name, cur, event.capture);
            }
            add(event.name, cur, event.capture, event.passive, event.params);
        }
        else if (cur !== old) {
            old.fns = cur;
            on[name] = old;
        }
    }
    for (name in oldOn) {
        if (isUndef(on[name])) {
            event = normalizeEvent(name);
            remove(event.name, oldOn[name], event.capture);
        }
    }
}

function mergeVNodeHook(def, hookKey, hook) {
    if (def instanceof VNode) {
        def = def.data.hook || (def.data.hook = {});
    }
    var invoker;
    var oldHook = def[hookKey];
    function wrappedHook() {
        hook.apply(this, arguments);
        // important: remove merged hook to ensure it's called only once
        // and prevent memory leak
        remove$2(invoker.fns, wrappedHook);
    }
    if (isUndef(oldHook)) {
        // no existing hook
        invoker = createFnInvoker([wrappedHook]);
    }
    else {
        /* istanbul ignore if */
        if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
            // already a merged invoker
            invoker = oldHook;
            invoker.fns.push(wrappedHook);
        }
        else {
            // existing plain hook
            invoker = createFnInvoker([oldHook, wrappedHook]);
        }
    }
    invoker.merged = true;
    def[hookKey] = invoker;
}

function extractPropsFromVNodeData(data, Ctor, tag) {
    // we are only extracting raw values here.
    // validation and default values are handled in the child
    // component itself.
    var propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
        return;
    }
    var res = {};
    var attrs = data.attrs, props = data.props;
    if (isDef(attrs) || isDef(props)) {
        for (var key in propOptions) {
            var altKey = hyphenate(key);
            if (true) {
                var keyInLowerCase = key.toLowerCase();
                if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
                    tip("Prop \"".concat(keyInLowerCase, "\" is passed to component ") +
                        "".concat(formatComponentName(
                        // @ts-expect-error tag is string
                        tag || Ctor), ", but the declared prop name is") +
                        " \"".concat(key, "\". ") +
                        "Note that HTML attributes are case-insensitive and camelCased " +
                        "props need to use their kebab-case equivalents when using in-DOM " +
                        "templates. You should probably use \"".concat(altKey, "\" instead of \"").concat(key, "\"."));
                }
            }
            checkProp(res, props, key, altKey, true) ||
                checkProp(res, attrs, key, altKey, false);
        }
    }
    return res;
}
function checkProp(res, hash, key, altKey, preserve) {
    if (isDef(hash)) {
        if (hasOwn(hash, key)) {
            res[key] = hash[key];
            if (!preserve) {
                delete hash[key];
            }
            return true;
        }
        else if (hasOwn(hash, altKey)) {
            res[key] = hash[altKey];
            if (!preserve) {
                delete hash[altKey];
            }
            return true;
        }
    }
    return false;
}

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
    for (var i = 0; i < children.length; i++) {
        if (isArray(children[i])) {
            return Array.prototype.concat.apply([], children);
        }
    }
    return children;
}
// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
    return isPrimitive(children)
        ? [createTextVNode(children)]
        : isArray(children)
            ? normalizeArrayChildren(children)
            : undefined;
}
function isTextNode(node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}
function normalizeArrayChildren(children, nestedIndex) {
    var res = [];
    var i, c, lastIndex, last;
    for (i = 0; i < children.length; i++) {
        c = children[i];
        if (isUndef(c) || typeof c === 'boolean')
            continue;
        lastIndex = res.length - 1;
        last = res[lastIndex];
        //  nested
        if (isArray(c)) {
            if (c.length > 0) {
                c = normalizeArrayChildren(c, "".concat(nestedIndex || '', "_").concat(i));
                // merge adjacent text nodes
                if (isTextNode(c[0]) && isTextNode(last)) {
                    res[lastIndex] = createTextVNode(last.text + c[0].text);
                    c.shift();
                }
                res.push.apply(res, c);
            }
        }
        else if (isPrimitive(c)) {
            if (isTextNode(last)) {
                // merge adjacent text nodes
                // this is necessary for SSR hydration because text nodes are
                // essentially merged when rendered to HTML strings
                res[lastIndex] = createTextVNode(last.text + c);
            }
            else if (c !== '') {
                // convert primitive to vnode
                res.push(createTextVNode(c));
            }
        }
        else {
            if (isTextNode(c) && isTextNode(last)) {
                // merge adjacent text nodes
                res[lastIndex] = createTextVNode(last.text + c.text);
            }
            else {
                // default key for nested array children (likely generated by v-for)
                if (isTrue(children._isVList) &&
                    isDef(c.tag) &&
                    isUndef(c.key) &&
                    isDef(nestedIndex)) {
                    c.key = "__vlist".concat(nestedIndex, "_").concat(i, "__");
                }
                res.push(c);
            }
        }
    }
    return res;
}

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
    var ret = null, i, l, keys, key;
    if (isArray(val) || typeof val === 'string') {
        ret = new Array(val.length);
        for (i = 0, l = val.length; i < l; i++) {
            ret[i] = render(val[i], i);
        }
    }
    else if (typeof val === 'number') {
        ret = new Array(val);
        for (i = 0; i < val; i++) {
            ret[i] = render(i + 1, i);
        }
    }
    else if (isObject(val)) {
        if (hasSymbol && val[Symbol.iterator]) {
            ret = [];
            var iterator = val[Symbol.iterator]();
            var result = iterator.next();
            while (!result.done) {
                ret.push(render(result.value, ret.length));
                result = iterator.next();
            }
        }
        else {
            keys = Object.keys(val);
            ret = new Array(keys.length);
            for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                ret[i] = render(val[key], key, i);
            }
        }
    }
    if (!isDef(ret)) {
        ret = [];
    }
    ret._isVList = true;
    return ret;
}

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallbackRender, props, bindObject) {
    var scopedSlotFn = this.$scopedSlots[name];
    var nodes;
    if (scopedSlotFn) {
        // scoped slot
        props = props || {};
        if (bindObject) {
            if ( true && !isObject(bindObject)) {
                warn('slot v-bind without argument expects an Object', this);
            }
            props = extend(extend({}, bindObject), props);
        }
        nodes =
            scopedSlotFn(props) ||
                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
    }
    else {
        nodes =
            this.$slots[name] ||
                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
    }
    var target = props && props.slot;
    if (target) {
        return this.$createElement('template', { slot: target }, nodes);
    }
    else {
        return nodes;
    }
}

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
    return resolveAsset(this.$options, 'filters', id, true) || identity;
}

function isKeyNotMatch(expect, actual) {
    if (isArray(expect)) {
        return expect.indexOf(actual) === -1;
    }
    else {
        return expect !== actual;
    }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
        return isKeyNotMatch(builtInKeyName, eventKeyName);
    }
    else if (mappedKeyCode) {
        return isKeyNotMatch(mappedKeyCode, eventKeyCode);
    }
    else if (eventKeyName) {
        return hyphenate(eventKeyName) !== key;
    }
    return eventKeyCode === undefined;
}

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp, isSync) {
    if (value) {
        if (!isObject(value)) {
             true &&
                warn('v-bind without argument expects an Object or Array value', this);
        }
        else {
            if (isArray(value)) {
                value = toObject(value);
            }
            var hash = void 0;
            var _loop_1 = function (key) {
                if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
                    hash = data;
                }
                else {
                    var type = data.attrs && data.attrs.type;
                    hash =
                        asProp || config.mustUseProp(tag, type, key)
                            ? data.domProps || (data.domProps = {})
                            : data.attrs || (data.attrs = {});
                }
                var camelizedKey = camelize(key);
                var hyphenatedKey = hyphenate(key);
                if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
                    hash[key] = value[key];
                    if (isSync) {
                        var on = data.on || (data.on = {});
                        on["update:".concat(key)] = function ($event) {
                            value[key] = $event;
                        };
                    }
                }
            };
            for (var key in value) {
                _loop_1(key);
            }
        }
    }
    return data;
}

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
    var cached = this._staticTrees || (this._staticTrees = []);
    var tree = cached[index];
    // if has already-rendered static tree and not inside v-for,
    // we can reuse the same tree.
    if (tree && !isInFor) {
        return tree;
    }
    // otherwise, render a fresh tree.
    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, this._c, this // for render fns generated for functional component templates
    );
    markStatic(tree, "__static__".concat(index), false);
    return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
    markStatic(tree, "__once__".concat(index).concat(key ? "_".concat(key) : ""), true);
    return tree;
}
function markStatic(tree, key, isOnce) {
    if (isArray(tree)) {
        for (var i = 0; i < tree.length; i++) {
            if (tree[i] && typeof tree[i] !== 'string') {
                markStaticNode(tree[i], "".concat(key, "_").concat(i), isOnce);
            }
        }
    }
    else {
        markStaticNode(tree, key, isOnce);
    }
}
function markStaticNode(node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
}

function bindObjectListeners(data, value) {
    if (value) {
        if (!isPlainObject(value)) {
             true && warn('v-on without argument expects an Object value', this);
        }
        else {
            var on = (data.on = data.on ? extend({}, data.on) : {});
            for (var key in value) {
                var existing = on[key];
                var ours = value[key];
                on[key] = existing ? [].concat(existing, ours) : ours;
            }
        }
    }
    return data;
}

function resolveScopedSlots(fns, res, 
// the following are added in 2.6
hasDynamicKeys, contentHashKey) {
    res = res || { $stable: !hasDynamicKeys };
    for (var i = 0; i < fns.length; i++) {
        var slot = fns[i];
        if (isArray(slot)) {
            resolveScopedSlots(slot, res, hasDynamicKeys);
        }
        else if (slot) {
            // marker for reverse proxying v-slot without scope on this.$slots
            // @ts-expect-error
            if (slot.proxy) {
                // @ts-expect-error
                slot.fn.proxy = true;
            }
            res[slot.key] = slot.fn;
        }
    }
    if (contentHashKey) {
        res.$key = contentHashKey;
    }
    return res;
}

// helper to process dynamic keys for dynamic arguments in v-bind and v-on.
function bindDynamicKeys(baseObj, values) {
    for (var i = 0; i < values.length; i += 2) {
        var key = values[i];
        if (typeof key === 'string' && key) {
            baseObj[values[i]] = values[i + 1];
        }
        else if ( true && key !== '' && key !== null) {
            // null is a special value for explicitly removing a binding
            warn("Invalid value for dynamic directive argument (expected string or null): ".concat(key), this);
        }
    }
    return baseObj;
}
// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier(value, symbol) {
    return typeof value === 'string' ? symbol + value : value;
}

function installRenderHelpers(target) {
    target._o = markOnce;
    target._n = toNumber;
    target._s = toString;
    target._l = renderList;
    target._t = renderSlot;
    target._q = looseEqual;
    target._i = looseIndexOf;
    target._m = renderStatic;
    target._f = resolveFilter;
    target._k = checkKeyCodes;
    target._b = bindObjectProps;
    target._v = createTextVNode;
    target._e = createEmptyVNode;
    target._u = resolveScopedSlots;
    target._g = bindObjectListeners;
    target._d = bindDynamicKeys;
    target._p = prependModifier;
}

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
    if (!children || !children.length) {
        return {};
    }
    var slots = {};
    for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i];
        var data = child.data;
        // remove slot attribute if the node is resolved as a Vue slot node
        if (data && data.attrs && data.attrs.slot) {
            delete data.attrs.slot;
        }
        // named slots should only be respected if the vnode was rendered in the
        // same context.
        if ((child.context === context || child.fnContext === context) &&
            data &&
            data.slot != null) {
            var name_1 = data.slot;
            var slot = slots[name_1] || (slots[name_1] = []);
            if (child.tag === 'template') {
                slot.push.apply(slot, child.children || []);
            }
            else {
                slot.push(child);
            }
        }
        else {
            (slots.default || (slots.default = [])).push(child);
        }
    }
    // ignore slots that contains only whitespace
    for (var name_2 in slots) {
        if (slots[name_2].every(isWhitespace)) {
            delete slots[name_2];
        }
    }
    return slots;
}
function isWhitespace(node) {
    return (node.isComment && !node.asyncFactory) || node.text === ' ';
}

function isAsyncPlaceholder(node) {
    // @ts-expect-error not really boolean type
    return node.isComment && node.asyncFactory;
}

function normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {
    var res;
    var hasNormalSlots = Object.keys(normalSlots).length > 0;
    var isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;
    var key = scopedSlots && scopedSlots.$key;
    if (!scopedSlots) {
        res = {};
    }
    else if (scopedSlots._normalized) {
        // fast path 1: child component re-render only, parent did not change
        return scopedSlots._normalized;
    }
    else if (isStable &&
        prevScopedSlots &&
        prevScopedSlots !== emptyObject &&
        key === prevScopedSlots.$key &&
        !hasNormalSlots &&
        !prevScopedSlots.$hasNormal) {
        // fast path 2: stable scoped slots w/ no normal slots to proxy,
        // only need to normalize once
        return prevScopedSlots;
    }
    else {
        res = {};
        for (var key_1 in scopedSlots) {
            if (scopedSlots[key_1] && key_1[0] !== '$') {
                res[key_1] = normalizeScopedSlot(ownerVm, normalSlots, key_1, scopedSlots[key_1]);
            }
        }
    }
    // expose normal slots on scopedSlots
    for (var key_2 in normalSlots) {
        if (!(key_2 in res)) {
            res[key_2] = proxyNormalSlot(normalSlots, key_2);
        }
    }
    // avoriaz seems to mock a non-extensible $scopedSlots object
    // and when that is passed down this would cause an error
    if (scopedSlots && Object.isExtensible(scopedSlots)) {
        scopedSlots._normalized = res;
    }
    def(res, '$stable', isStable);
    def(res, '$key', key);
    def(res, '$hasNormal', hasNormalSlots);
    return res;
}
function normalizeScopedSlot(vm, normalSlots, key, fn) {
    var normalized = function () {
        var cur = currentInstance;
        setCurrentInstance(vm);
        var res = arguments.length ? fn.apply(null, arguments) : fn({});
        res =
            res && typeof res === 'object' && !isArray(res)
                ? [res] // single vnode
                : normalizeChildren(res);
        var vnode = res && res[0];
        setCurrentInstance(cur);
        return res &&
            (!vnode ||
                (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode))) // #9658, #10391
            ? undefined
            : res;
    };
    // this is a slot using the new v-slot syntax without scope. although it is
    // compiled as a scoped slot, render fn users would expect it to be present
    // on this.$slots because the usage is semantically a normal slot.
    if (fn.proxy) {
        Object.defineProperty(normalSlots, key, {
            get: normalized,
            enumerable: true,
            configurable: true
        });
    }
    return normalized;
}
function proxyNormalSlot(slots, key) {
    return function () { return slots[key]; };
}

function initSetup(vm) {
    var options = vm.$options;
    var setup = options.setup;
    if (setup) {
        var ctx = (vm._setupContext = createSetupContext(vm));
        setCurrentInstance(vm);
        pushTarget();
        var setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, "setup");
        popTarget();
        setCurrentInstance();
        if (isFunction(setupResult)) {
            // render function
            // @ts-ignore
            options.render = setupResult;
        }
        else if (isObject(setupResult)) {
            // bindings
            if ( true && setupResult instanceof VNode) {
                warn("setup() should not return VNodes directly - " +
                    "return a render function instead.");
            }
            vm._setupState = setupResult;
            // __sfc indicates compiled bindings from <script setup>
            if (!setupResult.__sfc) {
                for (var key in setupResult) {
                    if (!isReserved(key)) {
                        proxyWithRefUnwrap(vm, setupResult, key);
                    }
                    else if (true) {
                        warn("Avoid using variables that start with _ or $ in setup().");
                    }
                }
            }
            else {
                // exposed for compiled render fn
                var proxy = (vm._setupProxy = {});
                for (var key in setupResult) {
                    if (key !== '__sfc') {
                        proxyWithRefUnwrap(proxy, setupResult, key);
                    }
                }
            }
        }
        else if ( true && setupResult !== undefined) {
            warn("setup() should return an object. Received: ".concat(setupResult === null ? 'null' : typeof setupResult));
        }
    }
}
function createSetupContext(vm) {
    var exposeCalled = false;
    return {
        get attrs() {
            if (!vm._attrsProxy) {
                var proxy = (vm._attrsProxy = {});
                def(proxy, '_v_attr_proxy', true);
                syncSetupProxy(proxy, vm.$attrs, emptyObject, vm, '$attrs');
            }
            return vm._attrsProxy;
        },
        get listeners() {
            if (!vm._listenersProxy) {
                var proxy = (vm._listenersProxy = {});
                syncSetupProxy(proxy, vm.$listeners, emptyObject, vm, '$listeners');
            }
            return vm._listenersProxy;
        },
        get slots() {
            return initSlotsProxy(vm);
        },
        emit: bind(vm.$emit, vm),
        expose: function (exposed) {
            if (true) {
                if (exposeCalled) {
                    warn("expose() should be called only once per setup().", vm);
                }
                exposeCalled = true;
            }
            if (exposed) {
                Object.keys(exposed).forEach(function (key) {
                    return proxyWithRefUnwrap(vm, exposed, key);
                });
            }
        }
    };
}
function syncSetupProxy(to, from, prev, instance, type) {
    var changed = false;
    for (var key in from) {
        if (!(key in to)) {
            changed = true;
            defineProxyAttr(to, key, instance, type);
        }
        else if (from[key] !== prev[key]) {
            changed = true;
        }
    }
    for (var key in to) {
        if (!(key in from)) {
            changed = true;
            delete to[key];
        }
    }
    return changed;
}
function defineProxyAttr(proxy, key, instance, type) {
    Object.defineProperty(proxy, key, {
        enumerable: true,
        configurable: true,
        get: function () {
            return instance[type][key];
        }
    });
}
function initSlotsProxy(vm) {
    if (!vm._slotsProxy) {
        syncSetupSlots((vm._slotsProxy = {}), vm.$scopedSlots);
    }
    return vm._slotsProxy;
}
function syncSetupSlots(to, from) {
    for (var key in from) {
        to[key] = from[key];
    }
    for (var key in to) {
        if (!(key in from)) {
            delete to[key];
        }
    }
}
/**
 * @internal use manual type def because public setup context type relies on
 * legacy VNode types
 */
function useSlots() {
    return getContext().slots;
}
/**
 * @internal use manual type def because public setup context type relies on
 * legacy VNode types
 */
function useAttrs() {
    return getContext().attrs;
}
/**
 * Vue 2 only
 * @internal use manual type def because public setup context type relies on
 * legacy VNode types
 */
function useListeners() {
    return getContext().listeners;
}
function getContext() {
    if ( true && !currentInstance) {
        warn("useContext() called without active instance.");
    }
    var vm = currentInstance;
    return vm._setupContext || (vm._setupContext = createSetupContext(vm));
}
/**
 * Runtime helper for merging default declarations. Imported by compiled code
 * only.
 * @internal
 */
function mergeDefaults(raw, defaults) {
    var props = isArray(raw)
        ? raw.reduce(function (normalized, p) { return ((normalized[p] = {}), normalized); }, {})
        : raw;
    for (var key in defaults) {
        var opt = props[key];
        if (opt) {
            if (isArray(opt) || isFunction(opt)) {
                props[key] = { type: opt, default: defaults[key] };
            }
            else {
                opt.default = defaults[key];
            }
        }
        else if (opt === null) {
            props[key] = { default: defaults[key] };
        }
        else if (true) {
            warn("props default key \"".concat(key, "\" has no corresponding declaration."));
        }
    }
    return props;
}

function initRender(vm) {
    vm._vnode = null; // the root of the child tree
    vm._staticTrees = null; // v-once cached trees
    var options = vm.$options;
    var parentVnode = (vm.$vnode = options._parentVnode); // the placeholder node in parent tree
    var renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(options._renderChildren, renderContext);
    vm.$scopedSlots = parentVnode
        ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots)
        : emptyObject;
    // bind the createElement fn to this instance
    // so that we get proper render context inside it.
    // args order: tag, data, children, normalizationType, alwaysNormalize
    // internal version is used by render functions compiled from templates
    // @ts-expect-error
    vm._c = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, false); };
    // normalization is always applied for the public version, used in
    // user-written render functions.
    // @ts-expect-error
    vm.$createElement = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, true); };
    // $attrs & $listeners are exposed for easier HOC creation.
    // they need to be reactive so that HOCs using them are always updated
    var parentData = parentVnode && parentVnode.data;
    /* istanbul ignore else */
    if (true) {
        defineReactive(vm, '$attrs', (parentData && parentData.attrs) || emptyObject, function () {
            !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
        }, true);
        defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
            !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
        }, true);
    }
    else // removed by dead control flow
{}
}
var currentRenderingInstance = null;
function renderMixin(Vue) {
    // install runtime convenience helpers
    installRenderHelpers(Vue.prototype);
    Vue.prototype.$nextTick = function (fn) {
        return nextTick(fn, this);
    };
    Vue.prototype._render = function () {
        var vm = this;
        var _a = vm.$options, render = _a.render, _parentVnode = _a._parentVnode;
        if (_parentVnode && vm._isMounted) {
            vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
            if (vm._slotsProxy) {
                syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);
            }
        }
        // set parent vnode. this allows render functions to have access
        // to the data on the placeholder node.
        vm.$vnode = _parentVnode;
        // render self
        var prevInst = currentInstance;
        var prevRenderInst = currentRenderingInstance;
        var vnode;
        try {
            setCurrentInstance(vm);
            currentRenderingInstance = vm;
            vnode = render.call(vm._renderProxy, vm.$createElement);
        }
        catch (e) {
            handleError(e, vm, "render");
            // return error render result,
            // or previous vnode to prevent render error causing blank component
            /* istanbul ignore else */
            if ( true && vm.$options.renderError) {
                try {
                    vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
                }
                catch (e) {
                    handleError(e, vm, "renderError");
                    vnode = vm._vnode;
                }
            }
            else {
                vnode = vm._vnode;
            }
        }
        finally {
            currentRenderingInstance = prevRenderInst;
            setCurrentInstance(prevInst);
        }
        // if the returned array contains only a single node, allow it
        if (isArray(vnode) && vnode.length === 1) {
            vnode = vnode[0];
        }
        // return empty vnode in case the render function errored out
        if (!(vnode instanceof VNode)) {
            if ( true && isArray(vnode)) {
                warn('Multiple root nodes returned from render function. Render function ' +
                    'should return a single root node.', vm);
            }
            vnode = createEmptyVNode();
        }
        // set parent
        vnode.parent = _parentVnode;
        return vnode;
    };
}

function ensureCtor(comp, base) {
    if (comp.__esModule || (hasSymbol && comp[Symbol.toStringTag] === 'Module')) {
        comp = comp.default;
    }
    return isObject(comp) ? base.extend(comp) : comp;
}
function createAsyncPlaceholder(factory, data, context, children, tag) {
    var node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = { data: data, context: context, children: children, tag: tag };
    return node;
}
function resolveAsyncComponent(factory, baseCtor) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
        return factory.errorComp;
    }
    if (isDef(factory.resolved)) {
        return factory.resolved;
    }
    var owner = currentRenderingInstance;
    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
        // already pending
        factory.owners.push(owner);
    }
    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
        return factory.loadingComp;
    }
    if (owner && !isDef(factory.owners)) {
        var owners_1 = (factory.owners = [owner]);
        var sync_1 = true;
        var timerLoading_1 = null;
        var timerTimeout_1 = null;
        owner.$on('hook:destroyed', function () { return remove$2(owners_1, owner); });
        var forceRender_1 = function (renderCompleted) {
            for (var i = 0, l = owners_1.length; i < l; i++) {
                owners_1[i].$forceUpdate();
            }
            if (renderCompleted) {
                owners_1.length = 0;
                if (timerLoading_1 !== null) {
                    clearTimeout(timerLoading_1);
                    timerLoading_1 = null;
                }
                if (timerTimeout_1 !== null) {
                    clearTimeout(timerTimeout_1);
                    timerTimeout_1 = null;
                }
            }
        };
        var resolve = once(function (res) {
            // cache resolved
            factory.resolved = ensureCtor(res, baseCtor);
            // invoke callbacks only if this is not a synchronous resolve
            // (async resolves are shimmed as synchronous during SSR)
            if (!sync_1) {
                forceRender_1(true);
            }
            else {
                owners_1.length = 0;
            }
        });
        var reject_1 = once(function (reason) {
             true &&
                warn("Failed to resolve async component: ".concat(String(factory)) +
                    (reason ? "\nReason: ".concat(reason) : ''));
            if (isDef(factory.errorComp)) {
                factory.error = true;
                forceRender_1(true);
            }
        });
        var res_1 = factory(resolve, reject_1);
        if (isObject(res_1)) {
            if (isPromise(res_1)) {
                // () => Promise
                if (isUndef(factory.resolved)) {
                    res_1.then(resolve, reject_1);
                }
            }
            else if (isPromise(res_1.component)) {
                res_1.component.then(resolve, reject_1);
                if (isDef(res_1.error)) {
                    factory.errorComp = ensureCtor(res_1.error, baseCtor);
                }
                if (isDef(res_1.loading)) {
                    factory.loadingComp = ensureCtor(res_1.loading, baseCtor);
                    if (res_1.delay === 0) {
                        factory.loading = true;
                    }
                    else {
                        // @ts-expect-error NodeJS timeout type
                        timerLoading_1 = setTimeout(function () {
                            timerLoading_1 = null;
                            if (isUndef(factory.resolved) && isUndef(factory.error)) {
                                factory.loading = true;
                                forceRender_1(false);
                            }
                        }, res_1.delay || 200);
                    }
                }
                if (isDef(res_1.timeout)) {
                    // @ts-expect-error NodeJS timeout type
                    timerTimeout_1 = setTimeout(function () {
                        timerTimeout_1 = null;
                        if (isUndef(factory.resolved)) {
                            reject_1( true ? "timeout (".concat(res_1.timeout, "ms)") : 0);
                        }
                    }, res_1.timeout);
                }
            }
        }
        sync_1 = false;
        // return in case resolved synchronously
        return factory.loading ? factory.loadingComp : factory.resolved;
    }
}

function getFirstComponentChild(children) {
    if (isArray(children)) {
        for (var i = 0; i < children.length; i++) {
            var c = children[i];
            if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
                return c;
            }
        }
    }
}

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;
// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {
    if (isArray(data) || isPrimitive(data)) {
        normalizationType = children;
        children = data;
        data = undefined;
    }
    if (isTrue(alwaysNormalize)) {
        normalizationType = ALWAYS_NORMALIZE;
    }
    return _createElement(context, tag, data, children, normalizationType);
}
function _createElement(context, tag, data, children, normalizationType) {
    if (isDef(data) && isDef(data.__ob__)) {
         true &&
            warn("Avoid using observed data object as vnode data: ".concat(JSON.stringify(data), "\n") + 'Always create fresh vnode data objects in each render!', context);
        return createEmptyVNode();
    }
    // object syntax in v-bind
    if (isDef(data) && isDef(data.is)) {
        tag = data.is;
    }
    if (!tag) {
        // in case of component :is set to falsy value
        return createEmptyVNode();
    }
    // warn against non-primitive key
    if ( true && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
        warn('Avoid using non-primitive value as key, ' +
            'use string/number value instead.', context);
    }
    // support single function children as default scoped slot
    if (isArray(children) && isFunction(children[0])) {
        data = data || {};
        data.scopedSlots = { default: children[0] };
        children.length = 0;
    }
    if (normalizationType === ALWAYS_NORMALIZE) {
        children = normalizeChildren(children);
    }
    else if (normalizationType === SIMPLE_NORMALIZE) {
        children = simpleNormalizeChildren(children);
    }
    var vnode, ns;
    if (typeof tag === 'string') {
        var Ctor = void 0;
        ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
        if (config.isReservedTag(tag)) {
            // platform built-in elements
            if ( true &&
                isDef(data) &&
                isDef(data.nativeOn) &&
                data.tag !== 'component') {
                warn("The .native modifier for v-on is only valid on components but it was used on <".concat(tag, ">."), context);
            }
            vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
        }
        else if ((!data || !data.pre) &&
            isDef((Ctor = resolveAsset(context.$options, 'components', tag)))) {
            // component
            vnode = createComponent(Ctor, data, context, children, tag);
        }
        else {
            // unknown or unlisted namespaced elements
            // check at runtime because it may get assigned a namespace when its
            // parent normalizes children
            vnode = new VNode(tag, data, children, undefined, undefined, context);
        }
    }
    else {
        // direct component options / constructor
        vnode = createComponent(tag, data, context, children);
    }
    if (isArray(vnode)) {
        return vnode;
    }
    else if (isDef(vnode)) {
        if (isDef(ns))
            applyNS(vnode, ns);
        if (isDef(data))
            registerDeepBindings(data);
        return vnode;
    }
    else {
        return createEmptyVNode();
    }
}
function applyNS(vnode, ns, force) {
    vnode.ns = ns;
    if (vnode.tag === 'foreignObject') {
        // use default namespace inside foreignObject
        ns = undefined;
        force = true;
    }
    if (isDef(vnode.children)) {
        for (var i = 0, l = vnode.children.length; i < l; i++) {
            var child = vnode.children[i];
            if (isDef(child.tag) &&
                (isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
                applyNS(child, ns, force);
            }
        }
    }
}
// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings(data) {
    if (isObject(data.style)) {
        traverse(data.style);
    }
    if (isObject(data.class)) {
        traverse(data.class);
    }
}

/**
 * @internal this function needs manual public type declaration because it relies
 * on previously manually authored types from Vue 2
 */
function h(type, props, children) {
    if (!currentInstance) {
         true &&
            warn("globally imported h() can only be invoked when there is an active " +
                "component instance, e.g. synchronously in a component's render or setup function.");
    }
    return createElement$1(currentInstance, type, props, children, 2, true);
}

function handleError(err, vm, info) {
    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
    // See: https://github.com/vuejs/vuex/issues/1505
    pushTarget();
    try {
        if (vm) {
            var cur = vm;
            while ((cur = cur.$parent)) {
                var hooks = cur.$options.errorCaptured;
                if (hooks) {
                    for (var i = 0; i < hooks.length; i++) {
                        try {
                            var capture = hooks[i].call(cur, err, vm, info) === false;
                            if (capture)
                                return;
                        }
                        catch (e) {
                            globalHandleError(e, cur, 'errorCaptured hook');
                        }
                    }
                }
            }
        }
        globalHandleError(err, vm, info);
    }
    finally {
        popTarget();
    }
}
function invokeWithErrorHandling(handler, context, args, vm, info) {
    var res;
    try {
        res = args ? handler.apply(context, args) : handler.call(context);
        if (res && !res._isVue && isPromise(res) && !res._handled) {
            res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
            res._handled = true;
        }
    }
    catch (e) {
        handleError(e, vm, info);
    }
    return res;
}
function globalHandleError(err, vm, info) {
    if (config.errorHandler) {
        try {
            return config.errorHandler.call(null, err, vm, info);
        }
        catch (e) {
            // if the user intentionally throws the original error in the handler,
            // do not log it twice
            if (e !== err) {
                logError(e, null, 'config.errorHandler');
            }
        }
    }
    logError(err, vm, info);
}
function logError(err, vm, info) {
    if (true) {
        warn("Error in ".concat(info, ": \"").concat(err.toString(), "\""), vm);
    }
    /* istanbul ignore else */
    if (inBrowser && typeof console !== 'undefined') {
        console.error(err);
    }
    else {
        throw err;
    }
}

/* globals MutationObserver */
var isUsingMicroTask = false;
var callbacks = [];
var pending = false;
function flushCallbacks() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
        copies[i]();
    }
}
// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
var timerFunc;
// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p_1 = Promise.resolve();
    timerFunc = function () {
        p_1.then(flushCallbacks);
        // In problematic UIWebViews, Promise.then doesn't completely break, but
        // it can get stuck in a weird state where callbacks are pushed into the
        // microtask queue but the queue isn't being flushed, until the browser
        // needs to do some other work, e.g. handle a timer. Therefore we can
        // "force" the microtask queue to be flushed by adding an empty timer.
        if (isIOS)
            setTimeout(noop);
    };
    isUsingMicroTask = true;
}
else if (!isIE &&
    typeof MutationObserver !== 'undefined' &&
    (isNative(MutationObserver) ||
        // PhantomJS and iOS 7.x
        MutationObserver.toString() === '[object MutationObserverConstructor]')) {
    // Use MutationObserver where native Promise is not available,
    // e.g. PhantomJS, iOS7, Android 4.4
    // (#6466 MutationObserver is unreliable in IE11)
    var counter_1 = 1;
    var observer = new MutationObserver(flushCallbacks);
    var textNode_1 = document.createTextNode(String(counter_1));
    observer.observe(textNode_1, {
        characterData: true
    });
    timerFunc = function () {
        counter_1 = (counter_1 + 1) % 2;
        textNode_1.data = String(counter_1);
    };
    isUsingMicroTask = true;
}
else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    // Fallback to setImmediate.
    // Technically it leverages the (macro) task queue,
    // but it is still a better choice than setTimeout.
    timerFunc = function () {
        setImmediate(flushCallbacks);
    };
}
else {
    // Fallback to setTimeout.
    timerFunc = function () {
        setTimeout(flushCallbacks, 0);
    };
}
/**
 * @internal
 */
function nextTick(cb, ctx) {
    var _resolve;
    callbacks.push(function () {
        if (cb) {
            try {
                cb.call(ctx);
            }
            catch (e) {
                handleError(e, ctx, 'nextTick');
            }
        }
        else if (_resolve) {
            _resolve(ctx);
        }
    });
    if (!pending) {
        pending = true;
        timerFunc();
    }
    // $flow-disable-line
    if (!cb && typeof Promise !== 'undefined') {
        return new Promise(function (resolve) {
            _resolve = resolve;
        });
    }
}

function useCssModule(name) {
    if (name === void 0) { name = '$style'; }
    /* istanbul ignore else */
    {
        if (!currentInstance) {
             true && warn("useCssModule must be called inside setup()");
            return emptyObject;
        }
        var mod = currentInstance[name];
        if (!mod) {
             true &&
                warn("Current instance does not have CSS module named \"".concat(name, "\"."));
            return emptyObject;
        }
        return mod;
    }
}

/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */
function useCssVars(getter) {
    if (!inBrowser && !false)
        return;
    var instance = currentInstance;
    if (!instance) {
         true &&
            warn("useCssVars is called without current active component instance.");
        return;
    }
    watchPostEffect(function () {
        var el = instance.$el;
        var vars = getter(instance, instance._setupProxy);
        if (el && el.nodeType === 1) {
            var style = el.style;
            for (var key in vars) {
                style.setProperty("--".concat(key), vars[key]);
            }
        }
    });
}

/**
 * v3-compatible async component API.
 * @internal the type is manually declared in <root>/types/v3-define-async-component.d.ts
 * because it relies on existing manual types
 */
function defineAsyncComponent(source) {
    if (isFunction(source)) {
        source = { loader: source };
    }
    var loader = source.loader, loadingComponent = source.loadingComponent, errorComponent = source.errorComponent, _a = source.delay, delay = _a === void 0 ? 200 : _a, timeout = source.timeout, // undefined = never times out
    _b = source.suspensible, // undefined = never times out
    suspensible = _b === void 0 ? false : _b, // in Vue 3 default is true
    userOnError = source.onError;
    if ( true && suspensible) {
        warn("The suspensible option for async components is not supported in Vue2. It is ignored.");
    }
    var pendingRequest = null;
    var retries = 0;
    var retry = function () {
        retries++;
        pendingRequest = null;
        return load();
    };
    var load = function () {
        var thisRequest;
        return (pendingRequest ||
            (thisRequest = pendingRequest =
                loader()
                    .catch(function (err) {
                    err = err instanceof Error ? err : new Error(String(err));
                    if (userOnError) {
                        return new Promise(function (resolve, reject) {
                            var userRetry = function () { return resolve(retry()); };
                            var userFail = function () { return reject(err); };
                            userOnError(err, userRetry, userFail, retries + 1);
                        });
                    }
                    else {
                        throw err;
                    }
                })
                    .then(function (comp) {
                    if (thisRequest !== pendingRequest && pendingRequest) {
                        return pendingRequest;
                    }
                    if ( true && !comp) {
                        warn("Async component loader resolved to undefined. " +
                            "If you are using retry(), make sure to return its return value.");
                    }
                    // interop module default
                    if (comp &&
                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
                        comp = comp.default;
                    }
                    if ( true && comp && !isObject(comp) && !isFunction(comp)) {
                        throw new Error("Invalid async component load result: ".concat(comp));
                    }
                    return comp;
                })));
    };
    return function () {
        var component = load();
        return {
            component: component,
            delay: delay,
            timeout: timeout,
            error: errorComponent,
            loading: loadingComponent
        };
    };
}

function createLifeCycle(hookName) {
    return function (fn, target) {
        if (target === void 0) { target = currentInstance; }
        if (!target) {
             true &&
                warn("".concat(formatName(hookName), " is called when there is no active component instance to be ") +
                    "associated with. " +
                    "Lifecycle injection APIs can only be used during execution of setup().");
            return;
        }
        return injectHook(target, hookName, fn);
    };
}
function formatName(name) {
    if (name === 'beforeDestroy') {
        name = 'beforeUnmount';
    }
    else if (name === 'destroyed') {
        name = 'unmounted';
    }
    return "on".concat(name[0].toUpperCase() + name.slice(1));
}
function injectHook(instance, hookName, fn) {
    var options = instance.$options;
    options[hookName] = mergeLifecycleHook(options[hookName], fn);
}
var onBeforeMount = createLifeCycle('beforeMount');
var onMounted = createLifeCycle('mounted');
var onBeforeUpdate = createLifeCycle('beforeUpdate');
var onUpdated = createLifeCycle('updated');
var onBeforeUnmount = createLifeCycle('beforeDestroy');
var onUnmounted = createLifeCycle('destroyed');
var onActivated = createLifeCycle('activated');
var onDeactivated = createLifeCycle('deactivated');
var onServerPrefetch = createLifeCycle('serverPrefetch');
var onRenderTracked = createLifeCycle('renderTracked');
var onRenderTriggered = createLifeCycle('renderTriggered');
var injectErrorCapturedHook = createLifeCycle('errorCaptured');
function onErrorCaptured(hook, target) {
    if (target === void 0) { target = currentInstance; }
    injectErrorCapturedHook(hook, target);
}

/**
 * Note: also update dist/vue.runtime.mjs when adding new exports to this file.
 */
var version = '2.7.16';
/**
 * @internal type is manually declared in <root>/types/v3-define-component.d.ts
 */
function defineComponent(options) {
    return options;
}

var seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse(val) {
    _traverse(val, seenObjects);
    seenObjects.clear();
    return val;
}
function _traverse(val, seen) {
    var i, keys;
    var isA = isArray(val);
    if ((!isA && !isObject(val)) ||
        val.__v_skip /* ReactiveFlags.SKIP */ ||
        Object.isFrozen(val) ||
        val instanceof VNode) {
        return;
    }
    if (val.__ob__) {
        var depId = val.__ob__.dep.id;
        if (seen.has(depId)) {
            return;
        }
        seen.add(depId);
    }
    if (isA) {
        i = val.length;
        while (i--)
            _traverse(val[i], seen);
    }
    else if (isRef(val)) {
        _traverse(val.value, seen);
    }
    else {
        keys = Object.keys(val);
        i = keys.length;
        while (i--)
            _traverse(val[keys[i]], seen);
    }
}

var uid$1 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 * @internal
 */
var Watcher = /** @class */ (function () {
    function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
        recordEffectScope(this, 
        // if the active effect scope is manually created (not a component scope),
        // prioritize it
        activeEffectScope && !activeEffectScope._vm
            ? activeEffectScope
            : vm
                ? vm._scope
                : undefined);
        if ((this.vm = vm) && isRenderWatcher) {
            vm._watcher = this;
        }
        // options
        if (options) {
            this.deep = !!options.deep;
            this.user = !!options.user;
            this.lazy = !!options.lazy;
            this.sync = !!options.sync;
            this.before = options.before;
            if (true) {
                this.onTrack = options.onTrack;
                this.onTrigger = options.onTrigger;
            }
        }
        else {
            this.deep = this.user = this.lazy = this.sync = false;
        }
        this.cb = cb;
        this.id = ++uid$1; // uid for batching
        this.active = true;
        this.post = false;
        this.dirty = this.lazy; // for lazy watchers
        this.deps = [];
        this.newDeps = [];
        this.depIds = new _Set();
        this.newDepIds = new _Set();
        this.expression =  true ? expOrFn.toString() : 0;
        // parse expression for getter
        if (isFunction(expOrFn)) {
            this.getter = expOrFn;
        }
        else {
            this.getter = parsePath(expOrFn);
            if (!this.getter) {
                this.getter = noop;
                 true &&
                    warn("Failed watching path: \"".concat(expOrFn, "\" ") +
                        'Watcher only accepts simple dot-delimited paths. ' +
                        'For full control, use a function instead.', vm);
            }
        }
        this.value = this.lazy ? undefined : this.get();
    }
    /**
     * Evaluate the getter, and re-collect dependencies.
     */
    Watcher.prototype.get = function () {
        pushTarget(this);
        var value;
        var vm = this.vm;
        try {
            value = this.getter.call(vm, vm);
        }
        catch (e) {
            if (this.user) {
                handleError(e, vm, "getter for watcher \"".concat(this.expression, "\""));
            }
            else {
                throw e;
            }
        }
        finally {
            // "touch" every property so they are all tracked as
            // dependencies for deep watching
            if (this.deep) {
                traverse(value);
            }
            popTarget();
            this.cleanupDeps();
        }
        return value;
    };
    /**
     * Add a dependency to this directive.
     */
    Watcher.prototype.addDep = function (dep) {
        var id = dep.id;
        if (!this.newDepIds.has(id)) {
            this.newDepIds.add(id);
            this.newDeps.push(dep);
            if (!this.depIds.has(id)) {
                dep.addSub(this);
            }
        }
    };
    /**
     * Clean up for dependency collection.
     */
    Watcher.prototype.cleanupDeps = function () {
        var i = this.deps.length;
        while (i--) {
            var dep = this.deps[i];
            if (!this.newDepIds.has(dep.id)) {
                dep.removeSub(this);
            }
        }
        var tmp = this.depIds;
        this.depIds = this.newDepIds;
        this.newDepIds = tmp;
        this.newDepIds.clear();
        tmp = this.deps;
        this.deps = this.newDeps;
        this.newDeps = tmp;
        this.newDeps.length = 0;
    };
    /**
     * Subscriber interface.
     * Will be called when a dependency changes.
     */
    Watcher.prototype.update = function () {
        /* istanbul ignore else */
        if (this.lazy) {
            this.dirty = true;
        }
        else if (this.sync) {
            this.run();
        }
        else {
            queueWatcher(this);
        }
    };
    /**
     * Scheduler job interface.
     * Will be called by the scheduler.
     */
    Watcher.prototype.run = function () {
        if (this.active) {
            var value = this.get();
            if (value !== this.value ||
                // Deep watchers and watchers on Object/Arrays should fire even
                // when the value is the same, because the value may
                // have mutated.
                isObject(value) ||
                this.deep) {
                // set new value
                var oldValue = this.value;
                this.value = value;
                if (this.user) {
                    var info = "callback for watcher \"".concat(this.expression, "\"");
                    invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
                }
                else {
                    this.cb.call(this.vm, value, oldValue);
                }
            }
        }
    };
    /**
     * Evaluate the value of the watcher.
     * This only gets called for lazy watchers.
     */
    Watcher.prototype.evaluate = function () {
        this.value = this.get();
        this.dirty = false;
    };
    /**
     * Depend on all deps collected by this watcher.
     */
    Watcher.prototype.depend = function () {
        var i = this.deps.length;
        while (i--) {
            this.deps[i].depend();
        }
    };
    /**
     * Remove self from all dependencies' subscriber list.
     */
    Watcher.prototype.teardown = function () {
        if (this.vm && !this.vm._isBeingDestroyed) {
            remove$2(this.vm._scope.effects, this);
        }
        if (this.active) {
            var i = this.deps.length;
            while (i--) {
                this.deps[i].removeSub(this);
            }
            this.active = false;
            if (this.onStop) {
                this.onStop();
            }
        }
    };
    return Watcher;
}());

var mark;
var measure;
if (true) {
    var perf_1 = inBrowser && window.performance;
    /* istanbul ignore if */
    if (perf_1 &&
        // @ts-ignore
        perf_1.mark &&
        // @ts-ignore
        perf_1.measure &&
        // @ts-ignore
        perf_1.clearMarks &&
        // @ts-ignore
        perf_1.clearMeasures) {
        mark = function (tag) { return perf_1.mark(tag); };
        measure = function (name, startTag, endTag) {
            perf_1.measure(name, startTag, endTag);
            perf_1.clearMarks(startTag);
            perf_1.clearMarks(endTag);
            // perf.clearMeasures(name)
        };
    }
}

function initEvents(vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false;
    // init parent attached events
    var listeners = vm.$options._parentListeners;
    if (listeners) {
        updateComponentListeners(vm, listeners);
    }
}
var target$1;
function add$1(event, fn) {
    target$1.$on(event, fn);
}
function remove$1(event, fn) {
    target$1.$off(event, fn);
}
function createOnceHandler$1(event, fn) {
    var _target = target$1;
    return function onceHandler() {
        var res = fn.apply(null, arguments);
        if (res !== null) {
            _target.$off(event, onceHandler);
        }
    };
}
function updateComponentListeners(vm, listeners, oldListeners) {
    target$1 = vm;
    updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);
    target$1 = undefined;
}
function eventsMixin(Vue) {
    var hookRE = /^hook:/;
    Vue.prototype.$on = function (event, fn) {
        var vm = this;
        if (isArray(event)) {
            for (var i = 0, l = event.length; i < l; i++) {
                vm.$on(event[i], fn);
            }
        }
        else {
            (vm._events[event] || (vm._events[event] = [])).push(fn);
            // optimize hook:event cost by using a boolean flag marked at registration
            // instead of a hash lookup
            if (hookRE.test(event)) {
                vm._hasHookEvent = true;
            }
        }
        return vm;
    };
    Vue.prototype.$once = function (event, fn) {
        var vm = this;
        function on() {
            vm.$off(event, on);
            fn.apply(vm, arguments);
        }
        on.fn = fn;
        vm.$on(event, on);
        return vm;
    };
    Vue.prototype.$off = function (event, fn) {
        var vm = this;
        // all
        if (!arguments.length) {
            vm._events = Object.create(null);
            return vm;
        }
        // array of events
        if (isArray(event)) {
            for (var i_1 = 0, l = event.length; i_1 < l; i_1++) {
                vm.$off(event[i_1], fn);
            }
            return vm;
        }
        // specific event
        var cbs = vm._events[event];
        if (!cbs) {
            return vm;
        }
        if (!fn) {
            vm._events[event] = null;
            return vm;
        }
        // specific handler
        var cb;
        var i = cbs.length;
        while (i--) {
            cb = cbs[i];
            if (cb === fn || cb.fn === fn) {
                cbs.splice(i, 1);
                break;
            }
        }
        return vm;
    };
    Vue.prototype.$emit = function (event) {
        var vm = this;
        if (true) {
            var lowerCaseEvent = event.toLowerCase();
            if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
                tip("Event \"".concat(lowerCaseEvent, "\" is emitted in component ") +
                    "".concat(formatComponentName(vm), " but the handler is registered for \"").concat(event, "\". ") +
                    "Note that HTML attributes are case-insensitive and you cannot use " +
                    "v-on to listen to camelCase events when using in-DOM templates. " +
                    "You should probably use \"".concat(hyphenate(event), "\" instead of \"").concat(event, "\"."));
            }
        }
        var cbs = vm._events[event];
        if (cbs) {
            cbs = cbs.length > 1 ? toArray(cbs) : cbs;
            var args = toArray(arguments, 1);
            var info = "event handler for \"".concat(event, "\"");
            for (var i = 0, l = cbs.length; i < l; i++) {
                invokeWithErrorHandling(cbs[i], vm, args, vm, info);
            }
        }
        return vm;
    };
}

var activeInstance = null;
var isUpdatingChildComponent = false;
function setActiveInstance(vm) {
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    return function () {
        activeInstance = prevActiveInstance;
    };
}
function initLifecycle(vm) {
    var options = vm.$options;
    // locate first non-abstract parent
    var parent = options.parent;
    if (parent && !options.abstract) {
        while (parent.$options.abstract && parent.$parent) {
            parent = parent.$parent;
        }
        parent.$children.push(vm);
    }
    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;
    vm.$children = [];
    vm.$refs = {};
    vm._provided = parent ? parent._provided : Object.create(null);
    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
}
function lifecycleMixin(Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
        var vm = this;
        var prevEl = vm.$el;
        var prevVnode = vm._vnode;
        var restoreActiveInstance = setActiveInstance(vm);
        vm._vnode = vnode;
        // Vue.prototype.__patch__ is injected in entry points
        // based on the rendering backend used.
        if (!prevVnode) {
            // initial render
            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
        }
        else {
            // updates
            vm.$el = vm.__patch__(prevVnode, vnode);
        }
        restoreActiveInstance();
        // update __vue__ reference
        if (prevEl) {
            prevEl.__vue__ = null;
        }
        if (vm.$el) {
            vm.$el.__vue__ = vm;
        }
        // if parent is an HOC, update its $el as well
        var wrapper = vm;
        while (wrapper &&
            wrapper.$vnode &&
            wrapper.$parent &&
            wrapper.$vnode === wrapper.$parent._vnode) {
            wrapper.$parent.$el = wrapper.$el;
            wrapper = wrapper.$parent;
        }
        // updated hook is called by the scheduler to ensure that children are
        // updated in a parent's updated hook.
    };
    Vue.prototype.$forceUpdate = function () {
        var vm = this;
        if (vm._watcher) {
            vm._watcher.update();
        }
    };
    Vue.prototype.$destroy = function () {
        var vm = this;
        if (vm._isBeingDestroyed) {
            return;
        }
        callHook$1(vm, 'beforeDestroy');
        vm._isBeingDestroyed = true;
        // remove self from parent
        var parent = vm.$parent;
        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
            remove$2(parent.$children, vm);
        }
        // teardown scope. this includes both the render watcher and other
        // watchers created
        vm._scope.stop();
        // remove reference from data ob
        // frozen object may not have observer.
        if (vm._data.__ob__) {
            vm._data.__ob__.vmCount--;
        }
        // call the last hook...
        vm._isDestroyed = true;
        // invoke destroy hooks on current rendered tree
        vm.__patch__(vm._vnode, null);
        // fire destroyed hook
        callHook$1(vm, 'destroyed');
        // turn off all instance listeners.
        vm.$off();
        // remove __vue__ reference
        if (vm.$el) {
            vm.$el.__vue__ = null;
        }
        // release circular reference (#6759)
        if (vm.$vnode) {
            vm.$vnode.parent = null;
        }
    };
}
function mountComponent(vm, el, hydrating) {
    vm.$el = el;
    if (!vm.$options.render) {
        // @ts-expect-error invalid type
        vm.$options.render = createEmptyVNode;
        if (true) {
            /* istanbul ignore if */
            if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
                vm.$options.el ||
                el) {
                warn('You are using the runtime-only build of Vue where the template ' +
                    'compiler is not available. Either pre-compile the templates into ' +
                    'render functions, or use the compiler-included build.', vm);
            }
            else {
                warn('Failed to mount component: template or render function not defined.', vm);
            }
        }
    }
    callHook$1(vm, 'beforeMount');
    var updateComponent;
    /* istanbul ignore if */
    if ( true && config.performance && mark) {
        updateComponent = function () {
            var name = vm._name;
            var id = vm._uid;
            var startTag = "vue-perf-start:".concat(id);
            var endTag = "vue-perf-end:".concat(id);
            mark(startTag);
            var vnode = vm._render();
            mark(endTag);
            measure("vue ".concat(name, " render"), startTag, endTag);
            mark(startTag);
            vm._update(vnode, hydrating);
            mark(endTag);
            measure("vue ".concat(name, " patch"), startTag, endTag);
        };
    }
    else {
        updateComponent = function () {
            vm._update(vm._render(), hydrating);
        };
    }
    var watcherOptions = {
        before: function () {
            if (vm._isMounted && !vm._isDestroyed) {
                callHook$1(vm, 'beforeUpdate');
            }
        }
    };
    if (true) {
        watcherOptions.onTrack = function (e) { return callHook$1(vm, 'renderTracked', [e]); };
        watcherOptions.onTrigger = function (e) { return callHook$1(vm, 'renderTriggered', [e]); };
    }
    // we set this to vm._watcher inside the watcher's constructor
    // since the watcher's initial patch may call $forceUpdate (e.g. inside child
    // component's mounted hook), which relies on vm._watcher being already defined
    new Watcher(vm, updateComponent, noop, watcherOptions, true /* isRenderWatcher */);
    hydrating = false;
    // flush buffer for flush: "pre" watchers queued in setup()
    var preWatchers = vm._preWatchers;
    if (preWatchers) {
        for (var i = 0; i < preWatchers.length; i++) {
            preWatchers[i].run();
        }
    }
    // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook
    if (vm.$vnode == null) {
        vm._isMounted = true;
        callHook$1(vm, 'mounted');
    }
    return vm;
}
function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
    if (true) {
        isUpdatingChildComponent = true;
    }
    // determine whether component has slot children
    // we need to do this before overwriting $options._renderChildren.
    // check if there are dynamic scopedSlots (hand-written or compiled but with
    // dynamic slot names). Static scoped slots compiled from template has the
    // "$stable" marker.
    var newScopedSlots = parentVnode.data.scopedSlots;
    var oldScopedSlots = vm.$scopedSlots;
    var hasDynamicScopedSlot = !!((newScopedSlots && !newScopedSlots.$stable) ||
        (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
        (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||
        (!newScopedSlots && vm.$scopedSlots.$key));
    // Any static slot children from the parent may have changed during parent's
    // update. Dynamic scoped slots may also have changed. In such cases, a forced
    // update is necessary to ensure correctness.
    var needsForceUpdate = !!(renderChildren || // has new static slots
        vm.$options._renderChildren || // has old static slots
        hasDynamicScopedSlot);
    var prevVNode = vm.$vnode;
    vm.$options._parentVnode = parentVnode;
    vm.$vnode = parentVnode; // update vm's placeholder node without re-render
    if (vm._vnode) {
        // update child tree's parent
        vm._vnode.parent = parentVnode;
    }
    vm.$options._renderChildren = renderChildren;
    // update $attrs and $listeners hash
    // these are also reactive so they may trigger child update if the child
    // used them during render
    var attrs = parentVnode.data.attrs || emptyObject;
    if (vm._attrsProxy) {
        // force update if attrs are accessed and has changed since it may be
        // passed to a child component.
        if (syncSetupProxy(vm._attrsProxy, attrs, (prevVNode.data && prevVNode.data.attrs) || emptyObject, vm, '$attrs')) {
            needsForceUpdate = true;
        }
    }
    vm.$attrs = attrs;
    // update listeners
    listeners = listeners || emptyObject;
    var prevListeners = vm.$options._parentListeners;
    if (vm._listenersProxy) {
        syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, '$listeners');
    }
    vm.$listeners = vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, prevListeners);
    // update props
    if (propsData && vm.$options.props) {
        toggleObserving(false);
        var props = vm._props;
        var propKeys = vm.$options._propKeys || [];
        for (var i = 0; i < propKeys.length; i++) {
            var key = propKeys[i];
            var propOptions = vm.$options.props; // wtf flow?
            props[key] = validateProp(key, propOptions, propsData, vm);
        }
        toggleObserving(true);
        // keep a copy of raw propsData
        vm.$options.propsData = propsData;
    }
    // resolve slots + force update if has children
    if (needsForceUpdate) {
        vm.$slots = resolveSlots(renderChildren, parentVnode.context);
        vm.$forceUpdate();
    }
    if (true) {
        isUpdatingChildComponent = false;
    }
}
function isInInactiveTree(vm) {
    while (vm && (vm = vm.$parent)) {
        if (vm._inactive)
            return true;
    }
    return false;
}
function activateChildComponent(vm, direct) {
    if (direct) {
        vm._directInactive = false;
        if (isInInactiveTree(vm)) {
            return;
        }
    }
    else if (vm._directInactive) {
        return;
    }
    if (vm._inactive || vm._inactive === null) {
        vm._inactive = false;
        for (var i = 0; i < vm.$children.length; i++) {
            activateChildComponent(vm.$children[i]);
        }
        callHook$1(vm, 'activated');
    }
}
function deactivateChildComponent(vm, direct) {
    if (direct) {
        vm._directInactive = true;
        if (isInInactiveTree(vm)) {
            return;
        }
    }
    if (!vm._inactive) {
        vm._inactive = true;
        for (var i = 0; i < vm.$children.length; i++) {
            deactivateChildComponent(vm.$children[i]);
        }
        callHook$1(vm, 'deactivated');
    }
}
function callHook$1(vm, hook, args, setContext) {
    if (setContext === void 0) { setContext = true; }
    // #7573 disable dep collection when invoking lifecycle hooks
    pushTarget();
    var prevInst = currentInstance;
    var prevScope = getCurrentScope();
    setContext && setCurrentInstance(vm);
    var handlers = vm.$options[hook];
    var info = "".concat(hook, " hook");
    if (handlers) {
        for (var i = 0, j = handlers.length; i < j; i++) {
            invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);
        }
    }
    if (vm._hasHookEvent) {
        vm.$emit('hook:' + hook);
    }
    if (setContext) {
        setCurrentInstance(prevInst);
        prevScope && prevScope.on();
    }
    popTarget();
}

var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;
/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
    index = queue.length = activatedChildren.length = 0;
    has = {};
    if (true) {
        circular = {};
    }
    waiting = flushing = false;
}
// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
var currentFlushTimestamp = 0;
// Async edge case fix requires storing an event listener's attach timestamp.
var getNow = Date.now;
// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE) {
    var performance_1 = window.performance;
    if (performance_1 &&
        typeof performance_1.now === 'function' &&
        getNow() > document.createEvent('Event').timeStamp) {
        // if the event timestamp, although evaluated AFTER the Date.now(), is
        // smaller than it, it means the event is using a hi-res timestamp,
        // and we need to use the hi-res version for event listener timestamps as
        // well.
        getNow = function () { return performance_1.now(); };
    }
}
var sortCompareFn = function (a, b) {
    if (a.post) {
        if (!b.post)
            return 1;
    }
    else if (b.post) {
        return -1;
    }
    return a.id - b.id;
};
/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
    currentFlushTimestamp = getNow();
    flushing = true;
    var watcher, id;
    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.
    queue.sort(sortCompareFn);
    // do not cache length because more watchers might be pushed
    // as we run existing watchers
    for (index = 0; index < queue.length; index++) {
        watcher = queue[index];
        if (watcher.before) {
            watcher.before();
        }
        id = watcher.id;
        has[id] = null;
        watcher.run();
        // in dev build, check and stop circular updates.
        if ( true && has[id] != null) {
            circular[id] = (circular[id] || 0) + 1;
            if (circular[id] > MAX_UPDATE_COUNT) {
                warn('You may have an infinite update loop ' +
                    (watcher.user
                        ? "in watcher with expression \"".concat(watcher.expression, "\"")
                        : "in a component render function."), watcher.vm);
                break;
            }
        }
    }
    // keep copies of post queues before resetting state
    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();
    resetSchedulerState();
    // call component updated and activated hooks
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);
    cleanupDeps();
    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
        devtools.emit('flush');
    }
}
function callUpdatedHooks(queue) {
    var i = queue.length;
    while (i--) {
        var watcher = queue[i];
        var vm = watcher.vm;
        if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
            callHook$1(vm, 'updated');
        }
    }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent(vm) {
    // setting _inactive to false here so that a render function can
    // rely on checking whether it's in an inactive tree (e.g. router-view)
    vm._inactive = false;
    activatedChildren.push(vm);
}
function callActivatedHooks(queue) {
    for (var i = 0; i < queue.length; i++) {
        queue[i]._inactive = true;
        activateChildComponent(queue[i], true /* true */);
    }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
    var id = watcher.id;
    if (has[id] != null) {
        return;
    }
    if (watcher === Dep.target && watcher.noRecurse) {
        return;
    }
    has[id] = true;
    if (!flushing) {
        queue.push(watcher);
    }
    else {
        // if already flushing, splice the watcher based on its id
        // if already past its id, it will be run next immediately.
        var i = queue.length - 1;
        while (i > index && queue[i].id > watcher.id) {
            i--;
        }
        queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
        waiting = true;
        if ( true && !config.async) {
            flushSchedulerQueue();
            return;
        }
        nextTick(flushSchedulerQueue);
    }
}

function initProvide(vm) {
    var provideOption = vm.$options.provide;
    if (provideOption) {
        var provided = isFunction(provideOption)
            ? provideOption.call(vm)
            : provideOption;
        if (!isObject(provided)) {
            return;
        }
        var source = resolveProvided(vm);
        // IE9 doesn't support Object.getOwnPropertyDescriptors so we have to
        // iterate the keys ourselves.
        var keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));
        }
    }
}
function initInjections(vm) {
    var result = resolveInject(vm.$options.inject, vm);
    if (result) {
        toggleObserving(false);
        Object.keys(result).forEach(function (key) {
            /* istanbul ignore else */
            if (true) {
                defineReactive(vm, key, result[key], function () {
                    warn("Avoid mutating an injected value directly since the changes will be " +
                        "overwritten whenever the provided component re-renders. " +
                        "injection being mutated: \"".concat(key, "\""), vm);
                });
            }
            else // removed by dead control flow
{}
        });
        toggleObserving(true);
    }
}
function resolveInject(inject, vm) {
    if (inject) {
        // inject is :any because flow is not smart enough to figure out cached
        var result = Object.create(null);
        var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            // #6574 in case the inject object is observed...
            if (key === '__ob__')
                continue;
            var provideKey = inject[key].from;
            if (provideKey in vm._provided) {
                result[key] = vm._provided[provideKey];
            }
            else if ('default' in inject[key]) {
                var provideDefault = inject[key].default;
                result[key] = isFunction(provideDefault)
                    ? provideDefault.call(vm)
                    : provideDefault;
            }
            else if (true) {
                warn("Injection \"".concat(key, "\" not found"), vm);
            }
        }
        return result;
    }
}

function FunctionalRenderContext(data, props, children, parent, Ctor) {
    var _this = this;
    var options = Ctor.options;
    // ensure the createElement function in functional components
    // gets a unique context - this is necessary for correct named slot check
    var contextVm;
    if (hasOwn(parent, '_uid')) {
        contextVm = Object.create(parent);
        contextVm._original = parent;
    }
    else {
        // the context vm passed in is a functional context as well.
        // in this case we want to make sure we are able to get a hold to the
        // real context instance.
        contextVm = parent;
        // @ts-ignore
        parent = parent._original;
    }
    var isCompiled = isTrue(options._compiled);
    var needNormalization = !isCompiled;
    this.data = data;
    this.props = props;
    this.children = children;
    this.parent = parent;
    this.listeners = data.on || emptyObject;
    this.injections = resolveInject(options.inject, parent);
    this.slots = function () {
        if (!_this.$slots) {
            normalizeScopedSlots(parent, data.scopedSlots, (_this.$slots = resolveSlots(children, parent)));
        }
        return _this.$slots;
    };
    Object.defineProperty(this, 'scopedSlots', {
        enumerable: true,
        get: function () {
            return normalizeScopedSlots(parent, data.scopedSlots, this.slots());
        }
    });
    // support for compiled functional template
    if (isCompiled) {
        // exposing $options for renderStatic()
        this.$options = options;
        // pre-resolve slots for renderSlot()
        this.$slots = this.slots();
        this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);
    }
    if (options._scopeId) {
        this._c = function (a, b, c, d) {
            var vnode = createElement$1(contextVm, a, b, c, d, needNormalization);
            if (vnode && !isArray(vnode)) {
                vnode.fnScopeId = options._scopeId;
                vnode.fnContext = parent;
            }
            return vnode;
        };
    }
    else {
        this._c = function (a, b, c, d) {
            return createElement$1(contextVm, a, b, c, d, needNormalization);
        };
    }
}
installRenderHelpers(FunctionalRenderContext.prototype);
function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
    var options = Ctor.options;
    var props = {};
    var propOptions = options.props;
    if (isDef(propOptions)) {
        for (var key in propOptions) {
            props[key] = validateProp(key, propOptions, propsData || emptyObject);
        }
    }
    else {
        if (isDef(data.attrs))
            mergeProps(props, data.attrs);
        if (isDef(data.props))
            mergeProps(props, data.props);
    }
    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
    var vnode = options.render.call(null, renderContext._c, renderContext);
    if (vnode instanceof VNode) {
        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
    }
    else if (isArray(vnode)) {
        var vnodes = normalizeChildren(vnode) || [];
        var res = new Array(vnodes.length);
        for (var i = 0; i < vnodes.length; i++) {
            res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
        }
        return res;
    }
}
function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
    // #7817 clone node before setting fnContext, otherwise if the node is reused
    // (e.g. it was from a cached normal slot) the fnContext causes named slots
    // that should not be matched to match.
    var clone = cloneVNode(vnode);
    clone.fnContext = contextVm;
    clone.fnOptions = options;
    if (true) {
        (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext =
            renderContext;
    }
    if (data.slot) {
        (clone.data || (clone.data = {})).slot = data.slot;
    }
    return clone;
}
function mergeProps(to, from) {
    for (var key in from) {
        to[camelize(key)] = from[key];
    }
}

function getComponentName(options) {
    return options.name || options.__name || options._componentTag;
}
// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
    init: function (vnode, hydrating) {
        if (vnode.componentInstance &&
            !vnode.componentInstance._isDestroyed &&
            vnode.data.keepAlive) {
            // kept-alive components, treat as a patch
            var mountedNode = vnode; // work around flow
            componentVNodeHooks.prepatch(mountedNode, mountedNode);
        }
        else {
            var child = (vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance));
            child.$mount(hydrating ? vnode.elm : undefined, hydrating);
        }
    },
    prepatch: function (oldVnode, vnode) {
        var options = vnode.componentOptions;
        var child = (vnode.componentInstance = oldVnode.componentInstance);
        updateChildComponent(child, options.propsData, // updated props
        options.listeners, // updated listeners
        vnode, // new parent vnode
        options.children // new children
        );
    },
    insert: function (vnode) {
        var context = vnode.context, componentInstance = vnode.componentInstance;
        if (!componentInstance._isMounted) {
            componentInstance._isMounted = true;
            callHook$1(componentInstance, 'mounted');
        }
        if (vnode.data.keepAlive) {
            if (context._isMounted) {
                // vue-router#1212
                // During updates, a kept-alive component's child components may
                // change, so directly walking the tree here may call activated hooks
                // on incorrect children. Instead we push them into a queue which will
                // be processed after the whole patch process ended.
                queueActivatedComponent(componentInstance);
            }
            else {
                activateChildComponent(componentInstance, true /* direct */);
            }
        }
    },
    destroy: function (vnode) {
        var componentInstance = vnode.componentInstance;
        if (!componentInstance._isDestroyed) {
            if (!vnode.data.keepAlive) {
                componentInstance.$destroy();
            }
            else {
                deactivateChildComponent(componentInstance, true /* direct */);
            }
        }
    }
};
var hooksToMerge = Object.keys(componentVNodeHooks);
function createComponent(Ctor, data, context, children, tag) {
    if (isUndef(Ctor)) {
        return;
    }
    var baseCtor = context.$options._base;
    // plain options object: turn it into a constructor
    if (isObject(Ctor)) {
        Ctor = baseCtor.extend(Ctor);
    }
    // if at this stage it's not a constructor or an async component factory,
    // reject.
    if (typeof Ctor !== 'function') {
        if (true) {
            warn("Invalid Component definition: ".concat(String(Ctor)), context);
        }
        return;
    }
    // async component
    var asyncFactory;
    // @ts-expect-error
    if (isUndef(Ctor.cid)) {
        asyncFactory = Ctor;
        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
        if (Ctor === undefined) {
            // return a placeholder node for async component, which is rendered
            // as a comment node but preserves all the raw information for the node.
            // the information will be used for async server-rendering and hydration.
            return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
        }
    }
    data = data || {};
    // resolve constructor options in case global mixins are applied after
    // component constructor creation
    resolveConstructorOptions(Ctor);
    // transform component v-model data into props & events
    if (isDef(data.model)) {
        // @ts-expect-error
        transformModel(Ctor.options, data);
    }
    // extract props
    // @ts-expect-error
    var propsData = extractPropsFromVNodeData(data, Ctor, tag);
    // functional component
    // @ts-expect-error
    if (isTrue(Ctor.options.functional)) {
        return createFunctionalComponent(Ctor, propsData, data, context, children);
    }
    // extract listeners, since these needs to be treated as
    // child component listeners instead of DOM listeners
    var listeners = data.on;
    // replace with listeners with .native modifier
    // so it gets processed during parent component patch.
    data.on = data.nativeOn;
    // @ts-expect-error
    if (isTrue(Ctor.options.abstract)) {
        // abstract components do not keep anything
        // other than props & listeners & slot
        // work around flow
        var slot = data.slot;
        data = {};
        if (slot) {
            data.slot = slot;
        }
    }
    // install component management hooks onto the placeholder node
    installComponentHooks(data);
    // return a placeholder vnode
    // @ts-expect-error
    var name = getComponentName(Ctor.options) || tag;
    var vnode = new VNode(
    // @ts-expect-error
    "vue-component-".concat(Ctor.cid).concat(name ? "-".concat(name) : ''), data, undefined, undefined, undefined, context, 
    // @ts-expect-error
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);
    return vnode;
}
function createComponentInstanceForVnode(
// we know it's MountedComponentVNode but flow doesn't
vnode, 
// activeInstance in lifecycle state
parent) {
    var options = {
        _isComponent: true,
        _parentVnode: vnode,
        parent: parent
    };
    // check inline-template render functions
    var inlineTemplate = vnode.data.inlineTemplate;
    if (isDef(inlineTemplate)) {
        options.render = inlineTemplate.render;
        options.staticRenderFns = inlineTemplate.staticRenderFns;
    }
    return new vnode.componentOptions.Ctor(options);
}
function installComponentHooks(data) {
    var hooks = data.hook || (data.hook = {});
    for (var i = 0; i < hooksToMerge.length; i++) {
        var key = hooksToMerge[i];
        var existing = hooks[key];
        var toMerge = componentVNodeHooks[key];
        // @ts-expect-error
        if (existing !== toMerge && !(existing && existing._merged)) {
            hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;
        }
    }
}
function mergeHook(f1, f2) {
    var merged = function (a, b) {
        // flow complains about extra args which is why we use any
        f1(a, b);
        f2(a, b);
    };
    merged._merged = true;
    return merged;
}
// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
    var prop = (options.model && options.model.prop) || 'value';
    var event = (options.model && options.model.event) || 'input';
    (data.attrs || (data.attrs = {}))[prop] = data.model.value;
    var on = data.on || (data.on = {});
    var existing = on[event];
    var callback = data.model.callback;
    if (isDef(existing)) {
        if (isArray(existing)
            ? existing.indexOf(callback) === -1
            : existing !== callback) {
            on[event] = [callback].concat(existing);
        }
    }
    else {
        on[event] = callback;
    }
}

var warn = noop;
var tip = noop;
var generateComponentTrace; // work around flow check
var formatComponentName;
if (true) {
    var hasConsole_1 = typeof console !== 'undefined';
    var classifyRE_1 = /(?:^|[-_])(\w)/g;
    var classify_1 = function (str) {
        return str.replace(classifyRE_1, function (c) { return c.toUpperCase(); }).replace(/[-_]/g, '');
    };
    warn = function (msg, vm) {
        if (vm === void 0) { vm = currentInstance; }
        var trace = vm ? generateComponentTrace(vm) : '';
        if (config.warnHandler) {
            config.warnHandler.call(null, msg, vm, trace);
        }
        else if (hasConsole_1 && !config.silent) {
            console.error("[Vue warn]: ".concat(msg).concat(trace));
        }
    };
    tip = function (msg, vm) {
        if (hasConsole_1 && !config.silent) {
            console.warn("[Vue tip]: ".concat(msg) + (vm ? generateComponentTrace(vm) : ''));
        }
    };
    formatComponentName = function (vm, includeFile) {
        if (vm.$root === vm) {
            return '<Root>';
        }
        var options = isFunction(vm) && vm.cid != null
            ? vm.options
            : vm._isVue
                ? vm.$options || vm.constructor.options
                : vm;
        var name = getComponentName(options);
        var file = options.__file;
        if (!name && file) {
            var match = file.match(/([^/\\]+)\.vue$/);
            name = match && match[1];
        }
        return ((name ? "<".concat(classify_1(name), ">") : "<Anonymous>") +
            (file && includeFile !== false ? " at ".concat(file) : ''));
    };
    var repeat_1 = function (str, n) {
        var res = '';
        while (n) {
            if (n % 2 === 1)
                res += str;
            if (n > 1)
                str += str;
            n >>= 1;
        }
        return res;
    };
    generateComponentTrace = function (vm) {
        if (vm._isVue && vm.$parent) {
            var tree = [];
            var currentRecursiveSequence = 0;
            while (vm) {
                if (tree.length > 0) {
                    var last = tree[tree.length - 1];
                    if (last.constructor === vm.constructor) {
                        currentRecursiveSequence++;
                        vm = vm.$parent;
                        continue;
                    }
                    else if (currentRecursiveSequence > 0) {
                        tree[tree.length - 1] = [last, currentRecursiveSequence];
                        currentRecursiveSequence = 0;
                    }
                }
                tree.push(vm);
                vm = vm.$parent;
            }
            return ('\n\nfound in\n\n' +
                tree
                    .map(function (vm, i) {
                    return "".concat(i === 0 ? '---> ' : repeat_1(' ', 5 + i * 2)).concat(isArray(vm)
                        ? "".concat(formatComponentName(vm[0]), "... (").concat(vm[1], " recursive calls)")
                        : formatComponentName(vm));
                })
                    .join('\n'));
        }
        else {
            return "\n\n(found in ".concat(formatComponentName(vm), ")");
        }
    };
}

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */
if (true) {
    strats.el = strats.propsData = function (parent, child, vm, key) {
        if (!vm) {
            warn("option \"".concat(key, "\" can only be used during instance ") +
                'creation with the `new` keyword.');
        }
        return defaultStrat(parent, child);
    };
}
/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from, recursive) {
    if (recursive === void 0) { recursive = true; }
    if (!from)
        return to;
    var key, toVal, fromVal;
    var keys = hasSymbol
        ? Reflect.ownKeys(from)
        : Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
        key = keys[i];
        // in case the object is already observed...
        if (key === '__ob__')
            continue;
        toVal = to[key];
        fromVal = from[key];
        if (!recursive || !hasOwn(to, key)) {
            set(to, key, fromVal);
        }
        else if (toVal !== fromVal &&
            isPlainObject(toVal) &&
            isPlainObject(fromVal)) {
            mergeData(toVal, fromVal);
        }
    }
    return to;
}
/**
 * Data
 */
function mergeDataOrFn(parentVal, childVal, vm) {
    if (!vm) {
        // in a Vue.extend merge, both should be functions
        if (!childVal) {
            return parentVal;
        }
        if (!parentVal) {
            return childVal;
        }
        // when parentVal & childVal are both present,
        // we need to return a function that returns the
        // merged result of both functions... no need to
        // check if parentVal is a function here because
        // it has to be a function to pass previous merges.
        return function mergedDataFn() {
            return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);
        };
    }
    else {
        return function mergedInstanceDataFn() {
            // instance merge
            var instanceData = isFunction(childVal)
                ? childVal.call(vm, vm)
                : childVal;
            var defaultData = isFunction(parentVal)
                ? parentVal.call(vm, vm)
                : parentVal;
            if (instanceData) {
                return mergeData(instanceData, defaultData);
            }
            else {
                return defaultData;
            }
        };
    }
}
strats.data = function (parentVal, childVal, vm) {
    if (!vm) {
        if (childVal && typeof childVal !== 'function') {
             true &&
                warn('The "data" option should be a function ' +
                    'that returns a per-instance value in component ' +
                    'definitions.', vm);
            return parentVal;
        }
        return mergeDataOrFn(parentVal, childVal);
    }
    return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */
function mergeLifecycleHook(parentVal, childVal) {
    var res = childVal
        ? parentVal
            ? parentVal.concat(childVal)
            : isArray(childVal)
                ? childVal
                : [childVal]
        : parentVal;
    return res ? dedupeHooks(res) : res;
}
function dedupeHooks(hooks) {
    var res = [];
    for (var i = 0; i < hooks.length; i++) {
        if (res.indexOf(hooks[i]) === -1) {
            res.push(hooks[i]);
        }
    }
    return res;
}
LIFECYCLE_HOOKS.forEach(function (hook) {
    strats[hook] = mergeLifecycleHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal, vm, key) {
    var res = Object.create(parentVal || null);
    if (childVal) {
         true && assertObjectType(key, childVal, vm);
        return extend(res, childVal);
    }
    else {
        return res;
    }
}
ASSET_TYPES.forEach(function (type) {
    strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal, vm, key) {
    // work around Firefox's Object.prototype.watch...
    //@ts-expect-error work around
    if (parentVal === nativeWatch)
        parentVal = undefined;
    //@ts-expect-error work around
    if (childVal === nativeWatch)
        childVal = undefined;
    /* istanbul ignore if */
    if (!childVal)
        return Object.create(parentVal || null);
    if (true) {
        assertObjectType(key, childVal, vm);
    }
    if (!parentVal)
        return childVal;
    var ret = {};
    extend(ret, parentVal);
    for (var key_1 in childVal) {
        var parent_1 = ret[key_1];
        var child = childVal[key_1];
        if (parent_1 && !isArray(parent_1)) {
            parent_1 = [parent_1];
        }
        ret[key_1] = parent_1 ? parent_1.concat(child) : isArray(child) ? child : [child];
    }
    return ret;
};
/**
 * Other object hashes.
 */
strats.props =
    strats.methods =
        strats.inject =
            strats.computed =
                function (parentVal, childVal, vm, key) {
                    if (childVal && "development" !== 'production') {
                        assertObjectType(key, childVal, vm);
                    }
                    if (!parentVal)
                        return childVal;
                    var ret = Object.create(null);
                    extend(ret, parentVal);
                    if (childVal)
                        extend(ret, childVal);
                    return ret;
                };
strats.provide = function (parentVal, childVal) {
    if (!parentVal)
        return childVal;
    return function () {
        var ret = Object.create(null);
        mergeData(ret, isFunction(parentVal) ? parentVal.call(this) : parentVal);
        if (childVal) {
            mergeData(ret, isFunction(childVal) ? childVal.call(this) : childVal, false // non-recursive
            );
        }
        return ret;
    };
};
/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
    return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */
function checkComponents(options) {
    for (var key in options.components) {
        validateComponentName(key);
    }
}
function validateComponentName(name) {
    if (!new RegExp("^[a-zA-Z][\\-\\.0-9_".concat(unicodeRegExp.source, "]*$")).test(name)) {
        warn('Invalid component name: "' +
            name +
            '". Component names ' +
            'should conform to valid custom element name in html5 specification.');
    }
    if (isBuiltInTag(name) || config.isReservedTag(name)) {
        warn('Do not use built-in or reserved HTML elements as component ' +
            'id: ' +
            name);
    }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options, vm) {
    var props = options.props;
    if (!props)
        return;
    var res = {};
    var i, val, name;
    if (isArray(props)) {
        i = props.length;
        while (i--) {
            val = props[i];
            if (typeof val === 'string') {
                name = camelize(val);
                res[name] = { type: null };
            }
            else if (true) {
                warn('props must be strings when using array syntax.');
            }
        }
    }
    else if (isPlainObject(props)) {
        for (var key in props) {
            val = props[key];
            name = camelize(key);
            res[name] = isPlainObject(val) ? val : { type: val };
        }
    }
    else if (true) {
        warn("Invalid value for option \"props\": expected an Array or an Object, " +
            "but got ".concat(toRawType(props), "."), vm);
    }
    options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */
function normalizeInject(options, vm) {
    var inject = options.inject;
    if (!inject)
        return;
    var normalized = (options.inject = {});
    if (isArray(inject)) {
        for (var i = 0; i < inject.length; i++) {
            normalized[inject[i]] = { from: inject[i] };
        }
    }
    else if (isPlainObject(inject)) {
        for (var key in inject) {
            var val = inject[key];
            normalized[key] = isPlainObject(val)
                ? extend({ from: key }, val)
                : { from: val };
        }
    }
    else if (true) {
        warn("Invalid value for option \"inject\": expected an Array or an Object, " +
            "but got ".concat(toRawType(inject), "."), vm);
    }
}
/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives$1(options) {
    var dirs = options.directives;
    if (dirs) {
        for (var key in dirs) {
            var def = dirs[key];
            if (isFunction(def)) {
                dirs[key] = { bind: def, update: def };
            }
        }
    }
}
function assertObjectType(name, value, vm) {
    if (!isPlainObject(value)) {
        warn("Invalid value for option \"".concat(name, "\": expected an Object, ") +
            "but got ".concat(toRawType(value), "."), vm);
    }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
    if (true) {
        checkComponents(child);
    }
    if (isFunction(child)) {
        // @ts-expect-error
        child = child.options;
    }
    normalizeProps(child, vm);
    normalizeInject(child, vm);
    normalizeDirectives$1(child);
    // Apply extends and mixins on the child options,
    // but only if it is a raw options object that isn't
    // the result of another mergeOptions call.
    // Only merged options has the _base property.
    if (!child._base) {
        if (child.extends) {
            parent = mergeOptions(parent, child.extends, vm);
        }
        if (child.mixins) {
            for (var i = 0, l = child.mixins.length; i < l; i++) {
                parent = mergeOptions(parent, child.mixins[i], vm);
            }
        }
    }
    var options = {};
    var key;
    for (key in parent) {
        mergeField(key);
    }
    for (key in child) {
        if (!hasOwn(parent, key)) {
            mergeField(key);
        }
    }
    function mergeField(key) {
        var strat = strats[key] || defaultStrat;
        options[key] = strat(parent[key], child[key], vm, key);
    }
    return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
    /* istanbul ignore if */
    if (typeof id !== 'string') {
        return;
    }
    var assets = options[type];
    // check local registration variations first
    if (hasOwn(assets, id))
        return assets[id];
    var camelizedId = camelize(id);
    if (hasOwn(assets, camelizedId))
        return assets[camelizedId];
    var PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId))
        return assets[PascalCaseId];
    // fallback to prototype chain
    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    if ( true && warnMissing && !res) {
        warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id);
    }
    return res;
}

function validateProp(key, propOptions, propsData, vm) {
    var prop = propOptions[key];
    var absent = !hasOwn(propsData, key);
    var value = propsData[key];
    // boolean casting
    var booleanIndex = getTypeIndex(Boolean, prop.type);
    if (booleanIndex > -1) {
        if (absent && !hasOwn(prop, 'default')) {
            value = false;
        }
        else if (value === '' || value === hyphenate(key)) {
            // only cast empty string / same name to boolean if
            // boolean has higher priority
            var stringIndex = getTypeIndex(String, prop.type);
            if (stringIndex < 0 || booleanIndex < stringIndex) {
                value = true;
            }
        }
    }
    // check default value
    if (value === undefined) {
        value = getPropDefaultValue(vm, prop, key);
        // since the default value is a fresh copy,
        // make sure to observe it.
        var prevShouldObserve = shouldObserve;
        toggleObserving(true);
        observe(value);
        toggleObserving(prevShouldObserve);
    }
    if (true) {
        assertProp(prop, key, value, vm, absent);
    }
    return value;
}
/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
    // no default, return undefined
    if (!hasOwn(prop, 'default')) {
        return undefined;
    }
    var def = prop.default;
    // warn against non-factory defaults for Object & Array
    if ( true && isObject(def)) {
        warn('Invalid default value for prop "' +
            key +
            '": ' +
            'Props with type Object/Array must use a factory function ' +
            'to return the default value.', vm);
    }
    // the raw prop value was also undefined from previous render,
    // return previous default value to avoid unnecessary watcher trigger
    if (vm &&
        vm.$options.propsData &&
        vm.$options.propsData[key] === undefined &&
        vm._props[key] !== undefined) {
        return vm._props[key];
    }
    // call factory function for non-Function types
    // a value is Function if its prototype is function even across different execution context
    return isFunction(def) && getType(prop.type) !== 'Function'
        ? def.call(vm)
        : def;
}
/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
    if (prop.required && absent) {
        warn('Missing required prop: "' + name + '"', vm);
        return;
    }
    if (value == null && !prop.required) {
        return;
    }
    var type = prop.type;
    var valid = !type || type === true;
    var expectedTypes = [];
    if (type) {
        if (!isArray(type)) {
            type = [type];
        }
        for (var i = 0; i < type.length && !valid; i++) {
            var assertedType = assertType(value, type[i], vm);
            expectedTypes.push(assertedType.expectedType || '');
            valid = assertedType.valid;
        }
    }
    var haveExpectedTypes = expectedTypes.some(function (t) { return t; });
    if (!valid && haveExpectedTypes) {
        warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
        return;
    }
    var validator = prop.validator;
    if (validator) {
        if (!validator(value)) {
            warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
        }
    }
}
var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;
function assertType(value, type, vm) {
    var valid;
    var expectedType = getType(type);
    if (simpleCheckRE.test(expectedType)) {
        var t = typeof value;
        valid = t === expectedType.toLowerCase();
        // for primitive wrapper objects
        if (!valid && t === 'object') {
            valid = value instanceof type;
        }
    }
    else if (expectedType === 'Object') {
        valid = isPlainObject(value);
    }
    else if (expectedType === 'Array') {
        valid = isArray(value);
    }
    else {
        try {
            valid = value instanceof type;
        }
        catch (e) {
            warn('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
            valid = false;
        }
    }
    return {
        valid: valid,
        expectedType: expectedType
    };
}
var functionTypeCheckRE = /^\s*function (\w+)/;
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
    var match = fn && fn.toString().match(functionTypeCheckRE);
    return match ? match[1] : '';
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if (!isArray(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
    }
    for (var i = 0, len = expectedTypes.length; i < len; i++) {
        if (isSameType(expectedTypes[i], type)) {
            return i;
        }
    }
    return -1;
}
function getInvalidTypeMessage(name, value, expectedTypes) {
    var message = "Invalid prop: type check failed for prop \"".concat(name, "\".") +
        " Expected ".concat(expectedTypes.map(capitalize).join(', '));
    var expectedType = expectedTypes[0];
    var receivedType = toRawType(value);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        isExplicable(typeof value) &&
        !isBoolean(expectedType, receivedType)) {
        message += " with value ".concat(styleValue(value, expectedType));
    }
    message += ", got ".concat(receivedType, " ");
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
        message += "with value ".concat(styleValue(value, receivedType), ".");
    }
    return message;
}
function styleValue(value, type) {
    if (type === 'String') {
        return "\"".concat(value, "\"");
    }
    else if (type === 'Number') {
        return "".concat(Number(value));
    }
    else {
        return "".concat(value);
    }
}
var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];
function isExplicable(value) {
    return EXPLICABLE_TYPES.some(function (elem) { return value.toLowerCase() === elem; });
}
function isBoolean() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; });
}

/* not type checking this file because flow doesn't play well with Proxy */
var initProxy;
if (true) {
    var allowedGlobals_1 = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' +
        'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
        'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +
        'require' // for Webpack/Browserify
    );
    var warnNonPresent_1 = function (target, key) {
        warn("Property or method \"".concat(key, "\" is not defined on the instance but ") +
            'referenced during render. Make sure that this property is reactive, ' +
            'either in the data option, or for class-based components, by ' +
            'initializing the property. ' +
            'See: https://v2.vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
    };
    var warnReservedPrefix_1 = function (target, key) {
        warn("Property \"".concat(key, "\" must be accessed with \"$data.").concat(key, "\" because ") +
            'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
            'prevent conflicts with Vue internals. ' +
            'See: https://v2.vuejs.org/v2/api/#data', target);
    };
    var hasProxy_1 = typeof Proxy !== 'undefined' && isNative(Proxy);
    if (hasProxy_1) {
        var isBuiltInModifier_1 = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
        config.keyCodes = new Proxy(config.keyCodes, {
            set: function (target, key, value) {
                if (isBuiltInModifier_1(key)) {
                    warn("Avoid overwriting built-in modifier in config.keyCodes: .".concat(key));
                    return false;
                }
                else {
                    target[key] = value;
                    return true;
                }
            }
        });
    }
    var hasHandler_1 = {
        has: function (target, key) {
            var has = key in target;
            var isAllowed = allowedGlobals_1(key) ||
                (typeof key === 'string' &&
                    key.charAt(0) === '_' &&
                    !(key in target.$data));
            if (!has && !isAllowed) {
                if (key in target.$data)
                    warnReservedPrefix_1(target, key);
                else
                    warnNonPresent_1(target, key);
            }
            return has || !isAllowed;
        }
    };
    var getHandler_1 = {
        get: function (target, key) {
            if (typeof key === 'string' && !(key in target)) {
                if (key in target.$data)
                    warnReservedPrefix_1(target, key);
                else
                    warnNonPresent_1(target, key);
            }
            return target[key];
        }
    };
    initProxy = function initProxy(vm) {
        if (hasProxy_1) {
            // determine which proxy handler to use
            var options = vm.$options;
            var handlers = options.render && options.render._withStripped ? getHandler_1 : hasHandler_1;
            vm._renderProxy = new Proxy(vm, handlers);
        }
        else {
            vm._renderProxy = vm;
        }
    };
}

var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
};
function proxy(target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter() {
        return this[sourceKey][key];
    };
    sharedPropertyDefinition.set = function proxySetter(val) {
        this[sourceKey][key] = val;
    };
    Object.defineProperty(target, key, sharedPropertyDefinition);
}
function initState(vm) {
    var opts = vm.$options;
    if (opts.props)
        initProps$1(vm, opts.props);
    // Composition API
    initSetup(vm);
    if (opts.methods)
        initMethods(vm, opts.methods);
    if (opts.data) {
        initData(vm);
    }
    else {
        var ob = observe((vm._data = {}));
        ob && ob.vmCount++;
    }
    if (opts.computed)
        initComputed$1(vm, opts.computed);
    if (opts.watch && opts.watch !== nativeWatch) {
        initWatch(vm, opts.watch);
    }
}
function initProps$1(vm, propsOptions) {
    var propsData = vm.$options.propsData || {};
    var props = (vm._props = shallowReactive({}));
    // cache prop keys so that future props updates can iterate using Array
    // instead of dynamic object key enumeration.
    var keys = (vm.$options._propKeys = []);
    var isRoot = !vm.$parent;
    // root instance props should be converted
    if (!isRoot) {
        toggleObserving(false);
    }
    var _loop_1 = function (key) {
        keys.push(key);
        var value = validateProp(key, propsOptions, propsData, vm);
        /* istanbul ignore else */
        if (true) {
            var hyphenatedKey = hyphenate(key);
            if (isReservedAttribute(hyphenatedKey) ||
                config.isReservedAttr(hyphenatedKey)) {
                warn("\"".concat(hyphenatedKey, "\" is a reserved attribute and cannot be used as component prop."), vm);
            }
            defineReactive(props, key, value, function () {
                if (!isRoot && !isUpdatingChildComponent) {
                    warn("Avoid mutating a prop directly since the value will be " +
                        "overwritten whenever the parent component re-renders. " +
                        "Instead, use a data or computed property based on the prop's " +
                        "value. Prop being mutated: \"".concat(key, "\""), vm);
                }
            }, true /* shallow */);
        }
        else // removed by dead control flow
{}
        // static props are already proxied on the component's prototype
        // during Vue.extend(). We only need to proxy props defined at
        // instantiation here.
        if (!(key in vm)) {
            proxy(vm, "_props", key);
        }
    };
    for (var key in propsOptions) {
        _loop_1(key);
    }
    toggleObserving(true);
}
function initData(vm) {
    var data = vm.$options.data;
    data = vm._data = isFunction(data) ? getData(data, vm) : data || {};
    if (!isPlainObject(data)) {
        data = {};
         true &&
            warn('data functions should return an object:\n' +
                'https://v2.vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
    }
    // proxy data on instance
    var keys = Object.keys(data);
    var props = vm.$options.props;
    var methods = vm.$options.methods;
    var i = keys.length;
    while (i--) {
        var key = keys[i];
        if (true) {
            if (methods && hasOwn(methods, key)) {
                warn("Method \"".concat(key, "\" has already been defined as a data property."), vm);
            }
        }
        if (props && hasOwn(props, key)) {
             true &&
                warn("The data property \"".concat(key, "\" is already declared as a prop. ") +
                    "Use prop default value instead.", vm);
        }
        else if (!isReserved(key)) {
            proxy(vm, "_data", key);
        }
    }
    // observe data
    var ob = observe(data);
    ob && ob.vmCount++;
}
function getData(data, vm) {
    // #7573 disable dep collection when invoking data getters
    pushTarget();
    try {
        return data.call(vm, vm);
    }
    catch (e) {
        handleError(e, vm, "data()");
        return {};
    }
    finally {
        popTarget();
    }
}
var computedWatcherOptions = { lazy: true };
function initComputed$1(vm, computed) {
    // $flow-disable-line
    var watchers = (vm._computedWatchers = Object.create(null));
    // computed properties are just getters during SSR
    var isSSR = isServerRendering();
    for (var key in computed) {
        var userDef = computed[key];
        var getter = isFunction(userDef) ? userDef : userDef.get;
        if ( true && getter == null) {
            warn("Getter is missing for computed property \"".concat(key, "\"."), vm);
        }
        if (!isSSR) {
            // create internal watcher for the computed property.
            watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
        }
        // component-defined computed properties are already defined on the
        // component prototype. We only need to define computed properties defined
        // at instantiation here.
        if (!(key in vm)) {
            defineComputed(vm, key, userDef);
        }
        else if (true) {
            if (key in vm.$data) {
                warn("The computed property \"".concat(key, "\" is already defined in data."), vm);
            }
            else if (vm.$options.props && key in vm.$options.props) {
                warn("The computed property \"".concat(key, "\" is already defined as a prop."), vm);
            }
            else if (vm.$options.methods && key in vm.$options.methods) {
                warn("The computed property \"".concat(key, "\" is already defined as a method."), vm);
            }
        }
    }
}
function defineComputed(target, key, userDef) {
    var shouldCache = !isServerRendering();
    if (isFunction(userDef)) {
        sharedPropertyDefinition.get = shouldCache
            ? createComputedGetter(key)
            : createGetterInvoker(userDef);
        sharedPropertyDefinition.set = noop;
    }
    else {
        sharedPropertyDefinition.get = userDef.get
            ? shouldCache && userDef.cache !== false
                ? createComputedGetter(key)
                : createGetterInvoker(userDef.get)
            : noop;
        sharedPropertyDefinition.set = userDef.set || noop;
    }
    if ( true && sharedPropertyDefinition.set === noop) {
        sharedPropertyDefinition.set = function () {
            warn("Computed property \"".concat(key, "\" was assigned to but it has no setter."), this);
        };
    }
    Object.defineProperty(target, key, sharedPropertyDefinition);
}
function createComputedGetter(key) {
    return function computedGetter() {
        var watcher = this._computedWatchers && this._computedWatchers[key];
        if (watcher) {
            if (watcher.dirty) {
                watcher.evaluate();
            }
            if (Dep.target) {
                if ( true && Dep.target.onTrack) {
                    Dep.target.onTrack({
                        effect: Dep.target,
                        target: this,
                        type: "get" /* TrackOpTypes.GET */,
                        key: key
                    });
                }
                watcher.depend();
            }
            return watcher.value;
        }
    };
}
function createGetterInvoker(fn) {
    return function computedGetter() {
        return fn.call(this, this);
    };
}
function initMethods(vm, methods) {
    var props = vm.$options.props;
    for (var key in methods) {
        if (true) {
            if (typeof methods[key] !== 'function') {
                warn("Method \"".concat(key, "\" has type \"").concat(typeof methods[key], "\" in the component definition. ") +
                    "Did you reference the function correctly?", vm);
            }
            if (props && hasOwn(props, key)) {
                warn("Method \"".concat(key, "\" has already been defined as a prop."), vm);
            }
            if (key in vm && isReserved(key)) {
                warn("Method \"".concat(key, "\" conflicts with an existing Vue instance method. ") +
                    "Avoid defining component methods that start with _ or $.");
            }
        }
        vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
    }
}
function initWatch(vm, watch) {
    for (var key in watch) {
        var handler = watch[key];
        if (isArray(handler)) {
            for (var i = 0; i < handler.length; i++) {
                createWatcher(vm, key, handler[i]);
            }
        }
        else {
            createWatcher(vm, key, handler);
        }
    }
}
function createWatcher(vm, expOrFn, handler, options) {
    if (isPlainObject(handler)) {
        options = handler;
        handler = handler.handler;
    }
    if (typeof handler === 'string') {
        handler = vm[handler];
    }
    return vm.$watch(expOrFn, handler, options);
}
function stateMixin(Vue) {
    // flow somehow has problems with directly declared definition object
    // when using Object.defineProperty, so we have to procedurally build up
    // the object here.
    var dataDef = {};
    dataDef.get = function () {
        return this._data;
    };
    var propsDef = {};
    propsDef.get = function () {
        return this._props;
    };
    if (true) {
        dataDef.set = function () {
            warn('Avoid replacing instance root $data. ' +
                'Use nested data properties instead.', this);
        };
        propsDef.set = function () {
            warn("$props is readonly.", this);
        };
    }
    Object.defineProperty(Vue.prototype, '$data', dataDef);
    Object.defineProperty(Vue.prototype, '$props', propsDef);
    Vue.prototype.$set = set;
    Vue.prototype.$delete = del;
    Vue.prototype.$watch = function (expOrFn, cb, options) {
        var vm = this;
        if (isPlainObject(cb)) {
            return createWatcher(vm, expOrFn, cb, options);
        }
        options = options || {};
        options.user = true;
        var watcher = new Watcher(vm, expOrFn, cb, options);
        if (options.immediate) {
            var info = "callback for immediate watcher \"".concat(watcher.expression, "\"");
            pushTarget();
            invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
            popTarget();
        }
        return function unwatchFn() {
            watcher.teardown();
        };
    };
}

var uid = 0;
function initMixin$1(Vue) {
    Vue.prototype._init = function (options) {
        var vm = this;
        // a uid
        vm._uid = uid++;
        var startTag, endTag;
        /* istanbul ignore if */
        if ( true && config.performance && mark) {
            startTag = "vue-perf-start:".concat(vm._uid);
            endTag = "vue-perf-end:".concat(vm._uid);
            mark(startTag);
        }
        // a flag to mark this as a Vue instance without having to do instanceof
        // check
        vm._isVue = true;
        // avoid instances from being observed
        vm.__v_skip = true;
        // effect scope
        vm._scope = new EffectScope(true /* detached */);
        // #13134 edge case where a child component is manually created during the
        // render of a parent component
        vm._scope.parent = undefined;
        vm._scope._vm = true;
        // merge options
        if (options && options._isComponent) {
            // optimize internal component instantiation
            // since dynamic options merging is pretty slow, and none of the
            // internal component options needs special treatment.
            initInternalComponent(vm, options);
        }
        else {
            vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
        }
        /* istanbul ignore else */
        if (true) {
            initProxy(vm);
        }
        else // removed by dead control flow
{}
        // expose real self
        vm._self = vm;
        initLifecycle(vm);
        initEvents(vm);
        initRender(vm);
        callHook$1(vm, 'beforeCreate', undefined, false /* setContext */);
        initInjections(vm); // resolve injections before data/props
        initState(vm);
        initProvide(vm); // resolve provide after data/props
        callHook$1(vm, 'created');
        /* istanbul ignore if */
        if ( true && config.performance && mark) {
            vm._name = formatComponentName(vm, false);
            mark(endTag);
            measure("vue ".concat(vm._name, " init"), startTag, endTag);
        }
        if (vm.$options.el) {
            vm.$mount(vm.$options.el);
        }
    };
}
function initInternalComponent(vm, options) {
    var opts = (vm.$options = Object.create(vm.constructor.options));
    // doing this because it's faster than dynamic enumeration.
    var parentVnode = options._parentVnode;
    opts.parent = options.parent;
    opts._parentVnode = parentVnode;
    var vnodeComponentOptions = parentVnode.componentOptions;
    opts.propsData = vnodeComponentOptions.propsData;
    opts._parentListeners = vnodeComponentOptions.listeners;
    opts._renderChildren = vnodeComponentOptions.children;
    opts._componentTag = vnodeComponentOptions.tag;
    if (options.render) {
        opts.render = options.render;
        opts.staticRenderFns = options.staticRenderFns;
    }
}
function resolveConstructorOptions(Ctor) {
    var options = Ctor.options;
    if (Ctor.super) {
        var superOptions = resolveConstructorOptions(Ctor.super);
        var cachedSuperOptions = Ctor.superOptions;
        if (superOptions !== cachedSuperOptions) {
            // super option changed,
            // need to resolve new options.
            Ctor.superOptions = superOptions;
            // check if there are any late-modified/attached options (#4976)
            var modifiedOptions = resolveModifiedOptions(Ctor);
            // update base extend options
            if (modifiedOptions) {
                extend(Ctor.extendOptions, modifiedOptions);
            }
            options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
            if (options.name) {
                options.components[options.name] = Ctor;
            }
        }
    }
    return options;
}
function resolveModifiedOptions(Ctor) {
    var modified;
    var latest = Ctor.options;
    var sealed = Ctor.sealedOptions;
    for (var key in latest) {
        if (latest[key] !== sealed[key]) {
            if (!modified)
                modified = {};
            modified[key] = latest[key];
        }
    }
    return modified;
}

function Vue(options) {
    if ( true && !(this instanceof Vue)) {
        warn('Vue is a constructor and should be called with the `new` keyword');
    }
    this._init(options);
}
//@ts-expect-error Vue has function type
initMixin$1(Vue);
//@ts-expect-error Vue has function type
stateMixin(Vue);
//@ts-expect-error Vue has function type
eventsMixin(Vue);
//@ts-expect-error Vue has function type
lifecycleMixin(Vue);
//@ts-expect-error Vue has function type
renderMixin(Vue);

function initUse(Vue) {
    Vue.use = function (plugin) {
        var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
        if (installedPlugins.indexOf(plugin) > -1) {
            return this;
        }
        // additional parameters
        var args = toArray(arguments, 1);
        args.unshift(this);
        if (isFunction(plugin.install)) {
            plugin.install.apply(plugin, args);
        }
        else if (isFunction(plugin)) {
            plugin.apply(null, args);
        }
        installedPlugins.push(plugin);
        return this;
    };
}

function initMixin(Vue) {
    Vue.mixin = function (mixin) {
        this.options = mergeOptions(this.options, mixin);
        return this;
    };
}

function initExtend(Vue) {
    /**
     * Each instance constructor, including Vue, has a unique
     * cid. This enables us to create wrapped "child
     * constructors" for prototypal inheritance and cache them.
     */
    Vue.cid = 0;
    var cid = 1;
    /**
     * Class inheritance
     */
    Vue.extend = function (extendOptions) {
        extendOptions = extendOptions || {};
        var Super = this;
        var SuperId = Super.cid;
        var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
        if (cachedCtors[SuperId]) {
            return cachedCtors[SuperId];
        }
        var name = getComponentName(extendOptions) || getComponentName(Super.options);
        if ( true && name) {
            validateComponentName(name);
        }
        var Sub = function VueComponent(options) {
            this._init(options);
        };
        Sub.prototype = Object.create(Super.prototype);
        Sub.prototype.constructor = Sub;
        Sub.cid = cid++;
        Sub.options = mergeOptions(Super.options, extendOptions);
        Sub['super'] = Super;
        // For props and computed properties, we define the proxy getters on
        // the Vue instances at extension time, on the extended prototype. This
        // avoids Object.defineProperty calls for each instance created.
        if (Sub.options.props) {
            initProps(Sub);
        }
        if (Sub.options.computed) {
            initComputed(Sub);
        }
        // allow further extension/mixin/plugin usage
        Sub.extend = Super.extend;
        Sub.mixin = Super.mixin;
        Sub.use = Super.use;
        // create asset registers, so extended classes
        // can have their private assets too.
        ASSET_TYPES.forEach(function (type) {
            Sub[type] = Super[type];
        });
        // enable recursive self-lookup
        if (name) {
            Sub.options.components[name] = Sub;
        }
        // keep a reference to the super options at extension time.
        // later at instantiation we can check if Super's options have
        // been updated.
        Sub.superOptions = Super.options;
        Sub.extendOptions = extendOptions;
        Sub.sealedOptions = extend({}, Sub.options);
        // cache constructor
        cachedCtors[SuperId] = Sub;
        return Sub;
    };
}
function initProps(Comp) {
    var props = Comp.options.props;
    for (var key in props) {
        proxy(Comp.prototype, "_props", key);
    }
}
function initComputed(Comp) {
    var computed = Comp.options.computed;
    for (var key in computed) {
        defineComputed(Comp.prototype, key, computed[key]);
    }
}

function initAssetRegisters(Vue) {
    /**
     * Create asset registration methods.
     */
    ASSET_TYPES.forEach(function (type) {
        // @ts-expect-error function is not exact same type
        Vue[type] = function (id, definition) {
            if (!definition) {
                return this.options[type + 's'][id];
            }
            else {
                /* istanbul ignore if */
                if ( true && type === 'component') {
                    validateComponentName(id);
                }
                if (type === 'component' && isPlainObject(definition)) {
                    // @ts-expect-error
                    definition.name = definition.name || id;
                    definition = this.options._base.extend(definition);
                }
                if (type === 'directive' && isFunction(definition)) {
                    definition = { bind: definition, update: definition };
                }
                this.options[type + 's'][id] = definition;
                return definition;
            }
        };
    });
}

function _getComponentName(opts) {
    return opts && (getComponentName(opts.Ctor.options) || opts.tag);
}
function matches(pattern, name) {
    if (isArray(pattern)) {
        return pattern.indexOf(name) > -1;
    }
    else if (typeof pattern === 'string') {
        return pattern.split(',').indexOf(name) > -1;
    }
    else if (isRegExp(pattern)) {
        return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
}
function pruneCache(keepAliveInstance, filter) {
    var cache = keepAliveInstance.cache, keys = keepAliveInstance.keys, _vnode = keepAliveInstance._vnode, $vnode = keepAliveInstance.$vnode;
    for (var key in cache) {
        var entry = cache[key];
        if (entry) {
            var name_1 = entry.name;
            if (name_1 && !filter(name_1)) {
                pruneCacheEntry(cache, key, keys, _vnode);
            }
        }
    }
    $vnode.componentOptions.children = undefined;
}
function pruneCacheEntry(cache, key, keys, current) {
    var entry = cache[key];
    if (entry && (!current || entry.tag !== current.tag)) {
        // @ts-expect-error can be undefined
        entry.componentInstance.$destroy();
    }
    cache[key] = null;
    remove$2(keys, key);
}
var patternTypes = [String, RegExp, Array];
// TODO defineComponent
var KeepAlive = {
    name: 'keep-alive',
    abstract: true,
    props: {
        include: patternTypes,
        exclude: patternTypes,
        max: [String, Number]
    },
    methods: {
        cacheVNode: function () {
            var _a = this, cache = _a.cache, keys = _a.keys, vnodeToCache = _a.vnodeToCache, keyToCache = _a.keyToCache;
            if (vnodeToCache) {
                var tag = vnodeToCache.tag, componentInstance = vnodeToCache.componentInstance, componentOptions = vnodeToCache.componentOptions;
                cache[keyToCache] = {
                    name: _getComponentName(componentOptions),
                    tag: tag,
                    componentInstance: componentInstance
                };
                keys.push(keyToCache);
                // prune oldest entry
                if (this.max && keys.length > parseInt(this.max)) {
                    pruneCacheEntry(cache, keys[0], keys, this._vnode);
                }
                this.vnodeToCache = null;
            }
        }
    },
    created: function () {
        this.cache = Object.create(null);
        this.keys = [];
    },
    destroyed: function () {
        for (var key in this.cache) {
            pruneCacheEntry(this.cache, key, this.keys);
        }
    },
    mounted: function () {
        var _this = this;
        this.cacheVNode();
        this.$watch('include', function (val) {
            pruneCache(_this, function (name) { return matches(val, name); });
        });
        this.$watch('exclude', function (val) {
            pruneCache(_this, function (name) { return !matches(val, name); });
        });
    },
    updated: function () {
        this.cacheVNode();
    },
    render: function () {
        var slot = this.$slots.default;
        var vnode = getFirstComponentChild(slot);
        var componentOptions = vnode && vnode.componentOptions;
        if (componentOptions) {
            // check pattern
            var name_2 = _getComponentName(componentOptions);
            var _a = this, include = _a.include, exclude = _a.exclude;
            if (
            // not included
            (include && (!name_2 || !matches(include, name_2))) ||
                // excluded
                (exclude && name_2 && matches(exclude, name_2))) {
                return vnode;
            }
            var _b = this, cache = _b.cache, keys = _b.keys;
            var key = vnode.key == null
                ? // same constructor may get registered as different local components
                    // so cid alone is not enough (#3269)
                    componentOptions.Ctor.cid +
                        (componentOptions.tag ? "::".concat(componentOptions.tag) : '')
                : vnode.key;
            if (cache[key]) {
                vnode.componentInstance = cache[key].componentInstance;
                // make current key freshest
                remove$2(keys, key);
                keys.push(key);
            }
            else {
                // delay setting the cache until update
                this.vnodeToCache = vnode;
                this.keyToCache = key;
            }
            // @ts-expect-error can vnode.data can be undefined
            vnode.data.keepAlive = true;
        }
        return vnode || (slot && slot[0]);
    }
};

var builtInComponents = {
    KeepAlive: KeepAlive
};

function initGlobalAPI(Vue) {
    // config
    var configDef = {};
    configDef.get = function () { return config; };
    if (true) {
        configDef.set = function () {
            warn('Do not replace the Vue.config object, set individual fields instead.');
        };
    }
    Object.defineProperty(Vue, 'config', configDef);
    // exposed util methods.
    // NOTE: these are not considered part of the public API - avoid relying on
    // them unless you are aware of the risk.
    Vue.util = {
        warn: warn,
        extend: extend,
        mergeOptions: mergeOptions,
        defineReactive: defineReactive
    };
    Vue.set = set;
    Vue.delete = del;
    Vue.nextTick = nextTick;
    // 2.6 explicit observable API
    Vue.observable = function (obj) {
        observe(obj);
        return obj;
    };
    Vue.options = Object.create(null);
    ASSET_TYPES.forEach(function (type) {
        Vue.options[type + 's'] = Object.create(null);
    });
    // this is used to identify the "base" constructor to extend all plain-object
    // components with in Weex's multi-instance scenarios.
    Vue.options._base = Vue;
    extend(Vue.options.components, builtInComponents);
    initUse(Vue);
    initMixin(Vue);
    initExtend(Vue);
    initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
    get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
    get: function () {
        /* istanbul ignore next */
        return this.$vnode && this.$vnode.ssrContext;
    }
});
// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
    value: FunctionalRenderContext
});
Vue.version = version;

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');
// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
    return ((attr === 'value' && acceptValue(tag) && type !== 'button') ||
        (attr === 'selected' && tag === 'option') ||
        (attr === 'checked' && tag === 'input') ||
        (attr === 'muted' && tag === 'video'));
};
var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');
var convertEnumeratedValue = function (key, value) {
    return isFalsyAttrValue(value) || value === 'false'
        ? 'false'
        : // allow arbitrary string value for contenteditable
            key === 'contenteditable' && isValidContentEditableValue(value)
                ? value
                : 'true';
};
var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
    'required,reversed,scoped,seamless,selected,sortable,' +
    'truespeed,typemustmatch,visible');
var xlinkNS = 'http://www.w3.org/1999/xlink';
var isXlink = function (name) {
    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};
var getXlinkProp = function (name) {
    return isXlink(name) ? name.slice(6, name.length) : '';
};
var isFalsyAttrValue = function (val) {
    return val == null || val === false;
};

function genClassForVnode(vnode) {
    var data = vnode.data;
    var parentNode = vnode;
    var childNode = vnode;
    while (isDef(childNode.componentInstance)) {
        childNode = childNode.componentInstance._vnode;
        if (childNode && childNode.data) {
            data = mergeClassData(childNode.data, data);
        }
    }
    // @ts-expect-error parentNode.parent not VNodeWithData
    while (isDef((parentNode = parentNode.parent))) {
        if (parentNode && parentNode.data) {
            data = mergeClassData(data, parentNode.data);
        }
    }
    return renderClass(data.staticClass, data.class);
}
function mergeClassData(child, parent) {
    return {
        staticClass: concat(child.staticClass, parent.staticClass),
        class: isDef(child.class) ? [child.class, parent.class] : parent.class
    };
}
function renderClass(staticClass, dynamicClass) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
        return concat(staticClass, stringifyClass(dynamicClass));
    }
    /* istanbul ignore next */
    return '';
}
function concat(a, b) {
    return a ? (b ? a + ' ' + b : a) : b || '';
}
function stringifyClass(value) {
    if (Array.isArray(value)) {
        return stringifyArray(value);
    }
    if (isObject(value)) {
        return stringifyObject(value);
    }
    if (typeof value === 'string') {
        return value;
    }
    /* istanbul ignore next */
    return '';
}
function stringifyArray(value) {
    var res = '';
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
        if (isDef((stringified = stringifyClass(value[i]))) && stringified !== '') {
            if (res)
                res += ' ';
            res += stringified;
        }
    }
    return res;
}
function stringifyObject(value) {
    var res = '';
    for (var key in value) {
        if (value[key]) {
            if (res)
                res += ' ';
            res += key;
        }
    }
    return res;
}

var namespaceMap = {
    svg: 'http://www.w3.org/2000/svg',
    math: 'http://www.w3.org/1998/Math/MathML'
};
var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' +
    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
    'embed,object,param,source,canvas,script,noscript,del,ins,' +
    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
    'output,progress,select,textarea,' +
    'details,dialog,menu,menuitem,summary,' +
    'content,element,shadow,template,blockquote,iframe,tfoot');
// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
    'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);
var isReservedTag = function (tag) {
    return isHTMLTag(tag) || isSVG(tag);
};
function getTagNamespace(tag) {
    if (isSVG(tag)) {
        return 'svg';
    }
    // basic support for MathML
    // note it doesn't support other MathML elements being component roots
    if (tag === 'math') {
        return 'math';
    }
}
var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
    /* istanbul ignore if */
    if (!inBrowser) {
        return true;
    }
    if (isReservedTag(tag)) {
        return false;
    }
    tag = tag.toLowerCase();
    /* istanbul ignore if */
    if (unknownElementCache[tag] != null) {
        return unknownElementCache[tag];
    }
    var el = document.createElement(tag);
    if (tag.indexOf('-') > -1) {
        // https://stackoverflow.com/a/28210364/1070244
        return (unknownElementCache[tag] =
            el.constructor === window.HTMLUnknownElement ||
                el.constructor === window.HTMLElement);
    }
    else {
        return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()));
    }
}
var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
    if (typeof el === 'string') {
        var selected = document.querySelector(el);
        if (!selected) {
             true && warn('Cannot find element: ' + el);
            return document.createElement('div');
        }
        return selected;
    }
    else {
        return el;
    }
}

function createElement(tagName, vnode) {
    var elm = document.createElement(tagName);
    if (tagName !== 'select') {
        return elm;
    }
    // false or null will remove the attribute but undefined will not
    if (vnode.data &&
        vnode.data.attrs &&
        vnode.data.attrs.multiple !== undefined) {
        elm.setAttribute('multiple', 'multiple');
    }
    return elm;
}
function createElementNS(namespace, tagName) {
    return document.createElementNS(namespaceMap[namespace], tagName);
}
function createTextNode(text) {
    return document.createTextNode(text);
}
function createComment(text) {
    return document.createComment(text);
}
function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
    node.removeChild(child);
}
function appendChild(node, child) {
    node.appendChild(child);
}
function parentNode(node) {
    return node.parentNode;
}
function nextSibling(node) {
    return node.nextSibling;
}
function tagName(node) {
    return node.tagName;
}
function setTextContent(node, text) {
    node.textContent = text;
}
function setStyleScope(node, scopeId) {
    node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createElement: createElement,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});

var ref = {
    create: function (_, vnode) {
        registerRef(vnode);
    },
    update: function (oldVnode, vnode) {
        if (oldVnode.data.ref !== vnode.data.ref) {
            registerRef(oldVnode, true);
            registerRef(vnode);
        }
    },
    destroy: function (vnode) {
        registerRef(vnode, true);
    }
};
function registerRef(vnode, isRemoval) {
    var ref = vnode.data.ref;
    if (!isDef(ref))
        return;
    var vm = vnode.context;
    var refValue = vnode.componentInstance || vnode.elm;
    var value = isRemoval ? null : refValue;
    var $refsValue = isRemoval ? undefined : refValue;
    if (isFunction(ref)) {
        invokeWithErrorHandling(ref, vm, [value], vm, "template ref function");
        return;
    }
    var isFor = vnode.data.refInFor;
    var _isString = typeof ref === 'string' || typeof ref === 'number';
    var _isRef = isRef(ref);
    var refs = vm.$refs;
    if (_isString || _isRef) {
        if (isFor) {
            var existing = _isString ? refs[ref] : ref.value;
            if (isRemoval) {
                isArray(existing) && remove$2(existing, refValue);
            }
            else {
                if (!isArray(existing)) {
                    if (_isString) {
                        refs[ref] = [refValue];
                        setSetupRef(vm, ref, refs[ref]);
                    }
                    else {
                        ref.value = [refValue];
                    }
                }
                else if (!existing.includes(refValue)) {
                    existing.push(refValue);
                }
            }
        }
        else if (_isString) {
            if (isRemoval && refs[ref] !== refValue) {
                return;
            }
            refs[ref] = $refsValue;
            setSetupRef(vm, ref, value);
        }
        else if (_isRef) {
            if (isRemoval && ref.value !== refValue) {
                return;
            }
            ref.value = value;
        }
        else if (true) {
            warn("Invalid template ref type: ".concat(typeof ref));
        }
    }
}
function setSetupRef(_a, key, val) {
    var _setupState = _a._setupState;
    if (_setupState && hasOwn(_setupState, key)) {
        if (isRef(_setupState[key])) {
            _setupState[key].value = val;
        }
        else {
            _setupState[key] = val;
        }
    }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */
var emptyNode = new VNode('', {}, []);
var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];
function sameVnode(a, b) {
    return (a.key === b.key &&
        a.asyncFactory === b.asyncFactory &&
        ((a.tag === b.tag &&
            a.isComment === b.isComment &&
            isDef(a.data) === isDef(b.data) &&
            sameInputType(a, b)) ||
            (isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error))));
}
function sameInputType(a, b) {
    if (a.tag !== 'input')
        return true;
    var i;
    var typeA = isDef((i = a.data)) && isDef((i = i.attrs)) && i.type;
    var typeB = isDef((i = b.data)) && isDef((i = i.attrs)) && i.type;
    return typeA === typeB || (isTextInputType(typeA) && isTextInputType(typeB));
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i, key;
    var map = {};
    for (i = beginIdx; i <= endIdx; ++i) {
        key = children[i].key;
        if (isDef(key))
            map[key] = i;
    }
    return map;
}
function createPatchFunction(backend) {
    var i, j;
    var cbs = {};
    var modules = backend.modules, nodeOps = backend.nodeOps;
    for (i = 0; i < hooks.length; ++i) {
        cbs[hooks[i]] = [];
        for (j = 0; j < modules.length; ++j) {
            if (isDef(modules[j][hooks[i]])) {
                cbs[hooks[i]].push(modules[j][hooks[i]]);
            }
        }
    }
    function emptyNodeAt(elm) {
        return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
    }
    function createRmCb(childElm, listeners) {
        function remove() {
            if (--remove.listeners === 0) {
                removeNode(childElm);
            }
        }
        remove.listeners = listeners;
        return remove;
    }
    function removeNode(el) {
        var parent = nodeOps.parentNode(el);
        // element may have already been removed due to v-html / v-text
        if (isDef(parent)) {
            nodeOps.removeChild(parent, el);
        }
    }
    function isUnknownElement(vnode, inVPre) {
        return (!inVPre &&
            !vnode.ns &&
            !(config.ignoredElements.length &&
                config.ignoredElements.some(function (ignore) {
                    return isRegExp(ignore)
                        ? ignore.test(vnode.tag)
                        : ignore === vnode.tag;
                })) &&
            config.isUnknownElement(vnode.tag));
    }
    var creatingElmInVPre = 0;
    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
        if (isDef(vnode.elm) && isDef(ownerArray)) {
            // This vnode was used in a previous render!
            // now it's used as a new node, overwriting its elm would cause
            // potential patch errors down the road when it's used as an insertion
            // reference node. Instead, we clone the node on-demand before creating
            // associated DOM element for it.
            vnode = ownerArray[index] = cloneVNode(vnode);
        }
        vnode.isRootInsert = !nested; // for transition enter check
        if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
            return;
        }
        var data = vnode.data;
        var children = vnode.children;
        var tag = vnode.tag;
        if (isDef(tag)) {
            if (true) {
                if (data && data.pre) {
                    creatingElmInVPre++;
                }
                if (isUnknownElement(vnode, creatingElmInVPre)) {
                    warn('Unknown custom element: <' +
                        tag +
                        '> - did you ' +
                        'register the component correctly? For recursive components, ' +
                        'make sure to provide the "name" option.', vnode.context);
                }
            }
            vnode.elm = vnode.ns
                ? nodeOps.createElementNS(vnode.ns, tag)
                : nodeOps.createElement(tag, vnode);
            setScope(vnode);
            createChildren(vnode, children, insertedVnodeQueue);
            if (isDef(data)) {
                invokeCreateHooks(vnode, insertedVnodeQueue);
            }
            insert(parentElm, vnode.elm, refElm);
            if ( true && data && data.pre) {
                creatingElmInVPre--;
            }
        }
        else if (isTrue(vnode.isComment)) {
            vnode.elm = nodeOps.createComment(vnode.text);
            insert(parentElm, vnode.elm, refElm);
        }
        else {
            vnode.elm = nodeOps.createTextNode(vnode.text);
            insert(parentElm, vnode.elm, refElm);
        }
    }
    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
        var i = vnode.data;
        if (isDef(i)) {
            var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
            if (isDef((i = i.hook)) && isDef((i = i.init))) {
                i(vnode, false /* hydrating */);
            }
            // after calling the init hook, if the vnode is a child component
            // it should've created a child instance and mounted it. the child
            // component also has set the placeholder vnode's elm.
            // in that case we can just return the element and be done.
            if (isDef(vnode.componentInstance)) {
                initComponent(vnode, insertedVnodeQueue);
                insert(parentElm, vnode.elm, refElm);
                if (isTrue(isReactivated)) {
                    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
                }
                return true;
            }
        }
    }
    function initComponent(vnode, insertedVnodeQueue) {
        if (isDef(vnode.data.pendingInsert)) {
            insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
            vnode.data.pendingInsert = null;
        }
        vnode.elm = vnode.componentInstance.$el;
        if (isPatchable(vnode)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            setScope(vnode);
        }
        else {
            // empty component root.
            // skip all element-related modules except for ref (#3455)
            registerRef(vnode);
            // make sure to invoke the insert hook
            insertedVnodeQueue.push(vnode);
        }
    }
    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
        var i;
        // hack for #4339: a reactivated component with inner transition
        // does not trigger because the inner node's created hooks are not called
        // again. It's not ideal to involve module-specific logic in here but
        // there doesn't seem to be a better way to do it.
        var innerNode = vnode;
        while (innerNode.componentInstance) {
            innerNode = innerNode.componentInstance._vnode;
            if (isDef((i = innerNode.data)) && isDef((i = i.transition))) {
                for (i = 0; i < cbs.activate.length; ++i) {
                    cbs.activate[i](emptyNode, innerNode);
                }
                insertedVnodeQueue.push(innerNode);
                break;
            }
        }
        // unlike a newly created component,
        // a reactivated keep-alive component doesn't insert itself
        insert(parentElm, vnode.elm, refElm);
    }
    function insert(parent, elm, ref) {
        if (isDef(parent)) {
            if (isDef(ref)) {
                if (nodeOps.parentNode(ref) === parent) {
                    nodeOps.insertBefore(parent, elm, ref);
                }
            }
            else {
                nodeOps.appendChild(parent, elm);
            }
        }
    }
    function createChildren(vnode, children, insertedVnodeQueue) {
        if (isArray(children)) {
            if (true) {
                checkDuplicateKeys(children);
            }
            for (var i_1 = 0; i_1 < children.length; ++i_1) {
                createElm(children[i_1], insertedVnodeQueue, vnode.elm, null, true, children, i_1);
            }
        }
        else if (isPrimitive(vnode.text)) {
            nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
        }
    }
    function isPatchable(vnode) {
        while (vnode.componentInstance) {
            vnode = vnode.componentInstance._vnode;
        }
        return isDef(vnode.tag);
    }
    function invokeCreateHooks(vnode, insertedVnodeQueue) {
        for (var i_2 = 0; i_2 < cbs.create.length; ++i_2) {
            cbs.create[i_2](emptyNode, vnode);
        }
        i = vnode.data.hook; // Reuse variable
        if (isDef(i)) {
            if (isDef(i.create))
                i.create(emptyNode, vnode);
            if (isDef(i.insert))
                insertedVnodeQueue.push(vnode);
        }
    }
    // set scope id attribute for scoped CSS.
    // this is implemented as a special case to avoid the overhead
    // of going through the normal attribute patching process.
    function setScope(vnode) {
        var i;
        if (isDef((i = vnode.fnScopeId))) {
            nodeOps.setStyleScope(vnode.elm, i);
        }
        else {
            var ancestor = vnode;
            while (ancestor) {
                if (isDef((i = ancestor.context)) && isDef((i = i.$options._scopeId))) {
                    nodeOps.setStyleScope(vnode.elm, i);
                }
                ancestor = ancestor.parent;
            }
        }
        // for slot content they should also get the scopeId from the host instance.
        if (isDef((i = activeInstance)) &&
            i !== vnode.context &&
            i !== vnode.fnContext &&
            isDef((i = i.$options._scopeId))) {
            nodeOps.setStyleScope(vnode.elm, i);
        }
    }
    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
            createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
        }
    }
    function invokeDestroyHook(vnode) {
        var i, j;
        var data = vnode.data;
        if (isDef(data)) {
            if (isDef((i = data.hook)) && isDef((i = i.destroy)))
                i(vnode);
            for (i = 0; i < cbs.destroy.length; ++i)
                cbs.destroy[i](vnode);
        }
        if (isDef((i = vnode.children))) {
            for (j = 0; j < vnode.children.length; ++j) {
                invokeDestroyHook(vnode.children[j]);
            }
        }
    }
    function removeVnodes(vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx];
            if (isDef(ch)) {
                if (isDef(ch.tag)) {
                    removeAndInvokeRemoveHook(ch);
                    invokeDestroyHook(ch);
                }
                else {
                    // Text node
                    removeNode(ch.elm);
                }
            }
        }
    }
    function removeAndInvokeRemoveHook(vnode, rm) {
        if (isDef(rm) || isDef(vnode.data)) {
            var i_3;
            var listeners = cbs.remove.length + 1;
            if (isDef(rm)) {
                // we have a recursively passed down rm callback
                // increase the listeners count
                rm.listeners += listeners;
            }
            else {
                // directly removing
                rm = createRmCb(vnode.elm, listeners);
            }
            // recursively invoke hooks on child component root node
            if (isDef((i_3 = vnode.componentInstance)) &&
                isDef((i_3 = i_3._vnode)) &&
                isDef(i_3.data)) {
                removeAndInvokeRemoveHook(i_3, rm);
            }
            for (i_3 = 0; i_3 < cbs.remove.length; ++i_3) {
                cbs.remove[i_3](vnode, rm);
            }
            if (isDef((i_3 = vnode.data.hook)) && isDef((i_3 = i_3.remove))) {
                i_3(vnode, rm);
            }
            else {
                rm();
            }
        }
        else {
            removeNode(vnode.elm);
        }
    }
    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
        var oldStartIdx = 0;
        var newStartIdx = 0;
        var oldEndIdx = oldCh.length - 1;
        var oldStartVnode = oldCh[0];
        var oldEndVnode = oldCh[oldEndIdx];
        var newEndIdx = newCh.length - 1;
        var newStartVnode = newCh[0];
        var newEndVnode = newCh[newEndIdx];
        var oldKeyToIdx, idxInOld, vnodeToMove, refElm;
        // removeOnly is a special flag used only by <transition-group>
        // to ensure removed elements stay in correct relative positions
        // during leaving transitions
        var canMove = !removeOnly;
        if (true) {
            checkDuplicateKeys(newCh);
        }
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (isUndef(oldStartVnode)) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
            }
            else if (isUndef(oldEndVnode)) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newEndVnode)) {
                // Vnode moved right
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
                canMove &&
                    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldEndVnode, newStartVnode)) {
                // Vnode moved left
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                canMove &&
                    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                if (isUndef(oldKeyToIdx))
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                idxInOld = isDef(newStartVnode.key)
                    ? oldKeyToIdx[newStartVnode.key]
                    : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
                if (isUndef(idxInOld)) {
                    // New element
                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                }
                else {
                    vnodeToMove = oldCh[idxInOld];
                    if (sameVnode(vnodeToMove, newStartVnode)) {
                        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                        oldCh[idxInOld] = undefined;
                        canMove &&
                            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
                    }
                    else {
                        // same key but different element. treat as new element
                        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                    }
                }
                newStartVnode = newCh[++newStartIdx];
            }
        }
        if (oldStartIdx > oldEndIdx) {
            refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
            addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
        }
        else if (newStartIdx > newEndIdx) {
            removeVnodes(oldCh, oldStartIdx, oldEndIdx);
        }
    }
    function checkDuplicateKeys(children) {
        var seenKeys = {};
        for (var i_4 = 0; i_4 < children.length; i_4++) {
            var vnode = children[i_4];
            var key = vnode.key;
            if (isDef(key)) {
                if (seenKeys[key]) {
                    warn("Duplicate keys detected: '".concat(key, "'. This may cause an update error."), vnode.context);
                }
                else {
                    seenKeys[key] = true;
                }
            }
        }
    }
    function findIdxInOld(node, oldCh, start, end) {
        for (var i_5 = start; i_5 < end; i_5++) {
            var c = oldCh[i_5];
            if (isDef(c) && sameVnode(node, c))
                return i_5;
        }
    }
    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
        if (oldVnode === vnode) {
            return;
        }
        if (isDef(vnode.elm) && isDef(ownerArray)) {
            // clone reused vnode
            vnode = ownerArray[index] = cloneVNode(vnode);
        }
        var elm = (vnode.elm = oldVnode.elm);
        if (isTrue(oldVnode.isAsyncPlaceholder)) {
            if (isDef(vnode.asyncFactory.resolved)) {
                hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
            }
            else {
                vnode.isAsyncPlaceholder = true;
            }
            return;
        }
        // reuse element for static trees.
        // note we only do this if the vnode is cloned -
        // if the new node is not cloned it means the render functions have been
        // reset by the hot-reload-api and we need to do a proper re-render.
        if (isTrue(vnode.isStatic) &&
            isTrue(oldVnode.isStatic) &&
            vnode.key === oldVnode.key &&
            (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
            vnode.componentInstance = oldVnode.componentInstance;
            return;
        }
        var i;
        var data = vnode.data;
        if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {
            i(oldVnode, vnode);
        }
        var oldCh = oldVnode.children;
        var ch = vnode.children;
        if (isDef(data) && isPatchable(vnode)) {
            for (i = 0; i < cbs.update.length; ++i)
                cbs.update[i](oldVnode, vnode);
            if (isDef((i = data.hook)) && isDef((i = i.update)))
                i(oldVnode, vnode);
        }
        if (isUndef(vnode.text)) {
            if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch)
                    updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
            }
            else if (isDef(ch)) {
                if (true) {
                    checkDuplicateKeys(ch);
                }
                if (isDef(oldVnode.text))
                    nodeOps.setTextContent(elm, '');
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            }
            else if (isDef(oldCh)) {
                removeVnodes(oldCh, 0, oldCh.length - 1);
            }
            else if (isDef(oldVnode.text)) {
                nodeOps.setTextContent(elm, '');
            }
        }
        else if (oldVnode.text !== vnode.text) {
            nodeOps.setTextContent(elm, vnode.text);
        }
        if (isDef(data)) {
            if (isDef((i = data.hook)) && isDef((i = i.postpatch)))
                i(oldVnode, vnode);
        }
    }
    function invokeInsertHook(vnode, queue, initial) {
        // delay insert hooks for component root nodes, invoke them after the
        // element is really inserted
        if (isTrue(initial) && isDef(vnode.parent)) {
            vnode.parent.data.pendingInsert = queue;
        }
        else {
            for (var i_6 = 0; i_6 < queue.length; ++i_6) {
                queue[i_6].data.hook.insert(queue[i_6]);
            }
        }
    }
    var hydrationBailed = false;
    // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    // Note: style is excluded because it relies on initial clone for future
    // deep updates (#7063).
    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');
    // Note: this is a browser-only function so we can assume elms are DOM nodes.
    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
        var i;
        var tag = vnode.tag, data = vnode.data, children = vnode.children;
        inVPre = inVPre || (data && data.pre);
        vnode.elm = elm;
        if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
            vnode.isAsyncPlaceholder = true;
            return true;
        }
        // assert node match
        if (true) {
            if (!assertNodeMatch(elm, vnode, inVPre)) {
                return false;
            }
        }
        if (isDef(data)) {
            if (isDef((i = data.hook)) && isDef((i = i.init)))
                i(vnode, true /* hydrating */);
            if (isDef((i = vnode.componentInstance))) {
                // child component. it should have hydrated its own tree.
                initComponent(vnode, insertedVnodeQueue);
                return true;
            }
        }
        if (isDef(tag)) {
            if (isDef(children)) {
                // empty element, allow client to pick up and populate children
                if (!elm.hasChildNodes()) {
                    createChildren(vnode, children, insertedVnodeQueue);
                }
                else {
                    // v-html and domProps: innerHTML
                    if (isDef((i = data)) &&
                        isDef((i = i.domProps)) &&
                        isDef((i = i.innerHTML))) {
                        if (i !== elm.innerHTML) {
                            /* istanbul ignore if */
                            if ( true &&
                                typeof console !== 'undefined' &&
                                !hydrationBailed) {
                                hydrationBailed = true;
                                console.warn('Parent: ', elm);
                                console.warn('server innerHTML: ', i);
                                console.warn('client innerHTML: ', elm.innerHTML);
                            }
                            return false;
                        }
                    }
                    else {
                        // iterate and compare children lists
                        var childrenMatch = true;
                        var childNode = elm.firstChild;
                        for (var i_7 = 0; i_7 < children.length; i_7++) {
                            if (!childNode ||
                                !hydrate(childNode, children[i_7], insertedVnodeQueue, inVPre)) {
                                childrenMatch = false;
                                break;
                            }
                            childNode = childNode.nextSibling;
                        }
                        // if childNode is not null, it means the actual childNodes list is
                        // longer than the virtual children list.
                        if (!childrenMatch || childNode) {
                            /* istanbul ignore if */
                            if ( true &&
                                typeof console !== 'undefined' &&
                                !hydrationBailed) {
                                hydrationBailed = true;
                                console.warn('Parent: ', elm);
                                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
                            }
                            return false;
                        }
                    }
                }
            }
            if (isDef(data)) {
                var fullInvoke = false;
                for (var key in data) {
                    if (!isRenderedModule(key)) {
                        fullInvoke = true;
                        invokeCreateHooks(vnode, insertedVnodeQueue);
                        break;
                    }
                }
                if (!fullInvoke && data['class']) {
                    // ensure collecting deps for deep class bindings for future updates
                    traverse(data['class']);
                }
            }
        }
        else if (elm.data !== vnode.text) {
            elm.data = vnode.text;
        }
        return true;
    }
    function assertNodeMatch(node, vnode, inVPre) {
        if (isDef(vnode.tag)) {
            return (vnode.tag.indexOf('vue-component') === 0 ||
                (!isUnknownElement(vnode, inVPre) &&
                    vnode.tag.toLowerCase() ===
                        (node.tagName && node.tagName.toLowerCase())));
        }
        else {
            return node.nodeType === (vnode.isComment ? 8 : 3);
        }
    }
    return function patch(oldVnode, vnode, hydrating, removeOnly) {
        if (isUndef(vnode)) {
            if (isDef(oldVnode))
                invokeDestroyHook(oldVnode);
            return;
        }
        var isInitialPatch = false;
        var insertedVnodeQueue = [];
        if (isUndef(oldVnode)) {
            // empty mount (likely as component), create new root element
            isInitialPatch = true;
            createElm(vnode, insertedVnodeQueue);
        }
        else {
            var isRealElement = isDef(oldVnode.nodeType);
            if (!isRealElement && sameVnode(oldVnode, vnode)) {
                // patch existing root node
                patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
            }
            else {
                if (isRealElement) {
                    // mounting to a real element
                    // check if this is server-rendered content and if we can perform
                    // a successful hydration.
                    if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
                        oldVnode.removeAttribute(SSR_ATTR);
                        hydrating = true;
                    }
                    if (isTrue(hydrating)) {
                        if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                            invokeInsertHook(vnode, insertedVnodeQueue, true);
                            return oldVnode;
                        }
                        else if (true) {
                            warn('The client-side rendered virtual DOM tree is not matching ' +
                                'server-rendered content. This is likely caused by incorrect ' +
                                'HTML markup, for example nesting block-level elements inside ' +
                                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                                'full client-side render.');
                        }
                    }
                    // either not server-rendered, or hydration failed.
                    // create an empty node and replace it
                    oldVnode = emptyNodeAt(oldVnode);
                }
                // replacing existing element
                var oldElm = oldVnode.elm;
                var parentElm = nodeOps.parentNode(oldElm);
                // create new node
                createElm(vnode, insertedVnodeQueue, 
                // extremely rare edge case: do not insert if old element is in a
                // leaving transition. Only happens when combining transition +
                // keep-alive + HOCs. (#4590)
                oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));
                // update parent placeholder node element, recursively
                if (isDef(vnode.parent)) {
                    var ancestor = vnode.parent;
                    var patchable = isPatchable(vnode);
                    while (ancestor) {
                        for (var i_8 = 0; i_8 < cbs.destroy.length; ++i_8) {
                            cbs.destroy[i_8](ancestor);
                        }
                        ancestor.elm = vnode.elm;
                        if (patchable) {
                            for (var i_9 = 0; i_9 < cbs.create.length; ++i_9) {
                                cbs.create[i_9](emptyNode, ancestor);
                            }
                            // #6513
                            // invoke insert hooks that may have been merged by create hooks.
                            // e.g. for directives that uses the "inserted" hook.
                            var insert_1 = ancestor.data.hook.insert;
                            if (insert_1.merged) {
                                // start at index 1 to avoid re-invoking component mounted hook
                                // clone insert hooks to avoid being mutated during iteration.
                                // e.g. for customed directives under transition group.
                                var cloned = insert_1.fns.slice(1);
                                for (var i_10 = 0; i_10 < cloned.length; i_10++) {
                                    cloned[i_10]();
                                }
                            }
                        }
                        else {
                            registerRef(ancestor);
                        }
                        ancestor = ancestor.parent;
                    }
                }
                // destroy old node
                if (isDef(parentElm)) {
                    removeVnodes([oldVnode], 0, 0);
                }
                else if (isDef(oldVnode.tag)) {
                    invokeDestroyHook(oldVnode);
                }
            }
        }
        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
        return vnode.elm;
    };
}

var directives = {
    create: updateDirectives,
    update: updateDirectives,
    destroy: function unbindDirectives(vnode) {
        // @ts-expect-error emptyNode is not VNodeWithData
        updateDirectives(vnode, emptyNode);
    }
};
function updateDirectives(oldVnode, vnode) {
    if (oldVnode.data.directives || vnode.data.directives) {
        _update(oldVnode, vnode);
    }
}
function _update(oldVnode, vnode) {
    var isCreate = oldVnode === emptyNode;
    var isDestroy = vnode === emptyNode;
    var oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);
    var newDirs = normalizeDirectives(vnode.data.directives, vnode.context);
    var dirsWithInsert = [];
    var dirsWithPostpatch = [];
    var key, oldDir, dir;
    for (key in newDirs) {
        oldDir = oldDirs[key];
        dir = newDirs[key];
        if (!oldDir) {
            // new directive, bind
            callHook(dir, 'bind', vnode, oldVnode);
            if (dir.def && dir.def.inserted) {
                dirsWithInsert.push(dir);
            }
        }
        else {
            // existing directive, update
            dir.oldValue = oldDir.value;
            dir.oldArg = oldDir.arg;
            callHook(dir, 'update', vnode, oldVnode);
            if (dir.def && dir.def.componentUpdated) {
                dirsWithPostpatch.push(dir);
            }
        }
    }
    if (dirsWithInsert.length) {
        var callInsert = function () {
            for (var i = 0; i < dirsWithInsert.length; i++) {
                callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);
            }
        };
        if (isCreate) {
            mergeVNodeHook(vnode, 'insert', callInsert);
        }
        else {
            callInsert();
        }
    }
    if (dirsWithPostpatch.length) {
        mergeVNodeHook(vnode, 'postpatch', function () {
            for (var i = 0; i < dirsWithPostpatch.length; i++) {
                callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
            }
        });
    }
    if (!isCreate) {
        for (key in oldDirs) {
            if (!newDirs[key]) {
                // no longer present, unbind
                callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
            }
        }
    }
}
var emptyModifiers = Object.create(null);
function normalizeDirectives(dirs, vm) {
    var res = Object.create(null);
    if (!dirs) {
        // $flow-disable-line
        return res;
    }
    var i, dir;
    for (i = 0; i < dirs.length; i++) {
        dir = dirs[i];
        if (!dir.modifiers) {
            // $flow-disable-line
            dir.modifiers = emptyModifiers;
        }
        res[getRawDirName(dir)] = dir;
        if (vm._setupState && vm._setupState.__sfc) {
            var setupDef = dir.def || resolveAsset(vm, '_setupState', 'v-' + dir.name);
            if (typeof setupDef === 'function') {
                dir.def = {
                    bind: setupDef,
                    update: setupDef,
                };
            }
            else {
                dir.def = setupDef;
            }
        }
        dir.def = dir.def || resolveAsset(vm.$options, 'directives', dir.name, true);
    }
    // $flow-disable-line
    return res;
}
function getRawDirName(dir) {
    return (dir.rawName || "".concat(dir.name, ".").concat(Object.keys(dir.modifiers || {}).join('.')));
}
function callHook(dir, hook, vnode, oldVnode, isDestroy) {
    var fn = dir.def && dir.def[hook];
    if (fn) {
        try {
            fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
        }
        catch (e) {
            handleError(e, vnode.context, "directive ".concat(dir.name, " ").concat(hook, " hook"));
        }
    }
}

var baseModules = [ref, directives];

function updateAttrs(oldVnode, vnode) {
    var opts = vnode.componentOptions;
    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
        return;
    }
    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
        return;
    }
    var key, cur, old;
    var elm = vnode.elm;
    var oldAttrs = oldVnode.data.attrs || {};
    var attrs = vnode.data.attrs || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(attrs.__ob__) || isTrue(attrs._v_attr_proxy)) {
        attrs = vnode.data.attrs = extend({}, attrs);
    }
    for (key in attrs) {
        cur = attrs[key];
        old = oldAttrs[key];
        if (old !== cur) {
            setAttr(elm, key, cur, vnode.data.pre);
        }
    }
    // #4391: in IE9, setting type can reset value for input[type=radio]
    // #6666: IE/Edge forces progress value down to 1 before setting a max
    /* istanbul ignore if */
    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
        setAttr(elm, 'value', attrs.value);
    }
    for (key in oldAttrs) {
        if (isUndef(attrs[key])) {
            if (isXlink(key)) {
                elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
            }
            else if (!isEnumeratedAttr(key)) {
                elm.removeAttribute(key);
            }
        }
    }
}
function setAttr(el, key, value, isInPre) {
    if (isInPre || el.tagName.indexOf('-') > -1) {
        baseSetAttr(el, key, value);
    }
    else if (isBooleanAttr(key)) {
        // set attribute for blank value
        // e.g. <option disabled>Select one</option>
        if (isFalsyAttrValue(value)) {
            el.removeAttribute(key);
        }
        else {
            // technically allowfullscreen is a boolean attribute for <iframe>,
            // but Flash expects a value of "true" when used on <embed> tag
            value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
            el.setAttribute(key, value);
        }
    }
    else if (isEnumeratedAttr(key)) {
        el.setAttribute(key, convertEnumeratedValue(key, value));
    }
    else if (isXlink(key)) {
        if (isFalsyAttrValue(value)) {
            el.removeAttributeNS(xlinkNS, getXlinkProp(key));
        }
        else {
            el.setAttributeNS(xlinkNS, key, value);
        }
    }
    else {
        baseSetAttr(el, key, value);
    }
}
function baseSetAttr(el, key, value) {
    if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
    }
    else {
        // #7138: IE10 & 11 fires input event when setting placeholder on
        // <textarea>... block the first input event and remove the blocker
        // immediately.
        /* istanbul ignore if */
        if (isIE &&
            !isIE9 &&
            el.tagName === 'TEXTAREA' &&
            key === 'placeholder' &&
            value !== '' &&
            !el.__ieph) {
            var blocker_1 = function (e) {
                e.stopImmediatePropagation();
                el.removeEventListener('input', blocker_1);
            };
            el.addEventListener('input', blocker_1);
            // $flow-disable-line
            el.__ieph = true; /* IE placeholder patched */
        }
        el.setAttribute(key, value);
    }
}
var attrs = {
    create: updateAttrs,
    update: updateAttrs
};

function updateClass(oldVnode, vnode) {
    var el = vnode.elm;
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (isUndef(data.staticClass) &&
        isUndef(data.class) &&
        (isUndef(oldData) ||
            (isUndef(oldData.staticClass) && isUndef(oldData.class)))) {
        return;
    }
    var cls = genClassForVnode(vnode);
    // handle transition classes
    var transitionClass = el._transitionClasses;
    if (isDef(transitionClass)) {
        cls = concat(cls, stringifyClass(transitionClass));
    }
    // set the class
    if (cls !== el._prevClass) {
        el.setAttribute('class', cls);
        el._prevClass = cls;
    }
}
var klass = {
    create: updateClass,
    update: updateClass
};

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
    /* istanbul ignore if */
    if (isDef(on[RANGE_TOKEN])) {
        // IE input[type=range] only supports `change` event
        var event_1 = isIE ? 'change' : 'input';
        on[event_1] = [].concat(on[RANGE_TOKEN], on[event_1] || []);
        delete on[RANGE_TOKEN];
    }
    // This was originally intended to fix #4521 but no longer necessary
    // after 2.5. Keeping it for backwards compat with generated code from < 2.4
    /* istanbul ignore if */
    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
        on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
        delete on[CHECKBOX_RADIO_TOKEN];
    }
}
var target;
function createOnceHandler(event, handler, capture) {
    var _target = target; // save current target element in closure
    return function onceHandler() {
        var res = handler.apply(null, arguments);
        if (res !== null) {
            remove(event, onceHandler, capture, _target);
        }
    };
}
// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);
function add(name, handler, capture, passive) {
    // async edge case #6566: inner click event triggers patch, event handler
    // attached to outer element during patch, and triggered again. This
    // happens because browsers fire microtask ticks between event propagation.
    // the solution is simple: we save the timestamp when a handler is attached,
    // and the handler would only fire if the event passed to it was fired
    // AFTER it was attached.
    if (useMicrotaskFix) {
        var attachedTimestamp_1 = currentFlushTimestamp;
        var original_1 = handler;
        //@ts-expect-error
        handler = original_1._wrapper = function (e) {
            if (
            // no bubbling, should always fire.
            // this is just a safety net in case event.timeStamp is unreliable in
            // certain weird environments...
            e.target === e.currentTarget ||
                // event is fired after handler attachment
                e.timeStamp >= attachedTimestamp_1 ||
                // bail for environments that have buggy event.timeStamp implementations
                // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
                // #9681 QtWebEngine event.timeStamp is negative value
                e.timeStamp <= 0 ||
                // #9448 bail if event is fired in another document in a multi-page
                // electron/nw.js app, since event.timeStamp will be using a different
                // starting reference
                e.target.ownerDocument !== document) {
                return original_1.apply(this, arguments);
            }
        };
    }
    target.addEventListener(name, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
}
function remove(name, handler, capture, _target) {
    (_target || target).removeEventListener(name, 
    //@ts-expect-error
    handler._wrapper || handler, capture);
}
function updateDOMListeners(oldVnode, vnode) {
    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
        return;
    }
    var on = vnode.data.on || {};
    var oldOn = oldVnode.data.on || {};
    // vnode is empty when removing all listeners,
    // and use old vnode dom element
    target = vnode.elm || oldVnode.elm;
    normalizeEvents(on);
    updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);
    target = undefined;
}
var events = {
    create: updateDOMListeners,
    update: updateDOMListeners,
    // @ts-expect-error emptyNode has actually data
    destroy: function (vnode) { return updateDOMListeners(vnode, emptyNode); }
};

var svgContainer;
function updateDOMProps(oldVnode, vnode) {
    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
        return;
    }
    var key, cur;
    var elm = vnode.elm;
    var oldProps = oldVnode.data.domProps || {};
    var props = vnode.data.domProps || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(props.__ob__) || isTrue(props._v_attr_proxy)) {
        props = vnode.data.domProps = extend({}, props);
    }
    for (key in oldProps) {
        if (!(key in props)) {
            elm[key] = '';
        }
    }
    for (key in props) {
        cur = props[key];
        // ignore children if the node has textContent or innerHTML,
        // as these will throw away existing DOM nodes and cause removal errors
        // on subsequent patches (#3360)
        if (key === 'textContent' || key === 'innerHTML') {
            if (vnode.children)
                vnode.children.length = 0;
            if (cur === oldProps[key])
                continue;
            // #6601 work around Chrome version <= 55 bug where single textNode
            // replaced by innerHTML/textContent retains its parentNode property
            if (elm.childNodes.length === 1) {
                elm.removeChild(elm.childNodes[0]);
            }
        }
        if (key === 'value' && elm.tagName !== 'PROGRESS') {
            // store value as _value as well since
            // non-string values will be stringified
            elm._value = cur;
            // avoid resetting cursor position when value is the same
            var strCur = isUndef(cur) ? '' : String(cur);
            if (shouldUpdateValue(elm, strCur)) {
                elm.value = strCur;
            }
        }
        else if (key === 'innerHTML' &&
            isSVG(elm.tagName) &&
            isUndef(elm.innerHTML)) {
            // IE doesn't support innerHTML for SVG elements
            svgContainer = svgContainer || document.createElement('div');
            svgContainer.innerHTML = "<svg>".concat(cur, "</svg>");
            var svg = svgContainer.firstChild;
            while (elm.firstChild) {
                elm.removeChild(elm.firstChild);
            }
            while (svg.firstChild) {
                elm.appendChild(svg.firstChild);
            }
        }
        else if (
        // skip the update if old and new VDOM state is the same.
        // `value` is handled separately because the DOM value may be temporarily
        // out of sync with VDOM state due to focus, composition and modifiers.
        // This  #4521 by skipping the unnecessary `checked` update.
        cur !== oldProps[key]) {
            // some property updates can throw
            // e.g. `value` on <progress> w/ non-finite value
            try {
                elm[key] = cur;
            }
            catch (e) { }
        }
    }
}
function shouldUpdateValue(elm, checkVal) {
    return (
    //@ts-expect-error
    !elm.composing &&
        (elm.tagName === 'OPTION' ||
            isNotInFocusAndDirty(elm, checkVal) ||
            isDirtyWithModifiers(elm, checkVal)));
}
function isNotInFocusAndDirty(elm, checkVal) {
    // return true when textbox (.number and .trim) loses focus and its value is
    // not equal to the updated value
    var notInFocus = true;
    // #6157
    // work around IE bug when accessing document.activeElement in an iframe
    try {
        notInFocus = document.activeElement !== elm;
    }
    catch (e) { }
    return notInFocus && elm.value !== checkVal;
}
function isDirtyWithModifiers(elm, newVal) {
    var value = elm.value;
    var modifiers = elm._vModifiers; // injected by v-model runtime
    if (isDef(modifiers)) {
        if (modifiers.number) {
            return toNumber(value) !== toNumber(newVal);
        }
        if (modifiers.trim) {
            return value.trim() !== newVal.trim();
        }
    }
    return value !== newVal;
}
var domProps = {
    create: updateDOMProps,
    update: updateDOMProps
};

var parseStyleText = cached(function (cssText) {
    var res = {};
    var listDelimiter = /;(?![^(]*\))/g;
    var propertyDelimiter = /:(.+)/;
    cssText.split(listDelimiter).forEach(function (item) {
        if (item) {
            var tmp = item.split(propertyDelimiter);
            tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return res;
});
// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
    var style = normalizeStyleBinding(data.style);
    // static style is pre-processed into an object during compilation
    // and is always a fresh object, so it's safe to merge into it
    return data.staticStyle ? extend(data.staticStyle, style) : style;
}
// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
    if (Array.isArray(bindingStyle)) {
        return toObject(bindingStyle);
    }
    if (typeof bindingStyle === 'string') {
        return parseStyleText(bindingStyle);
    }
    return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
    var res = {};
    var styleData;
    if (checkChild) {
        var childNode = vnode;
        while (childNode.componentInstance) {
            childNode = childNode.componentInstance._vnode;
            if (childNode &&
                childNode.data &&
                (styleData = normalizeStyleData(childNode.data))) {
                extend(res, styleData);
            }
        }
    }
    if ((styleData = normalizeStyleData(vnode.data))) {
        extend(res, styleData);
    }
    var parentNode = vnode;
    // @ts-expect-error parentNode.parent not VNodeWithData
    while ((parentNode = parentNode.parent)) {
        if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
            extend(res, styleData);
        }
    }
    return res;
}

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
    /* istanbul ignore if */
    if (cssVarRE.test(name)) {
        el.style.setProperty(name, val);
    }
    else if (importantRE.test(val)) {
        el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
    }
    else {
        var normalizedName = normalize(name);
        if (Array.isArray(val)) {
            // Support values array created by autoprefixer, e.g.
            // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
            // Set them one by one, and the browser will only set those it can recognize
            for (var i = 0, len = val.length; i < len; i++) {
                el.style[normalizedName] = val[i];
            }
        }
        else {
            el.style[normalizedName] = val;
        }
    }
};
var vendorNames = ['Webkit', 'Moz', 'ms'];
var emptyStyle;
var normalize = cached(function (prop) {
    emptyStyle = emptyStyle || document.createElement('div').style;
    prop = camelize(prop);
    if (prop !== 'filter' && prop in emptyStyle) {
        return prop;
    }
    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (var i = 0; i < vendorNames.length; i++) {
        var name_1 = vendorNames[i] + capName;
        if (name_1 in emptyStyle) {
            return name_1;
        }
    }
});
function updateStyle(oldVnode, vnode) {
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (isUndef(data.staticStyle) &&
        isUndef(data.style) &&
        isUndef(oldData.staticStyle) &&
        isUndef(oldData.style)) {
        return;
    }
    var cur, name;
    var el = vnode.elm;
    var oldStaticStyle = oldData.staticStyle;
    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
    // if static style exists, stylebinding already merged into it when doing normalizeStyleData
    var oldStyle = oldStaticStyle || oldStyleBinding;
    var style = normalizeStyleBinding(vnode.data.style) || {};
    // store normalized style under a different key for next diff
    // make sure to clone it if it's reactive, since the user likely wants
    // to mutate it.
    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
    var newStyle = getStyle(vnode, true);
    for (name in oldStyle) {
        if (isUndef(newStyle[name])) {
            setProp(el, name, '');
        }
    }
    for (name in newStyle) {
        cur = newStyle[name];
        // ie9 setting to null has no effect, must use empty string
        setProp(el, name, cur == null ? '' : cur);
    }
}
var style = {
    create: updateStyle,
    update: updateStyle
};

var whitespaceRE = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
        return;
    }
    /* istanbul ignore else */
    if (el.classList) {
        if (cls.indexOf(' ') > -1) {
            cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });
        }
        else {
            el.classList.add(cls);
        }
    }
    else {
        var cur = " ".concat(el.getAttribute('class') || '', " ");
        if (cur.indexOf(' ' + cls + ' ') < 0) {
            el.setAttribute('class', (cur + cls).trim());
        }
    }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
        return;
    }
    /* istanbul ignore else */
    if (el.classList) {
        if (cls.indexOf(' ') > -1) {
            cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });
        }
        else {
            el.classList.remove(cls);
        }
        if (!el.classList.length) {
            el.removeAttribute('class');
        }
    }
    else {
        var cur = " ".concat(el.getAttribute('class') || '', " ");
        var tar = ' ' + cls + ' ';
        while (cur.indexOf(tar) >= 0) {
            cur = cur.replace(tar, ' ');
        }
        cur = cur.trim();
        if (cur) {
            el.setAttribute('class', cur);
        }
        else {
            el.removeAttribute('class');
        }
    }
}

function resolveTransition(def) {
    if (!def) {
        return;
    }
    /* istanbul ignore else */
    if (typeof def === 'object') {
        var res = {};
        if (def.css !== false) {
            extend(res, autoCssTransition(def.name || 'v'));
        }
        extend(res, def);
        return res;
    }
    else if (typeof def === 'string') {
        return autoCssTransition(def);
    }
}
var autoCssTransition = cached(function (name) {
    return {
        enterClass: "".concat(name, "-enter"),
        enterToClass: "".concat(name, "-enter-to"),
        enterActiveClass: "".concat(name, "-enter-active"),
        leaveClass: "".concat(name, "-leave"),
        leaveToClass: "".concat(name, "-leave-to"),
        leaveActiveClass: "".concat(name, "-leave-active")
    };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';
// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
    /* istanbul ignore if */
    if (window.ontransitionend === undefined &&
        window.onwebkittransitionend !== undefined) {
        transitionProp = 'WebkitTransition';
        transitionEndEvent = 'webkitTransitionEnd';
    }
    if (window.onanimationend === undefined &&
        window.onwebkitanimationend !== undefined) {
        animationProp = 'WebkitAnimation';
        animationEndEvent = 'webkitAnimationEnd';
    }
}
// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
    ? window.requestAnimationFrame
        ? window.requestAnimationFrame.bind(window)
        : setTimeout
    : /* istanbul ignore next */ function (/* istanbul ignore next */ fn) { return fn(); };
function nextFrame(fn) {
    raf(function () {
        // @ts-expect-error
        raf(fn);
    });
}
function addTransitionClass(el, cls) {
    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
    if (transitionClasses.indexOf(cls) < 0) {
        transitionClasses.push(cls);
        addClass(el, cls);
    }
}
function removeTransitionClass(el, cls) {
    if (el._transitionClasses) {
        remove$2(el._transitionClasses, cls);
    }
    removeClass(el, cls);
}
function whenTransitionEnds(el, expectedType, cb) {
    var _a = getTransitionInfo(el, expectedType), type = _a.type, timeout = _a.timeout, propCount = _a.propCount;
    if (!type)
        return cb();
    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
    var ended = 0;
    var end = function () {
        el.removeEventListener(event, onEnd);
        cb();
    };
    var onEnd = function (e) {
        if (e.target === el) {
            if (++ended >= propCount) {
                end();
            }
        }
    };
    setTimeout(function () {
        if (ended < propCount) {
            end();
        }
    }, timeout + 1);
    el.addEventListener(event, onEnd);
}
var transformRE = /\b(transform|all)(,|$)/;
function getTransitionInfo(el, expectedType) {
    var styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
    var animationTimeout = getTimeout(animationDelays, animationDurations);
    var type;
    var timeout = 0;
    var propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    }
    else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    }
    else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type =
            timeout > 0
                ? transitionTimeout > animationTimeout
                    ? TRANSITION
                    : ANIMATION
                : null;
        propCount = type
            ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
            : 0;
    }
    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
    return {
        type: type,
        timeout: timeout,
        propCount: propCount,
        hasTransform: hasTransform
    };
}
function getTimeout(delays, durations) {
    /* istanbul ignore next */
    while (delays.length < durations.length) {
        delays = delays.concat(delays);
    }
    return Math.max.apply(null, durations.map(function (d, i) {
        return toMs(d) + toMs(delays[i]);
    }));
}
// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors
function toMs(s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}

function enter(vnode, toggleDisplay) {
    var el = vnode.elm;
    // call leave callback now
    if (isDef(el._leaveCb)) {
        el._leaveCb.cancelled = true;
        el._leaveCb();
    }
    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data)) {
        return;
    }
    /* istanbul ignore if */
    if (isDef(el._enterCb) || el.nodeType !== 1) {
        return;
    }
    var css = data.css, type = data.type, enterClass = data.enterClass, enterToClass = data.enterToClass, enterActiveClass = data.enterActiveClass, appearClass = data.appearClass, appearToClass = data.appearToClass, appearActiveClass = data.appearActiveClass, beforeEnter = data.beforeEnter, enter = data.enter, afterEnter = data.afterEnter, enterCancelled = data.enterCancelled, beforeAppear = data.beforeAppear, appear = data.appear, afterAppear = data.afterAppear, appearCancelled = data.appearCancelled, duration = data.duration;
    // activeInstance will always be the <transition> component managing this
    // transition. One edge case to check is when the <transition> is placed
    // as the root node of a child component. In that case we need to check
    // <transition>'s parent for appear check.
    var context = activeInstance;
    var transitionNode = activeInstance.$vnode;
    while (transitionNode && transitionNode.parent) {
        context = transitionNode.context;
        transitionNode = transitionNode.parent;
    }
    var isAppear = !context._isMounted || !vnode.isRootInsert;
    if (isAppear && !appear && appear !== '') {
        return;
    }
    var startClass = isAppear && appearClass ? appearClass : enterClass;
    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
    var enterHook = isAppear ? (isFunction(appear) ? appear : enter) : enter;
    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
    var enterCancelledHook = isAppear
        ? appearCancelled || enterCancelled
        : enterCancelled;
    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
    if ( true && explicitEnterDuration != null) {
        checkDuration(explicitEnterDuration, 'enter', vnode);
    }
    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(enterHook);
    var cb = (el._enterCb = once(function () {
        if (expectsCSS) {
            removeTransitionClass(el, toClass);
            removeTransitionClass(el, activeClass);
        }
        // @ts-expect-error
        if (cb.cancelled) {
            if (expectsCSS) {
                removeTransitionClass(el, startClass);
            }
            enterCancelledHook && enterCancelledHook(el);
        }
        else {
            afterEnterHook && afterEnterHook(el);
        }
        el._enterCb = null;
    }));
    if (!vnode.data.show) {
        // remove pending leave element on enter by injecting an insert hook
        mergeVNodeHook(vnode, 'insert', function () {
            var parent = el.parentNode;
            var pendingNode = parent && parent._pending && parent._pending[vnode.key];
            if (pendingNode &&
                pendingNode.tag === vnode.tag &&
                pendingNode.elm._leaveCb) {
                pendingNode.elm._leaveCb();
            }
            enterHook && enterHook(el, cb);
        });
    }
    // start enter transition
    beforeEnterHook && beforeEnterHook(el);
    if (expectsCSS) {
        addTransitionClass(el, startClass);
        addTransitionClass(el, activeClass);
        nextFrame(function () {
            removeTransitionClass(el, startClass);
            // @ts-expect-error
            if (!cb.cancelled) {
                addTransitionClass(el, toClass);
                if (!userWantsControl) {
                    if (isValidDuration(explicitEnterDuration)) {
                        setTimeout(cb, explicitEnterDuration);
                    }
                    else {
                        whenTransitionEnds(el, type, cb);
                    }
                }
            }
        });
    }
    if (vnode.data.show) {
        toggleDisplay && toggleDisplay();
        enterHook && enterHook(el, cb);
    }
    if (!expectsCSS && !userWantsControl) {
        cb();
    }
}
function leave(vnode, rm) {
    var el = vnode.elm;
    // call enter callback now
    if (isDef(el._enterCb)) {
        el._enterCb.cancelled = true;
        el._enterCb();
    }
    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data) || el.nodeType !== 1) {
        return rm();
    }
    /* istanbul ignore if */
    if (isDef(el._leaveCb)) {
        return;
    }
    var css = data.css, type = data.type, leaveClass = data.leaveClass, leaveToClass = data.leaveToClass, leaveActiveClass = data.leaveActiveClass, beforeLeave = data.beforeLeave, leave = data.leave, afterLeave = data.afterLeave, leaveCancelled = data.leaveCancelled, delayLeave = data.delayLeave, duration = data.duration;
    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(leave);
    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
    if ( true && isDef(explicitLeaveDuration)) {
        checkDuration(explicitLeaveDuration, 'leave', vnode);
    }
    var cb = (el._leaveCb = once(function () {
        if (el.parentNode && el.parentNode._pending) {
            el.parentNode._pending[vnode.key] = null;
        }
        if (expectsCSS) {
            removeTransitionClass(el, leaveToClass);
            removeTransitionClass(el, leaveActiveClass);
        }
        // @ts-expect-error
        if (cb.cancelled) {
            if (expectsCSS) {
                removeTransitionClass(el, leaveClass);
            }
            leaveCancelled && leaveCancelled(el);
        }
        else {
            rm();
            afterLeave && afterLeave(el);
        }
        el._leaveCb = null;
    }));
    if (delayLeave) {
        delayLeave(performLeave);
    }
    else {
        performLeave();
    }
    function performLeave() {
        // the delayed leave may have already been cancelled
        // @ts-expect-error
        if (cb.cancelled) {
            return;
        }
        // record leaving element
        if (!vnode.data.show && el.parentNode) {
            (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] =
                vnode;
        }
        beforeLeave && beforeLeave(el);
        if (expectsCSS) {
            addTransitionClass(el, leaveClass);
            addTransitionClass(el, leaveActiveClass);
            nextFrame(function () {
                removeTransitionClass(el, leaveClass);
                // @ts-expect-error
                if (!cb.cancelled) {
                    addTransitionClass(el, leaveToClass);
                    if (!userWantsControl) {
                        if (isValidDuration(explicitLeaveDuration)) {
                            setTimeout(cb, explicitLeaveDuration);
                        }
                        else {
                            whenTransitionEnds(el, type, cb);
                        }
                    }
                }
            });
        }
        leave && leave(el, cb);
        if (!expectsCSS && !userWantsControl) {
            cb();
        }
    }
}
// only used in dev mode
function checkDuration(val, name, vnode) {
    if (typeof val !== 'number') {
        warn("<transition> explicit ".concat(name, " duration is not a valid number - ") +
            "got ".concat(JSON.stringify(val), "."), vnode.context);
    }
    else if (isNaN(val)) {
        warn("<transition> explicit ".concat(name, " duration is NaN - ") +
            'the duration expression might be incorrect.', vnode.context);
    }
}
function isValidDuration(val) {
    return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
    if (isUndef(fn)) {
        return false;
    }
    // @ts-expect-error
    var invokerFns = fn.fns;
    if (isDef(invokerFns)) {
        // invoker
        return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
    }
    else {
        // @ts-expect-error
        return (fn._length || fn.length) > 1;
    }
}
function _enter(_, vnode) {
    if (vnode.data.show !== true) {
        enter(vnode);
    }
}
var transition = inBrowser
    ? {
        create: _enter,
        activate: _enter,
        remove: function (vnode, rm) {
            /* istanbul ignore else */
            if (vnode.data.show !== true) {
                // @ts-expect-error
                leave(vnode, rm);
            }
            else {
                rm();
            }
        }
    }
    : {};

var platformModules = [attrs, klass, events, domProps, style, transition];

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */
/* istanbul ignore if */
if (isIE9) {
    // http://www.matts411.com/post/internet-explorer-9-oninput/
    document.addEventListener('selectionchange', function () {
        var el = document.activeElement;
        // @ts-expect-error
        if (el && el.vmodel) {
            trigger(el, 'input');
        }
    });
}
var directive = {
    inserted: function (el, binding, vnode, oldVnode) {
        if (vnode.tag === 'select') {
            // #6903
            if (oldVnode.elm && !oldVnode.elm._vOptions) {
                mergeVNodeHook(vnode, 'postpatch', function () {
                    directive.componentUpdated(el, binding, vnode);
                });
            }
            else {
                setSelected(el, binding, vnode.context);
            }
            el._vOptions = [].map.call(el.options, getValue);
        }
        else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
            el._vModifiers = binding.modifiers;
            if (!binding.modifiers.lazy) {
                el.addEventListener('compositionstart', onCompositionStart);
                el.addEventListener('compositionend', onCompositionEnd);
                // Safari < 10.2 & UIWebView doesn't fire compositionend when
                // switching focus before confirming composition choice
                // this also fixes the issue where some browsers e.g. iOS Chrome
                // fires "change" instead of "input" on autocomplete.
                el.addEventListener('change', onCompositionEnd);
                /* istanbul ignore if */
                if (isIE9) {
                    el.vmodel = true;
                }
            }
        }
    },
    componentUpdated: function (el, binding, vnode) {
        if (vnode.tag === 'select') {
            setSelected(el, binding, vnode.context);
            // in case the options rendered by v-for have changed,
            // it's possible that the value is out-of-sync with the rendered options.
            // detect such cases and filter out values that no longer has a matching
            // option in the DOM.
            var prevOptions_1 = el._vOptions;
            var curOptions_1 = (el._vOptions = [].map.call(el.options, getValue));
            if (curOptions_1.some(function (o, i) { return !looseEqual(o, prevOptions_1[i]); })) {
                // trigger change event if
                // no matching option found for at least one value
                var needReset = el.multiple
                    ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions_1); })
                    : binding.value !== binding.oldValue &&
                        hasNoMatchingOption(binding.value, curOptions_1);
                if (needReset) {
                    trigger(el, 'change');
                }
            }
        }
    }
};
function setSelected(el, binding, vm) {
    actuallySetSelected(el, binding, vm);
    /* istanbul ignore if */
    if (isIE || isEdge) {
        setTimeout(function () {
            actuallySetSelected(el, binding, vm);
        }, 0);
    }
}
function actuallySetSelected(el, binding, vm) {
    var value = binding.value;
    var isMultiple = el.multiple;
    if (isMultiple && !Array.isArray(value)) {
         true &&
            warn("<select multiple v-model=\"".concat(binding.expression, "\"> ") +
                "expects an Array value for its binding, but got ".concat(Object.prototype.toString
                    .call(value)
                    .slice(8, -1)), vm);
        return;
    }
    var selected, option;
    for (var i = 0, l = el.options.length; i < l; i++) {
        option = el.options[i];
        if (isMultiple) {
            selected = looseIndexOf(value, getValue(option)) > -1;
            if (option.selected !== selected) {
                option.selected = selected;
            }
        }
        else {
            if (looseEqual(getValue(option), value)) {
                if (el.selectedIndex !== i) {
                    el.selectedIndex = i;
                }
                return;
            }
        }
    }
    if (!isMultiple) {
        el.selectedIndex = -1;
    }
}
function hasNoMatchingOption(value, options) {
    return options.every(function (o) { return !looseEqual(o, value); });
}
function getValue(option) {
    return '_value' in option ? option._value : option.value;
}
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    // prevent triggering an input event for no reason
    if (!e.target.composing)
        return;
    e.target.composing = false;
    trigger(e.target, 'input');
}
function trigger(el, type) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
}

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
    // @ts-expect-error
    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
        ? locateNode(vnode.componentInstance._vnode)
        : vnode;
}
var show = {
    bind: function (el, _a, vnode) {
        var value = _a.value;
        vnode = locateNode(vnode);
        var transition = vnode.data && vnode.data.transition;
        var originalDisplay = (el.__vOriginalDisplay =
            el.style.display === 'none' ? '' : el.style.display);
        if (value && transition) {
            vnode.data.show = true;
            enter(vnode, function () {
                el.style.display = originalDisplay;
            });
        }
        else {
            el.style.display = value ? originalDisplay : 'none';
        }
    },
    update: function (el, _a, vnode) {
        var value = _a.value, oldValue = _a.oldValue;
        /* istanbul ignore if */
        if (!value === !oldValue)
            return;
        vnode = locateNode(vnode);
        var transition = vnode.data && vnode.data.transition;
        if (transition) {
            vnode.data.show = true;
            if (value) {
                enter(vnode, function () {
                    el.style.display = el.__vOriginalDisplay;
                });
            }
            else {
                leave(vnode, function () {
                    el.style.display = 'none';
                });
            }
        }
        else {
            el.style.display = value ? el.__vOriginalDisplay : 'none';
        }
    },
    unbind: function (el, binding, vnode, oldVnode, isDestroy) {
        if (!isDestroy) {
            el.style.display = el.__vOriginalDisplay;
        }
    }
};

var platformDirectives = {
    model: directive,
    show: show
};

// Provides transition support for a single element/component.
var transitionProps = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
};
// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
    var compOptions = vnode && vnode.componentOptions;
    if (compOptions && compOptions.Ctor.options.abstract) {
        return getRealChild(getFirstComponentChild(compOptions.children));
    }
    else {
        return vnode;
    }
}
function extractTransitionData(comp) {
    var data = {};
    var options = comp.$options;
    // props
    for (var key in options.propsData) {
        data[key] = comp[key];
    }
    // events.
    // extract listeners and pass them directly to the transition methods
    var listeners = options._parentListeners;
    for (var key in listeners) {
        data[camelize(key)] = listeners[key];
    }
    return data;
}
function placeholder(h, rawChild) {
    // @ts-expect-error
    if (/\d-keep-alive$/.test(rawChild.tag)) {
        return h('keep-alive', {
            props: rawChild.componentOptions.propsData
        });
    }
}
function hasParentTransition(vnode) {
    while ((vnode = vnode.parent)) {
        if (vnode.data.transition) {
            return true;
        }
    }
}
function isSameChild(child, oldChild) {
    return oldChild.key === child.key && oldChild.tag === child.tag;
}
var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };
var isVShowDirective = function (d) { return d.name === 'show'; };
var Transition = {
    name: 'transition',
    props: transitionProps,
    abstract: true,
    render: function (h) {
        var _this = this;
        var children = this.$slots.default;
        if (!children) {
            return;
        }
        // filter out text nodes (possible whitespaces)
        children = children.filter(isNotTextNode);
        /* istanbul ignore if */
        if (!children.length) {
            return;
        }
        // warn multiple elements
        if ( true && children.length > 1) {
            warn('<transition> can only be used on a single element. Use ' +
                '<transition-group> for lists.', this.$parent);
        }
        var mode = this.mode;
        // warn invalid mode
        if ( true && mode && mode !== 'in-out' && mode !== 'out-in') {
            warn('invalid <transition> mode: ' + mode, this.$parent);
        }
        var rawChild = children[0];
        // if this is a component root node and the component's
        // parent container node also has transition, skip.
        if (hasParentTransition(this.$vnode)) {
            return rawChild;
        }
        // apply transition data to child
        // use getRealChild() to ignore abstract components e.g. keep-alive
        var child = getRealChild(rawChild);
        /* istanbul ignore if */
        if (!child) {
            return rawChild;
        }
        if (this._leaving) {
            return placeholder(h, rawChild);
        }
        // ensure a key that is unique to the vnode type and to this transition
        // component instance. This key will be used to remove pending leaving nodes
        // during entering.
        var id = "__transition-".concat(this._uid, "-");
        child.key =
            child.key == null
                ? child.isComment
                    ? id + 'comment'
                    : id + child.tag
                : isPrimitive(child.key)
                    ? String(child.key).indexOf(id) === 0
                        ? child.key
                        : id + child.key
                    : child.key;
        var data = ((child.data || (child.data = {})).transition =
            extractTransitionData(this));
        var oldRawChild = this._vnode;
        var oldChild = getRealChild(oldRawChild);
        // mark v-show
        // so that the transition module can hand over the control to the directive
        if (child.data.directives && child.data.directives.some(isVShowDirective)) {
            child.data.show = true;
        }
        if (oldChild &&
            oldChild.data &&
            !isSameChild(child, oldChild) &&
            !isAsyncPlaceholder(oldChild) &&
            // #6687 component root is a comment node
            !(oldChild.componentInstance &&
                oldChild.componentInstance._vnode.isComment)) {
            // replace old child transition data with fresh one
            // important for dynamic transitions!
            var oldData = (oldChild.data.transition = extend({}, data));
            // handle transition mode
            if (mode === 'out-in') {
                // return placeholder node and queue update when leave finishes
                this._leaving = true;
                mergeVNodeHook(oldData, 'afterLeave', function () {
                    _this._leaving = false;
                    _this.$forceUpdate();
                });
                return placeholder(h, rawChild);
            }
            else if (mode === 'in-out') {
                if (isAsyncPlaceholder(child)) {
                    return oldRawChild;
                }
                var delayedLeave_1;
                var performLeave = function () {
                    delayedLeave_1();
                };
                mergeVNodeHook(data, 'afterEnter', performLeave);
                mergeVNodeHook(data, 'enterCancelled', performLeave);
                mergeVNodeHook(oldData, 'delayLeave', function (leave) {
                    delayedLeave_1 = leave;
                });
            }
        }
        return rawChild;
    }
};

// Provides transition support for list items.
var props = extend({
    tag: String,
    moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
    props: props,
    beforeMount: function () {
        var _this = this;
        var update = this._update;
        this._update = function (vnode, hydrating) {
            var restoreActiveInstance = setActiveInstance(_this);
            // force removing pass
            _this.__patch__(_this._vnode, _this.kept, false, // hydrating
            true // removeOnly (!important, avoids unnecessary moves)
            );
            _this._vnode = _this.kept;
            restoreActiveInstance();
            update.call(_this, vnode, hydrating);
        };
    },
    render: function (h) {
        var tag = this.tag || this.$vnode.data.tag || 'span';
        var map = Object.create(null);
        var prevChildren = (this.prevChildren = this.children);
        var rawChildren = this.$slots.default || [];
        var children = (this.children = []);
        var transitionData = extractTransitionData(this);
        for (var i = 0; i < rawChildren.length; i++) {
            var c = rawChildren[i];
            if (c.tag) {
                if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
                    children.push(c);
                    map[c.key] = c;
                    (c.data || (c.data = {})).transition = transitionData;
                }
                else if (true) {
                    var opts = c.componentOptions;
                    var name_1 = opts
                        ? getComponentName(opts.Ctor.options) || opts.tag || ''
                        : c.tag;
                    warn("<transition-group> children must be keyed: <".concat(name_1, ">"));
                }
            }
        }
        if (prevChildren) {
            var kept = [];
            var removed = [];
            for (var i = 0; i < prevChildren.length; i++) {
                var c = prevChildren[i];
                c.data.transition = transitionData;
                // @ts-expect-error .getBoundingClientRect is not typed in Node
                c.data.pos = c.elm.getBoundingClientRect();
                if (map[c.key]) {
                    kept.push(c);
                }
                else {
                    removed.push(c);
                }
            }
            this.kept = h(tag, null, kept);
            this.removed = removed;
        }
        return h(tag, null, children);
    },
    updated: function () {
        var children = this.prevChildren;
        var moveClass = this.moveClass || (this.name || 'v') + '-move';
        if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
            return;
        }
        // we divide the work into three loops to avoid mixing DOM reads and writes
        // in each iteration - which helps prevent layout thrashing.
        children.forEach(callPendingCbs);
        children.forEach(recordPosition);
        children.forEach(applyTranslation);
        // force reflow to put everything in position
        // assign to this to avoid being removed in tree-shaking
        // $flow-disable-line
        this._reflow = document.body.offsetHeight;
        children.forEach(function (c) {
            if (c.data.moved) {
                var el_1 = c.elm;
                var s = el_1.style;
                addTransitionClass(el_1, moveClass);
                s.transform = s.WebkitTransform = s.transitionDuration = '';
                el_1.addEventListener(transitionEndEvent, (el_1._moveCb = function cb(e) {
                    if (e && e.target !== el_1) {
                        return;
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                        el_1.removeEventListener(transitionEndEvent, cb);
                        el_1._moveCb = null;
                        removeTransitionClass(el_1, moveClass);
                    }
                }));
            }
        });
    },
    methods: {
        hasMove: function (el, moveClass) {
            /* istanbul ignore if */
            if (!hasTransition) {
                return false;
            }
            /* istanbul ignore if */
            if (this._hasMove) {
                return this._hasMove;
            }
            // Detect whether an element with the move class applied has
            // CSS transitions. Since the element may be inside an entering
            // transition at this very moment, we make a clone of it and remove
            // all other transition classes applied to ensure only the move class
            // is applied.
            var clone = el.cloneNode();
            if (el._transitionClasses) {
                el._transitionClasses.forEach(function (cls) {
                    removeClass(clone, cls);
                });
            }
            addClass(clone, moveClass);
            clone.style.display = 'none';
            this.$el.appendChild(clone);
            var info = getTransitionInfo(clone);
            this.$el.removeChild(clone);
            return (this._hasMove = info.hasTransform);
        }
    }
};
function callPendingCbs(c) {
    /* istanbul ignore if */
    if (c.elm._moveCb) {
        c.elm._moveCb();
    }
    /* istanbul ignore if */
    if (c.elm._enterCb) {
        c.elm._enterCb();
    }
}
function recordPosition(c) {
    c.data.newPos = c.elm.getBoundingClientRect();
}
function applyTranslation(c) {
    var oldPos = c.data.pos;
    var newPos = c.data.newPos;
    var dx = oldPos.left - newPos.left;
    var dy = oldPos.top - newPos.top;
    if (dx || dy) {
        c.data.moved = true;
        var s = c.elm.style;
        s.transform = s.WebkitTransform = "translate(".concat(dx, "px,").concat(dy, "px)");
        s.transitionDuration = '0s';
    }
}

var platformComponents = {
    Transition: Transition,
    TransitionGroup: TransitionGroup
};

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;
// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);
// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;
// public mount method
Vue.prototype.$mount = function (el, hydrating) {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating);
};
// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
    setTimeout(function () {
        if (config.devtools) {
            if (devtools) {
                devtools.emit('init', Vue);
            }
            else if (true) {
                // @ts-expect-error
                console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' +
                    'https://github.com/vuejs/vue-devtools');
            }
        }
        if ( true &&
            config.productionTip !== false &&
            typeof console !== 'undefined') {
            // @ts-expect-error
            console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" +
                "Make sure to turn on production mode when deploying for production.\n" +
                "See more tips at https://vuejs.org/guide/deployment.html");
        }
    }, 0);
}




/***/ }),

/***/ "./node_modules/vuex/dist/vuex.esm.js":
/*!********************************************!*\
  !*** ./node_modules/vuex/dist/vuex.esm.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Store: () => (/* binding */ Store),
/* harmony export */   createLogger: () => (/* binding */ createLogger),
/* harmony export */   createNamespacedHelpers: () => (/* binding */ createNamespacedHelpers),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   install: () => (/* binding */ install),
/* harmony export */   mapActions: () => (/* binding */ mapActions),
/* harmony export */   mapGetters: () => (/* binding */ mapGetters),
/* harmony export */   mapMutations: () => (/* binding */ mapMutations),
/* harmony export */   mapState: () => (/* binding */ mapState)
/* harmony export */ });
/*!
 * vuex v3.6.2
 * (c) 2021 Evan You
 * @license MIT
 */
function applyMixin (Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    Vue.mixin({ beforeCreate: vuexInit });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;
    Vue.prototype._init = function (options) {
      if ( options === void 0 ) options = {};

      options.init = options.init
        ? [vuexInit].concat(options.init)
        : vuexInit;
      _init.call(this, options);
    };
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

  function vuexInit () {
    var options = this.$options;
    // store injection
    if (options.store) {
      this.$store = typeof options.store === 'function'
        ? options.store()
        : options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
}

var target = typeof window !== 'undefined'
  ? window
  : typeof __webpack_require__.g !== 'undefined'
    ? __webpack_require__.g
    : {};
var devtoolHook = target.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin (store) {
  if (!devtoolHook) { return }

  store._devtoolHook = devtoolHook;

  devtoolHook.emit('vuex:init', store);

  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });

  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  }, { prepend: true });

  store.subscribeAction(function (action, state) {
    devtoolHook.emit('vuex:action', action, state);
  }, { prepend: true });
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
function find (list, f) {
  return list.filter(f)[0]
}

/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */
function deepCopy (obj, cache) {
  if ( cache === void 0 ) cache = [];

  // just return if obj is immutable value
  if (obj === null || typeof obj !== 'object') {
    return obj
  }

  // if obj is hit, it is in circular structure
  var hit = find(cache, function (c) { return c.original === obj; });
  if (hit) {
    return hit.copy
  }

  var copy = Array.isArray(obj) ? [] : {};
  // put the copy into cache at first
  // because we want to refer it in recursive deepCopy
  cache.push({
    original: obj,
    copy: copy
  });

  Object.keys(obj).forEach(function (key) {
    copy[key] = deepCopy(obj[key], cache);
  });

  return copy
}

/**
 * forEach for object
 */
function forEachValue (obj, fn) {
  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });
}

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isPromise (val) {
  return val && typeof val.then === 'function'
}

function assert (condition, msg) {
  if (!condition) { throw new Error(("[vuex] " + msg)) }
}

function partial (fn, arg) {
  return function () {
    return fn(arg)
  }
}

// Base data struct for store's module, package with some attribute and method
var Module = function Module (rawModule, runtime) {
  this.runtime = runtime;
  // Store some children item
  this._children = Object.create(null);
  // Store the origin module object which passed by programmer
  this._rawModule = rawModule;
  var rawState = rawModule.state;

  // Store the origin module's state
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors = { namespaced: { configurable: true } };

prototypeAccessors.namespaced.get = function () {
  return !!this._rawModule.namespaced
};

Module.prototype.addChild = function addChild (key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild (key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild (key) {
  return this._children[key]
};

Module.prototype.hasChild = function hasChild (key) {
  return key in this._children
};

Module.prototype.update = function update (rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild (fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter (fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction (fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation (fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties( Module.prototype, prototypeAccessors );

var ModuleCollection = function ModuleCollection (rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get (path) {
  return path.reduce(function (module, key) {
    return module.getChild(key)
  }, this.root)
};

ModuleCollection.prototype.getNamespace = function getNamespace (path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '')
  }, '')
};

ModuleCollection.prototype.update = function update$1 (rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register (path, rawModule, runtime) {
    var this$1 = this;
    if ( runtime === void 0 ) runtime = true;

  if ((true)) {
    assertRawModule(path, rawModule);
  }

  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  var child = parent.getChild(key);

  if (!child) {
    if ((true)) {
      console.warn(
        "[vuex] trying to unregister module '" + key + "', which is " +
        "not registered"
      );
    }
    return
  }

  if (!child.runtime) {
    return
  }

  parent.removeChild(key);
};

ModuleCollection.prototype.isRegistered = function isRegistered (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];

  if (parent) {
    return parent.hasChild(key)
  }

  return false
};

function update (path, targetModule, newModule) {
  if ((true)) {
    assertRawModule(path, newModule);
  }

  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if ((true)) {
          console.warn(
            "[vuex] trying to add a new module '" + key + "' on hot reloading, " +
            'manual reload is needed'
          );
        }
        return
      }
      update(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      );
    }
  }
}

var functionAssert = {
  assert: function (value) { return typeof value === 'function'; },
  expected: 'function'
};

var objectAssert = {
  assert: function (value) { return typeof value === 'function' ||
    (typeof value === 'object' && typeof value.handler === 'function'); },
  expected: 'function or object with "handler" function'
};

var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};

function assertRawModule (path, rawModule) {
  Object.keys(assertTypes).forEach(function (key) {
    if (!rawModule[key]) { return }

    var assertOptions = assertTypes[key];

    forEachValue(rawModule[key], function (value, type) {
      assert(
        assertOptions.assert(value),
        makeAssertionMessage(path, key, type, value, assertOptions.expected)
      );
    });
  });
}

function makeAssertionMessage (path, key, type, value, expected) {
  var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";
  if (path.length > 0) {
    buf += " in module \"" + (path.join('.')) + "\"";
  }
  buf += " is " + (JSON.stringify(value)) + ".";
  return buf
}

var Vue; // bind on install

var Store = function Store (options) {
  var this$1 = this;
  if ( options === void 0 ) options = {};

  // Auto install if it is not done yet and `window` has `Vue`.
  // To allow users to avoid auto-installation in some cases,
  // this code should be placed here. See #731
  if (!Vue && typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }

  if ((true)) {
    assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
    assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store, "store must be called with the new operator.");
  }

  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];
  var strict = options.strict; if ( strict === void 0 ) strict = false;

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue();
  this._makeLocalGettersCache = Object.create(null);

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch (type, payload) {
    return dispatch.call(store, type, payload)
  };
  this.commit = function boundCommit (type, payload, options) {
    return commit.call(store, type, payload, options)
  };

  // strict mode
  this.strict = strict;

  var state = this._modules.root.state;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreVM(this, state);

  // apply plugins
  plugins.forEach(function (plugin) { return plugin(this$1); });

  var useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools;
  if (useDevtools) {
    devtoolPlugin(this);
  }
};

var prototypeAccessors$1 = { state: { configurable: true } };

prototypeAccessors$1.state.get = function () {
  return this._vm._data.$$state
};

prototypeAccessors$1.state.set = function (v) {
  if ((true)) {
    assert(false, "use store.replaceState() to explicit replace store state.");
  }
};

Store.prototype.commit = function commit (_type, _payload, _options) {
    var this$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
    var type = ref.type;
    var payload = ref.payload;
    var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    if ((true)) {
      console.error(("[vuex] unknown mutation type: " + type));
    }
    return
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator (handler) {
      handler(payload);
    });
  });

  this._subscribers
    .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
    .forEach(function (sub) { return sub(mutation, this$1.state); });

  if (
    ( true) &&
    options && options.silent
  ) {
    console.warn(
      "[vuex] mutation type: " + type + ". Silent option has been removed. " +
      'Use the filter functionality in the vue-devtools'
    );
  }
};

Store.prototype.dispatch = function dispatch (_type, _payload) {
    var this$1 = this;

  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
    var type = ref.type;
    var payload = ref.payload;

  var action = { type: type, payload: payload };
  var entry = this._actions[type];
  if (!entry) {
    if ((true)) {
      console.error(("[vuex] unknown action type: " + type));
    }
    return
  }

  try {
    this._actionSubscribers
      .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
      .filter(function (sub) { return sub.before; })
      .forEach(function (sub) { return sub.before(action, this$1.state); });
  } catch (e) {
    if ((true)) {
      console.warn("[vuex] error in before action subscribers: ");
      console.error(e);
    }
  }

  var result = entry.length > 1
    ? Promise.all(entry.map(function (handler) { return handler(payload); }))
    : entry[0](payload);

  return new Promise(function (resolve, reject) {
    result.then(function (res) {
      try {
        this$1._actionSubscribers
          .filter(function (sub) { return sub.after; })
          .forEach(function (sub) { return sub.after(action, this$1.state); });
      } catch (e) {
        if ((true)) {
          console.warn("[vuex] error in after action subscribers: ");
          console.error(e);
        }
      }
      resolve(res);
    }, function (error) {
      try {
        this$1._actionSubscribers
          .filter(function (sub) { return sub.error; })
          .forEach(function (sub) { return sub.error(action, this$1.state, error); });
      } catch (e) {
        if ((true)) {
          console.warn("[vuex] error in error action subscribers: ");
          console.error(e);
        }
      }
      reject(error);
    });
  })
};

Store.prototype.subscribe = function subscribe (fn, options) {
  return genericSubscribe(fn, this._subscribers, options)
};

Store.prototype.subscribeAction = function subscribeAction (fn, options) {
  var subs = typeof fn === 'function' ? { before: fn } : fn;
  return genericSubscribe(subs, this._actionSubscribers, options)
};

Store.prototype.watch = function watch (getter, cb, options) {
    var this$1 = this;

  if ((true)) {
    assert(typeof getter === 'function', "store.watch only accepts a function.");
  }
  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)
};

Store.prototype.replaceState = function replaceState (state) {
    var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule (path, rawModule, options) {
    if ( options === void 0 ) options = {};

  if (typeof path === 'string') { path = [path]; }

  if ((true)) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, 'cannot register the root module by using registerModule.');
  }

  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  // reset store to update getters...
  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule (path) {
    var this$1 = this;

  if (typeof path === 'string') { path = [path]; }

  if ((true)) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });
  resetStore(this);
};

Store.prototype.hasModule = function hasModule (path) {
  if (typeof path === 'string') { path = [path]; }

  if ((true)) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  return this._modules.isRegistered(path)
};

Store.prototype.hotUpdate = function hotUpdate (newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit (fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties( Store.prototype, prototypeAccessors$1 );

function genericSubscribe (fn, subs, options) {
  if (subs.indexOf(fn) < 0) {
    options && options.prepend
      ? subs.unshift(fn)
      : subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  }
}

function resetStore (store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset vm
  resetStoreVM(store, state, hot);
}

function resetStoreVM (store, state, hot) {
  var oldVm = store._vm;

  // bind store public getters
  store.getters = {};
  // reset local getters cache
  store._makeLocalGettersCache = Object.create(null);
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    // direct inline function use will lead to closure preserving oldVm.
    // using partial to return function with only arguments preserved in closure environment.
    computed[key] = partial(fn, store);
    Object.defineProperty(store.getters, key, {
      get: function () { return store._vm[key]; },
      enumerable: true // for local getters
    });
  });

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent;

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }
    Vue.nextTick(function () { return oldVm.$destroy(); });
  }
}

function installModule (store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    if (store._modulesNamespaceMap[namespace] && ("development" !== 'production')) {
      console.error(("[vuex] duplicate namespace " + namespace + " for the namespaced module " + (path.join('/'))));
    }
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      if ((true)) {
        if (moduleName in parentState) {
          console.warn(
            ("[vuex] state field \"" + moduleName + "\" was overridden by a module with the same name at \"" + (path.join('.')) + "\"")
          );
        }
      }
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext (store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (( true) && !store._actions[type]) {
          console.error(("[vuex] unknown local action type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      return store.dispatch(type, payload)
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (( true) && !store._mutations[type]) {
          console.error(("[vuex] unknown local mutation type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? function () { return store.getters; }
        : function () { return makeLocalGetters(store, namespace); }
    },
    state: {
      get: function () { return getNestedState(store.state, path); }
    }
  });

  return local
}

function makeLocalGetters (store, namespace) {
  if (!store._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store.getters).forEach(function (type) {
      // skip if the target getter is not match this namespace
      if (type.slice(0, splitPos) !== namespace) { return }

      // extract local getter type
      var localType = type.slice(splitPos);

      // Add a port to the getters proxy.
      // Define as getter property because
      // we do not want to evaluate the getters in this time.
      Object.defineProperty(gettersProxy, localType, {
        get: function () { return store.getters[type]; },
        enumerable: true
      });
    });
    store._makeLocalGettersCache[namespace] = gettersProxy;
  }

  return store._makeLocalGettersCache[namespace]
}

function registerMutation (store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler (payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction (store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler (payload) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err
      })
    } else {
      return res
    }
  });
}

function registerGetter (store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if ((true)) {
      console.error(("[vuex] duplicate getter key: " + type));
    }
    return
  }
  store._wrappedGetters[type] = function wrappedGetter (store) {
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )
  };
}

function enableStrictMode (store) {
  store._vm.$watch(function () { return this._data.$$state }, function () {
    if ((true)) {
      assert(store._committing, "do not mutate vuex store state outside mutation handlers.");
    }
  }, { deep: true, sync: true });
}

function getNestedState (state, path) {
  return path.reduce(function (state, key) { return state[key]; }, state)
}

function unifyObjectStyle (type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if ((true)) {
    assert(typeof type === 'string', ("expects string as the type, but found " + (typeof type) + "."));
  }

  return { type: type, payload: payload, options: options }
}

function install (_Vue) {
  if (Vue && _Vue === Vue) {
    if ((true)) {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      );
    }
    return
  }
  Vue = _Vue;
  applyMixin(Vue);
}

/**
 * Reduce the code which written in Vue.js for getting the state.
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
 * @param {Object}
 */
var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  if (( true) && !isValidMap(states)) {
    console.error('[vuex] mapState: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState () {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for committing the mutation
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept another params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  if (( true) && !isValidMap(mutations)) {
    console.error('[vuex] mapMutations: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // Get the commit method from store
      var commit = this.$store.commit;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);
        if (!module) {
          return
        }
        commit = module.context.commit;
      }
      return typeof val === 'function'
        ? val.apply(this, [commit].concat(args))
        : commit.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for getting the getters
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} getters
 * @return {Object}
 */
var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  if (( true) && !isValidMap(getters)) {
    console.error('[vuex] mapGetters: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    // The namespace has been mutated by normalizeNamespace
    val = namespace + val;
    res[key] = function mappedGetter () {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      if (( true) && !(val in this.$store.getters)) {
        console.error(("[vuex] unknown getter: " + val));
        return
      }
      return this.$store.getters[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for dispatch the action
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  if (( true) && !isValidMap(actions)) {
    console.error('[vuex] mapActions: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // get dispatch function from store
      var dispatch = this.$store.dispatch;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);
        if (!module) {
          return
        }
        dispatch = module.context.dispatch;
      }
      return typeof val === 'function'
        ? val.apply(this, [dispatch].concat(args))
        : dispatch.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object
 * @param {String} namespace
 * @return {Object}
 */
var createNamespacedHelpers = function (namespace) { return ({
  mapState: mapState.bind(null, namespace),
  mapGetters: mapGetters.bind(null, namespace),
  mapMutations: mapMutations.bind(null, namespace),
  mapActions: mapActions.bind(null, namespace)
}); };

/**
 * Normalize the map
 * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
 * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
 * @param {Array|Object} map
 * @return {Object}
 */
function normalizeMap (map) {
  if (!isValidMap(map)) {
    return []
  }
  return Array.isArray(map)
    ? map.map(function (key) { return ({ key: key, val: key }); })
    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })
}

/**
 * Validate whether given map is valid or not
 * @param {*} map
 * @return {Boolean}
 */
function isValidMap (map) {
  return Array.isArray(map) || isObject(map)
}

/**
 * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
 * @param {Function} fn
 * @return {Function}
 */
function normalizeNamespace (fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map)
  }
}

/**
 * Search a special module from store by namespace. if module not exist, print error message.
 * @param {Object} store
 * @param {String} helper
 * @param {String} namespace
 * @return {Object}
 */
function getModuleByNamespace (store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if (( true) && !module) {
    console.error(("[vuex] module namespace not found in " + helper + "(): " + namespace));
  }
  return module
}

// Credits: borrowed code from fcomb/redux-logger

function createLogger (ref) {
  if ( ref === void 0 ) ref = {};
  var collapsed = ref.collapsed; if ( collapsed === void 0 ) collapsed = true;
  var filter = ref.filter; if ( filter === void 0 ) filter = function (mutation, stateBefore, stateAfter) { return true; };
  var transformer = ref.transformer; if ( transformer === void 0 ) transformer = function (state) { return state; };
  var mutationTransformer = ref.mutationTransformer; if ( mutationTransformer === void 0 ) mutationTransformer = function (mut) { return mut; };
  var actionFilter = ref.actionFilter; if ( actionFilter === void 0 ) actionFilter = function (action, state) { return true; };
  var actionTransformer = ref.actionTransformer; if ( actionTransformer === void 0 ) actionTransformer = function (act) { return act; };
  var logMutations = ref.logMutations; if ( logMutations === void 0 ) logMutations = true;
  var logActions = ref.logActions; if ( logActions === void 0 ) logActions = true;
  var logger = ref.logger; if ( logger === void 0 ) logger = console;

  return function (store) {
    var prevState = deepCopy(store.state);

    if (typeof logger === 'undefined') {
      return
    }

    if (logMutations) {
      store.subscribe(function (mutation, state) {
        var nextState = deepCopy(state);

        if (filter(mutation, prevState, nextState)) {
          var formattedTime = getFormattedTime();
          var formattedMutation = mutationTransformer(mutation);
          var message = "mutation " + (mutation.type) + formattedTime;

          startMessage(logger, message, collapsed);
          logger.log('%c prev state', 'color: #9E9E9E; font-weight: bold', transformer(prevState));
          logger.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation);
          logger.log('%c next state', 'color: #4CAF50; font-weight: bold', transformer(nextState));
          endMessage(logger);
        }

        prevState = nextState;
      });
    }

    if (logActions) {
      store.subscribeAction(function (action, state) {
        if (actionFilter(action, state)) {
          var formattedTime = getFormattedTime();
          var formattedAction = actionTransformer(action);
          var message = "action " + (action.type) + formattedTime;

          startMessage(logger, message, collapsed);
          logger.log('%c action', 'color: #03A9F4; font-weight: bold', formattedAction);
          endMessage(logger);
        }
      });
    }
  }
}

function startMessage (logger, message, collapsed) {
  var startMessage = collapsed
    ? logger.groupCollapsed
    : logger.group;

  // render
  try {
    startMessage.call(logger, message);
  } catch (e) {
    logger.log(message);
  }
}

function endMessage (logger) {
  try {
    logger.groupEnd();
  } catch (e) {
    logger.log('—— log end ——');
  }
}

function getFormattedTime () {
  var time = new Date();
  return (" @ " + (pad(time.getHours(), 2)) + ":" + (pad(time.getMinutes(), 2)) + ":" + (pad(time.getSeconds(), 2)) + "." + (pad(time.getMilliseconds(), 3)))
}

function repeat (str, times) {
  return (new Array(times + 1)).join(str)
}

function pad (num, maxLength) {
  return repeat('0', maxLength - num.toString().length) + num
}

var index = {
  Store: Store,
  install: install,
  version: '3.6.2',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers,
  createLogger: createLogger
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);



/***/ }),

/***/ "./src/App.vue":
/*!*********************!*\
  !*** ./src/App.vue ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _App_vue_vue_type_template_id_7ba5bd90__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.vue?vue&type=template&id=7ba5bd90 */ "./src/App.vue?vue&type=template&id=7ba5bd90");
/* harmony import */ var _App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App.vue?vue&type=script&lang=js */ "./src/App.vue?vue&type=script&lang=js");
/* harmony import */ var _App_vue_vue_type_style_index_0_id_7ba5bd90_lang_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./App.vue?vue&type=style&index=0&id=7ba5bd90&lang=scss */ "./src/App.vue?vue&type=style&index=0&id=7ba5bd90&lang=scss");
/* harmony import */ var _App_vue_vue_type_style_index_1_id_7ba5bd90_lang_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./App.vue?vue&type=style&index=1&id=7ba5bd90&lang=css */ "./src/App.vue?vue&type=style&index=1&id=7ba5bd90&lang=css");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;



/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_4__["default"])(
  _App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  _App_vue_vue_type_template_id_7ba5bd90__WEBPACK_IMPORTED_MODULE_0__.render,
  _App_vue_vue_type_template_id_7ba5bd90__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) // removed by dead control flow
{ var api; }
component.options.__file = "src/App.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/App.vue?vue&type=script&lang=js":
/*!*********************************************!*\
  !*** ./src/App.vue?vue&type=script&lang=js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/App.vue?vue&type=script&lang=js");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/App.vue?vue&type=style&index=0&id=7ba5bd90&lang=scss":
/*!******************************************************************!*\
  !*** ./src/App.vue?vue&type=style&index=0&id=7ba5bd90&lang=scss ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_2_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_id_7ba5bd90_lang_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/mini-css-extract-plugin/dist/loader.js!../node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/sass-loader/dist/cjs.js!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=style&index=0&id=7ba5bd90&lang=scss */ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/App.vue?vue&type=style&index=0&id=7ba5bd90&lang=scss");


/***/ }),

/***/ "./src/App.vue?vue&type=style&index=1&id=7ba5bd90&lang=css":
/*!*****************************************************************!*\
  !*** ./src/App.vue?vue&type=style&index=1&id=7ba5bd90&lang=css ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_2_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_1_id_7ba5bd90_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/mini-css-extract-plugin/dist/loader.js!../node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/sass-loader/dist/cjs.js!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=style&index=1&id=7ba5bd90&lang=css */ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/App.vue?vue&type=style&index=1&id=7ba5bd90&lang=css");


/***/ }),

/***/ "./src/App.vue?vue&type=template&id=7ba5bd90":
/*!***************************************************!*\
  !*** ./src/App.vue?vue&type=template&id=7ba5bd90 ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_template_id_7ba5bd90__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   staticRenderFns: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_template_id_7ba5bd90__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_template_id_7ba5bd90__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!../node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=template&id=7ba5bd90 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/App.vue?vue&type=template&id=7ba5bd90");


/***/ }),

/***/ "./src/assets/image/AnimationDemo.PNG":
/*!********************************************!*\
  !*** ./src/assets/image/AnimationDemo.PNG ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/AnimationDemo.PNG";

/***/ }),

/***/ "./src/assets/image/brightland.jpg":
/*!*****************************************!*\
  !*** ./src/assets/image/brightland.jpg ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/brightland.jpg";

/***/ }),

/***/ "./src/assets/scripts/gsap/CSSPlugin.js":
/*!**********************************************!*\
  !*** ./src/assets/scripts/gsap/CSSPlugin.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CSSPlugin: () => (/* binding */ CSSPlugin),
/* harmony export */   _createElement: () => (/* binding */ _createElement),
/* harmony export */   _getBBox: () => (/* binding */ _getBBox),
/* harmony export */   checkPrefix: () => (/* binding */ _checkPropPrefix),
/* harmony export */   "default": () => (/* binding */ CSSPlugin)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gsap-core.js */ "./src/assets/scripts/gsap/gsap-core.js");

/*!
 * CSSPlugin 3.7.0
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */


var _win,
  _doc,
  _docElement,
  _pluginInitted,
  _tempDiv,
  _tempDivStyler,
  _recentSetterPlugin,
  _windowExists = function _windowExists() {
    return typeof window !== "undefined";
  },
  _transformProps = {},
  _RAD2DEG = 180 / Math.PI,
  _DEG2RAD = Math.PI / 180,
  _atan2 = Math.atan2,
  _bigNum = 1e8,
  _capsExp = /([A-Z])/g,
  _horizontalExp = /(?:left|right|width|margin|padding|x)/i,
  _complexExp = /[\s,\(]\S/,
  _propertyAliases = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
  },
  _renderCSSProp = function _renderCSSProp(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
  },
  _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
  },
  _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
    return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
  },
  //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
  _renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
    var value = data.s + data.c * ratio;
    data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
  },
  _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
    return data.set(data.t, data.p, ratio ? data.e : data.b, data);
  },
  _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
  },
  _setterCSSStyle = function _setterCSSStyle(target, property, value) {
    return target.style[property] = value;
  },
  _setterCSSProp = function _setterCSSProp(target, property, value) {
    return target.style.setProperty(property, value);
  },
  _setterTransform = function _setterTransform(target, property, value) {
    return target._gsap[property] = value;
  },
  _setterScale = function _setterScale(target, property, value) {
    return target._gsap.scaleX = target._gsap.scaleY = value;
  },
  _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache.scaleX = cache.scaleY = value;
    cache.renderTransform(ratio, cache);
  },
  _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache[property] = value;
    cache.renderTransform(ratio, cache);
  },
  _transformProp = "transform",
  _transformOriginProp = _transformProp + "Origin",
  _supports3D,
  _createElement = function _createElement(type, ns) {
    var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.
    return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
  },
  _getComputedProperty2 = function _getComputedProperty(target, property, skipPrefixFallback) {
    var cs = getComputedStyle(target);
    return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
  },
  _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
  _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
    var e = element || _tempDiv,
      s = e.style,
      i = 5;
    if (property in s && !preferPrefix) {
      return property;
    }
    property = property.charAt(0).toUpperCase() + property.substr(1);
    while (i-- && !(_prefixes[i] + property in s)) {}
    return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
  },
  _initCore = function _initCore() {
    if (_windowExists() && window.document) {
      _win = window;
      _doc = _win.document;
      _docElement = _doc.documentElement;
      _tempDiv = _createElement("div") || {
        style: {}
      };
      _tempDivStyler = _createElement("div");
      _transformProp = _checkPropPrefix(_transformProp);
      _transformOriginProp = _transformProp + "Origin";
      _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.
      _supports3D = !!_checkPropPrefix("perspective");
      _pluginInitted = 1;
    }
  },
  _getBBoxHack2 = function _getBBoxHack(swapIfPossible) {
    //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
    var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
      oldParent = this.parentNode,
      oldSibling = this.nextSibling,
      oldCSS = this.style.cssText,
      bbox;
    _docElement.appendChild(svg);
    svg.appendChild(this);
    this.style.display = "block";
    if (swapIfPossible) {
      try {
        bbox = this.getBBox();
        this._gsapBBox = this.getBBox; //store the original
        this.getBBox = _getBBoxHack2;
      } catch (e) {}
    } else if (this._gsapBBox) {
      bbox = this._gsapBBox();
    }
    if (oldParent) {
      if (oldSibling) {
        oldParent.insertBefore(this, oldSibling);
      } else {
        oldParent.appendChild(this);
      }
    }
    _docElement.removeChild(svg);
    this.style.cssText = oldCSS;
    return bbox;
  },
  _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
    var i = attributesArray.length;
    while (i--) {
      if (target.hasAttribute(attributesArray[i])) {
        return target.getAttribute(attributesArray[i]);
      }
    }
  },
  _getBBox = function _getBBox(target) {
    var bounds;
    try {
      bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
    } catch (error) {
      bounds = _getBBoxHack2.call(target, true);
    }
    bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack2 || (bounds = _getBBoxHack2.call(target, true));
    //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.
    return bounds && !bounds.width && !bounds.x && !bounds.y ? {
      x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
      y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
      width: 0,
      height: 0
    } : bounds;
  },
  _isSVG = function _isSVG(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
  },
  //reports if the element is an SVG on which getBBox() actually works
  _removeProperty = function _removeProperty(target, property) {
    if (property) {
      var style = target.style;
      if (property in _transformProps && property !== _transformOriginProp) {
        property = _transformProp;
      }
      if (style.removeProperty) {
        if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
          //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
          property = "-" + property;
        }
        style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
      } else {
        //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
        style.removeAttribute(property);
      }
    }
  },
  _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
    var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
    plugin._pt = pt;
    pt.b = beginning;
    pt.e = end;
    plugin._props.push(property);
    return pt;
  },
  _nonConvertibleUnits = {
    deg: 1,
    rad: 1,
    turn: 1
  },
  //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
  _convertToUnit2 = function _convertToUnit(target, property, value, unit) {
    var curValue = parseFloat(value) || 0,
      curUnit = (value + "").trim().substr((curValue + "").length) || "px",
      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
      style = _tempDiv.style,
      horizontal = _horizontalExp.test(property),
      isRootSVG = target.tagName.toLowerCase() === "svg",
      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
      amount = 100,
      toPixels = unit === "px",
      toPercent = unit === "%",
      px,
      parent,
      cache,
      isSVG;
    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
      return curValue;
    }
    curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property, value, "px"));
    isSVG = target.getCTM && _isSVG(target);
    if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
      px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
      return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(toPercent ? curValue / px * amount : curValue / 100 * px);
    }
    style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
    parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
    if (isSVG) {
      parent = (target.ownerSVGElement || {}).parentNode;
    }
    if (!parent || parent === _doc || !parent.appendChild) {
      parent = _doc.body;
    }
    cache = parent._gsap;
    if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._ticker.time) {
      return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(curValue / cache.width * amount);
    } else {
      (toPercent || curUnit === "%") && (style.position = _getComputedProperty2(target, "position"));
      parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.
      parent.appendChild(_tempDiv);
      px = _tempDiv[measureProperty];
      parent.removeChild(_tempDiv);
      style.position = "absolute";
      if (horizontal && toPercent) {
        cache = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._getCache)(parent);
        cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._ticker.time;
        cache.width = parent[measureProperty];
      }
    }
    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
  },
  _get = function _get(target, property, unit, uncache) {
    var value;
    _pluginInitted || _initCore();
    if (property in _propertyAliases && property !== "transform") {
      property = _propertyAliases[property];
      if (~property.indexOf(",")) {
        property = property.split(",")[0];
      }
    }
    if (_transformProps[property] && property !== "transform") {
      value = _parseTransform(target, uncache);
      value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty2(target, _transformOriginProp)) + " " + value.zOrigin + "px";
    } else {
      value = target.style[property];
      if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
        value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty2(target, property) || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._getProperty)(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
      }
    }
    return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit2(target, property, value, unit) + unit : value;
  },
  _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
    //note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
    if (!start || start === "none") {
      // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/
      var p = _checkPropPrefix(prop, target, 1),
        s = p && _getComputedProperty2(target, p, 1);
      if (s && s !== start) {
        prop = p;
        start = s;
      } else if (prop === "borderColor") {
        start = _getComputedProperty2(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
      }
    }
    var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.PropTween(this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._renderComplexString),
      index = 0,
      matchIndex = 0,
      a,
      result,
      startValues,
      startNum,
      color,
      startValue,
      endValue,
      endNum,
      chunk,
      endUnit,
      startUnit,
      relative,
      endValues;
    pt.b = start;
    pt.e = end;
    start += ""; //ensure values are strings
    end += "";
    if (end === "auto") {
      target.style[prop] = end;
      end = _getComputedProperty2(target, prop) || end;
      target.style[prop] = start;
    }
    a = [start, end];
    (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._colorStringFilter)(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().
    start = a[0];
    end = a[1];
    startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._numWithUnitExp) || [];
    endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._numWithUnitExp) || [];
    if (endValues.length) {
      while (result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._numWithUnitExp.exec(end)) {
        endValue = result[0];
        chunk = end.substring(index, result.index);
        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
          color = 1;
        }
        if (endValue !== (startValue = startValues[matchIndex++] || "")) {
          startNum = parseFloat(startValue) || 0;
          startUnit = startValue.substr((startNum + "").length);
          relative = endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;
          if (relative) {
            endValue = endValue.substr(2);
          }
          endNum = parseFloat(endValue);
          endUnit = endValue.substr((endNum + "").length);
          index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._numWithUnitExp.lastIndex - endUnit.length;
          if (!endUnit) {
            //if something like "perspective:300" is passed in and we must add a unit to the end
            endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._config.units[prop] || startUnit;
            if (index === end.length) {
              end += endUnit;
              pt.e += endUnit;
            }
          }
          if (startUnit !== endUnit) {
            startNum = _convertToUnit2(target, prop, startValue, endUnit) || 0;
          }
          //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.
          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
            s: startNum,
            c: relative ? relative * endNum : endNum - startNum,
            m: color && color < 4 || prop === "zIndex" ? Math.round : 0
          };
        }
      }
      pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
    } else {
      pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
    }
    _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.
    return pt;
  },
  _keywordToPercent = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
  },
  _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
    var split = value.split(" "),
      x = split[0],
      y = split[1] || "50%";
    if (x === "top" || x === "bottom" || y === "left" || y === "right") {
      //the user provided them in the wrong order, so flip them
      value = x;
      x = y;
      y = value;
    }
    split[0] = _keywordToPercent[x] || x;
    split[1] = _keywordToPercent[y] || y;
    return split.join(" ");
  },
  _renderClearProps = function _renderClearProps(ratio, data) {
    if (data.tween && data.tween._time === data.tween._dur) {
      var target = data.t,
        style = target.style,
        props = data.u,
        cache = target._gsap,
        prop,
        clearTransforms,
        i;
      if (props === "all" || props === true) {
        style.cssText = "";
        clearTransforms = 1;
      } else {
        props = props.split(",");
        i = props.length;
        while (--i > -1) {
          prop = props[i];
          if (_transformProps[prop]) {
            clearTransforms = 1;
            prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
          }
          _removeProperty(target, prop);
        }
      }
      if (clearTransforms) {
        _removeProperty(target, _transformProp);
        if (cache) {
          cache.svg && target.removeAttribute("transform");
          _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.
          cache.uncache = 1;
        }
      }
    }
  },
  // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
  _specialProps = {
    clearProps: function clearProps(plugin, target, property, endValue, tween) {
      if (tween.data !== "isFromStart") {
        var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
        pt.u = endValue;
        pt.pr = -10;
        pt.tween = tween;
        plugin._props.push(property);
        return 1;
      }
    }
    /* className feature (about 0.4kb gzipped).
    , className(plugin, target, property, endValue, tween) {
    	let _renderClassName = (ratio, data) => {
    			data.css.render(ratio, data.css);
    			if (!ratio || ratio === 1) {
    				let inline = data.rmv,
    					target = data.t,
    					p;
    				target.setAttribute("class", ratio ? data.e : data.b);
    				for (p in inline) {
    					_removeProperty(target, p);
    				}
    			}
    		},
    		_getAllStyles = (target) => {
    			let styles = {},
    				computed = getComputedStyle(target),
    				p;
    			for (p in computed) {
    				if (isNaN(p) && p !== "cssText" && p !== "length") {
    					styles[p] = computed[p];
    				}
    			}
    			_setDefaults(styles, _parseTransform(target, 1));
    			return styles;
    		},
    		startClassList = target.getAttribute("class"),
    		style = target.style,
    		cssText = style.cssText,
    		cache = target._gsap,
    		classPT = cache.classPT,
    		inlineToRemoveAtEnd = {},
    		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
    		changingVars = {},
    		startVars = _getAllStyles(target),
    		transformRelated = /(transform|perspective)/i,
    		endVars, p;
    	if (classPT) {
    		classPT.r(1, classPT.d);
    		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
    	}
    	target.setAttribute("class", data.e);
    	endVars = _getAllStyles(target, true);
    	target.setAttribute("class", startClassList);
    	for (p in endVars) {
    		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
    			changingVars[p] = endVars[p];
    			if (!style[p] && style[p] !== "0") {
    				inlineToRemoveAtEnd[p] = 1;
    			}
    		}
    	}
    	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
    	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
    		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
    	}
    	_parseTransform(target, true); //to clear the caching of transforms
    	data.css = new gsap.plugins.css();
    	data.css.init(target, changingVars, tween);
    	plugin._props.push(...data.css._props);
    	return 1;
    }
    */
  },
  /*
   * --------------------------------------------------------------------------------------
   * TRANSFORMS
   * --------------------------------------------------------------------------------------
   */
  _identity2DMatrix = [1, 0, 0, 1, 0, 0],
  _rotationalProperties = {},
  _isNullTransform = function _isNullTransform(value) {
    return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
  },
  _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
    var matrixString = _getComputedProperty2(target, _transformProp);
    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._numExp).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round);
  },
  _getMatrix = function _getMatrix(target, force2D) {
    var cache = target._gsap || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._getCache)(target),
      style = target.style,
      matrix = _getComputedTransformMatrixAsArray(target),
      parent,
      nextSibling,
      temp,
      addedToDOM;
    if (cache.svg && target.getAttribute("transform")) {
      temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.
      matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
      return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
      //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
      //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
      temp = style.display;
      style.display = "block";
      parent = target.parentNode;
      if (!parent || !target.offsetParent) {
        // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
        addedToDOM = 1; //flag
        nextSibling = target.nextSibling;
        _docElement.appendChild(target); //we must add it to the DOM in order to get values properly
      }
      matrix = _getComputedTransformMatrixAsArray(target);
      temp ? style.display = temp : _removeProperty(target, "display");
      if (addedToDOM) {
        nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
      }
    }
    return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
  },
  _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
    var cache = target._gsap,
      matrix = matrixArray || _getMatrix(target, true),
      xOriginOld = cache.xOrigin || 0,
      yOriginOld = cache.yOrigin || 0,
      xOffsetOld = cache.xOffset || 0,
      yOffsetOld = cache.yOffset || 0,
      a = matrix[0],
      b = matrix[1],
      c = matrix[2],
      d = matrix[3],
      tx = matrix[4],
      ty = matrix[5],
      originSplit = origin.split(" "),
      xOrigin = parseFloat(originSplit[0]) || 0,
      yOrigin = parseFloat(originSplit[1]) || 0,
      bounds,
      determinant,
      x,
      y;
    if (!originIsAbsolute) {
      bounds = _getBBox(target);
      xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
      yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
    } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
      //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
      x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
      y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
      xOrigin = x;
      yOrigin = y;
    }
    if (smooth || smooth !== false && cache.smooth) {
      tx = xOrigin - xOriginOld;
      ty = yOrigin - yOriginOld;
      cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
      cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
    } else {
      cache.xOffset = cache.yOffset = 0;
    }
    cache.xOrigin = xOrigin;
    cache.yOrigin = yOrigin;
    cache.smooth = !!smooth;
    cache.origin = origin;
    cache.originIsAbsolute = !!originIsAbsolute;
    target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).
    if (pluginToAddPropTweensTo) {
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
    }
    target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
  },
  _parseTransform = function _parseTransform(target, uncache) {
    var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.GSCache(target);
    if ("x" in cache && !uncache && !cache.uncache) {
      return cache;
    }
    var style = target.style,
      invertedScaleX = cache.scaleX < 0,
      px = "px",
      deg = "deg",
      origin = _getComputedProperty2(target, _transformOriginProp) || "0",
      x,
      y,
      z,
      scaleX,
      scaleY,
      rotation,
      rotationX,
      rotationY,
      skewX,
      skewY,
      perspective,
      xOrigin,
      yOrigin,
      matrix,
      angle,
      cos,
      sin,
      a,
      b,
      c,
      d,
      a12,
      a22,
      t1,
      t2,
      t3,
      a13,
      a23,
      a33,
      a42,
      a43,
      a32;
    x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
    scaleX = scaleY = 1;
    cache.svg = !!(target.getCTM && _isSVG(target));
    matrix = _getMatrix(target, cache.svg);
    if (cache.svg) {
      t1 = (!cache.uncache || origin === "0px 0px") && !uncache && target.getAttribute("data-svg-origin"); // if origin is 0,0 and cache.uncache is true, let the recorded data-svg-origin stay. Otherwise, whenever we set cache.uncache to true, we'd need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.
      _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
    }
    xOrigin = cache.xOrigin || 0;
    yOrigin = cache.yOrigin || 0;
    if (matrix !== _identity2DMatrix) {
      a = matrix[0]; //a11
      b = matrix[1]; //a21
      c = matrix[2]; //a31
      d = matrix[3]; //a41
      x = a12 = matrix[4];
      y = a22 = matrix[5];

      //2D matrix
      if (matrix.length === 6) {
        scaleX = Math.sqrt(a * a + b * b);
        scaleY = Math.sqrt(d * d + c * c);
        rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
        skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
        skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
        if (cache.svg) {
          x -= xOrigin - (xOrigin * a + yOrigin * c);
          y -= yOrigin - (xOrigin * b + yOrigin * d);
        }

        //3D matrix
      } else {
        a32 = matrix[6];
        a42 = matrix[7];
        a13 = matrix[8];
        a23 = matrix[9];
        a33 = matrix[10];
        a43 = matrix[11];
        x = matrix[12];
        y = matrix[13];
        z = matrix[14];
        angle = _atan2(a32, a33);
        rotationX = angle * _RAD2DEG;
        //rotationX
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a12 * cos + a13 * sin;
          t2 = a22 * cos + a23 * sin;
          t3 = a32 * cos + a33 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a32 * -sin + a33 * cos;
          a43 = a42 * -sin + a43 * cos;
          a12 = t1;
          a22 = t2;
          a32 = t3;
        }
        //rotationY
        angle = _atan2(-c, a33);
        rotationY = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a * cos - a13 * sin;
          t2 = b * cos - a23 * sin;
          t3 = c * cos - a33 * sin;
          a43 = d * sin + a43 * cos;
          a = t1;
          b = t2;
          c = t3;
        }
        //rotationZ
        angle = _atan2(b, a);
        rotation = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a * cos + b * sin;
          t2 = a12 * cos + a22 * sin;
          b = b * cos - a * sin;
          a22 = a22 * cos - a12 * sin;
          a = t1;
          a12 = t2;
        }
        if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
          //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
          rotationX = rotation = 0;
          rotationY = 180 - rotationY;
        }
        scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(Math.sqrt(a * a + b * b + c * c));
        scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(Math.sqrt(a22 * a22 + a32 * a32));
        angle = _atan2(a12, a22);
        skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
        perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
      }
      if (cache.svg) {
        //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
        t1 = target.getAttribute("transform");
        cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty2(target, _transformProp));
        t1 && target.setAttribute("transform", t1);
      }
    }
    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
      if (invertedScaleX) {
        scaleX *= -1;
        skewX += rotation <= 0 ? 180 : -180;
        rotation += rotation <= 0 ? 180 : -180;
      } else {
        scaleY *= -1;
        skewX += skewX <= 0 ? 180 : -180;
      }
    }
    cache.x = x - ((cache.xPercent = x && (cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
    cache.y = y - ((cache.yPercent = y && (cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
    cache.z = z + px;
    cache.scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(scaleX);
    cache.scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(scaleY);
    cache.rotation = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(rotation) + deg;
    cache.rotationX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(rotationX) + deg;
    cache.rotationY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(rotationY) + deg;
    cache.skewX = skewX + deg;
    cache.skewY = skewY + deg;
    cache.transformPerspective = perspective + px;
    if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
      style[_transformOriginProp] = _firstTwoOnly(origin);
    }
    cache.xOffset = cache.yOffset = 0;
    cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._config.force3D;
    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
    cache.uncache = 0;
    return cache;
  },
  _firstTwoOnly = function _firstTwoOnly(value) {
    return (value = value.split(" "))[0] + " " + value[1];
  },
  //for handling transformOrigin values, stripping out the 3rd dimension
  _addPxTranslate = function _addPxTranslate(target, start, value) {
    var unit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.getUnit)(start);
    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(parseFloat(start) + parseFloat(_convertToUnit2(target, "x", value + "px", unit))) + unit;
  },
  _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
    cache.z = "0px";
    cache.rotationY = cache.rotationX = "0deg";
    cache.force3D = 0;
    _renderCSSTransforms(ratio, cache);
  },
  _zeroDeg = "0deg",
  _zeroPx = "0px",
  _endParenthesis = ") ",
  _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
    var _ref = cache || this,
      xPercent = _ref.xPercent,
      yPercent = _ref.yPercent,
      x = _ref.x,
      y = _ref.y,
      z = _ref.z,
      rotation = _ref.rotation,
      rotationY = _ref.rotationY,
      rotationX = _ref.rotationX,
      skewX = _ref.skewX,
      skewY = _ref.skewY,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      transformPerspective = _ref.transformPerspective,
      force3D = _ref.force3D,
      target = _ref.target,
      zOrigin = _ref.zOrigin,
      transforms = "",
      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;

    // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)
    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
      var angle = parseFloat(rotationY) * _DEG2RAD,
        a13 = Math.sin(angle),
        a33 = Math.cos(angle),
        cos;
      angle = parseFloat(rotationX) * _DEG2RAD;
      cos = Math.cos(angle);
      x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
      y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
      z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
    }
    if (transformPerspective !== _zeroPx) {
      transforms += "perspective(" + transformPerspective + _endParenthesis;
    }
    if (xPercent || yPercent) {
      transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
    }
    if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
      transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
    }
    if (rotation !== _zeroDeg) {
      transforms += "rotate(" + rotation + _endParenthesis;
    }
    if (rotationY !== _zeroDeg) {
      transforms += "rotateY(" + rotationY + _endParenthesis;
    }
    if (rotationX !== _zeroDeg) {
      transforms += "rotateX(" + rotationX + _endParenthesis;
    }
    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
      transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
    }
    if (scaleX !== 1 || scaleY !== 1) {
      transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
    }
    target.style[_transformProp] = transforms || "translate(0, 0)";
  },
  _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
    var _ref2 = cache || this,
      xPercent = _ref2.xPercent,
      yPercent = _ref2.yPercent,
      x = _ref2.x,
      y = _ref2.y,
      rotation = _ref2.rotation,
      skewX = _ref2.skewX,
      skewY = _ref2.skewY,
      scaleX = _ref2.scaleX,
      scaleY = _ref2.scaleY,
      target = _ref2.target,
      xOrigin = _ref2.xOrigin,
      yOrigin = _ref2.yOrigin,
      xOffset = _ref2.xOffset,
      yOffset = _ref2.yOffset,
      forceCSS = _ref2.forceCSS,
      tx = parseFloat(x),
      ty = parseFloat(y),
      a11,
      a21,
      a12,
      a22,
      temp;
    rotation = parseFloat(rotation);
    skewX = parseFloat(skewX);
    skewY = parseFloat(skewY);
    if (skewY) {
      //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
      skewY = parseFloat(skewY);
      skewX += skewY;
      rotation += skewY;
    }
    if (rotation || skewX) {
      rotation *= _DEG2RAD;
      skewX *= _DEG2RAD;
      a11 = Math.cos(rotation) * scaleX;
      a21 = Math.sin(rotation) * scaleX;
      a12 = Math.sin(rotation - skewX) * -scaleY;
      a22 = Math.cos(rotation - skewX) * scaleY;
      if (skewX) {
        skewY *= _DEG2RAD;
        temp = Math.tan(skewX - skewY);
        temp = Math.sqrt(1 + temp * temp);
        a12 *= temp;
        a22 *= temp;
        if (skewY) {
          temp = Math.tan(skewY);
          temp = Math.sqrt(1 + temp * temp);
          a11 *= temp;
          a21 *= temp;
        }
      }
      a11 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(a11);
      a21 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(a21);
      a12 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(a12);
      a22 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(a22);
    } else {
      a11 = scaleX;
      a22 = scaleY;
      a21 = a12 = 0;
    }
    if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
      tx = _convertToUnit2(target, "x", x, "px");
      ty = _convertToUnit2(target, "y", y, "px");
    }
    if (xOrigin || yOrigin || xOffset || yOffset) {
      tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
      ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
    }
    if (xPercent || yPercent) {
      //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
      temp = target.getBBox();
      tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(tx + xPercent / 100 * temp.width);
      ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._round)(ty + yPercent / 100 * temp.height);
    }
    temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
    target.setAttribute("transform", temp);
    forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the  transform attribute changes!)
  },
  _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue, relative) {
    var cap = 360,
      isString = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._isString)(endValue),
      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
      change = relative ? endNum * relative : endNum - startNum,
      finalValue = startNum + change + "deg",
      direction,
      pt;
    if (isString) {
      direction = endValue.split("_")[1];
      if (direction === "short") {
        change %= cap;
        if (change !== change % (cap / 2)) {
          change += change < 0 ? cap : -cap;
        }
      }
      if (direction === "cw" && change < 0) {
        change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
      } else if (direction === "ccw" && change > 0) {
        change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
      }
    }
    plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
    pt.e = finalValue;
    pt.u = "deg";
    plugin._props.push(property);
    return pt;
  },
  _assign = function _assign(target, source) {
    // Internet Explorer doesn't have Object.assign(), so we recreate it here.
    for (var p in source) {
      target[p] = source[p];
    }
    return target;
  },
  _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
    //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
    var startCache = _assign({}, target._gsap),
      exclude = "perspective,force3D,transformOrigin,svgOrigin",
      style = target.style,
      endCache,
      p,
      startValue,
      endValue,
      startNum,
      endNum,
      startUnit,
      endUnit;
    if (startCache.svg) {
      startValue = target.getAttribute("transform");
      target.setAttribute("transform", "");
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      _removeProperty(target, _transformProp);
      target.setAttribute("transform", startValue);
    } else {
      startValue = getComputedStyle(target)[_transformProp];
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      style[_transformProp] = startValue;
    }
    for (p in _transformProps) {
      startValue = startCache[p];
      endValue = endCache[p];
      if (startValue !== endValue && exclude.indexOf(p) < 0) {
        //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
        startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.getUnit)(startValue);
        endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.getUnit)(endValue);
        startNum = startUnit !== endUnit ? _convertToUnit2(target, p, startValue, endUnit) : parseFloat(startValue);
        endNum = parseFloat(endValue);
        plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
        plugin._pt.u = endUnit || 0;
        plugin._props.push(p);
      }
    }
    _assign(endCache, startCache);
  };

// handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.
(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._forEachName)("padding,margin,Width,Radius", function (name, index) {
  var t = "Top",
    r = "Right",
    b = "Bottom",
    l = "Left",
    props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
      return index < 2 ? name + side : "border" + side + name;
    });
  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
    var a, vars;
    if (arguments.length < 4) {
      // getter, passed target, property, and unit (from _get())
      a = props.map(function (prop) {
        return _get(plugin, prop, property);
      });
      vars = a.join(" ");
      return vars.split(a[0]).length === 5 ? a[0] : vars;
    }
    a = (endValue + "").split(" ");
    vars = {};
    props.forEach(function (prop, i) {
      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
    });
    plugin.init(target, vars, tween);
  };
});
var CSSPlugin = {
  name: "css",
  register: _initCore,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init(target, vars, tween, index, targets) {
    var props = this._props,
      style = target.style,
      startAt = tween.vars.startAt,
      startValue,
      endValue,
      endNum,
      startNum,
      type,
      specialProp,
      p,
      startUnit,
      endUnit,
      relative,
      isTransformRelated,
      transformPropTween,
      cache,
      smooth,
      hasPriority;
    _pluginInitted || _initCore();
    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }
      endValue = vars[p];
      if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._plugins[p] && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._checkPlugin)(p, vars, tween, index, target, targets)) {
        // plugins
        continue;
      }
      type = (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(endValue);
      specialProp = _specialProps[p];
      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(endValue);
      }
      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._replaceRandom)(endValue);
      }
      if (specialProp) {
        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
      } else if (p.substr(0, 2) === "--") {
        //CSS variable
        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
        endValue += "";
        _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._colorExp.lastIndex = 0;
        if (!_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._colorExp.test(startValue)) {
          // colors don't have units
          startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.getUnit)(startValue);
          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.getUnit)(endValue);
        }
        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit2(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
        props.push(p);
      } else if (type !== "undefined") {
        if (startAt && p in startAt) {
          // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
          p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._config.units && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.getUnit)(startValue) && (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._config.units[p]); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.
          (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
        } else {
          startValue = _get(target, p);
        }
        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;
        relative && (endValue = endValue.substr(2));
        endNum = parseFloat(endValue);
        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
              startNum = 0;
            }
            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }
          if (p !== "scale" && p !== "transform") {
            p = _propertyAliases[p];
            ~p.indexOf(",") && (p = p.split(",")[0]);
          }
        }
        isTransformRelated = p in _transformProps;

        //--- TRANSFORM-RELATED ---
        if (isTransformRelated) {
          if (!transformPropTween) {
            cache = target._gsap;
            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.
            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)
            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
          }
          if (p === "scale") {
            this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? relative * endNum : endNum - cache.scaleY) || 0);
            props.push("scaleY", p);
            p += "X";
          } else if (p === "transformOrigin") {
            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.
            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!
              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }
            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);
            continue;
          } else if (p in _rotationalProperties) {
            _addRotationalPropTween(this, cache, p, startNum, endValue, relative);
            continue;
          } else if (p === "smoothOrigin") {
            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            _addRawTransformPTs(this, endValue, target);
            continue;
          }
        } else if (!(p in style)) {
          p = _checkPropPrefix(p) || p;
        }
        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endNum || (endNum = 0); // protect against NaN
          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.getUnit)(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._config.units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._config.units[p] : startUnit);
          startUnit !== endUnit && (startNum = _convertToUnit2(target, p, startValue, endUnit));
          this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, relative ? relative * endNum : endNum - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;
          if (startUnit !== endUnit) {
            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
            this.add(target, p, startValue || target[p], endValue, index, targets);
          } else {
            (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._missingPlugin)(p, endValue);
            continue;
          }
        } else {
          _tweenComplexCSSString.call(this, target, p, startValue, endValue);
        }
        props.push(p);
      }
    }
    hasPriority && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._sortPropTweensByPriority)(this);
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
    var p = _propertyAliases[property];
    p && p.indexOf(",") < 0 && (property = p);
    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._getSetter)(target, property);
  },
  core: {
    _removeProperty: _removeProperty,
    _getMatrix: _getMatrix
  }
};
_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.gsap.utils.checkPrefix = _checkPropPrefix;
(function (positionAndScale, rotation, others, aliases) {
  var all = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._forEachName)(positionAndScale + "," + rotation + "," + others, function (name) {
    _transformProps[name] = 1;
  });
  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._forEachName)(rotation, function (name) {
    _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._config.units[name] = "deg";
    _rotationalProperties[name] = 1;
  });
  _propertyAliases[all[13]] = positionAndScale + "," + rotation;
  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._forEachName)(aliases, function (name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._forEachName)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
  _gsap_core_js__WEBPACK_IMPORTED_MODULE_1__._config.units[name] = "px";
});
_gsap_core_js__WEBPACK_IMPORTED_MODULE_1__.gsap.registerPlugin(CSSPlugin);


/***/ }),

/***/ "./src/assets/scripts/gsap/CSSRulePlugin.js":
/*!**************************************************!*\
  !*** ./src/assets/scripts/gsap/CSSRulePlugin.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CSSRulePlugin: () => (/* binding */ CSSRulePlugin),
/* harmony export */   "default": () => (/* binding */ CSSRulePlugin)
/* harmony export */ });
/*!
 * CSSRulePlugin 3.7.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */

var gsap,
  _coreInitted,
  _win,
  _doc,
  CSSPlugin,
  _windowExists = function _windowExists() {
    return typeof window !== "undefined";
  },
  _getGSAP = function _getGSAP() {
    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
  },
  _checkRegister = function _checkRegister() {
    if (!_coreInitted) {
      _initCore();
      if (!CSSPlugin) {
        console.warn("Please gsap.registerPlugin(CSSPlugin, CSSRulePlugin)");
      }
    }
    return _coreInitted;
  },
  _initCore = function _initCore(core) {
    gsap = core || _getGSAP();
    if (_windowExists()) {
      _win = window;
      _doc = document;
    }
    if (gsap) {
      CSSPlugin = gsap.plugins.css;
      if (CSSPlugin) {
        _coreInitted = 1;
      }
    }
  };
var CSSRulePlugin = {
  version: "3.7.0",
  name: "cssRule",
  init: function init(target, value, tween, index, targets) {
    if (!_checkRegister() || typeof target.cssText === "undefined") {
      return false;
    }
    var div = target._gsProxy = target._gsProxy || _doc.createElement("div");
    this.ss = target;
    this.style = div.style;
    div.style.cssText = target.cssText;
    CSSPlugin.prototype.init.call(this, div, value, tween, index, targets); //we just offload all the work to the regular CSSPlugin and then copy the cssText back over to the rule in the render() method. This allows us to have all of the updates to CSSPlugin automatically flow through to CSSRulePlugin instead of having to maintain both
  },
  render: function render(ratio, data) {
    var pt = data._pt,
      style = data.style,
      ss = data.ss,
      i;
    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
    i = style.length;
    while (--i > -1) {
      ss[style[i]] = style[style[i]];
    }
  },
  getRule: function getRule(selector) {
    _checkRegister();
    var ruleProp = _doc.all ? "rules" : "cssRules",
      styleSheets = _doc.styleSheets,
      i = styleSheets.length,
      pseudo = selector.charAt(0) === ":",
      j,
      curSS,
      cs,
      a;
    selector = (pseudo ? "" : ",") + selector.split("::").join(":").toLowerCase() + ","; //note: old versions of IE report tag name selectors as upper case, so we just change everything to lowercase.
    if (pseudo) {
      a = [];
    }
    while (i--) {
      //Firefox may throw insecure operation errors when css is loaded from other domains, so try/catch.
      try {
        curSS = styleSheets[i][ruleProp];
        if (!curSS) {
          continue;
        }
        j = curSS.length;
      } catch (e) {
        console.warn(e);
        continue;
      }
      while (--j > -1) {
        cs = curSS[j];
        if (cs.selectorText && ("," + cs.selectorText.split("::").join(":").toLowerCase() + ",").indexOf(selector) !== -1) {
          //note: IE adds an extra ":" to pseudo selectors, so .myClass:after becomes .myClass::after, so we need to strip the extra one out.
          if (pseudo) {
            a.push(cs.style);
          } else {
            return cs.style;
          }
        }
      }
    }
    return a;
  },
  register: _initCore
};
_getGSAP() && gsap.registerPlugin(CSSRulePlugin);


/***/ }),

/***/ "./src/assets/scripts/gsap/CustomEase.js":
/*!***********************************************!*\
  !*** ./src/assets/scripts/gsap/CustomEase.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CustomEase: () => (/* binding */ CustomEase),
/* harmony export */   "default": () => (/* binding */ CustomEase)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _utils_paths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/paths.js */ "./src/assets/scripts/gsap/utils/paths.js");


/*!
 * CustomEase 3.7.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */


var gsap,
  _coreInitted,
  _getGSAP = function _getGSAP() {
    return gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap;
  },
  _initCore = function _initCore() {
    gsap = _getGSAP();
    if (gsap) {
      gsap.registerEase("_CE", CustomEase.create);
      _coreInitted = 1;
    } else {
      console.warn("Please gsap.registerPlugin(CustomEase)");
    }
  },
  _bigNum = 1e20,
  _round = function _round(value) {
    return ~~(value * 1000 + (value < 0 ? -.5 : .5)) / 1000;
  },
  _bonusValidated = 1,
  //<name>CustomEase</name>
  _numExp = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
  //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
  _needsParsingExp = /[cLlsSaAhHvVtTqQ]/g,
  _findMinimum = function _findMinimum(values) {
    var l = values.length,
      min = _bigNum,
      i;
    for (i = 1; i < l; i += 6) {
      +values[i] < min && (min = +values[i]);
    }
    return min;
  },
  //takes all the points and translates/scales them so that the x starts at 0 and ends at 1.
  _normalize = function _normalize(values, height, originY) {
    if (!originY && originY !== 0) {
      originY = Math.max(+values[values.length - 1], +values[1]);
    }
    var tx = +values[0] * -1,
      ty = -originY,
      l = values.length,
      sx = 1 / (+values[l - 2] + tx),
      sy = -height || (Math.abs(+values[l - 1] - +values[1]) < 0.01 * (+values[l - 2] - +values[0]) ? _findMinimum(values) + ty : +values[l - 1] + ty),
      i;
    if (sy) {
      //typically y ends at 1 (so that the end values are reached)
      sy = 1 / sy;
    } else {
      //in case the ease returns to its beginning value, scale everything proportionally
      sy = -sx;
    }
    for (i = 0; i < l; i += 2) {
      values[i] = (+values[i] + tx) * sx;
      values[i + 1] = (+values[i + 1] + ty) * sy;
    }
  },
  //note that this function returns point objects like {x, y} rather than working with segments which are arrays with alternating x, y values as in the similar function in paths.js
  _bezierToPoints2 = function _bezierToPoints(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {
    var x12 = (x1 + x2) / 2,
      y12 = (y1 + y2) / 2,
      x23 = (x2 + x3) / 2,
      y23 = (y2 + y3) / 2,
      x34 = (x3 + x4) / 2,
      y34 = (y3 + y4) / 2,
      x123 = (x12 + x23) / 2,
      y123 = (y12 + y23) / 2,
      x234 = (x23 + x34) / 2,
      y234 = (y23 + y34) / 2,
      x1234 = (x123 + x234) / 2,
      y1234 = (y123 + y234) / 2,
      dx = x4 - x1,
      dy = y4 - y1,
      d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx),
      d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx),
      length;
    if (!points) {
      points = [{
        x: x1,
        y: y1
      }, {
        x: x4,
        y: y4
      }];
      index = 1;
    }
    points.splice(index || points.length - 1, 0, {
      x: x1234,
      y: y1234
    });
    if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {
      length = points.length;
      _bezierToPoints2(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);
      _bezierToPoints2(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 1 + (points.length - length));
    }
    return points;
  };
var CustomEase = /*#__PURE__*/function () {
  function CustomEase(id, data, config) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, CustomEase);
    _coreInitted || _initCore();
    this.id = id;
    _bonusValidated && this.setData(data, config);
  }
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(CustomEase, [{
    key: "setData",
    value: function setData(data, config) {
      config = config || {};
      data = data || "0,0,1,1";
      var values = data.match(_numExp),
        closest = 1,
        points = [],
        lookup = [],
        precision = config.precision || 1,
        fast = precision <= 1,
        l,
        a1,
        a2,
        i,
        inc,
        j,
        point,
        prevPoint,
        p;
      this.data = data;
      if (_needsParsingExp.test(data) || ~data.indexOf("M") && data.indexOf("C") < 0) {
        values = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_2__.stringToRawPath)(data)[0];
      }
      l = values.length;
      if (l === 4) {
        values.unshift(0, 0);
        values.push(1, 1);
        l = 8;
      } else if ((l - 2) % 6) {
        throw "Invalid CustomEase";
      }
      if (+values[0] !== 0 || +values[l - 2] !== 1) {
        _normalize(values, config.height, config.originY);
      }
      this.segment = values;
      for (i = 2; i < l; i += 6) {
        a1 = {
          x: +values[i - 2],
          y: +values[i - 1]
        };
        a2 = {
          x: +values[i + 4],
          y: +values[i + 5]
        };
        points.push(a1, a2);
        _bezierToPoints2(a1.x, a1.y, +values[i], +values[i + 1], +values[i + 2], +values[i + 3], a2.x, a2.y, 1 / (precision * 200000), points, points.length - 1);
      }
      l = points.length;
      for (i = 0; i < l; i++) {
        point = points[i];
        prevPoint = points[i - 1] || point;
        if ((point.x > prevPoint.x || prevPoint.y !== point.y && prevPoint.x === point.x || point === prevPoint) && point.x <= 1) {
          //if a point goes BACKWARD in time or is a duplicate, just drop it. Also it shouldn't go past 1 on the x axis, as could happen in a string like "M0,0 C0,0 0.12,0.68 0.18,0.788 0.195,0.845 0.308,1 0.32,1 0.403,1.005 0.398,1 0.5,1 0.602,1 0.816,1.005 0.9,1 0.91,1 0.948,0.69 0.962,0.615 1.003,0.376 1,0 1,0".
          prevPoint.cx = point.x - prevPoint.x; //change in x between this point and the next point (performance optimization)
          prevPoint.cy = point.y - prevPoint.y;
          prevPoint.n = point;
          prevPoint.nx = point.x; //next point's x value (performance optimization, making lookups faster in getRatio()). Remember, the lookup will always land on a spot where it's either this point or the very next one (never beyond that)
          if (fast && i > 1 && Math.abs(prevPoint.cy / prevPoint.cx - points[i - 2].cy / points[i - 2].cx) > 2) {
            //if there's a sudden change in direction, prioritize accuracy over speed. Like a bounce ease - you don't want to risk the sampling chunks landing on each side of the bounce anchor and having it clipped off.
            fast = 0;
          }
          if (prevPoint.cx < closest) {
            if (!prevPoint.cx) {
              prevPoint.cx = 0.001; //avoids math problems in getRatio() (dividing by zero)
              if (i === l - 1) {
                //in case the final segment goes vertical RIGHT at the end, make sure we end at the end.
                prevPoint.x -= 0.001;
                closest = Math.min(closest, 0.001);
                fast = 0;
              }
            } else {
              closest = prevPoint.cx;
            }
          }
        } else {
          points.splice(i--, 1);
          l--;
        }
      }
      l = 1 / closest + 1 | 0;
      inc = 1 / l;
      j = 0;
      point = points[0];
      if (fast) {
        for (i = 0; i < l; i++) {
          //for fastest lookups, we just sample along the path at equal x (time) distance. Uses more memory and is slightly less accurate for anchors that don't land on the sampling points, but for the vast majority of eases it's excellent (and fast).
          p = i * inc;
          if (point.nx < p) {
            point = points[++j];
          }
          a1 = point.y + (p - point.x) / point.cx * point.cy;
          lookup[i] = {
            x: p,
            cx: inc,
            y: a1,
            cy: 0,
            nx: 9
          };
          if (i) {
            lookup[i - 1].cy = a1 - lookup[i - 1].y;
          }
        }
        lookup[l - 1].cy = points[points.length - 1].y - a1;
      } else {
        //this option is more accurate, ensuring that EVERY anchor is hit perfectly. Clipping across a bounce, for example, would never happen.
        for (i = 0; i < l; i++) {
          //build a lookup table based on the smallest distance so that we can instantly find the appropriate point (well, it'll either be that point or the very next one). We'll look up based on the linear progress. So it's it's 0.5 and the lookup table has 100 elements, it'd be like lookup[Math.floor(0.5 * 100)]
          if (point.nx < i * inc) {
            point = points[++j];
          }
          lookup[i] = point;
        }
        if (j < points.length - 1) {
          lookup[i - 1] = points[points.length - 2];
        }
      }
      //this._calcEnd = (points[points.length-1].y !== 1 || points[0].y !== 0); //ensures that we don't run into floating point errors. As long as we're starting at 0 and ending at 1, tell GSAP to skip the final calculation and use 0/1 as the factor.

      this.ease = function (p) {
        var point = lookup[p * l | 0] || lookup[l - 1];
        if (point.nx < p) {
          point = point.n;
        }
        return point.y + (p - point.x) / point.cx * point.cy;
      };
      this.ease.custom = this;
      this.id && gsap.registerEase(this.id, this.ease);
      return this;
    }
  }, {
    key: "getSVGData",
    value: function getSVGData(config) {
      return CustomEase.getSVGData(this, config);
    }
  }], [{
    key: "create",
    value: function create(id, data, config) {
      return new CustomEase(id, data, config).ease;
    }
  }, {
    key: "register",
    value: function register(core) {
      gsap = core;
      _initCore();
    }
  }, {
    key: "get",
    value: function get(id) {
      return gsap.parseEase(id);
    }
  }, {
    key: "getSVGData",
    value: function getSVGData(ease, config) {
      config = config || {};
      var width = config.width || 100,
        height = config.height || 100,
        x = config.x || 0,
        y = (config.y || 0) + height,
        e = gsap.utils.toArray(config.path)[0],
        a,
        slope,
        i,
        inc,
        tx,
        ty,
        precision,
        threshold,
        prevX,
        prevY;
      if (config.invert) {
        height = -height;
        y = 0;
      }
      if (typeof ease === "string") {
        ease = gsap.parseEase(ease);
      }
      if (ease.custom) {
        ease = ease.custom;
      }
      if (ease instanceof CustomEase) {
        a = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_2__.rawPathToString)((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_2__.transformRawPath)([ease.segment], width, 0, 0, -height, x, y));
      } else {
        a = [x, y];
        precision = Math.max(5, (config.precision || 1) * 200);
        inc = 1 / precision;
        precision += 2;
        threshold = 5 / precision;
        prevX = _round(x + inc * width);
        prevY = _round(y + ease(inc) * -height);
        slope = (prevY - y) / (prevX - x);
        for (i = 2; i < precision; i++) {
          tx = _round(x + i * inc * width);
          ty = _round(y + ease(i * inc) * -height);
          if (Math.abs((ty - prevY) / (tx - prevX) - slope) > threshold || i === precision - 1) {
            //only add points when the slope changes beyond the threshold
            a.push(prevX, prevY);
            slope = (ty - prevY) / (tx - prevX);
          }
          prevX = tx;
          prevY = ty;
        }
        a = "M" + a.join(",");
      }
      e && e.setAttribute("d", a);
      return a;
    }
  }]);
}();
_getGSAP() && gsap.registerPlugin(CustomEase);
CustomEase.version = "3.7.0";


/***/ }),

/***/ "./src/assets/scripts/gsap/ScrollTrigger.js":
/*!**************************************************!*\
  !*** ./src/assets/scripts/gsap/ScrollTrigger.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ScrollTrigger: () => (/* binding */ ScrollTrigger),
/* harmony export */   "default": () => (/* binding */ ScrollTrigger)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");



/*!
 * ScrollTrigger 3.7.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */

var gsap,
  _coreInitted,
  _win,
  _doc,
  _docEl,
  _body,
  _root,
  _resizeDelay,
  _raf,
  _request,
  _toArray,
  _clamp,
  _time2,
  _syncInterval,
  _refreshing,
  _pointerIsDown,
  _transformProp,
  _i,
  _prevWidth,
  _prevHeight,
  _autoRefresh,
  _sort,
  _suppressOverwrites,
  _ignoreResize,
  _limitCallbacks,
  // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.
  _startup = 1,
  _proxies = [],
  _scrollers = [],
  _getTime = Date.now,
  _time1 = _getTime(),
  _lastScrollTime = 0,
  _enabled = 1,
  _passThrough = function _passThrough(v) {
    return v;
  },
  _round = function _round(value) {
    return Math.round(value * 100000) / 100000 || 0;
  },
  _windowExists = function _windowExists() {
    return typeof window !== "undefined";
  },
  _getGSAP = function _getGSAP() {
    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
  },
  _isViewport = function _isViewport(e) {
    return !!~_root.indexOf(e);
  },
  _getProxyProp = function _getProxyProp(element, property) {
    return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
  },
  _getScrollFunc = function _getScrollFunc(element, _ref) {
    var s = _ref.s,
      sc = _ref.sc;
    // we store the scroller functions in a alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a ".rec" property in order to revert to that after refreshing to ensure things don't shift around.
    var i = _scrollers.indexOf(element),
      offset = sc === _vertical.sc ? 1 : 2;
    !~i && (i = _scrollers.push(element) - 1);
    return _scrollers[i + offset] || (_scrollers[i + offset] = _getProxyProp(element, s) || (_isViewport(element) ? sc : function (value) {
      return arguments.length ? element[s] = value : element[s];
    }));
  },
  _getBoundsFunc = function _getBoundsFunc(element) {
    return _getProxyProp(element, "getBoundingClientRect") || (_isViewport(element) ? function () {
      _winOffsets.width = _win.innerWidth;
      _winOffsets.height = _win.innerHeight;
      return _winOffsets;
    } : function () {
      return _getBounds(element);
    });
  },
  _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref2) {
    var d = _ref2.d,
      d2 = _ref2.d2,
      a = _ref2.a;
    return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function () {
      return a()[d];
    } : function () {
      return (isViewport ? _win["inner" + d2] : scroller["client" + d2]) || 0;
    };
  },
  _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {
    return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function () {
      return _winOffsets;
    };
  },
  _maxScroll = function _maxScroll(element, _ref3) {
    var s = _ref3.s,
      d2 = _ref3.d2,
      d = _ref3.d,
      a = _ref3.a;
    return (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? Math.max(_docEl[s], _body[s]) - (_win["inner" + d2] || _docEl["client" + d2] || _body["client" + d2]) : element[s] - element["offset" + d2];
  },
  _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
    for (var i = 0; i < _autoRefresh.length; i += 3) {
      (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
    }
  },
  _isString = function _isString(value) {
    return typeof value === "string";
  },
  _isFunction = function _isFunction(value) {
    return typeof value === "function";
  },
  _isNumber = function _isNumber(value) {
    return typeof value === "number";
  },
  _isObject = function _isObject(value) {
    return (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2__["default"])(value) === "object";
  },
  _callIfFunc = function _callIfFunc(value) {
    return _isFunction(value) && value();
  },
  _combineFunc = function _combineFunc(f1, f2) {
    return function () {
      var result1 = _callIfFunc(f1),
        result2 = _callIfFunc(f2);
      return function () {
        _callIfFunc(result1);
        _callIfFunc(result2);
      };
    };
  },
  _abs = Math.abs,
  _scrollLeft = "scrollLeft",
  _scrollTop = "scrollTop",
  _left = "left",
  _top = "top",
  _right = "right",
  _bottom = "bottom",
  _width = "width",
  _height = "height",
  _Right = "Right",
  _Left = "Left",
  _Top = "Top",
  _Bottom = "Bottom",
  _padding = "padding",
  _margin = "margin",
  _Width = "Width",
  _Height = "Height",
  _px = "px",
  _horizontal = {
    s: _scrollLeft,
    p: _left,
    p2: _Left,
    os: _right,
    os2: _Right,
    d: _width,
    d2: _Width,
    a: "x",
    sc: function sc(value) {
      return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;
    }
  },
  _vertical = {
    s: _scrollTop,
    p: _top,
    p2: _Top,
    os: _bottom,
    os2: _Bottom,
    d: _height,
    d2: _Height,
    a: "y",
    op: _horizontal,
    sc: function sc(value) {
      return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;
    }
  },
  _getComputedStyle = function _getComputedStyle(element) {
    return _win.getComputedStyle(element);
  },
  _makePositionable = function _makePositionable(element) {
    // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative
    var position = _getComputedStyle(element).position;
    element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
  },
  _setDefaults = function _setDefaults(obj, defaults) {
    for (var p in defaults) {
      p in obj || (obj[p] = defaults[p]);
    }
    return obj;
  },
  //_isInViewport = element => (element = _getBounds(element)) && !(element.top > (_win.innerHeight || _docEl.clientHeight) || element.bottom < 0 || element.left > (_win.innerWidth || _docEl.clientWidth) || element.right < 0) && element,
  _getBounds = function _getBounds(element, withoutTransforms) {
    var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap.to(element, {
        x: 0,
        y: 0,
        xPercent: 0,
        yPercent: 0,
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        scale: 1,
        skewX: 0,
        skewY: 0
      }).progress(1),
      bounds = element.getBoundingClientRect();
    tween && tween.progress(0).kill();
    return bounds;
  },
  _getSize = function _getSize(element, _ref4) {
    var d2 = _ref4.d2;
    return element["offset" + d2] || element["client" + d2] || 0;
  },
  _getLabelRatioArray = function _getLabelRatioArray(timeline) {
    var a = [],
      labels = timeline.labels,
      duration = timeline.duration(),
      p;
    for (p in labels) {
      a.push(labels[p] / duration);
    }
    return a;
  },
  _getClosestLabel = function _getClosestLabel(animation) {
    return function (value) {
      return gsap.utils.snap(_getLabelRatioArray(animation), value);
    };
  },
  _getLabelAtDirection = function _getLabelAtDirection(timeline) {
    return function (value, st) {
      var a = _getLabelRatioArray(timeline),
        i;
      a.sort(function (a, b) {
        return a - b;
      });
      if (st.direction > 0) {
        value -= 1e-4; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.
        for (i = 0; i < a.length; i++) {
          if (a[i] >= value) {
            return a[i];
          }
        }
        return a.pop();
      } else {
        i = a.length;
        value += 1e-4;
        while (i--) {
          if (a[i] <= value) {
            return a[i];
          }
        }
      }
      return a[0];
    };
  },
  _multiListener = function _multiListener(func, element, types, callback) {
    return types.split(",").forEach(function (type) {
      return func(element, type, callback);
    });
  },
  _addListener = function _addListener(element, type, func) {
    return element.addEventListener(type, func, {
      passive: true
    });
  },
  _removeListener = function _removeListener(element, type, func) {
    return element.removeEventListener(type, func);
  },
  _markerDefaults = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal"
  },
  _defaults = {
    toggleActions: "play",
    anticipatePin: 0
  },
  _keywords = {
    top: 0,
    left: 0,
    center: 0.5,
    bottom: 1,
    right: 1
  },
  _offsetToPx = function _offsetToPx(value, size) {
    if (_isString(value)) {
      var eqIndex = value.indexOf("="),
        relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;
      if (~eqIndex) {
        value.indexOf("%") > eqIndex && (relative *= size / 100);
        value = value.substr(0, eqIndex - 1);
      }
      value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
    }
    return value;
  },
  _createMarker = function _createMarker(type, name, container, direction, _ref5, offset, matchWidthEl) {
    var startColor = _ref5.startColor,
      endColor = _ref5.endColor,
      fontSize = _ref5.fontSize,
      indent = _ref5.indent,
      fontWeight = _ref5.fontWeight;
    var e = _doc.createElement("div"),
      useFixedPosition = _isViewport(container) || _getProxyProp(container, "pinType") === "fixed",
      isScroller = type.indexOf("scroller") !== -1,
      parent = useFixedPosition ? _body : container,
      isStart = type.indexOf("start") !== -1,
      color = isStart ? startColor : endColor,
      css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    css += "position:" + (isScroller && useFixedPosition ? "fixed;" : "absolute;");
    (isScroller || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
    matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
    e._isStart = isStart;
    e.setAttribute("class", "gsap-marker-" + type);
    e.style.cssText = css;
    e.innerText = name || name === 0 ? type + "-" + name : type;
    parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
    e._offset = e["offset" + direction.op.d2];
    _positionMarker(e, 0, direction, isStart);
    return e;
  },
  _positionMarker = function _positionMarker(marker, start, direction, flipped) {
    var vars = {
        display: "block"
      },
      side = direction[flipped ? "os2" : "p2"],
      oppositeSide = direction[flipped ? "p2" : "os2"];
    marker._isFlipped = flipped;
    vars[direction.a + "Percent"] = flipped ? -100 : 0;
    vars[direction.a] = flipped ? "1px" : 0;
    vars["border" + side + _Width] = 1;
    vars["border" + oppositeSide + _Width] = 0;
    vars[direction.p] = start + "px";
    gsap.set(marker, vars);
  },
  _triggers = [],
  _ids = {},
  _sync = function _sync() {
    return _request || (_request = _raf(_updateAll));
  },
  _onScroll = function _onScroll() {
    if (!_request) {
      _request = _raf(_updateAll);
      _lastScrollTime || _dispatch("scrollStart");
      _lastScrollTime = _getTime();
    }
  },
  _onResize = function _onResize() {
    return !_refreshing && !_ignoreResize && !_doc.fullscreenElement && _resizeDelay.restart(true);
  },
  // ignore resizes triggered by refresh()
  _listeners = {},
  _emptyArray = [],
  _media = [],
  _creatingMedia,
  // when ScrollTrigger.matchMedia() is called, we record the current media key here (like "(min-width: 800px)") so that we can assign it to everything that's created during that call. Then we can revert just those when necessary. In the ScrollTrigger's init() call, the _creatingMedia is recorded as a "media" property on the instance.
  _lastMediaTick,
  _onMediaChange = function _onMediaChange(e) {
    var tick = gsap.ticker.frame,
      matches = [],
      i = 0,
      index;
    if (_lastMediaTick !== tick || _startup) {
      _revertAll();
      for (; i < _media.length; i += 4) {
        index = _win.matchMedia(_media[i]).matches;
        if (index !== _media[i + 3]) {
          // note: some browsers fire the matchMedia event multiple times, like when going full screen, so we shouldn't call the function multiple times. Check to see if it's already matched.
          _media[i + 3] = index;
          index ? matches.push(i) : _revertAll(1, _media[i]) || _isFunction(_media[i + 2]) && _media[i + 2](); // Firefox doesn't update the "matches" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.
        }
      }
      _revertRecorded(); // in case killing/reverting any of the animations actually added inline styles back.
      for (i = 0; i < matches.length; i++) {
        index = matches[i];
        _creatingMedia = _media[index];
        _media[index + 2] = _media[index + 1](e);
      }
      _creatingMedia = 0;
      _coreInitted && _refreshAll(0, 1);
      _lastMediaTick = tick;
      _dispatch("matchMedia");
    }
  },
  _softRefresh2 = function _softRefresh() {
    return _removeListener(ScrollTrigger, "scrollEnd", _softRefresh2) || _refreshAll(true);
  },
  _dispatch = function _dispatch(type) {
    return _listeners[type] && _listeners[type].map(function (f) {
      return f();
    }) || _emptyArray;
  },
  _savedStyles = [],
  // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.
  _revertRecorded = function _revertRecorded(media) {
    for (var i = 0; i < _savedStyles.length; i += 5) {
      if (!media || _savedStyles[i + 4] === media) {
        _savedStyles[i].style.cssText = _savedStyles[i + 1];
        _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
        _savedStyles[i + 3].uncache = 1;
      }
    }
  },
  _revertAll = function _revertAll(kill, media) {
    var trigger;
    for (_i = 0; _i < _triggers.length; _i++) {
      trigger = _triggers[_i];
      if (!media || trigger.media === media) {
        if (kill) {
          trigger.kill(1);
        } else {
          trigger.revert();
        }
      }
    }
    media && _revertRecorded(media);
    media || _dispatch("revert");
  },
  _refreshAll = function _refreshAll(force, skipRevert) {
    if (_lastScrollTime && !force) {
      _addListener(ScrollTrigger, "scrollEnd", _softRefresh2);
      return;
    }
    var refreshInits = _dispatch("refreshInit");
    _sort && ScrollTrigger.sort();
    skipRevert || _revertAll();
    _triggers.forEach(function (t) {
      return t.refresh();
    }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.
    refreshInits.forEach(function (result) {
      return result && result.render && result.render(-1);
    }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.
    _scrollers.forEach(function (obj) {
      return typeof obj === "function" && (obj.rec = 0);
    }); // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.
    _resizeDelay.pause();
    _dispatch("refresh");
  },
  _lastScroll = 0,
  _direction = 1,
  _updateAll = function _updateAll() {
    var l = _triggers.length,
      time = _getTime(),
      recordVelocity = time - _time1 >= 50,
      scroll = l && _triggers[0].scroll();
    _direction = _lastScroll > scroll ? -1 : 1;
    _lastScroll = scroll;
    if (recordVelocity) {
      if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
        _lastScrollTime = 0;
        _dispatch("scrollEnd");
      }
      _time2 = _time1;
      _time1 = time;
    }
    if (_direction < 0) {
      _i = l;
      while (_i-- > 0) {
        _triggers[_i] && _triggers[_i].update(0, recordVelocity);
      }
      _direction = 1;
    } else {
      for (_i = 0; _i < l; _i++) {
        _triggers[_i] && _triggers[_i].update(0, recordVelocity);
      }
    }
    _request = 0;
  },
  _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "grid-column-start", "grid-column-end", "grid-row-start", "grid-row-end", "grid-area", "justify-self", "align-self", "place-self"],
  _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),
  _swapPinOut = function _swapPinOut(pin, spacer, state) {
    _setState(state);
    if (pin.parentNode === spacer) {
      var parent = spacer.parentNode;
      if (parent) {
        parent.insertBefore(pin, spacer);
        parent.removeChild(spacer);
      }
    }
  },
  _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
    if (pin.parentNode !== spacer) {
      var i = _propNamesToCopy.length,
        spacerStyle = spacer.style,
        pinStyle = pin.style,
        p;
      while (i--) {
        p = _propNamesToCopy[i];
        spacerStyle[p] = cs[p];
      }
      spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
      cs.display === "inline" && (spacerStyle.display = "inline-block");
      pinStyle[_bottom] = pinStyle[_right] = "auto";
      spacerStyle.overflow = "visible";
      spacerStyle.boxSizing = "border-box";
      spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
      spacerStyle[_height] = _getSize(pin, _vertical) + _px;
      spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";
      _setState(spacerState);
      pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
      pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
      pinStyle[_padding] = cs[_padding];
      pin.parentNode.insertBefore(spacer, pin);
      spacer.appendChild(pin);
    }
  },
  _capsExp = /([A-Z])/g,
  _setState = function _setState(state) {
    if (state) {
      var style = state.t.style,
        l = state.length,
        i = 0,
        p,
        value;
      (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off
      for (; i < l; i += 2) {
        value = state[i + 1];
        p = state[i];
        if (value) {
          style[p] = value;
        } else if (style[p]) {
          style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
        }
      }
    }
  },
  _getState = function _getState(element) {
    // returns an Array with alternating values like [property, value, property, value] and a "t" property pointing to the target (element). Makes it fast and cheap.
    var l = _stateProps.length,
      style = element.style,
      state = [],
      i = 0;
    for (; i < l; i++) {
      state.push(_stateProps[i], style[_stateProps[i]]);
    }
    state.t = element;
    return state;
  },
  _copyState = function _copyState(state, override, omitOffsets) {
    var result = [],
      l = state.length,
      i = omitOffsets ? 8 : 0,
      // skip top, left, right, bottom if omitOffsets is true
      p;
    for (; i < l; i += 2) {
      p = state[i];
      result.push(p, p in override ? override[p] : state[i + 1]);
    }
    result.t = state.t;
    return result;
  },
  _winOffsets = {
    left: 0,
    top: 0
  },
  _parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax) {
    _isFunction(value) && (value = value(self));
    if (_isString(value) && value.substr(0, 3) === "max") {
      value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
    }
    if (!_isNumber(value)) {
      _isFunction(trigger) && (trigger = trigger(self));
      var element = _toArray(trigger)[0] || _body,
        bounds = _getBounds(element) || {},
        offsets = value.split(" "),
        localOffset,
        globalOffset,
        display;
      if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
        // if display is "none", it won't report getBoundingClientRect() properly
        display = element.style.display;
        element.style.display = "block";
        bounds = _getBounds(element);
        display ? element.style.display = display : element.style.removeProperty("display");
      }
      localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
      globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
      value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
      markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
      scrollerSize -= scrollerSize - globalOffset; // adjust for the marker
    } else if (markerScroller) {
      _positionMarker(markerScroller, scrollerSize, direction, true);
    }
    if (marker) {
      var position = value + scrollerSize,
        isStart = marker._isStart;
      scrollerMax = "scroll" + direction.d2;
      _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[scrollerMax], _docEl[scrollerMax]) : marker.parentNode[scrollerMax]) <= position + 1);
      if (useFixedPosition) {
        scrollerBounds = _getBounds(markerScroller);
        useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
      }
    }
    return Math.round(value);
  },
  _prefixExp = /(?:webkit|moz|length|cssText|inset)/i,
  _reparent = function _reparent(element, parent, top, left) {
    if (element.parentNode !== parent) {
      var style = element.style,
        p,
        cs;
      if (parent === _body) {
        element._stOrig = style.cssText; // record original inline styles so we can revert them later
        cs = _getComputedStyle(element);
        for (p in cs) {
          // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.
          if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
            style[p] = cs[p];
          }
        }
        style.top = top;
        style.left = left;
      } else {
        style.cssText = element._stOrig;
      }
      gsap.core.getCache(element).uncache = 1;
      parent.appendChild(element);
    }
  },
  // returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)
  _getTweenCreator = function _getTweenCreator(scroller, direction) {
    var getScroll = _getScrollFunc(scroller, direction),
      prop = "_scroll" + direction.p2,
      // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.
      lastScroll1,
      lastScroll2,
      _getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {
        var tween = _getTween.tween,
          onComplete = vars.onComplete,
          modifiers = {};
        tween && tween.kill();
        lastScroll1 = Math.round(initialValue);
        vars[prop] = scrollTo;
        vars.modifiers = modifiers;
        modifiers[prop] = function (value) {
          value = _round(getScroll()); // round because in some [very uncommon] Windows environments, it can get reported with decimals even though it was set without.
          if (value !== lastScroll1 && value !== lastScroll2 && Math.abs(value - lastScroll1) > 2) {
            // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.
            tween.kill();
            _getTween.tween = 0;
          } else {
            value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;
          }
          lastScroll2 = lastScroll1;
          return lastScroll1 = _round(value);
        };
        vars.onComplete = function () {
          _getTween.tween = 0;
          onComplete && onComplete.call(tween);
        };
        tween = _getTween.tween = gsap.to(scroller, vars);
        return tween;
      };
    scroller[prop] = getScroll;
    scroller.addEventListener("wheel", function () {
      return _getTween.tween && _getTween.tween.kill() && (_getTween.tween = 0);
    }); // Windows machines handle mousewheel scrolling in chunks (like "3 lines per scroll") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.
    return _getTween;
  };
_horizontal.op = _vertical;
var ScrollTrigger = /*#__PURE__*/function () {
  function ScrollTrigger(vars, animation) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, ScrollTrigger);
    _coreInitted || ScrollTrigger.register(gsap) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
    this.init(vars, animation);
  }
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(ScrollTrigger, [{
    key: "init",
    value: function init(vars, animation) {
      this.progress = this.start = 0;
      this.vars && this.kill(1); // in case it's being initted again
      if (!_enabled) {
        this.update = this.refresh = this.kill = _passThrough;
        return;
      }
      vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {
        trigger: vars
      } : vars, _defaults);
      var direction = vars.horizontal ? _horizontal : _vertical,
        _vars = vars,
        onUpdate = _vars.onUpdate,
        toggleClass = _vars.toggleClass,
        id = _vars.id,
        onToggle = _vars.onToggle,
        onRefresh = _vars.onRefresh,
        scrub = _vars.scrub,
        trigger = _vars.trigger,
        pin = _vars.pin,
        pinSpacing = _vars.pinSpacing,
        invalidateOnRefresh = _vars.invalidateOnRefresh,
        anticipatePin = _vars.anticipatePin,
        onScrubComplete = _vars.onScrubComplete,
        onSnapComplete = _vars.onSnapComplete,
        once = _vars.once,
        snap = _vars.snap,
        pinReparent = _vars.pinReparent,
        isToggle = !scrub && scrub !== 0,
        scroller = _toArray(vars.scroller || _win)[0],
        scrollerCache = gsap.core.getCache(scroller),
        isViewport = _isViewport(scroller),
        useFixedPosition = "pinType" in vars ? vars.pinType === "fixed" : isViewport || _getProxyProp(scroller, "pinType") === "fixed",
        callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],
        toggleActions = isToggle && vars.toggleActions.split(" "),
        markers = "markers" in vars ? vars.markers : _defaults.markers,
        borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0,
        self = this,
        onRefreshInit = vars.onRefreshInit && function () {
          return vars.onRefreshInit(self);
        },
        getScrollerSize = _getSizeFunc(scroller, isViewport, direction),
        getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),
        lastSnap = 0,
        tweenTo,
        pinCache,
        snapFunc,
        scroll1,
        scroll2,
        start,
        end,
        markerStart,
        markerEnd,
        markerStartTrigger,
        markerEndTrigger,
        markerVars,
        change,
        pinOriginalState,
        pinActiveState,
        pinState,
        spacer,
        offset,
        pinGetter,
        pinSetter,
        pinStart,
        pinChange,
        spacingStart,
        spacerState,
        markerStartSetter,
        markerEndSetter,
        cs,
        snap1,
        snap2,
        scrubTween,
        scrubSmooth,
        snapDurClamp,
        snapDelayedCall,
        prevProgress,
        prevScroll,
        prevAnimProgress;
      self.media = _creatingMedia;
      anticipatePin *= 45;
      self.scroller = scroller;
      self.scroll = _getScrollFunc(scroller, direction);
      scroll1 = self.scroll();
      self.vars = vars;
      animation = animation || vars.animation;
      "refreshPriority" in vars && (_sort = 1);
      scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
        top: _getTweenCreator(scroller, _vertical),
        left: _getTweenCreator(scroller, _horizontal)
      };
      self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];
      if (animation) {
        animation.vars.lazy = false;
        animation._initted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.render(0, true, true);
        self.animation = animation.pause();
        animation.scrollTrigger = self;
        scrubSmooth = _isNumber(scrub) && scrub;
        scrubSmooth && (scrubTween = gsap.to(animation, {
          ease: "power3",
          duration: scrubSmooth,
          onComplete: function onComplete() {
            return onScrubComplete && onScrubComplete(self);
          }
        }));
        snap1 = 0;
        id || (id = animation.vars.id);
      }
      _triggers.push(self);
      if (snap) {
        _isObject(snap) || (snap = {
          snapTo: snap
        });
        "scrollBehavior" in _body.style && gsap.set(isViewport ? [_body, _docEl] : scroller, {
          scrollBehavior: "auto"
        }); // smooth scrolling doesn't work with snap.
        snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : gsap.utils.snap(snap.snapTo);
        snapDurClamp = snap.duration || {
          min: 0.1,
          max: 2
        };
        snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);
        snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {
          if (Math.abs(self.getVelocity()) < 10 && !_pointerIsDown && lastSnap !== self.scroll()) {
            var totalProgress = animation && !isToggle ? animation.totalProgress() : self.progress,
              velocity = (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0,
              change1 = gsap.utils.clamp(-self.progress, 1 - self.progress, _abs(velocity / 2) * velocity / 0.185),
              naturalEnd = self.progress + (snap.inertia === false ? 0 : change1),
              endValue = _clamp(0, 1, snapFunc(naturalEnd, self)),
              scroll = self.scroll(),
              endScroll = Math.round(start + endValue * change),
              _snap = snap,
              onStart = _snap.onStart,
              _onInterrupt = _snap.onInterrupt,
              _onComplete = _snap.onComplete,
              tween = tweenTo.tween;
            if (scroll <= end && scroll >= start && endScroll !== scroll) {
              if (tween && !tween._initted && tween.data <= Math.abs(endScroll - scroll)) {
                // there's an overlapping snap! So we must figure out which one is closer and let that tween live.
                return;
              }
              if (snap.inertia === false) {
                change1 = endValue - self.progress;
              }
              tweenTo(endScroll, {
                duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
                ease: snap.ease || "power3",
                data: Math.abs(endScroll - scroll),
                // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
                onInterrupt: function onInterrupt() {
                  return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);
                },
                onComplete: function onComplete() {
                  lastSnap = self.scroll();
                  snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
                  onSnapComplete && onSnapComplete(self);
                  _onComplete && _onComplete(self);
                }
              }, scroll, change1 * change, endScroll - scroll - change1 * change);
              onStart && onStart(self, tweenTo.tween);
            }
          } else if (self.isActive) {
            snapDelayedCall.restart(true);
          }
        }).pause();
      }
      id && (_ids[id] = self);
      trigger = self.trigger = _toArray(trigger || pin)[0];
      pin = pin === true ? trigger : _toArray(pin)[0];
      _isString(toggleClass) && (toggleClass = {
        targets: trigger,
        className: toggleClass
      });
      if (pin) {
        pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default.
        self.pin = pin;
        vars.force3D !== false && gsap.set(pin, {
          force3D: true
        });
        pinCache = gsap.core.getCache(pin);
        if (!pinCache.spacer) {
          // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the "original" pin state after it has already been affected by another ScrollTrigger.
          pinCache.spacer = spacer = _doc.createElement("div");
          spacer.setAttribute("class", "pin-spacer" + (id ? " pin-spacer-" + id : ""));
          pinCache.pinState = pinOriginalState = _getState(pin);
        } else {
          pinOriginalState = pinCache.pinState;
        }
        self.spacer = spacer = pinCache.spacer;
        cs = _getComputedStyle(pin);
        spacingStart = cs[pinSpacing + direction.os2];
        pinGetter = gsap.getProperty(pin);
        pinSetter = gsap.quickSetter(pin, direction.a, _px);
        // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = "hidden"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).
        _swapPinIn(pin, spacer, cs);
        pinState = _getState(pin);
      }
      if (markers) {
        markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;
        markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
        markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
        offset = markerStartTrigger["offset" + direction.op.d2];
        markerStart = _createMarker("start", id, scroller, direction, markerVars, offset);
        markerEnd = _createMarker("end", id, scroller, direction, markerVars, offset);
        if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
          _makePositionable(isViewport ? _body : scroller);
          gsap.set([markerStartTrigger, markerEndTrigger], {
            force3D: true
          });
          markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);
          markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);
        }
      }
      self.revert = function (revert) {
        var r = revert !== false || !self.enabled,
          prevRefreshing = _refreshing;
        if (r !== self.isReverted) {
          if (r) {
            self.scroll.rec || (self.scroll.rec = self.scroll());
            prevScroll = Math.max(self.scroll(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.
            prevProgress = self.progress;
            prevAnimProgress = animation && animation.progress();
          }
          markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
            return m.style.display = r ? "none" : "block";
          });
          r && (_refreshing = 1);
          self.update(r); // make sure the pin is back in its original position so that all the measurements are correct.
          _refreshing = prevRefreshing;
          pin && (r ? _swapPinOut(pin, spacer, pinOriginalState) : (!pinReparent || !self.isActive) && _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState));
          self.isReverted = r;
        }
      };
      self.refresh = function (soft, force) {
        if ((_refreshing || !self.enabled) && !force) {
          return;
        }
        if (pin && soft && _lastScrollTime) {
          _addListener(ScrollTrigger, "scrollEnd", _softRefresh2);
          return;
        }
        _refreshing = 1;
        scrubTween && scrubTween.pause();
        invalidateOnRefresh && animation && animation.progress(0).invalidate();
        self.isReverted || self.revert();
        var size = getScrollerSize(),
          scrollerBounds = getScrollerOffsets(),
          max = _maxScroll(scroller, direction),
          offset = 0,
          otherPinOffset = 0,
          parsedEnd = vars.end,
          parsedEndTrigger = vars.endTrigger || trigger,
          parsedStart = vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"),
          pinnedContainer = vars.pinnedContainer && _toArray(vars.pinnedContainer)[0],
          triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,
          i = triggerIndex,
          cs,
          bounds,
          scroll,
          isVertical,
          override,
          curTrigger,
          curPin,
          oppositeScroll,
          initted,
          revertedPins;
        while (i--) {
          // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things "rewind" properly.
          curTrigger = _triggers[i];
          curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = 1); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.
          curPin = curTrigger.pin;
          if (curPin && (curPin === trigger || curPin === pin) && !curTrigger.isReverted) {
            revertedPins || (revertedPins = []);
            revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly
            curTrigger.revert();
          }
        }
        start = _parsePosition(parsedStart, trigger, size, direction, self.scroll(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max) || (pin ? -0.001 : 0);
        _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));
        if (_isString(parsedEnd) && !parsedEnd.indexOf("+=")) {
          if (~parsedEnd.indexOf(" ")) {
            parsedEnd = (_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
          } else {
            offset = _offsetToPx(parsedEnd.substr(2), size);
            parsedEnd = _isString(parsedStart) ? parsedStart : start + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.
            parsedEndTrigger = trigger;
          }
        }
        end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, self.scroll() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max)) || -0.001;
        change = end - start || (start -= 0.01) && 0.001;
        offset = 0;
        i = triggerIndex;
        while (i--) {
          curTrigger = _triggers[i];
          curPin = curTrigger.pin;
          if (curPin && curTrigger.start - curTrigger._pinPush < start) {
            cs = curTrigger.end - curTrigger.start;
            (curPin === trigger || curPin === pinnedContainer) && (offset += cs);
            curPin === pin && (otherPinOffset += cs);
          }
        }
        start += offset;
        end += offset;
        self._pinPush = otherPinOffset;
        if (markerStart && offset) {
          // offset the markers if necessary
          cs = {};
          cs[direction.a] = "+=" + offset;
          pinnedContainer && (cs[direction.p] = "-=" + self.scroll());
          gsap.set([markerStart, markerEnd], cs);
        }
        if (pin) {
          cs = _getComputedStyle(pin);
          isVertical = direction === _vertical;
          scroll = self.scroll(); // recalculate because the triggers can affect the scroll
          pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
          !max && end > 1 && ((isViewport ? _body : scroller).style["overflow-" + direction.a] = "scroll"); // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://greensock.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/
          _swapPinIn(pin, spacer, cs);
          pinState = _getState(pin);
          // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.
          bounds = _getBounds(pin, true);
          oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();
          if (pinSpacing) {
            spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
            spacerState.t = spacer;
            i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
            i && spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).
            _setState(spacerState);
            useFixedPosition && self.scroll(prevScroll);
          }
          if (useFixedPosition) {
            override = {
              top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
              left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
              boxSizing: "border-box",
              position: "fixed"
            };
            override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
            override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
            override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
            override[_padding] = cs[_padding];
            override[_padding + _Top] = cs[_padding + _Top];
            override[_padding + _Right] = cs[_padding + _Right];
            override[_padding + _Bottom] = cs[_padding + _Bottom];
            override[_padding + _Left] = cs[_padding + _Left];
            pinActiveState = _copyState(pinOriginalState, override, pinReparent);
          }
          if (animation) {
            // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.
            initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.
            _suppressOverwrites(1);
            animation.render(animation.duration(), true, true);
            pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
            change !== pinChange && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.
            animation.render(0, true, true);
            initted || animation.invalidate();
            _suppressOverwrites(0);
          } else {
            pinChange = change;
          }
        } else if (trigger && self.scroll()) {
          // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()
          bounds = trigger.parentNode;
          while (bounds && bounds !== _body) {
            if (bounds._pinOffset) {
              start -= bounds._pinOffset;
              end -= bounds._pinOffset;
            }
            bounds = bounds.parentNode;
          }
        }
        revertedPins && revertedPins.forEach(function (t) {
          return t.revert(false);
        });
        self.start = start;
        self.end = end;
        scroll1 = scroll2 = self.scroll(); // reset velocity
        scroll1 < prevScroll && self.scroll(prevScroll);
        self.revert(false);
        _refreshing = 0;
        animation && isToggle && animation._initted && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().
        if (prevProgress !== self.progress) {
          // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.
          scrubTween && animation.totalProgress(prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.
          self.progress = prevProgress;
          self.update();
        }
        pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));
        onRefresh && onRefresh(self);
      };
      self.getVelocity = function () {
        return (self.scroll() - scroll2) / (_getTime() - _time2) * 1000 || 0;
      };
      self.update = function (reset, recordVelocity) {
        var scroll = self.scroll(),
          p = reset ? 0 : (scroll - start) / change,
          clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
          prevProgress = self.progress,
          isActive,
          wasActive,
          toggleState,
          action,
          stateChanged,
          toggled;
        if (recordVelocity) {
          scroll2 = scroll1;
          scroll1 = scroll;
          if (snap) {
            snap2 = snap1;
            snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
          }
        }
        // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).
        anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin && (clipped = 0.0001);
        if (clipped !== prevProgress && self.enabled) {
          isActive = self.isActive = !!clipped && clipped < 1;
          wasActive = !!prevProgress && prevProgress < 1;
          toggled = isActive !== wasActive;
          stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)
          self.direction = clipped > prevProgress ? 1 : -1;
          self.progress = clipped;
          if (!isToggle) {
            if (scrubTween && !_refreshing && !_startup) {
              scrubTween.vars.totalProgress = clipped;
              scrubTween.invalidate().restart();
            } else if (animation) {
              animation.totalProgress(clipped, !!_refreshing);
            }
          }
          if (pin) {
            reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);
            if (!useFixedPosition) {
              pinSetter(pinStart + pinChange * clipped);
            } else if (stateChanged) {
              action = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)
              if (pinReparent) {
                if (!reset && (isActive || action)) {
                  var bounds = _getBounds(pin, true),
                    _offset = scroll - start;
                  _reparent(pin, _body, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);
                } else {
                  _reparent(pin, spacer);
                }
              }
              _setState(isActive || action ? pinActiveState : pinState);
              pinChange !== change && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !action ? pinChange : 0));
            }
          }
          snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);
          toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function (el) {
            return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
          }); // classes could affect positioning, so do it even if reset or refreshing is true.
          onUpdate && !isToggle && !reset && onUpdate(self);
          if (stateChanged && !_refreshing) {
            toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.
            if (isToggle) {
              action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the "enter" action, we should switch to the "leave" in this case (but only if one is defined)
              if (animation && (action === "complete" || action === "reset" || action in animation)) {
                if (action === "complete") {
                  animation.pause().totalProgress(1);
                } else if (action === "reset") {
                  animation.restart(true).pause();
                } else if (action === "restart") {
                  animation.restart(true);
                } else {
                  animation[action]();
                }
              }
              onUpdate && onUpdate(self);
            }
            if (toggled || !_limitCallbacks) {
              // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.
              onToggle && toggled && onToggle(self);
              callbacks[toggleState] && callbacks[toggleState](self);
              once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.
              if (!toggled) {
                // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order
                toggleState = clipped === 1 ? 1 : 3;
                callbacks[toggleState] && callbacks[toggleState](self);
              }
            }
          } else if (isToggle && onUpdate && !_refreshing) {
            onUpdate(self);
          }
        }
        // update absolutely-positioned markers (only if the scroller isn't the viewport)
        if (markerEndSetter) {
          markerStartSetter(scroll + (markerStartTrigger._isFlipped ? 1 : 0));
          markerEndSetter(scroll);
        }
      };
      self.enable = function (reset, refresh) {
        if (!self.enabled) {
          self.enabled = true;
          _addListener(scroller, "resize", _onResize);
          _addListener(scroller, "scroll", _onScroll);
          onRefreshInit && _addListener(ScrollTrigger, "refreshInit", onRefreshInit);
          if (reset !== false) {
            self.progress = prevProgress = 0;
            scroll1 = scroll2 = lastSnap = self.scroll();
          }
          refresh !== false && self.refresh();
        }
      };
      self.getTween = function (snap) {
        return snap && tweenTo ? tweenTo.tween : scrubTween;
      };
      self.disable = function (reset, allowAnimation) {
        if (self.enabled) {
          reset !== false && self.revert();
          self.enabled = self.isActive = false;
          allowAnimation || scrubTween && scrubTween.pause();
          prevScroll = 0;
          pinCache && (pinCache.uncache = 1);
          onRefreshInit && _removeListener(ScrollTrigger, "refreshInit", onRefreshInit);
          if (snapDelayedCall) {
            snapDelayedCall.pause();
            tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
          }
          if (!isViewport) {
            var i = _triggers.length;
            while (i--) {
              if (_triggers[i].scroller === scroller && _triggers[i] !== self) {
                return; //don't remove the listeners if there are still other triggers referencing it.
              }
            }
            _removeListener(scroller, "resize", _onResize);
            _removeListener(scroller, "scroll", _onScroll);
          }
        }
      };
      self.kill = function (revert, allowAnimation) {
        self.disable(revert, allowAnimation);
        id && delete _ids[id];
        var i = _triggers.indexOf(self);
        _triggers.splice(i, 1);
        i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...
        if (animation) {
          animation.scrollTrigger = null;
          revert && animation.render(-1);
          allowAnimation || animation.kill();
        }
        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
          return m.parentNode && m.parentNode.removeChild(m);
        });
        if (pin) {
          pinCache && (pinCache.uncache = 1);
          i = 0;
          _triggers.forEach(function (t) {
            return t.pin === pin && i++;
          });
          i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.
        }
      };
      self.enable(false, false);
      !animation || !animation.add || change ? self.refresh() : gsap.delayedCall(0.01, function () {
        return start || end || self.refresh();
      }) && (change = 0.01) && (start = end = 0); // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If "change" is defined, we know it must be re-enabling, thus we can refresh() right away.
    }
  }], [{
    key: "register",
    value: function register(core) {
      if (!_coreInitted) {
        gsap = core || _getGSAP();
        if (_windowExists() && window.document) {
          _win = window;
          _doc = document;
          _docEl = _doc.documentElement;
          _body = _doc.body;
        }
        if (gsap) {
          _toArray = gsap.utils.toArray;
          _clamp = gsap.utils.clamp;
          _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;
          gsap.core.globals("ScrollTrigger", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a "name" property.
          if (_body) {
            _raf = _win.requestAnimationFrame || function (f) {
              return setTimeout(f, 16);
            };
            _addListener(_win, "wheel", _onScroll);
            _root = [_win, _doc, _docEl, _body];
            _addListener(_doc, "scroll", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!
            var bodyStyle = _body.style,
              border = bodyStyle.borderTop,
              bounds;
            bodyStyle.borderTop = "1px solid #000"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.
            bounds = _getBounds(_body);
            _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding
            _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
            border ? bodyStyle.borderTop = border : bodyStyle.removeProperty("border-top");
            _syncInterval = setInterval(_sync, 200);
            gsap.delayedCall(0.5, function () {
              return _startup = 0;
            });
            _addListener(_doc, "touchcancel", _passThrough); // some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document.
            _addListener(_body, "touchstart", _passThrough); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/
            _multiListener(_addListener, _doc, "pointerdown,touchstart,mousedown", function () {
              return _pointerIsDown = 1;
            });
            _multiListener(_addListener, _doc, "pointerup,touchend,mouseup", function () {
              return _pointerIsDown = 0;
            });
            _transformProp = gsap.utils.checkPrefix("transform");
            _stateProps.push(_transformProp);
            _coreInitted = _getTime();
            _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();
            _autoRefresh = [_doc, "visibilitychange", function () {
              var w = _win.innerWidth,
                h = _win.innerHeight;
              if (_doc.hidden) {
                _prevWidth = w;
                _prevHeight = h;
              } else if (_prevWidth !== w || _prevHeight !== h) {
                _onResize();
              }
            }, _doc, "DOMContentLoaded", _refreshAll, _win, "load", function () {
              return _lastScrollTime || _refreshAll();
            }, _win, "resize", _onResize];
            _iterateAutoRefresh(_addListener);
          }
        }
      }
      return _coreInitted;
    }
  }, {
    key: "defaults",
    value: function defaults(config) {
      for (var p in config) {
        _defaults[p] = config[p];
      }
    }
  }, {
    key: "kill",
    value: function kill() {
      _enabled = 0;
      _triggers.slice(0).forEach(function (trigger) {
        return trigger.kill(1);
      });
    }
  }, {
    key: "config",
    value: function config(vars) {
      "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
      var ms = vars.syncInterval;
      ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
      if ("autoRefreshEvents" in vars) {
        _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || "none");
        _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
      }
    }
  }, {
    key: "scrollerProxy",
    value: function scrollerProxy(target, vars) {
      var t = _toArray(target)[0],
        i = _scrollers.indexOf(t),
        isViewport = _isViewport(t);
      if (~i) {
        _scrollers.splice(i, isViewport ? 6 : 2);
      }
      isViewport ? _proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _proxies.unshift(t, vars);
    }
  }, {
    key: "matchMedia",
    value: function matchMedia(vars) {
      // _media is populated in the following order: mediaQueryString, onMatch, onUnmatch, isMatched. So if there are two media queries, the Array would have a length of 8
      var mq, p, i, func, result;
      for (p in vars) {
        i = _media.indexOf(p);
        func = vars[p];
        _creatingMedia = p;
        if (p === "all") {
          func();
        } else {
          mq = _win.matchMedia(p);
          if (mq) {
            mq.matches && (result = func());
            if (~i) {
              _media[i + 1] = _combineFunc(_media[i + 1], func);
              _media[i + 2] = _combineFunc(_media[i + 2], result);
            } else {
              i = _media.length;
              _media.push(p, func, result);
              mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
            }
            _media[i + 3] = mq.matches;
          }
        }
        _creatingMedia = 0;
      }
      return _media;
    }
  }, {
    key: "clearMatchMedia",
    value: function clearMatchMedia(query) {
      query || (_media.length = 0);
      query = _media.indexOf(query);
      query >= 0 && _media.splice(query, 4);
    }
  }]);
}();
ScrollTrigger.version = "3.7.0";
ScrollTrigger.saveStyles = function (targets) {
  return targets ? _toArray(targets).forEach(function (target) {
    // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]
    if (target && target.style) {
      var i = _savedStyles.indexOf(target);
      i >= 0 && _savedStyles.splice(i, 5);
      _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap.core.getCache(target), _creatingMedia);
    }
  }) : _savedStyles;
};
ScrollTrigger.revert = function (soft, media) {
  return _revertAll(!soft, media);
};
ScrollTrigger.create = function (vars, animation) {
  return new ScrollTrigger(vars, animation);
};
ScrollTrigger.refresh = function (safe) {
  return safe ? _onResize() : _refreshAll(true);
};
ScrollTrigger.update = _updateAll;
ScrollTrigger.maxScroll = function (element, horizontal) {
  return _maxScroll(element, horizontal ? _horizontal : _vertical);
};
ScrollTrigger.getScrollFunc = function (element, horizontal) {
  return _getScrollFunc(_toArray(element)[0], horizontal ? _horizontal : _vertical);
};
ScrollTrigger.getById = function (id) {
  return _ids[id];
};
ScrollTrigger.getAll = function () {
  return _triggers.slice(0);
};
ScrollTrigger.isScrolling = function () {
  return !!_lastScrollTime;
};
ScrollTrigger.addEventListener = function (type, callback) {
  var a = _listeners[type] || (_listeners[type] = []);
  ~a.indexOf(callback) || a.push(callback);
};
ScrollTrigger.removeEventListener = function (type, callback) {
  var a = _listeners[type],
    i = a && a.indexOf(callback);
  i >= 0 && a.splice(i, 1);
};
ScrollTrigger.batch = function (targets, vars) {
  var result = [],
    varsCopy = {},
    interval = vars.interval || 0.016,
    batchMax = vars.batchMax || 1e9,
    proxyCallback = function proxyCallback(type, callback) {
      var elements = [],
        triggers = [],
        delay = gsap.delayedCall(interval, function () {
          callback(elements, triggers);
          elements = [];
          triggers = [];
        }).pause();
      return function (self) {
        elements.length || delay.restart(true);
        elements.push(self.trigger);
        triggers.push(self);
        batchMax <= elements.length && delay.progress(1);
      };
    },
    p;
  for (p in vars) {
    varsCopy[p] = p.substr(0, 2) === "on" && _isFunction(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
  }
  if (_isFunction(batchMax)) {
    batchMax = batchMax();
    _addListener(ScrollTrigger, "refresh", function () {
      return batchMax = vars.batchMax();
    });
  }
  _toArray(targets).forEach(function (target) {
    var config = {};
    for (p in varsCopy) {
      config[p] = varsCopy[p];
    }
    config.trigger = target;
    result.push(ScrollTrigger.create(config));
  });
  return result;
};
ScrollTrigger.sort = function (func) {
  return _triggers.sort(func || function (a, b) {
    return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);
  });
};
_getGSAP() && gsap.registerPlugin(ScrollTrigger);


/***/ }),

/***/ "./src/assets/scripts/gsap/gsap-core.js":
/*!**********************************************!*\
  !*** ./src/assets/scripts/gsap/gsap-core.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Animation: () => (/* binding */ Animation),
/* harmony export */   Back: () => (/* binding */ Back),
/* harmony export */   Bounce: () => (/* binding */ Bounce),
/* harmony export */   Circ: () => (/* binding */ Circ),
/* harmony export */   Cubic: () => (/* binding */ Cubic),
/* harmony export */   Elastic: () => (/* binding */ Elastic),
/* harmony export */   Expo: () => (/* binding */ Expo),
/* harmony export */   GSCache: () => (/* binding */ GSCache),
/* harmony export */   Linear: () => (/* binding */ Linear),
/* harmony export */   Power0: () => (/* binding */ Power0),
/* harmony export */   Power1: () => (/* binding */ Power1),
/* harmony export */   Power2: () => (/* binding */ Power2),
/* harmony export */   Power3: () => (/* binding */ Power3),
/* harmony export */   Power4: () => (/* binding */ Power4),
/* harmony export */   PropTween: () => (/* binding */ PropTween),
/* harmony export */   Quad: () => (/* binding */ Quad),
/* harmony export */   Quart: () => (/* binding */ Quart),
/* harmony export */   Quint: () => (/* binding */ Quint),
/* harmony export */   Sine: () => (/* binding */ Sine),
/* harmony export */   SteppedEase: () => (/* binding */ SteppedEase),
/* harmony export */   Strong: () => (/* binding */ Strong),
/* harmony export */   Timeline: () => (/* binding */ Timeline),
/* harmony export */   TimelineLite: () => (/* binding */ Timeline),
/* harmony export */   TimelineMax: () => (/* binding */ Timeline),
/* harmony export */   Tween: () => (/* binding */ Tween),
/* harmony export */   TweenLite: () => (/* binding */ Tween),
/* harmony export */   TweenMax: () => (/* binding */ Tween),
/* harmony export */   _checkPlugin: () => (/* binding */ _checkPlugin),
/* harmony export */   _colorExp: () => (/* binding */ _colorExp),
/* harmony export */   _colorStringFilter: () => (/* binding */ _colorStringFilter),
/* harmony export */   _config: () => (/* binding */ _config),
/* harmony export */   _forEachName: () => (/* binding */ _forEachName),
/* harmony export */   _getCache: () => (/* binding */ _getCache),
/* harmony export */   _getProperty: () => (/* binding */ _getProperty),
/* harmony export */   _getSetter: () => (/* binding */ _getSetter),
/* harmony export */   _isString: () => (/* binding */ _isString),
/* harmony export */   _isUndefined: () => (/* binding */ _isUndefined),
/* harmony export */   _missingPlugin: () => (/* binding */ _missingPlugin),
/* harmony export */   _numExp: () => (/* binding */ _numExp),
/* harmony export */   _numWithUnitExp: () => (/* binding */ _numWithUnitExp),
/* harmony export */   _plugins: () => (/* binding */ _plugins),
/* harmony export */   _relExp: () => (/* binding */ _relExp),
/* harmony export */   _removeLinkedListItem: () => (/* binding */ _removeLinkedListItem),
/* harmony export */   _renderComplexString: () => (/* binding */ _renderComplexString),
/* harmony export */   _replaceRandom: () => (/* binding */ _replaceRandom),
/* harmony export */   _round: () => (/* binding */ _round),
/* harmony export */   _roundModifier: () => (/* binding */ _roundModifier),
/* harmony export */   _setDefaults: () => (/* binding */ _setDefaults),
/* harmony export */   _sortPropTweensByPriority: () => (/* binding */ _sortPropTweensByPriority),
/* harmony export */   _ticker: () => (/* binding */ _ticker),
/* harmony export */   clamp: () => (/* binding */ clamp),
/* harmony export */   "default": () => (/* binding */ gsap),
/* harmony export */   distribute: () => (/* binding */ distribute),
/* harmony export */   getUnit: () => (/* binding */ getUnit),
/* harmony export */   gsap: () => (/* binding */ gsap),
/* harmony export */   interpolate: () => (/* binding */ _interpolate),
/* harmony export */   mapRange: () => (/* binding */ mapRange),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   pipe: () => (/* binding */ pipe),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   selector: () => (/* binding */ selector),
/* harmony export */   shuffle: () => (/* binding */ shuffle),
/* harmony export */   snap: () => (/* binding */ snap),
/* harmony export */   splitColor: () => (/* binding */ splitColor),
/* harmony export */   toArray: () => (/* binding */ toArray),
/* harmony export */   unitize: () => (/* binding */ unitize),
/* harmony export */   wrap: () => (/* binding */ _wrap),
/* harmony export */   wrapYoyo: () => (/* binding */ _wrapYoyo)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/esm/get.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");








function _callSuper(t, o, e) { return o = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_1__["default"])(o), (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0__["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_1__["default"])(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = (0,_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_1__["default"])(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
/*!
 * GSAP 3.7.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */

var _config = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
      lineHeight: ""
    }
  },
  _defaults = {
    duration: .5,
    overwrite: false,
    delay: 0
  },
  _suppressOverwrites,
  _bigNum = 1e8,
  _tinyNum = 1 / _bigNum,
  _2PI = Math.PI * 2,
  _HALF_PI = _2PI / 4,
  _gsID = 0,
  _sqrt = Math.sqrt,
  _cos = Math.cos,
  _sin = Math.sin,
  _isString = function _isString(value) {
    return typeof value === "string";
  },
  _isFunction = function _isFunction(value) {
    return typeof value === "function";
  },
  _isNumber = function _isNumber(value) {
    return typeof value === "number";
  },
  _isUndefined = function _isUndefined(value) {
    return typeof value === "undefined";
  },
  _isObject = function _isObject(value) {
    return (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_7__["default"])(value) === "object";
  },
  _isNotFalse = function _isNotFalse(value) {
    return value !== false;
  },
  _windowExists = function _windowExists() {
    return typeof window !== "undefined";
  },
  _isFuncOrString = function _isFuncOrString(value) {
    return _isFunction(value) || _isString(value);
  },
  _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
  // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
  _isArray = Array.isArray,
  _strictNumExp = /(?:-?\.?\d|\.)+/gi,
  //only numbers (including negatives and decimals) but NOT relative values.
  _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
  //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
  _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
  _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
  //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
  _relExp = /[+-]=-?[.\d]+/,
  _delimitedValueExp = /[^,'"\[\]\s]+/gi,
  // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
  _unitExp = /[\d.+\-=]+(?:e[-+]\d*)*/i,
  _globalTimeline,
  _win,
  _coreInitted,
  _doc,
  _globals = {},
  _installScope = {},
  _coreReady,
  _install = function _install(scope) {
    return (_installScope = _merge(scope, _globals)) && gsap;
  },
  _missingPlugin = function _missingPlugin(property, value) {
    return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
  },
  _warn = function _warn(message, suppress) {
    return !suppress && console.warn(message);
  },
  _addGlobal = function _addGlobal(name, obj) {
    return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
  },
  _emptyFunc = function _emptyFunc() {
    return 0;
  },
  _reservedProps = {},
  _lazyTweens = [],
  _lazyLookup = {},
  _lastRenderedFrame,
  _plugins = {},
  _effects = {},
  _nextGCFrame = 30,
  _harnessPlugins = [],
  _callbackNames = "",
  _harness = function _harness(targets) {
    var target = targets[0],
      harnessPlugin,
      i;
    _isObject(target) || _isFunction(target) || (targets = [targets]);
    if (!(harnessPlugin = (target._gsap || {}).harness)) {
      // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
      i = _harnessPlugins.length;
      while (i-- && !_harnessPlugins[i].targetTest(target)) {}
      harnessPlugin = _harnessPlugins[i];
    }
    i = targets.length;
    while (i--) {
      targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
    }
    return targets;
  },
  _getCache = function _getCache(target) {
    return target._gsap || _harness(toArray(target))[0]._gsap;
  },
  _getProperty = function _getProperty(target, property, v) {
    return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
  },
  _forEachName = function _forEachName(names, func) {
    return (names = names.split(",")).forEach(func) || names;
  },
  //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
  _round = function _round(value) {
    return Math.round(value * 100000) / 100000 || 0;
  },
  _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
    //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
    var l = toFind.length,
      i = 0;
    for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}
    return i < l;
  },
  _lazyRender = function _lazyRender() {
    var l = _lazyTweens.length,
      a = _lazyTweens.slice(0),
      i,
      tween;
    _lazyLookup = {};
    _lazyTweens.length = 0;
    for (i = 0; i < l; i++) {
      tween = a[i];
      tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
    }
  },
  _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
    _lazyTweens.length && _lazyRender();
    animation.render(time, suppressEvents, force);
    _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
  },
  _numericIfPossible = function _numericIfPossible(value) {
    var n = parseFloat(value);
    return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
  },
  _passThrough = function _passThrough(p) {
    return p;
  },
  _setDefaults = function _setDefaults(obj, defaults) {
    for (var p in defaults) {
      p in obj || (obj[p] = defaults[p]);
    }
    return obj;
  },
  _setKeyframeDefaults = function _setKeyframeDefaults(obj, defaults) {
    for (var p in defaults) {
      p in obj || p === "duration" || p === "ease" || (obj[p] = defaults[p]);
    }
  },
  _merge = function _merge(base, toMerge) {
    for (var p in toMerge) {
      base[p] = toMerge[p];
    }
    return base;
  },
  _mergeDeep2 = function _mergeDeep(base, toMerge) {
    for (var p in toMerge) {
      p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep2(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
    }
    return base;
  },
  _copyExcluding = function _copyExcluding(obj, excluding) {
    var copy = {},
      p;
    for (p in obj) {
      p in excluding || (copy[p] = obj[p]);
    }
    return copy;
  },
  _inheritDefaults = function _inheritDefaults(vars) {
    var parent = vars.parent || _globalTimeline,
      func = vars.keyframes ? _setKeyframeDefaults : _setDefaults;
    if (_isNotFalse(vars.inherit)) {
      while (parent) {
        func(vars, parent.vars.defaults);
        parent = parent.parent || parent._dp;
      }
    }
    return vars;
  },
  _arraysMatch = function _arraysMatch(a1, a2) {
    var i = a1.length,
      match = i === a2.length;
    while (match && i-- && a1[i] === a2[i]) {}
    return i < 0;
  },
  _addLinkedListItem = function _addLinkedListItem(parent, child) {
    var firstProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "_first";
    var lastProp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "_last";
    var sortBy = arguments.length > 4 ? arguments[4] : undefined;
    var prev = parent[lastProp],
      t;
    if (sortBy) {
      t = child[sortBy];
      while (prev && prev[sortBy] > t) {
        prev = prev._prev;
      }
    }
    if (prev) {
      child._next = prev._next;
      prev._next = child;
    } else {
      child._next = parent[firstProp];
      parent[firstProp] = child;
    }
    if (child._next) {
      child._next._prev = child;
    } else {
      parent[lastProp] = child;
    }
    child._prev = prev;
    child.parent = child._dp = parent;
    return child;
  },
  _removeLinkedListItem = function _removeLinkedListItem(parent, child) {
    var firstProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "_first";
    var lastProp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "_last";
    var prev = child._prev,
      next = child._next;
    if (prev) {
      prev._next = next;
    } else if (parent[firstProp] === child) {
      parent[firstProp] = next;
    }
    if (next) {
      next._prev = prev;
    } else if (parent[lastProp] === child) {
      parent[lastProp] = prev;
    }
    child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
  },
  _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
    child._act = 0;
  },
  _uncache = function _uncache(animation, child) {
    if (animation && (!child || child._end > animation._dur || child._start < 0)) {
      // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
      var a = animation;
      while (a) {
        a._dirty = 1;
        a = a.parent;
      }
    }
    return animation;
  },
  _recacheAncestors = function _recacheAncestors(animation) {
    var parent = animation.parent;
    while (parent && parent.parent) {
      //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
      parent._dirty = 1;
      parent.totalDuration();
      parent = parent.parent;
    }
    return animation;
  },
  _hasNoPausedAncestors2 = function _hasNoPausedAncestors(animation) {
    return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
  },
  _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
  },
  // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
  _animationCycle = function _animationCycle(tTime, cycleDuration) {
    var whole = Math.floor(tTime /= cycleDuration);
    return tTime && whole === tTime ? whole - 1 : whole;
  },
  _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
  },
  _setEnd = function _setEnd(animation) {
    return animation._end = _round(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
  },
  _alignPlayhead = function _alignPlayhead(animation, totalTime) {
    // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
    var parent = animation._dp;
    if (parent && parent.smoothChildTiming && animation._ts) {
      animation._start = _round(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
      _setEnd(animation);
      parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
    }
    return animation;
  },
  /*
  _totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
  	let cycleDuration = duration + repeatDelay,
  		time = _round(clampedTotalTime % cycleDuration);
  	if (time > duration) {
  		time = duration;
  	}
  	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
  },
  */
  _postAddChecks = function _postAddChecks(timeline, child) {
    var t;
    if (child._time || child._initted && !child._dur) {
      //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
      t = _parentToChildTotalTime(timeline.rawTime(), child);
      if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
        child.render(t, true);
      }
    }
    //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
    if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
      //in case any of the ancestors had completed but should now be enabled...
      if (timeline._dur < timeline.duration()) {
        t = timeline;
        while (t._dp) {
          t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.
          t = t._dp;
        }
      }
      timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
    }
  },
  _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
    child.parent && _removeFromParent(child);
    child._start = _round((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition2(timeline, position, child) : timeline._time) + child._delay);
    child._end = _round(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
    _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);
    _isFromOrFromStart(child) || (timeline._recent = child);
    skipChecks || _postAddChecks(timeline, child);
    return timeline;
  },
  _scrollTrigger = function _scrollTrigger(animation, trigger) {
    return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
  },
  _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {
    _initTween2(tween, totalTime);
    if (!tween._initted) {
      return 1;
    }
    if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
      _lazyTweens.push(tween);
      tween._lazy = [totalTime, suppressEvents];
      return 1;
    }
  },
  _parentPlayheadIsBeforeStart2 = function _parentPlayheadIsBeforeStart(_ref) {
    var parent = _ref.parent;
    return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent));
  },
  // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
  _isFromOrFromStart = function _isFromOrFromStart(_ref2) {
    var data = _ref2.data;
    return data === "isFromStart" || data === "isStart";
  },
  _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
    var prevRatio = tween.ratio,
      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart2(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
      repeatDelay = tween._rDelay,
      tTime = 0,
      pt,
      iteration,
      prevIteration;
    if (repeatDelay && tween._repeat) {
      // in case there's a zero-duration tween that has a repeat with a repeatDelay
      tTime = _clamp(0, tween._tDur, totalTime);
      iteration = _animationCycle(tTime, repeatDelay);
      prevIteration = _animationCycle(tween._tTime, repeatDelay);
      tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
      if (iteration !== prevIteration) {
        prevRatio = 1 - ratio;
        tween.vars.repeatRefresh && tween._initted && tween.invalidate();
      }
    }
    if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
      if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
        // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
        return;
      }
      prevIteration = tween._zTime;
      tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.
      suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.
      tween.ratio = ratio;
      tween._from && (ratio = 1 - ratio);
      tween._time = 0;
      tween._tTime = tTime;
      pt = tween._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);
      tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
      tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
      if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
        ratio && _removeFromParent(tween, 1);
        if (!suppressEvents) {
          _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
          tween._prom && tween._prom();
        }
      }
    } else if (!tween._zTime) {
      tween._zTime = totalTime;
    }
  },
  _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
    var child;
    if (time > prevTime) {
      child = animation._first;
      while (child && child._start <= time) {
        if (!child._dur && child.data === "isPause" && child._start > prevTime) {
          return child;
        }
        child = child._next;
      }
    } else {
      child = animation._last;
      while (child && child._start >= time) {
        if (!child._dur && child.data === "isPause" && child._start < prevTime) {
          return child;
        }
        child = child._prev;
      }
    }
  },
  _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
    var repeat = animation._repeat,
      dur = _round(duration) || 0,
      totalProgress = animation._tTime / animation._tDur;
    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
    animation._dur = dur;
    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _round(dur * (repeat + 1) + animation._rDelay * repeat);
    totalProgress && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);
    skipUncache || _uncache(animation.parent, animation);
    return animation;
  },
  _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
  },
  _zeroPosition = {
    _start: 0,
    endTime: _emptyFunc,
    totalDuration: _emptyFunc
  },
  _parsePosition2 = function _parsePosition(animation, position, percentAnimation) {
    var labels = animation.labels,
      recent = animation._recent || _zeroPosition,
      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
      i,
      offset,
      isPercent;
    if (_isString(position) && (isNaN(position) || position in labels)) {
      //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
      offset = position.charAt(0);
      isPercent = position.substr(-1) === "%";
      i = position.indexOf("=");
      if (offset === "<" || offset === ">") {
        i >= 0 && (position = position.replace(/=/, ""));
        return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
      }
      if (i < 0) {
        position in labels || (labels[position] = clippedDuration);
        return labels[position];
      }
      offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));
      if (isPercent && percentAnimation) {
        offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
      }
      return i > 1 ? _parsePosition2(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
    }
    return position == null ? clippedDuration : +position;
  },
  _createTweenType = function _createTweenType(type, params, timeline) {
    var isLegacy = _isNumber(params[1]),
      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
      vars = params[varsIndex],
      irVars,
      parent;
    isLegacy && (vars.duration = params[1]);
    vars.parent = timeline;
    if (type) {
      irVars = vars;
      parent = timeline;
      while (parent && !("immediateRender" in irVars)) {
        // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
        irVars = parent.vars.defaults || {};
        parent = _isNotFalse(parent.vars.inherit) && parent.parent;
      }
      vars.immediateRender = _isNotFalse(irVars.immediateRender);
      type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
    }
    return new Tween(params[0], vars, params[varsIndex + 1]);
  },
  _conditionalReturn = function _conditionalReturn(value, func) {
    return value || value === 0 ? func(value) : func;
  },
  _clamp = function _clamp(min, max, value) {
    return value < min ? min : value > max ? max : value;
  },
  getUnit = function getUnit(value) {
    if (typeof value !== "string") {
      return "";
    }
    var v = _unitExp.exec(value);
    return v ? value.substr(v.index + v[0].length) : "";
  },
  // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
  clamp = function clamp(min, max, value) {
    return _conditionalReturn(value, function (v) {
      return _clamp(min, max, v);
    });
  },
  _slice = [].slice,
  _isArrayLike = function _isArrayLike(value, nonEmpty) {
    return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
  },
  _flatten = function _flatten(ar, leaveStrings) {
    var accumulator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    return ar.forEach(function (value) {
      return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? accumulator.push.apply(accumulator, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_6__["default"])(toArray(value))) : accumulator.push(value);
    }) || accumulator;
  },
  //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
  toArray = function toArray(value, scope, leaveStrings) {
    return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
  },
  selector = function selector(value) {
    value = toArray(value)[0] || _warn("Invalid scope") || {};
    return function (v) {
      var el = value.current || value.nativeElement || value;
      return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
    };
  },
  shuffle = function shuffle(a) {
    return a.sort(function () {
      return .5 - Math.random();
    });
  },
  // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
  //for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
  distribute = function distribute(v) {
    if (_isFunction(v)) {
      return v;
    }
    var vars = _isObject(v) ? v : {
        each: v
      },
      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
      ease = _parseEase(vars.ease),
      from = vars.from || 0,
      base = parseFloat(vars.base) || 0,
      cache = {},
      isDecimal = from > 0 && from < 1,
      ratios = isNaN(from) || isDecimal,
      axis = vars.axis,
      ratioX = from,
      ratioY = from;
    if (_isString(from)) {
      ratioX = ratioY = {
        center: .5,
        edges: .5,
        end: 1
      }[from] || 0;
    } else if (!isDecimal && ratios) {
      ratioX = from[0];
      ratioY = from[1];
    }
    return function (i, target, a) {
      var l = (a || vars).length,
        distances = cache[l],
        originX,
        originY,
        x,
        y,
        d,
        j,
        max,
        min,
        wrapAt;
      if (!distances) {
        wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
        if (!wrapAt) {
          max = -_bigNum;
          while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}
          wrapAt--;
        }
        distances = cache[l] = [];
        originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
        originY = ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
        max = 0;
        min = _bigNum;
        for (j = 0; j < l; j++) {
          x = j % wrapAt - originX;
          y = originY - (j / wrapAt | 0);
          distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
          d > max && (max = d);
          d < min && (min = d);
        }
        from === "random" && shuffle(distances);
        distances.max = max - min;
        distances.min = min;
        distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
        distances.b = l < 0 ? base - l : base;
        distances.u = getUnit(vars.amount || vars.each) || 0; //unit
        ease = ease && l < 0 ? _invertEase(ease) : ease;
      }
      l = (distances[i] - distances.min) / distances.max || 0;
      return _round(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
    };
  },
  _roundModifier = function _roundModifier(v) {
    //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
    var p = v < 1 ? Math.pow(10, (v + "").length - 2) : 1; //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed()
    return function (raw) {
      var n = Math.round(parseFloat(raw) / v) * v * p;
      return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
    };
  },
  snap = function snap(snapTo, value) {
    var isArray = _isArray(snapTo),
      radius,
      is2D;
    if (!isArray && _isObject(snapTo)) {
      radius = isArray = snapTo.radius || _bigNum;
      if (snapTo.values) {
        snapTo = toArray(snapTo.values);
        if (is2D = !_isNumber(snapTo[0])) {
          radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
        }
      } else {
        snapTo = _roundModifier(snapTo.increment);
      }
    }
    return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
      is2D = snapTo(raw);
      return Math.abs(is2D - raw) <= radius ? is2D : raw;
    } : function (raw) {
      var x = parseFloat(is2D ? raw.x : raw),
        y = parseFloat(is2D ? raw.y : 0),
        min = _bigNum,
        closest = 0,
        i = snapTo.length,
        dx,
        dy;
      while (i--) {
        if (is2D) {
          dx = snapTo[i].x - x;
          dy = snapTo[i].y - y;
          dx = dx * dx + dy * dy;
        } else {
          dx = Math.abs(snapTo[i] - x);
        }
        if (dx < min) {
          min = dx;
          closest = i;
        }
      }
      closest = !radius || min <= radius ? snapTo[closest] : raw;
      return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
    });
  },
  random = function random(min, max, roundingIncrement, returnFunction) {
    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
      return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
    });
  },
  pipe = function pipe() {
    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
      functions[_key] = arguments[_key];
    }
    return function (value) {
      return functions.reduce(function (v, f) {
        return f(v);
      }, value);
    };
  },
  unitize = function unitize(func, unit) {
    return function (value) {
      return func(parseFloat(value)) + (unit || getUnit(value));
    };
  },
  normalize = function normalize(min, max, value) {
    return mapRange(min, max, 0, 1, value);
  },
  _wrapArray = function _wrapArray(a, wrapper, value) {
    return _conditionalReturn(value, function (index) {
      return a[~~wrapper(index)];
    });
  },
  _wrap = function wrap(min, max, value) {
    // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
    var range = max - min;
    return _isArray(min) ? _wrapArray(min, _wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
      return (range + (value - min) % range) % range + min;
    });
  },
  _wrapYoyo = function wrapYoyo(min, max, value) {
    var range = max - min,
      total = range * 2;
    return _isArray(min) ? _wrapArray(min, _wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
      value = (total + (value - min) % total) % total || 0;
      return min + (value > range ? total - value : value);
    });
  },
  _replaceRandom = function _replaceRandom(value) {
    //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
    var prev = 0,
      s = "",
      i,
      nums,
      end,
      isArray;
    while (~(i = value.indexOf("random(", prev))) {
      end = value.indexOf(")", i);
      isArray = value.charAt(i + 7) === "[";
      nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
      s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
      prev = end + 1;
    }
    return s + value.substr(prev, value.length - prev);
  },
  mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
    var inRange = inMax - inMin,
      outRange = outMax - outMin;
    return _conditionalReturn(value, function (value) {
      return outMin + ((value - inMin) / inRange * outRange || 0);
    });
  },
  _interpolate = function interpolate(start, end, progress, mutate) {
    var func = isNaN(start + end) ? 0 : function (p) {
      return (1 - p) * start + p * end;
    };
    if (!func) {
      var isString = _isString(start),
        master = {},
        p,
        i,
        interpolators,
        l,
        il;
      progress === true && (mutate = 1) && (progress = null);
      if (isString) {
        start = {
          p: start
        };
        end = {
          p: end
        };
      } else if (_isArray(start) && !_isArray(end)) {
        interpolators = [];
        l = start.length;
        il = l - 2;
        for (i = 1; i < l; i++) {
          interpolators.push(_interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
        }
        l--;
        func = function func(p) {
          p *= l;
          var i = Math.min(il, ~~p);
          return interpolators[i](p - i);
        };
        progress = end;
      } else if (!mutate) {
        start = _merge(_isArray(start) ? [] : {}, start);
      }
      if (!interpolators) {
        for (p in end) {
          _addPropTween.call(master, start, p, "get", end[p]);
        }
        func = function func(p) {
          return _renderPropTweens(p, master) || (isString ? start.p : start);
        };
      }
    }
    return _conditionalReturn(progress, func);
  },
  _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
    //used for nextLabel() and previousLabel()
    var labels = timeline.labels,
      min = _bigNum,
      p,
      distance,
      label;
    for (p in labels) {
      distance = labels[p] - fromTime;
      if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
        label = p;
        min = distance;
      }
    }
    return label;
  },
  _callback = function _callback(animation, type, executeLazyFirst) {
    var v = animation.vars,
      callback = v[type],
      params,
      scope;
    if (!callback) {
      return;
    }
    params = v[type + "Params"];
    scope = v.callbackScope || animation;
    executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
    return params ? callback.apply(scope, params) : callback.call(scope);
  },
  _interrupt = function _interrupt(animation) {
    _removeFromParent(animation);
    animation.scrollTrigger && animation.scrollTrigger.kill(false);
    animation.progress() < 1 && _callback(animation, "onInterrupt");
    return animation;
  },
  _quickTween,
  _createPlugin = function _createPlugin(config) {
    config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.
    var name = config.name,
      isFunc = _isFunction(config),
      Plugin = name && !isFunc && config.init ? function () {
        this._props = [];
      } : config,
      //in case someone passes in an object that's not a plugin, like CustomEase
      instanceDefaults = {
        init: _emptyFunc,
        render: _renderPropTweens,
        add: _addPropTween,
        kill: _killPropTweensOf,
        modifier: _addPluginModifier,
        rawVars: 0
      },
      statics = {
        targetTest: 0,
        get: 0,
        getSetter: _getSetter,
        aliases: {},
        register: 0
      };
    _wake();
    if (config !== Plugin) {
      if (_plugins[name]) {
        return;
      }
      _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods
      _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods
      _plugins[Plugin.prop = name] = Plugin;
      if (config.targetTest) {
        _harnessPlugins.push(Plugin);
        _reservedProps[name] = 1;
      }
      name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
    }
    _addGlobal(name, Plugin);
    config.register && config.register(gsap, Plugin, PropTween);
  },
  /*
   * --------------------------------------------------------------------------------------
   * COLORS
   * --------------------------------------------------------------------------------------
   */

  _255 = 255,
  _colorLookup = {
    aqua: [0, _255, _255],
    lime: [0, _255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _255],
    navy: [0, 0, 128],
    white: [_255, _255, _255],
    olive: [128, 128, 0],
    yellow: [_255, _255, 0],
    orange: [_255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_255, 0, 0],
    pink: [_255, 192, 203],
    cyan: [0, _255, _255],
    transparent: [_255, _255, _255, 0]
  },
  _hue = function _hue(h, m1, m2) {
    h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
    return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
  },
  splitColor = function splitColor(v, toHSL, forceAlpha) {
    var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;
    if (!a) {
      if (v.substr(-1) === ",") {
        //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
        v = v.substr(0, v.length - 1);
      }
      if (_colorLookup[v]) {
        a = _colorLookup[v];
      } else if (v.charAt(0) === "#") {
        if (v.length < 6) {
          //for shorthand like #9F0 or #9F0F (could have alpha)
          r = v.charAt(1);
          g = v.charAt(2);
          b = v.charAt(3);
          v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
        }
        if (v.length === 9) {
          // hex with alpha, like #fd5e53ff
          a = parseInt(v.substr(1, 6), 16);
          return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
        }
        v = parseInt(v.substr(1), 16);
        a = [v >> 16, v >> 8 & _255, v & _255];
      } else if (v.substr(0, 3) === "hsl") {
        a = wasHSL = v.match(_strictNumExp);
        if (!toHSL) {
          h = +a[0] % 360 / 360;
          s = +a[1] / 100;
          l = +a[2] / 100;
          g = l <= .5 ? l * (s + 1) : l + s - l * s;
          r = l * 2 - g;
          a.length > 3 && (a[3] *= 1); //cast as number
          a[0] = _hue(h + 1 / 3, r, g);
          a[1] = _hue(h, r, g);
          a[2] = _hue(h - 1 / 3, r, g);
        } else if (~v.indexOf("=")) {
          //if relative values are found, just return the raw strings with the relative prefixes in place.
          a = v.match(_numExp);
          forceAlpha && a.length < 4 && (a[3] = 1);
          return a;
        }
      } else {
        a = v.match(_strictNumExp) || _colorLookup.transparent;
      }
      a = a.map(Number);
    }
    if (toHSL && !wasHSL) {
      r = a[0] / _255;
      g = a[1] / _255;
      b = a[2] / _255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
        h *= 60;
      }
      a[0] = ~~(h + .5);
      a[1] = ~~(s * 100 + .5);
      a[2] = ~~(l * 100 + .5);
    }
    forceAlpha && a.length < 4 && (a[3] = 1);
    return a;
  },
  _colorOrderData = function _colorOrderData(v) {
    // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
    var values = [],
      c = [],
      i = -1;
    v.split(_colorExp).forEach(function (v) {
      var a = v.match(_numWithUnitExp) || [];
      values.push.apply(values, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_6__["default"])(a));
      c.push(i += a.length + 1);
    });
    values.c = c;
    return values;
  },
  _formatColors = function _formatColors(s, toHSL, orderMatchData) {
    var result = "",
      colors = (s + result).match(_colorExp),
      type = toHSL ? "hsla(" : "rgba(",
      i = 0,
      c,
      shell,
      d,
      l;
    if (!colors) {
      return s;
    }
    colors = colors.map(function (color) {
      return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
    });
    if (orderMatchData) {
      d = _colorOrderData(s);
      c = orderMatchData.c;
      if (c.join(result) !== d.c.join(result)) {
        shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
        l = shell.length - 1;
        for (; i < l; i++) {
          result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
        }
      }
    }
    if (!shell) {
      shell = s.split(_colorExp);
      l = shell.length - 1;
      for (; i < l; i++) {
        result += shell[i] + colors[i];
      }
    }
    return result + shell[l];
  },
  _colorExp = function () {
    var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
      p;
    for (p in _colorLookup) {
      s += "|" + p + "\\b";
    }
    return new RegExp(s + ")", "gi");
  }(),
  _hslExp = /hsl[a]?\(/,
  _colorStringFilter = function _colorStringFilter(a) {
    var combined = a.join(" "),
      toHSL;
    _colorExp.lastIndex = 0;
    if (_colorExp.test(combined)) {
      toHSL = _hslExp.test(combined);
      a[1] = _formatColors(a[1], toHSL);
      a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.
      return true;
    }
  },
  /*
   * --------------------------------------------------------------------------------------
   * TICKER
   * --------------------------------------------------------------------------------------
   */
  _tickerActive,
  _ticker = function () {
    var _getTime = Date.now,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _startTime = _getTime(),
      _lastUpdate = _startTime,
      _gap = 1000 / 240,
      _nextTime = _gap,
      _listeners = [],
      _id,
      _req,
      _raf,
      _self,
      _delta,
      _i,
      _tick2 = function _tick(v) {
        var elapsed = _getTime() - _lastUpdate,
          manual = v === true,
          overlap,
          dispatch,
          time,
          frame;
        elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
        _lastUpdate += elapsed;
        time = _lastUpdate - _startTime;
        overlap = time - _nextTime;
        if (overlap > 0 || manual) {
          frame = ++_self.frame;
          _delta = time - _self.time * 1000;
          _self.time = time = time / 1000;
          _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
          dispatch = 1;
        }
        manual || (_id = _req(_tick2)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
        if (dispatch) {
          for (_i = 0; _i < _listeners.length; _i++) {
            // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
            _listeners[_i](time, _delta, frame, v);
          }
        }
      };
    _self = {
      time: 0,
      frame: 0,
      tick: function tick() {
        _tick2(true);
      },
      deltaRatio: function deltaRatio(fps) {
        return _delta / (1000 / (fps || 60));
      },
      wake: function wake() {
        if (_coreReady) {
          if (!_coreInitted && _windowExists()) {
            _win = _coreInitted = window;
            _doc = _win.document || {};
            _globals.gsap = gsap;
            (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
            _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
            _raf = _win.requestAnimationFrame;
          }
          _id && _self.sleep();
          _req = _raf || function (f) {
            return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
          };
          _tickerActive = 1;
          _tick2(2);
        }
      },
      sleep: function sleep() {
        (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
        _tickerActive = 0;
        _req = _emptyFunc;
      },
      lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
        _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited
        _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
      },
      fps: function fps(_fps) {
        _gap = 1000 / (_fps || 240);
        _nextTime = _self.time * 1000 + _gap;
      },
      add: function add(callback) {
        _listeners.indexOf(callback) < 0 && _listeners.push(callback);
        _wake();
      },
      remove: function remove(callback) {
        var i;
        ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
      },
      _listeners: _listeners
    };
    return _self;
  }(),
  _wake = function _wake() {
    return !_tickerActive && _ticker.wake();
  },
  //also ensures the core classes are initialized.

  /*
  * -------------------------------------------------
  * EASING
  * -------------------------------------------------
  */
  _easeMap = {},
  _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
  _quotesExp = /["']/g,
  _parseObjectInString = function _parseObjectInString(value) {
    //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
    var obj = {},
      split = value.substr(1, value.length - 3).split(":"),
      key = split[0],
      i = 1,
      l = split.length,
      index,
      val,
      parsedVal;
    for (; i < l; i++) {
      val = split[i];
      index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
      parsedVal = val.substr(0, index);
      obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
      key = val.substr(index + 1).trim();
    }
    return obj;
  },
  _valueInParentheses = function _valueInParentheses(value) {
    var open = value.indexOf("(") + 1,
      close = value.indexOf(")"),
      nested = value.indexOf("(", open);
    return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
  },
  _configEaseFromString = function _configEaseFromString(name) {
    //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
    var split = (name + "").split("("),
      ease = _easeMap[split[0]];
    return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
  },
  _invertEase = function _invertEase(ease) {
    return function (p) {
      return 1 - ease(1 - p);
    };
  },
  // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
  _propagateYoyoEase2 = function _propagateYoyoEase(timeline, isYoyo) {
    var child = timeline._first,
      ease;
    while (child) {
      if (child instanceof Timeline) {
        _propagateYoyoEase2(child, isYoyo);
      } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
        if (child.timeline) {
          _propagateYoyoEase2(child.timeline, isYoyo);
        } else {
          ease = child._ease;
          child._ease = child._yEase;
          child._yEase = ease;
          child._yoyo = isYoyo;
        }
      }
      child = child._next;
    }
  },
  _parseEase = function _parseEase(ease, defaultEase) {
    return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
  },
  _insertEase = function _insertEase(names, easeIn) {
    var easeOut = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (p) {
      return 1 - easeIn(1 - p);
    };
    var easeInOut = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (p) {
      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
    };
    var ease = {
        easeIn: easeIn,
        easeOut: easeOut,
        easeInOut: easeInOut
      },
      lowercaseName;
    _forEachName(names, function (name) {
      _easeMap[name] = _globals[name] = ease;
      _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
      for (var p in ease) {
        _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
      }
    });
    return ease;
  },
  _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
    return function (p) {
      return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
    };
  },
  _configElastic2 = function _configElastic(type, amplitude, period) {
    var p1 = amplitude >= 1 ? amplitude : 1,
      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
      p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
      easeOut = function easeOut(p) {
        return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
      },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
        return 1 - easeOut(1 - p);
      } : _easeInOutFromOut(easeOut);
    p2 = _2PI / p2; //precalculate to optimize
    ease.config = function (amplitude, period) {
      return _configElastic2(type, amplitude, period);
    };
    return ease;
  },
  _configBack2 = function _configBack(type) {
    var overshoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.70158;
    var easeOut = function easeOut(p) {
        return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
      },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
        return 1 - easeOut(1 - p);
      } : _easeInOutFromOut(easeOut);
    ease.config = function (overshoot) {
      return _configBack2(type, overshoot);
    };
    return ease;
  };
// a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEase = ratio => {
// 	let y = 0.5 + ratio / 2;
// 	return p => (2 * (1 - p) * p * y + p * p);
// },
// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEaseStrong = ratio => {
// 	ratio = .5 + ratio / 2;
// 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
// 		b = ratio - o,
// 		c = ratio + o;
// 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
// };

_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
  var power = i < 5 ? i + 1 : i;
  _insertEase(name + ",Power" + (power - 1), i ? function (p) {
    return Math.pow(p, power);
  } : function (p) {
    return p;
  }, function (p) {
    return 1 - Math.pow(1 - p, power);
  }, function (p) {
    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});
_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
_insertEase("Elastic", _configElastic2("in"), _configElastic2("out"), _configElastic2());
(function (n, c) {
  var n1 = 1 / c,
    n2 = 2 * n1,
    n3 = 2.5 * n1,
    easeOut = function easeOut(p) {
      return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
    };
  _insertEase("Bounce", function (p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);
_insertEase("Expo", function (p) {
  return p ? Math.pow(2, 10 * (p - 1)) : 0;
});
_insertEase("Circ", function (p) {
  return -(_sqrt(1 - p * p) - 1);
});
_insertEase("Sine", function (p) {
  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
});
_insertEase("Back", _configBack2("in"), _configBack2("out"), _configBack2());
_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config() {
    var steps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var immediateStart = arguments.length > 1 ? arguments[1] : undefined;
    var p1 = 1 / steps,
      p2 = steps + (immediateStart ? 0 : 1),
      p3 = immediateStart ? 1 : 0,
      max = 1 - _tinyNum;
    return function (p) {
      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];
_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
  return _callbackNames += name + "," + name + "Params,";
});

/*
 * --------------------------------------------------------------------------------------
 * CACHE
 * --------------------------------------------------------------------------------------
 */
var GSCache = /*#__PURE__*/(0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(function GSCache(target, harness) {
  (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_5__["default"])(this, GSCache);
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
});

/*
 * --------------------------------------------------------------------------------------
 * ANIMATION
 * --------------------------------------------------------------------------------------
 */

var Animation = /*#__PURE__*/function () {
  function Animation(vars) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_5__["default"])(this, Animation);
    this.vars = vars;
    this._delay = +vars.delay || 0;
    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
    }
    this._ts = 1;
    _setDuration(this, +vars.duration, 1, 1);
    this.data = vars.data;
    _tickerActive || _ticker.wake();
  }
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(Animation, [{
    key: "delay",
    value: function delay(value) {
      if (value || value === 0) {
        this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
        this._delay = value;
        return this;
      }
      return this._delay;
    }
  }, {
    key: "duration",
    value: function duration(value) {
      return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
    }
  }, {
    key: "totalDuration",
    value: function totalDuration(value) {
      if (!arguments.length) {
        return this._tDur;
      }
      this._dirty = 0;
      return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
    }
  }, {
    key: "totalTime",
    value: function totalTime(_totalTime, suppressEvents) {
      _wake();
      if (!arguments.length) {
        return this._tTime;
      }
      var parent = this._dp;
      if (parent && parent.smoothChildTiming && this._ts) {
        _alignPlayhead(this, _totalTime);
        !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
        //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.
        while (parent.parent) {
          if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
            parent.totalTime(parent._tTime, true);
          }
          parent = parent.parent;
        }
        if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
          //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
          _addToTimeline(this._dp, this, this._start - this._delay);
        }
      }
      if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
        // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
        this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
        //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
        //   this._lock = 1;
        _lazySafeRender(this, _totalTime, suppressEvents);
        //   this._lock = 0;
        //}
      }
      return this;
    }
  }, {
    key: "time",
    value: function time(value, suppressEvents) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % this._dur || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
    }
  }, {
    key: "totalProgress",
    value: function totalProgress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
    }
  }, {
    key: "progress",
    value: function progress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
    }
  }, {
    key: "iteration",
    value: function iteration(value, suppressEvents) {
      var cycleDuration = this.duration() + this._rDelay;
      return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
    }

    // potential future addition:
    // isPlayingBackwards() {
    // 	let animation = this,
    // 		orientation = 1; // 1 = forward, -1 = backward
    // 	while (animation) {
    // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
    // 		animation = animation.parent;
    // 	}
    // 	return orientation < 0;
    // }
  }, {
    key: "timeScale",
    value: function timeScale(value) {
      if (!arguments.length) {
        return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
      }
      if (this._rts === value) {
        return this;
      }
      var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.

      // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
      //(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);

      // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.
      this._rts = +value || 0;
      this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.
      return _recacheAncestors(this.totalTime(_clamp(-this._delay, this._tDur, tTime), true));
    }
  }, {
    key: "paused",
    value: function paused(value) {
      if (!arguments.length) {
        return this._ps;
      }
      if (this._ps !== value) {
        this._ps = value;
        if (value) {
          this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.
          this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
        } else {
          _wake();
          this._ts = this._rts;
          //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.
          this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && (this._tTime -= _tinyNum) && Math.abs(this._zTime) !== _tinyNum); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
        }
      }
      return this;
    }
  }, {
    key: "startTime",
    value: function startTime(value) {
      if (arguments.length) {
        this._start = value;
        var parent = this.parent || this._dp;
        parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
        return this;
      }
      return this._start;
    }
  }, {
    key: "endTime",
    value: function endTime(includeRepeats) {
      return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts);
    }
  }, {
    key: "rawTime",
    value: function rawTime(wrapRepeats) {
      var parent = this.parent || this._dp; // _dp = detached parent
      return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
    }
  }, {
    key: "globalTime",
    value: function globalTime(rawTime) {
      var animation = this,
        time = arguments.length ? rawTime : animation.rawTime();
      while (animation) {
        time = animation._start + time / (animation._ts || 1);
        animation = animation._dp;
      }
      return time;
    }
  }, {
    key: "repeat",
    value: function repeat(value) {
      if (arguments.length) {
        this._repeat = value === Infinity ? -2 : value;
        return _onUpdateTotalDuration(this);
      }
      return this._repeat === -2 ? Infinity : this._repeat;
    }
  }, {
    key: "repeatDelay",
    value: function repeatDelay(value) {
      if (arguments.length) {
        this._rDelay = value;
        return _onUpdateTotalDuration(this);
      }
      return this._rDelay;
    }
  }, {
    key: "yoyo",
    value: function yoyo(value) {
      if (arguments.length) {
        this._yoyo = value;
        return this;
      }
      return this._yoyo;
    }
  }, {
    key: "seek",
    value: function seek(position, suppressEvents) {
      return this.totalTime(_parsePosition2(this, position), _isNotFalse(suppressEvents));
    }
  }, {
    key: "restart",
    value: function restart(includeDelay, suppressEvents) {
      return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
    }
  }, {
    key: "play",
    value: function play(from, suppressEvents) {
      from != null && this.seek(from, suppressEvents);
      return this.reversed(false).paused(false);
    }
  }, {
    key: "reverse",
    value: function reverse(from, suppressEvents) {
      from != null && this.seek(from || this.totalDuration(), suppressEvents);
      return this.reversed(true).paused(false);
    }
  }, {
    key: "pause",
    value: function pause(atTime, suppressEvents) {
      atTime != null && this.seek(atTime, suppressEvents);
      return this.paused(true);
    }
  }, {
    key: "resume",
    value: function resume() {
      return this.paused(false);
    }
  }, {
    key: "reversed",
    value: function reversed(value) {
      if (arguments.length) {
        !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.
        return this;
      }
      return this._rts < 0;
    }
  }, {
    key: "invalidate",
    value: function invalidate() {
      this._initted = this._act = 0;
      this._zTime = -_tinyNum;
      return this;
    }
  }, {
    key: "isActive",
    value: function isActive() {
      var parent = this.parent || this._dp,
        start = this._start,
        rawTime;
      return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
    }
  }, {
    key: "eventCallback",
    value: function eventCallback(type, callback, params) {
      var vars = this.vars;
      if (arguments.length > 1) {
        if (!callback) {
          delete vars[type];
        } else {
          vars[type] = callback;
          params && (vars[type + "Params"] = params);
          type === "onUpdate" && (this._onUpdate = callback);
        }
        return this;
      }
      return vars[type];
    }
  }, {
    key: "then",
    value: function then(onFulfilled) {
      var self = this;
      return new Promise(function (resolve) {
        var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
          _resolve = function _resolve() {
            var _then = self.then;
            self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)
            _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
            resolve(f);
            self.then = _then;
          };
        if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
          _resolve();
        } else {
          self._prom = _resolve;
        }
      });
    }
  }, {
    key: "kill",
    value: function kill() {
      _interrupt(this);
    }
  }]);
}();
_setDefaults(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: null,
  _initted: false,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: false,
  _rts: 1
});

/*
 * -------------------------------------------------
 * TIMELINE
 * -------------------------------------------------
 */

var Timeline = /*#__PURE__*/function (_Animation) {
  function Timeline() {
    var _this;
    var vars = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var position = arguments.length > 1 ? arguments[1] : undefined;
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_5__["default"])(this, Timeline);
    _this = _callSuper(this, Timeline, [vars]);
    _this.labels = {};
    _this.smoothChildTiming = !!vars.smoothChildTiming;
    _this.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this._sort = _isNotFalse(vars.sortChildren);
    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _this, position);
    vars.reversed && _this.reverse();
    vars.paused && _this.paused(true);
    vars.scrollTrigger && _scrollTrigger(_this, vars.scrollTrigger);
    return _this;
  }
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(Timeline, _Animation);
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(Timeline, [{
    key: "to",
    value: function to(targets, vars, position) {
      _createTweenType(0, arguments, this);
      return this;
    }
  }, {
    key: "from",
    value: function from(targets, vars, position) {
      _createTweenType(1, arguments, this);
      return this;
    }
  }, {
    key: "fromTo",
    value: function fromTo(targets, fromVars, toVars, position) {
      _createTweenType(2, arguments, this);
      return this;
    }
  }, {
    key: "set",
    value: function set(targets, vars, position) {
      vars.duration = 0;
      vars.parent = this;
      _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
      vars.immediateRender = !!vars.immediateRender;
      new Tween(targets, vars, _parsePosition2(this, position), 1);
      return this;
    }
  }, {
    key: "call",
    value: function call(callback, params, position) {
      return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
    }

    //ONLY for backward compatibility! Maybe delete?
  }, {
    key: "staggerTo",
    value: function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.duration = duration;
      vars.stagger = vars.stagger || stagger;
      vars.onComplete = onCompleteAll;
      vars.onCompleteParams = onCompleteAllParams;
      vars.parent = this;
      new Tween(targets, vars, _parsePosition2(this, position));
      return this;
    }
  }, {
    key: "staggerFrom",
    value: function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.runBackwards = 1;
      _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
      return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
    }
  }, {
    key: "staggerFromTo",
    value: function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
      toVars.startAt = fromVars;
      _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
      return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
    }
  }, {
    key: "render",
    value: function render(totalTime, suppressEvents, force) {
      var prevTime = this._time,
        tDur = this._dirty ? this.totalDuration() : this._tDur,
        dur = this._dur,
        tTime = this !== _globalTimeline && totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
        time,
        child,
        next,
        iteration,
        cycleDuration,
        prevPaused,
        pauseTween,
        timeScale,
        prevStart,
        prevIteration,
        yoyo,
        isYoyo;
      if (tTime !== this._tTime || force || crossingStart) {
        if (prevTime !== this._time && dur) {
          //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
          tTime += this._time - prevTime;
          totalTime += this._time - prevTime;
        }
        time = tTime;
        prevStart = this._start;
        timeScale = this._ts;
        prevPaused = !timeScale;
        if (crossingStart) {
          dur || (prevTime = this._zTime);
          //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.
          (totalTime || !suppressEvents) && (this._zTime = totalTime);
        }
        if (this._repeat) {
          //adjust the time for repeats and yoyos
          yoyo = this._yoyo;
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && totalTime < 0) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)
          if (tTime === tDur) {
            // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
            iteration = this._repeat;
            time = dur;
          } else {
            iteration = ~~(tTime / cycleDuration);
            if (iteration && iteration === tTime / cycleDuration) {
              time = dur;
              iteration--;
            }
            time > dur && (time = dur);
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005
          if (yoyo && iteration & 1) {
            time = dur - time;
            isYoyo = 1;
          }
          /*
          make sure children at the end/beginning of the timeline are rendered properly. If, for example,
          a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
          would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
          could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
          we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
          ensure that zero-duration tweens at the very beginning or end of the Timeline work.
          */
          if (iteration !== prevIteration && !this._lock) {
            var rewinding = yoyo && prevIteration & 1,
              doesWrap = rewinding === (yoyo && iteration & 1);
            iteration < prevIteration && (rewinding = !rewinding);
            prevTime = rewinding ? 0 : dur;
            this._lock = 1;
            this.render(prevTime || (isYoyo ? 0 : _round(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
            this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.
            !suppressEvents && this.parent && _callback(this, "onRepeat");
            this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
            if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
              // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
              return this;
            }
            dur = this._dur; // in case the duration changed in the onRepeat
            tDur = this._tDur;
            if (doesWrap) {
              this._lock = 2;
              prevTime = rewinding ? dur : -0.0001;
              this.render(prevTime, true);
              this.vars.repeatRefresh && !isYoyo && this.invalidate();
            }
            this._lock = 0;
            if (!this._ts && !prevPaused) {
              return this;
            }
            //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.
            _propagateYoyoEase2(this, isYoyo);
          }
        }
        if (this._hasPause && !this._forcing && this._lock < 2) {
          pauseTween = _findNextPauseTween(this, _round(prevTime), _round(time));
          if (pauseTween) {
            tTime -= time - (time = pauseTween._start);
          }
        }
        this._tTime = tTime;
        this._time = time;
        this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        if (!this._initted) {
          this._onUpdate = this.vars.onUpdate;
          this._initted = 1;
          this._zTime = totalTime;
          prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
        }
        if (!prevTime && time && !suppressEvents) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
            return this;
          }
        }
        if (time >= prevTime && totalTime >= 0) {
          child = this._first;
          while (child) {
            next = child._next;
            if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
              if (time !== this._time || !this._ts && !prevPaused) {
                //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
                pauseTween = 0;
                next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)
                break;
              }
            }
            child = next;
          }
        } else {
          child = this._last;
          var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.
          while (child) {
            next = child._prev;
            if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);
              if (time !== this._time || !this._ts && !prevPaused) {
                //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
                pauseTween = 0;
                next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)
                break;
              }
            }
            child = next;
          }
        }
        if (pauseTween && !suppressEvents) {
          this.pause();
          pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
          if (this._ts) {
            //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
            this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.
            _setEnd(this);
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
        if (tTime === tDur && tDur >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
          (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.
          if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
            _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }
      return this;
    }
  }, {
    key: "add",
    value: function add(child, position) {
      var _this2 = this;
      _isNumber(position) || (position = _parsePosition2(this, position, child));
      if (!(child instanceof Animation)) {
        if (_isArray(child)) {
          child.forEach(function (obj) {
            return _this2.add(obj, position);
          });
          return this;
        }
        if (_isString(child)) {
          return this.addLabel(child, position);
        }
        if (_isFunction(child)) {
          child = Tween.delayedCall(0, child);
        } else {
          return this;
        }
      }
      return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
    }
  }, {
    key: "getChildren",
    value: function getChildren() {
      var nested = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var tweens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var timelines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var ignoreBeforeTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -_bigNum;
      var a = [],
        child = this._first;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          if (child instanceof Tween) {
            tweens && a.push(child);
          } else {
            timelines && a.push(child);
            nested && a.push.apply(a, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_6__["default"])(child.getChildren(true, tweens, timelines)));
          }
        }
        child = child._next;
      }
      return a;
    }
  }, {
    key: "getById",
    value: function getById(id) {
      var animations = this.getChildren(1, 1, 1),
        i = animations.length;
      while (i--) {
        if (animations[i].vars.id === id) {
          return animations[i];
        }
      }
    }
  }, {
    key: "remove",
    value: function remove(child) {
      if (_isString(child)) {
        return this.removeLabel(child);
      }
      if (_isFunction(child)) {
        return this.killTweensOf(child);
      }
      _removeLinkedListItem(this, child);
      if (child === this._recent) {
        this._recent = this._last;
      }
      return _uncache(this);
    }
  }, {
    key: "totalTime",
    value: function totalTime(_totalTime2, suppressEvents) {
      if (!arguments.length) {
        return this._tTime;
      }
      this._forcing = 1;
      if (!this._dp && this._ts) {
        //special case for the global timeline (or any other that has no parent or detached parent).
        this._start = _round(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
      }
      _superPropGet(Timeline, "totalTime", this, 3)([_totalTime2, suppressEvents]);
      this._forcing = 0;
      return this;
    }
  }, {
    key: "addLabel",
    value: function addLabel(label, position) {
      this.labels[label] = _parsePosition2(this, position);
      return this;
    }
  }, {
    key: "removeLabel",
    value: function removeLabel(label) {
      delete this.labels[label];
      return this;
    }
  }, {
    key: "addPause",
    value: function addPause(position, callback, params) {
      var t = Tween.delayedCall(0, callback || _emptyFunc, params);
      t.data = "isPause";
      this._hasPause = 1;
      return _addToTimeline(this, t, _parsePosition2(this, position));
    }
  }, {
    key: "removePause",
    value: function removePause(position) {
      var child = this._first;
      position = _parsePosition2(this, position);
      while (child) {
        if (child._start === position && child.data === "isPause") {
          _removeFromParent(child);
        }
        child = child._next;
      }
    }
  }, {
    key: "killTweensOf",
    value: function killTweensOf(targets, props, onlyActive) {
      var tweens = this.getTweensOf(targets, onlyActive),
        i = tweens.length;
      while (i--) {
        _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
      }
      return this;
    }
  }, {
    key: "getTweensOf",
    value: function getTweensOf(targets, onlyActive) {
      var a = [],
        parsedTargets = toArray(targets),
        child = this._first,
        isGlobalTime = _isNumber(onlyActive),
        // a number is interpreted as a global time. If the animation spans
        children;
      while (child) {
        if (child instanceof Tween) {
          if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
            // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
            a.push(child);
          }
        } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
          a.push.apply(a, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_6__["default"])(children));
        }
        child = child._next;
      }
      return a;
    }

    // potential future feature - targets() on timelines
    // targets() {
    // 	let result = [];
    // 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
    // 	return result.filter((v, i) => result.indexOf(v) === i);
    // }
  }, {
    key: "tweenTo",
    value: function tweenTo(position, vars) {
      vars = vars || {};
      var tl = this,
        endTime = _parsePosition2(tl, position),
        _vars = vars,
        startAt = _vars.startAt,
        _onStart = _vars.onStart,
        onStartParams = _vars.onStartParams,
        immediateRender = _vars.immediateRender,
        initted,
        tween = Tween.to(tl, _setDefaults({
          ease: vars.ease || "none",
          lazy: false,
          immediateRender: false,
          time: endTime,
          overwrite: "auto",
          duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
          onStart: function onStart() {
            tl.pause();
            if (!initted) {
              var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
              tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
              initted = 1;
            }
            _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
          }
        }, vars));
      return immediateRender ? tween.render(0) : tween;
    }
  }, {
    key: "tweenFromTo",
    value: function tweenFromTo(fromPosition, toPosition, vars) {
      return this.tweenTo(toPosition, _setDefaults({
        startAt: {
          time: _parsePosition2(this, fromPosition)
        }
      }, vars));
    }
  }, {
    key: "recent",
    value: function recent() {
      return this._recent;
    }
  }, {
    key: "nextLabel",
    value: function nextLabel() {
      var afterTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._time;
      return _getLabelInDirection(this, _parsePosition2(this, afterTime));
    }
  }, {
    key: "previousLabel",
    value: function previousLabel() {
      var beforeTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._time;
      return _getLabelInDirection(this, _parsePosition2(this, beforeTime), 1);
    }
  }, {
    key: "currentLabel",
    value: function currentLabel(value) {
      return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
    }
  }, {
    key: "shiftChildren",
    value: function shiftChildren(amount, adjustLabels) {
      var ignoreBeforeTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var child = this._first,
        labels = this.labels,
        p;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          child._start += amount;
          child._end += amount;
        }
        child = child._next;
      }
      if (adjustLabels) {
        for (p in labels) {
          if (labels[p] >= ignoreBeforeTime) {
            labels[p] += amount;
          }
        }
      }
      return _uncache(this);
    }
  }, {
    key: "invalidate",
    value: function invalidate() {
      var child = this._first;
      this._lock = 0;
      while (child) {
        child.invalidate();
        child = child._next;
      }
      return _superPropGet(Timeline, "invalidate", this, 3)([]);
    }
  }, {
    key: "clear",
    value: function clear() {
      var includeLabels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var child = this._first,
        next;
      while (child) {
        next = child._next;
        this.remove(child);
        child = next;
      }
      this._dp && (this._time = this._tTime = this._pTime = 0);
      includeLabels && (this.labels = {});
      return _uncache(this);
    }
  }, {
    key: "totalDuration",
    value: function totalDuration(value) {
      var max = 0,
        self = this,
        child = self._last,
        prevStart = _bigNum,
        prev,
        start,
        parent;
      if (arguments.length) {
        return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
      }
      if (self._dirty) {
        parent = self.parent;
        while (child) {
          prev = child._prev; //record it here in case the tween changes position in the sequence...
          child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.
          start = child._start;
          if (start > prevStart && self._sort && child._ts && !self._lock) {
            //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
            self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().
            _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
          } else {
            prevStart = start;
          }
          if (start < 0 && child._ts) {
            //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
            max -= start;
            if (!parent && !self._dp || parent && parent.smoothChildTiming) {
              self._start += start / self._ts;
              self._time -= start;
              self._tTime -= start;
            }
            self.shiftChildren(-start, false, -1e999);
            prevStart = 0;
          }
          child._end > max && child._ts && (max = child._end);
          child = prev;
        }
        _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);
        self._dirty = 0;
      }
      return self._tDur;
    }
  }], [{
    key: "updateRoot",
    value: function updateRoot(time) {
      if (_globalTimeline._ts) {
        _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
        _lastRenderedFrame = _ticker.frame;
      }
      if (_ticker.frame >= _nextGCFrame) {
        _nextGCFrame += _config.autoSleep || 120;
        var child = _globalTimeline._first;
        if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
          while (child && !child._ts) {
            child = child._next;
          }
          child || _ticker.sleep();
        }
      }
    }
  }]);
}(Animation);
_setDefaults(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});
var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
    //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
      index = 0,
      matchIndex = 0,
      result,
      startNums,
      color,
      endNum,
      chunk,
      startNum,
      hasRandom,
      a;
    pt.b = start;
    pt.e = end;
    start += ""; //ensure values are strings
    end += "";
    if (hasRandom = ~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }
    if (stringFilter) {
      a = [start, end];
      stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.
      start = a[0];
      end = a[1];
    }
    startNums = start.match(_complexStringNumExp) || [];
    while (result = _complexStringNumExp.exec(end)) {
      endNum = result[0];
      chunk = end.substring(index, result.index);
      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(") {
        color = 1;
      }
      if (endNum !== startNums[matchIndex++]) {
        startNum = parseFloat(startNums[matchIndex - 1]) || 0;
        //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.
        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum.charAt(1) === "=" ? parseFloat(endNum.substr(2)) * (endNum.charAt(0) === "-" ? -1 : 1) : parseFloat(endNum) - startNum,
          m: color && color < 4 ? Math.round : 0
        };
        index = _complexStringNumExp.lastIndex;
      }
    }
    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
    pt.fp = funcParam;
    if (_relExp.test(end) || hasRandom) {
      pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
    }
    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
    return pt;
  },
  _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
    _isFunction(end) && (end = end(index || 0, target, targets));
    var currentValue = target[prop],
      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
      pt;
    if (_isString(end)) {
      if (~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }
      if (end.charAt(1) === "=") {
        pt = parseFloat(parsedStart) + parseFloat(end.substr(2)) * (end.charAt(0) === "-" ? -1 : 1) + (getUnit(parsedStart) || 0);
        if (pt || pt === 0) {
          // to avoid isNaN, like if someone passes in a value like "!= whatever"
          end = pt;
        }
      }
    }
    if (parsedStart !== end) {
      if (!isNaN(parsedStart * end) && end !== "") {
        // fun fact: any number multiplied by "" is evaluated as the number 0!
        pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
        funcParam && (pt.fp = funcParam);
        modifier && pt.modifier(modifier, this, target);
        return this._pt = pt;
      }
      !currentValue && !(prop in target) && _missingPlugin(prop, end);
      return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
    }
  },
  //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
  _processVars = function _processVars(vars, index, target, targets, tween) {
    _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
      return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
    }
    var copy = {},
      p;
    for (p in vars) {
      copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
    }
    return copy;
  },
  _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
    var plugin, pt, ptLookup, i;
    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
      tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
      if (tween !== _quickTween) {
        ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.
        i = plugin._props.length;
        while (i--) {
          ptLookup[plugin._props[i]] = pt;
        }
      }
    }
    return plugin;
  },
  _overwritingTween,
  //store a reference temporarily so we can avoid overwriting itself.
  _initTween2 = function _initTween(tween, time) {
    var vars = tween.vars,
      ease = vars.ease,
      startAt = vars.startAt,
      immediateRender = vars.immediateRender,
      lazy = vars.lazy,
      onUpdate = vars.onUpdate,
      onUpdateParams = vars.onUpdateParams,
      callbackScope = vars.callbackScope,
      runBackwards = vars.runBackwards,
      yoyoEase = vars.yoyoEase,
      keyframes = vars.keyframes,
      autoRevert = vars.autoRevert,
      dur = tween._dur,
      prevStartAt = tween._startAt,
      targets = tween._targets,
      parent = tween.parent,
      fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,
      autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
      tl = tween.timeline,
      cleanVars,
      i,
      p,
      pt,
      target,
      hasPriority,
      gsData,
      harness,
      plugin,
      ptLookup,
      index,
      harnessVars,
      overwritten;
    tl && (!keyframes || !ease) && (ease = "none");
    tween._ease = _parseEase(ease, _defaults.ease);
    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
    if (yoyoEase && tween._yoyo && !tween._repeat) {
      //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
      yoyoEase = tween._yEase;
      tween._yEase = tween._ease;
      tween._ease = yoyoEase;
    }
    tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.
    if (!tl) {
      //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
      harness = targets[0] ? _getCache(targets[0]).harness : 0;
      harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.
      cleanVars = _copyExcluding(vars, _reservedProps);
      prevStartAt && prevStartAt.render(-1, true).kill();
      if (startAt) {
        _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
          data: "isStart",
          overwrite: false,
          parent: parent,
          immediateRender: true,
          lazy: _isNotFalse(lazy),
          startAt: null,
          delay: 0,
          onUpdate: onUpdate,
          onUpdateParams: onUpdateParams,
          callbackScope: callbackScope,
          stagger: 0
        }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);
        time < 0 && !immediateRender && !autoRevert && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.
        if (immediateRender) {
          time > 0 && !autoRevert && (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
          if (dur && time <= 0) {
            time && (tween._zTime = time);
            return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
          }
          // if (time > 0) {
          // 	autoRevert || (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
          // } else if (dur && !(time < 0 && prevStartAt)) {
          // 	time && (tween._zTime = time);
          // 	return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
          // }
        } else if (autoRevert === false) {
          tween._startAt = 0;
        }
      } else if (runBackwards && dur) {
        //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
        if (prevStartAt) {
          !autoRevert && (tween._startAt = 0);
        } else {
          time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
          p = _setDefaults({
            overwrite: false,
            data: "isFromStart",
            //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
            lazy: immediateRender && _isNotFalse(lazy),
            immediateRender: immediateRender,
            //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
            stagger: 0,
            parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})
          }, cleanVars);
          harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})
          _removeFromParent(tween._startAt = Tween.set(targets, p));
          time < 0 && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted from() tween.
          if (!immediateRender) {
            _initTween2(tween._startAt, _tinyNum); //ensures that the initial values are recorded
          } else if (!time) {
            return;
          }
        }
      }
      tween._pt = 0;
      lazy = dur && _isNotFalse(lazy) || lazy && !dur;
      for (i = 0; i < targets.length; i++) {
        target = targets[i];
        gsData = target._gsap || _harness(targets)[i]._gsap;
        tween._ptLookup[i] = ptLookup = {};
        _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
        index = fullTargets === targets ? i : fullTargets.indexOf(target);
        if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
          plugin._props.forEach(function (name) {
            ptLookup[name] = pt;
          });
          plugin.priority && (hasPriority = 1);
        }
        if (!harness || harnessVars) {
          for (p in cleanVars) {
            if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
              plugin.priority && (hasPriority = 1);
            } else {
              ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
            }
          }
        }
        tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
        if (autoOverwrite && tween._pt) {
          _overwritingTween = tween;
          _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(0)); //Also make sure the overwriting doesn't overwrite THIS tween!!!
          overwritten = !tween.parent;
          _overwritingTween = 0;
        }
        tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
      }
      hasPriority && _sortPropTweensByPriority(tween);
      tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
    }
    tween._onUpdate = onUpdate;
    tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.
  },
  _addAliasesToVars = function _addAliasesToVars(targets, vars) {
    var harness = targets[0] ? _getCache(targets[0]).harness : 0,
      propertyAliases = harness && harness.aliases,
      copy,
      p,
      i,
      aliases;
    if (!propertyAliases) {
      return vars;
    }
    copy = _merge({}, vars);
    for (p in propertyAliases) {
      if (p in copy) {
        aliases = propertyAliases[p].split(",");
        i = aliases.length;
        while (i--) {
          copy[aliases[i]] = copy[p];
        }
      }
    }
    return copy;
  },
  _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
    return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
  },
  _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
  _staggerPropsToSkip = (_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger").split(",");

/*
 * --------------------------------------------------------------------------------------
 * TWEEN
 * --------------------------------------------------------------------------------------
 */

var Tween = /*#__PURE__*/function (_Animation2) {
  function Tween(targets, vars, position, skipInherit) {
    var _this3;
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_5__["default"])(this, Tween);
    if (typeof vars === "number") {
      position.duration = vars;
      vars = position;
      position = null;
    }
    _this3 = _callSuper(this, Tween, [skipInherit ? vars : _inheritDefaults(vars)]);
    var _this3$vars = _this3.vars,
      duration = _this3$vars.duration,
      delay = _this3$vars.delay,
      immediateRender = _this3$vars.immediateRender,
      stagger = _this3$vars.stagger,
      overwrite = _this3$vars.overwrite,
      keyframes = _this3$vars.keyframes,
      defaults = _this3$vars.defaults,
      scrollTrigger = _this3$vars.scrollTrigger,
      yoyoEase = _this3$vars.yoyoEase,
      parent = vars.parent || _globalTimeline,
      parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
      tl,
      i,
      copy,
      l,
      p,
      curTarget,
      staggerFunc,
      staggerVarsToMerge;
    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property
    _this3._overwrite = overwrite;
    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this3.vars;
      tl = _this3.timeline = new Timeline({
        data: "nested",
        defaults: defaults || {}
      });
      tl.kill();
      tl.parent = tl._dp = _this3;
      tl._start = 0;
      if (keyframes) {
        _setDefaults(tl.vars.defaults, {
          ease: "none"
        });
        stagger ? parsedTargets.forEach(function (t, i) {
          return keyframes.forEach(function (frame, j) {
            return tl.to(t, frame, j ? ">" : i * stagger);
          });
        }) : keyframes.forEach(function (frame) {
          return tl.to(parsedTargets, frame, ">");
        });
      } else {
        l = parsedTargets.length;
        staggerFunc = stagger ? distribute(stagger) : _emptyFunc;
        if (_isObject(stagger)) {
          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              staggerVarsToMerge || (staggerVarsToMerge = {});
              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }
        for (i = 0; i < l; i++) {
          copy = {};
          for (p in vars) {
            if (_staggerPropsToSkip.indexOf(p) < 0) {
              copy[p] = vars[p];
            }
          }
          copy.stagger = 0;
          yoyoEase && (copy.yoyoEase = yoyoEase);
          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
          curTarget = parsedTargets[i];
          //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.
          copy.duration = +_parseFuncOrString(duration, _this3, i, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _this3, i, curTarget, parsedTargets) || 0) - _this3._delay;
          if (!stagger && l === 1 && copy.delay) {
            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
            _this3._delay = delay = copy.delay;
            _this3._start += delay;
            copy.delay = 0;
          }
          tl.to(curTarget, copy, staggerFunc(i, curTarget, parsedTargets));
        }
        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
      }
      duration || _this3.duration(duration = tl.duration());
    } else {
      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
    }
    if (overwrite === true && !_suppressOverwrites) {
      _overwritingTween = _this3;
      _globalTimeline.killTweensOf(parsedTargets);
      _overwritingTween = 0;
    }
    _addToTimeline(parent, _this3, position);
    vars.reversed && _this3.reverse();
    vars.paused && _this3.paused(true);
    if (immediateRender || !duration && !keyframes && _this3._start === _round(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors2(_this3) && parent.data !== "nested") {
      _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
      _this3.render(Math.max(0, -delay)); //in case delay is negative
    }
    scrollTrigger && _scrollTrigger(_this3, scrollTrigger);
    return _this3;
  }
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(Tween, _Animation2);
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(Tween, [{
    key: "render",
    value: function render(totalTime, suppressEvents, force) {
      var prevTime = this._time,
        tDur = this._tDur,
        dur = this._dur,
        tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        time,
        pt,
        iteration,
        cycleDuration,
        prevIteration,
        isYoyo,
        ratio,
        timeline,
        yoyoEase;
      if (!dur) {
        _renderZeroDurationTween(this, totalTime, suppressEvents, force);
      } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {
        //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
        time = tTime;
        timeline = this.timeline;
        if (this._repeat) {
          //adjust the time for repeats and yoyos
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && totalTime < 0) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)
          if (tTime === tDur) {
            // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
            iteration = this._repeat;
            time = dur;
          } else {
            iteration = ~~(tTime / cycleDuration);
            if (iteration && iteration === tTime / cycleDuration) {
              time = dur;
              iteration--;
            }
            time > dur && (time = dur);
          }
          isYoyo = this._yoyo && iteration & 1;
          if (isYoyo) {
            yoyoEase = this._yEase;
            time = dur - time;
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          if (time === prevTime && !force && this._initted) {
            //could be during the repeatDelay part. No need to render and fire callbacks.
            return this;
          }
          if (iteration !== prevIteration) {
            timeline && this._yEase && _propagateYoyoEase2(timeline, isYoyo);
            //repeatRefresh functionality
            if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
              this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.
              this.render(_round(cycleDuration * iteration), true).invalidate()._lock = 0;
            }
          }
        }
        if (!this._initted) {
          if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {
            this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.
            return this;
          }
          if (dur !== this._dur) {
            // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._tTime = tTime;
        this._time = time;
        if (!this._act && this._ts) {
          this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.
          this._lazy = 0;
        }
        this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
        if (this._from) {
          this.ratio = ratio = 1 - ratio;
        }
        time && !prevTime && !suppressEvents && _callback(this, "onStart");
        if (time && !prevTime && !suppressEvents) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
            return this;
          }
        }
        pt = this._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
        timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * ratio, suppressEvents, force) || this._startAt && (this._zTime = totalTime);
        if (this._onUpdate && !suppressEvents) {
          totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
          _callback(this, "onUpdate");
        }
        this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
        if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
          totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);
          (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.
          if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
            // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
            _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }
      return this;
    }
  }, {
    key: "targets",
    value: function targets() {
      return this._targets;
    }
  }, {
    key: "invalidate",
    value: function invalidate() {
      this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;
      this._ptLookup = [];
      this.timeline && this.timeline.invalidate();
      return _superPropGet(Tween, "invalidate", this, 3)([]);
    }
  }, {
    key: "kill",
    value: function kill(targets) {
      var vars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "all";
      if (!targets && (!vars || vars === "all")) {
        this._lazy = this._pt = 0;
        return this.parent ? _interrupt(this) : this;
      }
      if (this.timeline) {
        var tDur = this.timeline.totalDuration();
        this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.
        this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.
        return this;
      }
      var parsedTargets = this._targets,
        killingTargets = targets ? toArray(targets) : parsedTargets,
        propTweenLookup = this._ptLookup,
        firstPT = this._pt,
        overwrittenProps,
        curLookup,
        curOverwriteProps,
        props,
        p,
        pt,
        i;
      if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
        vars === "all" && (this._pt = 0);
        return _interrupt(this);
      }
      overwrittenProps = this._op = this._op || [];
      if (vars !== "all") {
        //so people can pass in a comma-delimited list of property names
        if (_isString(vars)) {
          p = {};
          _forEachName(vars, function (name) {
            return p[name] = 1;
          });
          vars = p;
        }
        vars = _addAliasesToVars(parsedTargets, vars);
      }
      i = parsedTargets.length;
      while (i--) {
        if (~killingTargets.indexOf(parsedTargets[i])) {
          curLookup = propTweenLookup[i];
          if (vars === "all") {
            overwrittenProps[i] = vars;
            props = curLookup;
            curOverwriteProps = {};
          } else {
            curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
            props = vars;
          }
          for (p in props) {
            pt = curLookup && curLookup[p];
            if (pt) {
              if (!("kill" in pt.d) || pt.d.kill(p) === true) {
                _removeLinkedListItem(this, pt, "_pt");
              }
              delete curLookup[p];
            }
            if (curOverwriteProps !== "all") {
              curOverwriteProps[p] = 1;
            }
          }
        }
      }
      this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
      return this;
    }
  }], [{
    key: "to",
    value: function to(targets, vars) {
      return new Tween(targets, vars, arguments[2]);
    }
  }, {
    key: "from",
    value: function from(targets, vars) {
      return _createTweenType(1, arguments);
    }
  }, {
    key: "delayedCall",
    value: function delayedCall(delay, callback, params, scope) {
      return new Tween(callback, 0, {
        immediateRender: false,
        lazy: false,
        overwrite: false,
        delay: delay,
        onComplete: callback,
        onReverseComplete: callback,
        onCompleteParams: params,
        onReverseCompleteParams: params,
        callbackScope: scope
      });
    }
  }, {
    key: "fromTo",
    value: function fromTo(targets, fromVars, toVars) {
      return _createTweenType(2, arguments);
    }
  }, {
    key: "set",
    value: function set(targets, vars) {
      vars.duration = 0;
      vars.repeatDelay || (vars.repeat = 0);
      return new Tween(targets, vars);
    }
  }, {
    key: "killTweensOf",
    value: function killTweensOf(targets, props, onlyActive) {
      return _globalTimeline.killTweensOf(targets, props, onlyActive);
    }
  }]);
}(Animation);
_setDefaults(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
});

//add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
// 	Tween.prototype[name] = function() {
// 		let tl = new Timeline();
// 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
// 	}
// });

//for backward compatibility. Leverage the timeline calls.
_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
  Tween[name] = function () {
    var tl = new Timeline(),
      params = _slice.call(arguments, 0);
    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});

/*
 * --------------------------------------------------------------------------------------
 * PROPTWEEN
 * --------------------------------------------------------------------------------------
 */
var _setterPlain = function _setterPlain(target, property, value) {
    return target[property] = value;
  },
  _setterFunc = function _setterFunc(target, property, value) {
    return target[property](value);
  },
  _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
    return target[property](data.fp, value);
  },
  _setterAttribute = function _setterAttribute(target, property, value) {
    return target.setAttribute(property, value);
  },
  _getSetter = function _getSetter(target, property) {
    return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
  },
  _renderPlain = function _renderPlain(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
  },
  _renderBoolean = function _renderBoolean(ratio, data) {
    return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
  },
  _renderComplexString = function _renderComplexString(ratio, data) {
    var pt = data._pt,
      s = "";
    if (!ratio && data.b) {
      //b = beginning string
      s = data.b;
    } else if (ratio === 1 && data.e) {
      //e = ending string
      s = data.e;
    } else {
      while (pt) {
        s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.
        pt = pt._next;
      }
      s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
    }
    data.set(data.t, data.p, s, data);
  },
  _renderPropTweens = function _renderPropTweens(ratio, data) {
    var pt = data._pt;
    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
  },
  _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
    var pt = this._pt,
      next;
    while (pt) {
      next = pt._next;
      pt.p === property && pt.modifier(modifier, tween, target);
      pt = next;
    }
  },
  _killPropTweensOf = function _killPropTweensOf(property) {
    var pt = this._pt,
      hasNonDependentRemaining,
      next;
    while (pt) {
      next = pt._next;
      if (pt.p === property && !pt.op || pt.op === property) {
        _removeLinkedListItem(this, pt, "_pt");
      } else if (!pt.dep) {
        hasNonDependentRemaining = 1;
      }
      pt = next;
    }
    return !hasNonDependentRemaining;
  },
  _setterWithModifier = function _setterWithModifier(target, property, value, data) {
    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
  },
  _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
    var pt = parent._pt,
      next,
      pt2,
      first,
      last;
    //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)
    while (pt) {
      next = pt._next;
      pt2 = first;
      while (pt2 && pt2.pr > pt.pr) {
        pt2 = pt2._next;
      }
      if (pt._prev = pt2 ? pt2._prev : last) {
        pt._prev._next = pt;
      } else {
        first = pt;
      }
      if (pt._next = pt2) {
        pt2._prev = pt;
      } else {
        last = pt;
      }
      pt = next;
    }
    parent._pt = first;
  };

//PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)
var PropTween = /*#__PURE__*/function () {
  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_5__["default"])(this, PropTween);
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;
    if (next) {
      next._prev = this;
    }
  }
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(PropTween, [{
    key: "modifier",
    value: function modifier(func, tween, target) {
      this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)
      this.set = _setterWithModifier;
      this.m = func;
      this.mt = target; //modifier target
      this.tween = tween;
    }
  }]);
}();

//Initialization tasks
_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
  return _reservedProps[name] = 1;
});
_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root",
  smoothChildTiming: true
});
_config.stringFilter = _colorStringFilter;

/*
 * --------------------------------------------------------------------------------------
 * GSAP
 * --------------------------------------------------------------------------------------
 */
var _gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    args.forEach(function (config) {
      return _createPlugin(config);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty(target, property, unit, uncache) {
    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in
    var getter = _getCache(target || {}).get,
      format = unit ? _passThrough : _numericIfPossible;
    unit === "native" && (unit = "");
    return !target ? target : !property ? function (property, unit, uncache) {
      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray(target);
    if (target.length > 1) {
      var setters = target.map(function (t) {
          return gsap.quickSetter(t, property, unit);
        }),
        l = setters.length;
      return function (value) {
        var i = l;
        while (i--) {
          setters[i](value);
        }
      };
    }
    target = target[0] || {};
    var Plugin = _plugins[property],
      cache = _getCache(target),
      p = cache.harness && (cache.harness.aliases || {})[property] || property,
      // in case it's an alias, like "rotate" for "rotation".
      setter = Plugin ? function (value) {
        var p = new Plugin();
        _quickTween._pt = 0;
        p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
        p.render(1, p);
        _quickTween._pt && _renderPropTweens(1, _quickTween);
      } : cache.set(target, p);
    return Plugin ? setter : function (value) {
      return setter(target, p, unit ? value + unit : value, cache, 1);
    };
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
    return _mergeDeep2(_defaults, value || {});
  },
  config: function config(value) {
    return _mergeDeep2(_config, value || {});
  },
  registerEffect: function registerEffect(_ref3) {
    var name = _ref3.name,
      effect = _ref3.effect,
      plugins = _ref3.plugins,
      defaults = _ref3.defaults,
      extendTimeline = _ref3.extendTimeline;
    (plugins || "").split(",").forEach(function (pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });
    _effects[name] = function (targets, vars, tl) {
      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
    };
    if (extendTimeline) {
      Timeline.prototype[name] = function (targets, vars, position) {
        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot() {
    var vars = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var includeDelayedCalls = arguments.length > 1 ? arguments[1] : undefined;
    var tl = new Timeline(vars),
      child,
      next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
    _globalTimeline.remove(tl);
    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).
    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;
    while (child) {
      next = child._next;
      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }
      child = next;
    }
    _addToTimeline(_globalTimeline, tl, 0);
    return tl;
  },
  utils: {
    wrap: _wrap,
    wrapYoyo: _wrapYoyo,
    distribute: distribute,
    random: random,
    snap: snap,
    normalize: normalize,
    getUnit: getUnit,
    clamp: clamp,
    splitColor: splitColor,
    toArray: toArray,
    selector: selector,
    mapRange: mapRange,
    pipe: pipe,
    unitize: unitize,
    interpolate: _interpolate,
    shuffle: shuffle
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween: PropTween,
    globals: _addGlobal,
    Tween: Tween,
    Timeline: Timeline,
    Animation: Animation,
    getCache: _getCache,
    _removeLinkedListItem: _removeLinkedListItem,
    suppressOverwrites: function suppressOverwrites(value) {
      return _suppressOverwrites = value;
    }
  }
};
_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
  return _gsap[name] = Tween[name];
});
_ticker.add(Timeline.updateRoot);
_quickTween = _gsap.to({}, {
  duration: 0
});

// ---- EXTRA PLUGINS --------------------------------------------------------

var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
    var pt = plugin._pt;
    while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
      pt = pt._next;
    }
    return pt;
  },
  _addModifiers = function _addModifiers(tween, modifiers) {
    var targets = tween._targets,
      p,
      i,
      pt;
    for (p in modifiers) {
      i = targets.length;
      while (i--) {
        pt = tween._ptLookup[i][p];
        if (pt && (pt = pt.d)) {
          if (pt._pt) {
            // is a plugin
            pt = _getPluginPropTween(pt, p);
          }
          pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
        }
      }
    }
  },
  _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
    return {
      name: name,
      rawVars: 1,
      //don't pre-process function-based values or "random()" strings.
      init: function init(target, vars, tween) {
        tween._onInit = function (tween) {
          var temp, p;
          if (_isString(vars)) {
            temp = {};
            _forEachName(vars, function (name) {
              return temp[name] = 1;
            }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.
            vars = temp;
          }
          if (modifier) {
            temp = {};
            for (p in vars) {
              temp[p] = modifier(vars[p]);
            }
            vars = temp;
          }
          _addModifiers(tween, vars);
        };
      }
    };
  };

//register core plugins
var gsap = _gsap.registerPlugin({
  name: "attr",
  init: function init(target, vars, tween, index, targets) {
    var p, pt;
    for (p in vars) {
      pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);
      pt && (pt.op = p);
      this._props.push(p);
    }
  }
}, {
  name: "endArray",
  init: function init(target, value) {
    var i = value.length;
    while (i--) {
      this.add(target, i, target[i] || 0, value[i]);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.

Tween.version = Timeline.version = gsap.version = "3.7.0";
_coreReady = 1;
_windowExists() && _wake();
var Power0 = _easeMap.Power0,
  Power1 = _easeMap.Power1,
  Power2 = _easeMap.Power2,
  Power3 = _easeMap.Power3,
  Power4 = _easeMap.Power4,
  Linear = _easeMap.Linear,
  Quad = _easeMap.Quad,
  Cubic = _easeMap.Cubic,
  Quart = _easeMap.Quart,
  Quint = _easeMap.Quint,
  Strong = _easeMap.Strong,
  Elastic = _easeMap.Elastic,
  Back = _easeMap.Back,
  SteppedEase = _easeMap.SteppedEase,
  Bounce = _easeMap.Bounce,
  Sine = _easeMap.Sine,
  Expo = _easeMap.Expo,
  Circ = _easeMap.Circ;


//export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.


/***/ }),

/***/ "./src/assets/scripts/gsap/index.js":
/*!******************************************!*\
  !*** ./src/assets/scripts/gsap/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Back: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back),
/* harmony export */   Bounce: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce),
/* harmony export */   CSSPlugin: () => (/* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin),
/* harmony export */   Circ: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ),
/* harmony export */   Cubic: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic),
/* harmony export */   Elastic: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic),
/* harmony export */   Expo: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo),
/* harmony export */   Linear: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear),
/* harmony export */   Power0: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0),
/* harmony export */   Power1: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1),
/* harmony export */   Power2: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2),
/* harmony export */   Power3: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3),
/* harmony export */   Power4: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4),
/* harmony export */   Quad: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad),
/* harmony export */   Quart: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart),
/* harmony export */   Quint: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint),
/* harmony export */   Sine: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine),
/* harmony export */   SteppedEase: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase),
/* harmony export */   Strong: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong),
/* harmony export */   TimelineLite: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite),
/* harmony export */   TimelineMax: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax),
/* harmony export */   TweenLite: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite),
/* harmony export */   TweenMax: () => (/* binding */ TweenMaxWithCSS),
/* harmony export */   "default": () => (/* binding */ gsapWithCSS),
/* harmony export */   gsap: () => (/* binding */ gsapWithCSS)
/* harmony export */ });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./src/assets/scripts/gsap/gsap-core.js");
/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ "./src/assets/scripts/gsap/CSSPlugin.js");


var gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap,
  // to protect from tree shaking
  TweenMaxWithCSS = gsapWithCSS.core.Tween;


/***/ }),

/***/ "./src/assets/scripts/gsap/utils/paths.js":
/*!************************************************!*\
  !*** ./src/assets/scripts/gsap/utils/paths.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bezierToPoints: () => (/* binding */ bezierToPoints),
/* harmony export */   cacheRawPathMeasurements: () => (/* binding */ cacheRawPathMeasurements),
/* harmony export */   convertToPath: () => (/* binding */ convertToPath),
/* harmony export */   copyRawPath: () => (/* binding */ copyRawPath),
/* harmony export */   flatPointsToSegment: () => (/* binding */ flatPointsToSegment),
/* harmony export */   getClosestData: () => (/* binding */ getClosestData),
/* harmony export */   getPositionOnPath: () => (/* binding */ getPositionOnPath),
/* harmony export */   getRawPath: () => (/* binding */ getRawPath),
/* harmony export */   getRotationAtProgress: () => (/* binding */ getRotationAtProgress),
/* harmony export */   pointsToSegment: () => (/* binding */ pointsToSegment),
/* harmony export */   rawPathToString: () => (/* binding */ rawPathToString),
/* harmony export */   reverseSegment: () => (/* binding */ reverseSegment),
/* harmony export */   simplifyPoints: () => (/* binding */ simplifyPoints),
/* harmony export */   sliceRawPath: () => (/* binding */ sliceRawPath),
/* harmony export */   stringToRawPath: () => (/* binding */ stringToRawPath),
/* harmony export */   subdivideSegment: () => (/* binding */ subdivideSegment),
/* harmony export */   subdivideSegmentNear: () => (/* binding */ subdivideSegmentNear),
/* harmony export */   transformRawPath: () => (/* binding */ transformRawPath)
/* harmony export */ });
/*!
 * paths 3.7.0
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */

var _svgPathExp = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
  _numbersExp = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
  _scientific = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig,
  _selectorExp = /(^[#\.][a-z]|[a-y][a-z])/i,
  _DEG2RAD = Math.PI / 180,
  _RAD2DEG = 180 / Math.PI,
  _sin = Math.sin,
  _cos = Math.cos,
  _abs = Math.abs,
  _sqrt = Math.sqrt,
  _atan2 = Math.atan2,
  _largeNum = 1e8,
  _isString = function _isString(value) {
    return typeof value === "string";
  },
  _isNumber = function _isNumber(value) {
    return typeof value === "number";
  },
  _isUndefined = function _isUndefined(value) {
    return typeof value === "undefined";
  },
  _temp = {},
  _temp2 = {},
  _roundingNum = 1e5,
  _wrapProgress = function _wrapProgress(progress) {
    return Math.round((progress + _largeNum) % 1 * _roundingNum) / _roundingNum || (progress < 0 ? 0 : 1);
  },
  //if progress lands on 1, the % will make it 0 which is why we || 1, but not if it's negative because it makes more sense for motion to end at 0 in that case.
  _round = function _round(value) {
    return Math.round(value * _roundingNum) / _roundingNum || 0;
  },
  _roundPrecise = function _roundPrecise(value) {
    return Math.round(value * 1e10) / 1e10 || 0;
  },
  _splitSegment = function _splitSegment(rawPath, segIndex, i, t) {
    var segment = rawPath[segIndex],
      shift = t === 1 ? 6 : subdivideSegment(segment, i, t);
    if (shift && shift + i + 2 < segment.length) {
      rawPath.splice(segIndex, 0, segment.slice(0, i + shift + 2));
      segment.splice(0, i + shift);
      return 1;
    }
  },
  _reverseRawPath = function _reverseRawPath(rawPath, skipOuter) {
    var i = rawPath.length;
    skipOuter || rawPath.reverse();
    while (i--) {
      rawPath[i].reversed || reverseSegment(rawPath[i]);
    }
  },
  _copyMetaData = function _copyMetaData(source, copy) {
    copy.totalLength = source.totalLength;
    if (source.samples) {
      //segment
      copy.samples = source.samples.slice(0);
      copy.lookup = source.lookup.slice(0);
      copy.minLength = source.minLength;
      copy.resolution = source.resolution;
    } else if (source.totalPoints) {
      //rawPath
      copy.totalPoints = source.totalPoints;
    }
    return copy;
  },
  //pushes a new segment into a rawPath, but if its starting values match the ending values of the last segment, it'll merge it into that same segment (to reduce the number of segments)
  _appendOrMerge = function _appendOrMerge(rawPath, segment) {
    var index = rawPath.length,
      prevSeg = rawPath[index - 1] || [],
      l = prevSeg.length;
    if (index && segment[0] === prevSeg[l - 2] && segment[1] === prevSeg[l - 1]) {
      segment = prevSeg.concat(segment.slice(2));
      index--;
    }
    rawPath[index] = segment;
  },
  _bestDistance;

/* TERMINOLOGY
 - RawPath - an array of arrays, one for each Segment. A single RawPath could have multiple "M" commands, defining Segments (paths aren't always connected).
 - Segment - an array containing a sequence of Cubic Bezier coordinates in alternating x, y, x, y format. Starting anchor, then control point 1, control point 2, and ending anchor, then the next control point 1, control point 2, anchor, etc. Uses less memory than an array with a bunch of {x, y} points.
 - Bezier - a single cubic Bezier with a starting anchor, two control points, and an ending anchor.
 - the variable "t" is typically the position along an individual Bezier path (time) and it's NOT linear, meaning it could accelerate/decelerate based on the control points whereas the "p" or "progress" value is linearly mapped to the whole path, so it shouldn't really accelerate/decelerate based on control points. So a progress of 0.2 would be almost exactly 20% along the path. "t" is ONLY in an individual Bezier piece.
 */

//accepts basic selector text, a path instance, a RawPath instance, or a Segment and returns a RawPath (makes it easy to homogenize things). If an element or selector text is passed in, it'll also cache the value so that if it's queried again, it'll just take the path data from there instead of parsing it all over again (as long as the path data itself hasn't changed - it'll check).
function getRawPath(value) {
  value = _isString(value) && _selectorExp.test(value) ? document.querySelector(value) || value : value;
  var e = value.getAttribute ? value : 0,
    rawPath;
  if (e && (value = value.getAttribute("d"))) {
    //implements caching
    if (!e._gsPath) {
      e._gsPath = {};
    }
    rawPath = e._gsPath[value];
    return rawPath && !rawPath._dirty ? rawPath : e._gsPath[value] = stringToRawPath(value);
  }
  return !value ? console.warn("Expecting a <path> element or an SVG path data string") : _isString(value) ? stringToRawPath(value) : _isNumber(value[0]) ? [value] : value;
}

//copies a RawPath WITHOUT the length meta data (for speed)
function copyRawPath(rawPath) {
  var a = [],
    i = 0;
  for (; i < rawPath.length; i++) {
    a[i] = _copyMetaData(rawPath[i], rawPath[i].slice(0));
  }
  return _copyMetaData(rawPath, a);
}
function reverseSegment(segment) {
  var i = 0,
    y;
  segment.reverse(); //this will invert the order y, x, y, x so we must flip it back.
  for (; i < segment.length; i += 2) {
    y = segment[i];
    segment[i] = segment[i + 1];
    segment[i + 1] = y;
  }
  segment.reversed = !segment.reversed;
}
var _createPath = function _createPath(e, ignore) {
    var path = document.createElementNS("http://www.w3.org/2000/svg", "path"),
      attr = [].slice.call(e.attributes),
      i = attr.length,
      name;
    ignore = "," + ignore + ",";
    while (--i > -1) {
      name = attr[i].nodeName.toLowerCase(); //in Microsoft Edge, if you don't set the attribute with a lowercase name, it doesn't render correctly! Super weird.
      if (ignore.indexOf("," + name + ",") < 0) {
        path.setAttributeNS(null, name, attr[i].nodeValue);
      }
    }
    return path;
  },
  _typeAttrs = {
    rect: "rx,ry,x,y,width,height",
    circle: "r,cx,cy",
    ellipse: "rx,ry,cx,cy",
    line: "x1,x2,y1,y2"
  },
  _attrToObj = function _attrToObj(e, attrs) {
    var props = attrs ? attrs.split(",") : [],
      obj = {},
      i = props.length;
    while (--i > -1) {
      obj[props[i]] = +e.getAttribute(props[i]) || 0;
    }
    return obj;
  };

//converts an SVG shape like <circle>, <rect>, <polygon>, <polyline>, <ellipse>, etc. to a <path>, swapping it in and copying the attributes to match.
function convertToPath(element, swap) {
  var type = element.tagName.toLowerCase(),
    circ = 0.552284749831,
    data,
    x,
    y,
    r,
    ry,
    path,
    rcirc,
    rycirc,
    points,
    w,
    h,
    x2,
    x3,
    x4,
    x5,
    x6,
    y2,
    y3,
    y4,
    y5,
    y6,
    attr;
  if (type === "path" || !element.getBBox) {
    return element;
  }
  path = _createPath(element, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points");
  attr = _attrToObj(element, _typeAttrs[type]);
  if (type === "rect") {
    r = attr.rx;
    ry = attr.ry || r;
    x = attr.x;
    y = attr.y;
    w = attr.width - r * 2;
    h = attr.height - ry * 2;
    if (r || ry) {
      //if there are rounded corners, render cubic beziers
      x2 = x + r * (1 - circ);
      x3 = x + r;
      x4 = x3 + w;
      x5 = x4 + r * circ;
      x6 = x4 + r;
      y2 = y + ry * (1 - circ);
      y3 = y + ry;
      y4 = y3 + h;
      y5 = y4 + ry * circ;
      y6 = y4 + ry;
      data = "M" + x6 + "," + y3 + " V" + y4 + " C" + [x6, y5, x5, y6, x4, y6, x4 - (x4 - x3) / 3, y6, x3 + (x4 - x3) / 3, y6, x3, y6, x2, y6, x, y5, x, y4, x, y4 - (y4 - y3) / 3, x, y3 + (y4 - y3) / 3, x, y3, x, y2, x2, y, x3, y, x3 + (x4 - x3) / 3, y, x4 - (x4 - x3) / 3, y, x4, y, x5, y, x6, y2, x6, y3].join(",") + "z";
    } else {
      data = "M" + (x + w) + "," + y + " v" + h + " h" + -w + " v" + -h + " h" + w + "z";
    }
  } else if (type === "circle" || type === "ellipse") {
    if (type === "circle") {
      r = ry = attr.r;
      rycirc = r * circ;
    } else {
      r = attr.rx;
      ry = attr.ry;
      rycirc = ry * circ;
    }
    x = attr.cx;
    y = attr.cy;
    rcirc = r * circ;
    data = "M" + (x + r) + "," + y + " C" + [x + r, y + rycirc, x + rcirc, y + ry, x, y + ry, x - rcirc, y + ry, x - r, y + rycirc, x - r, y, x - r, y - rycirc, x - rcirc, y - ry, x, y - ry, x + rcirc, y - ry, x + r, y - rycirc, x + r, y].join(",") + "z";
  } else if (type === "line") {
    data = "M" + attr.x1 + "," + attr.y1 + " L" + attr.x2 + "," + attr.y2; //previously, we just converted to "Mx,y Lx,y" but Safari has bugs that cause that not to render properly when using a stroke-dasharray that's not fully visible! Using a cubic bezier fixes that issue.
  } else if (type === "polyline" || type === "polygon") {
    points = (element.getAttribute("points") + "").match(_numbersExp) || [];
    x = points.shift();
    y = points.shift();
    data = "M" + x + "," + y + " L" + points.join(",");
    if (type === "polygon") {
      data += "," + x + "," + y + "z";
    }
  }
  path.setAttribute("d", rawPathToString(path._gsRawPath = stringToRawPath(data)));
  if (swap && element.parentNode) {
    element.parentNode.insertBefore(path, element);
    element.parentNode.removeChild(element);
  }
  return path;
}

//returns the rotation (in degrees) at a particular progress on a rawPath (the slope of the tangent)
function getRotationAtProgress(rawPath, progress) {
  var d = getProgressData(rawPath, progress >= 1 ? 1 - 1e-9 : progress ? progress : 1e-9);
  return getRotationAtBezierT(d.segment, d.i, d.t);
}
function getRotationAtBezierT(segment, i, t) {
  var a = segment[i],
    b = segment[i + 2],
    c = segment[i + 4],
    x;
  a += (b - a) * t;
  b += (c - b) * t;
  a += (b - a) * t;
  x = b + (c + (segment[i + 6] - c) * t - b) * t - a;
  a = segment[i + 1];
  b = segment[i + 3];
  c = segment[i + 5];
  a += (b - a) * t;
  b += (c - b) * t;
  a += (b - a) * t;
  return _round(_atan2(b + (c + (segment[i + 7] - c) * t - b) * t - a, x) * _RAD2DEG);
}
function sliceRawPath(rawPath, start, end) {
  end = _isUndefined(end) ? 1 : _roundPrecise(end) || 0; // we must round to avoid issues like 4.15 / 8 = 0.8300000000000001 instead of 0.83 or 2.8 / 5 = 0.5599999999999999 instead of 0.56 and if someone is doing a loop like start: 2.8 / 0.5, end: 2.8 / 0.5 + 1.
  start = _roundPrecise(start) || 0;
  var loops = Math.max(0, ~~(_abs(end - start) - 1e-8)),
    path = copyRawPath(rawPath);
  if (start > end) {
    start = 1 - start;
    end = 1 - end;
    _reverseRawPath(path);
    path.totalLength = 0;
  }
  if (start < 0 || end < 0) {
    var offset = Math.abs(~~Math.min(start, end)) + 1;
    start += offset;
    end += offset;
  }
  path.totalLength || cacheRawPathMeasurements(path);
  var wrap = end > 1,
    s = getProgressData(path, start, _temp, true),
    e = getProgressData(path, end, _temp2),
    eSeg = e.segment,
    sSeg = s.segment,
    eSegIndex = e.segIndex,
    sSegIndex = s.segIndex,
    ei = e.i,
    si = s.i,
    sameSegment = sSegIndex === eSegIndex,
    sameBezier = ei === si && sameSegment,
    wrapsBehind,
    sShift,
    eShift,
    i,
    copy,
    totalSegments,
    l,
    j;
  if (wrap || loops) {
    wrapsBehind = eSegIndex < sSegIndex || sameSegment && ei < si || sameBezier && e.t < s.t;
    if (_splitSegment(path, sSegIndex, si, s.t)) {
      sSegIndex++;
      if (!wrapsBehind) {
        eSegIndex++;
        if (sameBezier) {
          e.t = (e.t - s.t) / (1 - s.t);
          ei = 0;
        } else if (sameSegment) {
          ei -= si;
        }
      }
    }
    if (1 - (end - start) < 1e-5) {
      eSegIndex = sSegIndex - 1;
    } else if (!e.t && eSegIndex) {
      eSegIndex--;
    } else if (_splitSegment(path, eSegIndex, ei, e.t) && wrapsBehind) {
      sSegIndex++;
    }
    if (s.t === 1) {
      sSegIndex = (sSegIndex + 1) % path.length;
    }
    copy = [];
    totalSegments = path.length;
    l = 1 + totalSegments * loops;
    j = sSegIndex;
    l += (totalSegments - sSegIndex + eSegIndex) % totalSegments;
    for (i = 0; i < l; i++) {
      _appendOrMerge(copy, path[j++ % totalSegments]);
    }
    path = copy;
  } else {
    eShift = e.t === 1 ? 6 : subdivideSegment(eSeg, ei, e.t);
    if (start !== end) {
      sShift = subdivideSegment(sSeg, si, sameBezier ? s.t / e.t : s.t);
      sameSegment && (eShift += sShift);
      eSeg.splice(ei + eShift + 2);
      (sShift || si) && sSeg.splice(0, si + sShift);
      i = path.length;
      while (i--) {
        //chop off any extra segments
        (i < sSegIndex || i > eSegIndex) && path.splice(i, 1);
      }
    } else {
      eSeg.angle = getRotationAtBezierT(eSeg, ei + eShift, 0); //record the value before we chop because it'll be impossible to determine the angle after its length is 0!
      ei += eShift;
      s = eSeg[ei];
      e = eSeg[ei + 1];
      eSeg.length = eSeg.totalLength = 0;
      eSeg.totalPoints = path.totalPoints = 8;
      eSeg.push(s, e, s, e, s, e, s, e);
    }
  }
  path.totalLength = 0;
  return path;
}

//measures a Segment according to its resolution (so if segment.resolution is 6, for example, it'll take 6 samples equally across each Bezier) and create/populate a "samples" Array that has the length up to each of those sample points (always increasing from the start) as well as a "lookup" array that's broken up according to the smallest distance between 2 samples. This gives us a very fast way of looking up a progress position rather than looping through all the points/Beziers. You can optionally have it only measure a subset, starting at startIndex and going for a specific number of beziers (remember, there are 3 x/y pairs each, for a total of 6 elements for each Bezier). It will also populate a "totalLength" property, but that's not generally super accurate because by default it'll only take 6 samples per Bezier. But for performance reasons, it's perfectly adequate for measuring progress values along the path. If you need a more accurate totalLength, either increase the resolution or use the more advanced bezierToPoints() method which keeps adding points until they don't deviate by more than a certain precision value.
function measureSegment(segment, startIndex, bezierQty) {
  startIndex = startIndex || 0;
  if (!segment.samples) {
    segment.samples = [];
    segment.lookup = [];
  }
  var resolution = ~~segment.resolution || 12,
    inc = 1 / resolution,
    endIndex = bezierQty ? startIndex + bezierQty * 6 + 1 : segment.length,
    x1 = segment[startIndex],
    y1 = segment[startIndex + 1],
    samplesIndex = startIndex ? startIndex / 6 * resolution : 0,
    samples = segment.samples,
    lookup = segment.lookup,
    min = (startIndex ? segment.minLength : _largeNum) || _largeNum,
    prevLength = samples[samplesIndex + bezierQty * resolution - 1],
    length = startIndex ? samples[samplesIndex - 1] : 0,
    i,
    j,
    x4,
    x3,
    x2,
    xd,
    xd1,
    y4,
    y3,
    y2,
    yd,
    yd1,
    inv,
    t,
    lengthIndex,
    l,
    segLength;
  samples.length = lookup.length = 0;
  for (j = startIndex + 2; j < endIndex; j += 6) {
    x4 = segment[j + 4] - x1;
    x3 = segment[j + 2] - x1;
    x2 = segment[j] - x1;
    y4 = segment[j + 5] - y1;
    y3 = segment[j + 3] - y1;
    y2 = segment[j + 1] - y1;
    xd = xd1 = yd = yd1 = 0;
    if (_abs(x4) < 1e-5 && _abs(y4) < 1e-5 && _abs(x2) + _abs(y2) < 1e-5) {
      //dump points that are sufficiently close (basically right on top of each other, making a bezier super tiny or 0 length)
      if (segment.length > 8) {
        segment.splice(j, 6);
        j -= 6;
        endIndex -= 6;
      }
    } else {
      for (i = 1; i <= resolution; i++) {
        t = inc * i;
        inv = 1 - t;
        xd = xd1 - (xd1 = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t);
        yd = yd1 - (yd1 = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t);
        l = _sqrt(yd * yd + xd * xd);
        if (l < min) {
          min = l;
        }
        length += l;
        samples[samplesIndex++] = length;
      }
    }
    x1 += x4;
    y1 += y4;
  }
  if (prevLength) {
    prevLength -= length;
    for (; samplesIndex < samples.length; samplesIndex++) {
      samples[samplesIndex] += prevLength;
    }
  }
  if (samples.length && min) {
    segment.totalLength = segLength = samples[samples.length - 1] || 0;
    segment.minLength = min;
    l = lengthIndex = 0;
    for (i = 0; i < segLength; i += min) {
      lookup[l++] = samples[lengthIndex] < i ? ++lengthIndex : lengthIndex;
    }
  } else {
    segment.totalLength = samples[0] = 0;
  }
  return startIndex ? length - samples[startIndex / 2 - 1] : length;
}
function cacheRawPathMeasurements(rawPath, resolution) {
  var pathLength, points, i;
  for (i = pathLength = points = 0; i < rawPath.length; i++) {
    rawPath[i].resolution = ~~resolution || 12; //steps per Bezier curve (anchor, 2 control points, to anchor)
    points += rawPath[i].length;
    pathLength += measureSegment(rawPath[i]);
  }
  rawPath.totalPoints = points;
  rawPath.totalLength = pathLength;
  return rawPath;
}

//divide segment[i] at position t (value between 0 and 1, progress along that particular cubic bezier segment that starts at segment[i]). Returns how many elements were spliced into the segment array (either 0 or 6)
function subdivideSegment(segment, i, t) {
  if (t <= 0 || t >= 1) {
    return 0;
  }
  var ax = segment[i],
    ay = segment[i + 1],
    cp1x = segment[i + 2],
    cp1y = segment[i + 3],
    cp2x = segment[i + 4],
    cp2y = segment[i + 5],
    bx = segment[i + 6],
    by = segment[i + 7],
    x1a = ax + (cp1x - ax) * t,
    x2 = cp1x + (cp2x - cp1x) * t,
    y1a = ay + (cp1y - ay) * t,
    y2 = cp1y + (cp2y - cp1y) * t,
    x1 = x1a + (x2 - x1a) * t,
    y1 = y1a + (y2 - y1a) * t,
    x2a = cp2x + (bx - cp2x) * t,
    y2a = cp2y + (by - cp2y) * t;
  x2 += (x2a - x2) * t;
  y2 += (y2a - y2) * t;
  segment.splice(i + 2, 4, _round(x1a),
  //first control point
  _round(y1a), _round(x1),
  //second control point
  _round(y1), _round(x1 + (x2 - x1) * t),
  //new fabricated anchor on line
  _round(y1 + (y2 - y1) * t), _round(x2),
  //third control point
  _round(y2), _round(x2a),
  //fourth control point
  _round(y2a));
  segment.samples && segment.samples.splice(i / 6 * segment.resolution | 0, 0, 0, 0, 0, 0, 0, 0);
  return 6;
}

// returns an object {path, segment, segIndex, i, t}
function getProgressData(rawPath, progress, decoratee, pushToNextIfAtEnd) {
  decoratee = decoratee || {};
  rawPath.totalLength || cacheRawPathMeasurements(rawPath);
  if (progress < 0 || progress > 1) {
    progress = _wrapProgress(progress);
  }
  var segIndex = 0,
    segment = rawPath[0],
    samples,
    resolution,
    length,
    min,
    max,
    i,
    t;
  if (!progress) {
    t = i = segIndex = 0;
    segment = rawPath[0];
  } else if (progress === 1) {
    t = 1;
    segIndex = rawPath.length - 1;
    segment = rawPath[segIndex];
    i = segment.length - 8;
  } else {
    if (rawPath.length > 1) {
      //speed optimization: most of the time, there's only one segment so skip the recursion.
      length = rawPath.totalLength * progress;
      max = i = 0;
      while ((max += rawPath[i++].totalLength) < length) {
        segIndex = i;
      }
      segment = rawPath[segIndex];
      min = max - segment.totalLength;
      progress = (length - min) / (max - min) || 0;
    }
    samples = segment.samples;
    resolution = segment.resolution; //how many samples per cubic bezier chunk
    length = segment.totalLength * progress;
    i = segment.lookup[~~(length / segment.minLength)] || 0;
    min = i ? samples[i - 1] : 0;
    max = samples[i];
    if (max < length) {
      min = max;
      max = samples[++i];
    }
    t = 1 / resolution * ((length - min) / (max - min) + i % resolution);
    i = ~~(i / resolution) * 6;
    if (pushToNextIfAtEnd && t === 1) {
      if (i + 6 < segment.length) {
        i += 6;
        t = 0;
      } else if (segIndex + 1 < rawPath.length) {
        i = t = 0;
        segment = rawPath[++segIndex];
      }
    }
  }
  decoratee.t = t;
  decoratee.i = i;
  decoratee.path = rawPath;
  decoratee.segment = segment;
  decoratee.segIndex = segIndex;
  return decoratee;
}
function getPositionOnPath(rawPath, progress, includeAngle, point) {
  var segment = rawPath[0],
    result = point || {},
    samples,
    resolution,
    length,
    min,
    max,
    i,
    t,
    a,
    inv;
  if (progress < 0 || progress > 1) {
    progress = _wrapProgress(progress);
  }
  if (rawPath.length > 1) {
    //speed optimization: most of the time, there's only one segment so skip the recursion.
    length = rawPath.totalLength * progress;
    max = i = 0;
    while ((max += rawPath[i++].totalLength) < length) {
      segment = rawPath[i];
    }
    min = max - segment.totalLength;
    progress = (length - min) / (max - min) || 0;
  }
  samples = segment.samples;
  resolution = segment.resolution;
  length = segment.totalLength * progress;
  i = segment.lookup[progress < 1 ? ~~(length / segment.minLength) : segment.lookup.length - 1] || 0;
  min = i ? samples[i - 1] : 0;
  max = samples[i];
  if (max < length) {
    min = max;
    max = samples[++i];
  }
  t = 1 / resolution * ((length - min) / (max - min) + i % resolution) || 0;
  inv = 1 - t;
  i = ~~(i / resolution) * 6;
  a = segment[i];
  result.x = _round((t * t * (segment[i + 6] - a) + 3 * inv * (t * (segment[i + 4] - a) + inv * (segment[i + 2] - a))) * t + a);
  result.y = _round((t * t * (segment[i + 7] - (a = segment[i + 1])) + 3 * inv * (t * (segment[i + 5] - a) + inv * (segment[i + 3] - a))) * t + a);
  if (includeAngle) {
    result.angle = segment.totalLength ? getRotationAtBezierT(segment, i, t >= 1 ? 1 - 1e-9 : t ? t : 1e-9) : segment.angle || 0;
  }
  return result;
}

//applies a matrix transform to RawPath (or a segment in a RawPath) and returns whatever was passed in (it transforms the values in the array(s), not a copy).
function transformRawPath(rawPath, a, b, c, d, tx, ty) {
  var j = rawPath.length,
    segment,
    l,
    i,
    x,
    y;
  while (--j > -1) {
    segment = rawPath[j];
    l = segment.length;
    for (i = 0; i < l; i += 2) {
      x = segment[i];
      y = segment[i + 1];
      segment[i] = x * a + y * c + tx;
      segment[i + 1] = x * b + y * d + ty;
    }
  }
  rawPath._dirty = 1;
  return rawPath;
}

// translates SVG arc data into a segment (cubic beziers). Angle is in degrees.
function arcToSegment(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
  if (lastX === x && lastY === y) {
    return;
  }
  rx = _abs(rx);
  ry = _abs(ry);
  var angleRad = angle % 360 * _DEG2RAD,
    cosAngle = _cos(angleRad),
    sinAngle = _sin(angleRad),
    PI = Math.PI,
    TWOPI = PI * 2,
    dx2 = (lastX - x) / 2,
    dy2 = (lastY - y) / 2,
    x1 = cosAngle * dx2 + sinAngle * dy2,
    y1 = -sinAngle * dx2 + cosAngle * dy2,
    x1_sq = x1 * x1,
    y1_sq = y1 * y1,
    radiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);
  if (radiiCheck > 1) {
    rx = _sqrt(radiiCheck) * rx;
    ry = _sqrt(radiiCheck) * ry;
  }
  var rx_sq = rx * rx,
    ry_sq = ry * ry,
    sq = (rx_sq * ry_sq - rx_sq * y1_sq - ry_sq * x1_sq) / (rx_sq * y1_sq + ry_sq * x1_sq);
  if (sq < 0) {
    sq = 0;
  }
  var coef = (largeArcFlag === sweepFlag ? -1 : 1) * _sqrt(sq),
    cx1 = coef * (rx * y1 / ry),
    cy1 = coef * -(ry * x1 / rx),
    sx2 = (lastX + x) / 2,
    sy2 = (lastY + y) / 2,
    cx = sx2 + (cosAngle * cx1 - sinAngle * cy1),
    cy = sy2 + (sinAngle * cx1 + cosAngle * cy1),
    ux = (x1 - cx1) / rx,
    uy = (y1 - cy1) / ry,
    vx = (-x1 - cx1) / rx,
    vy = (-y1 - cy1) / ry,
    temp = ux * ux + uy * uy,
    angleStart = (uy < 0 ? -1 : 1) * Math.acos(ux / _sqrt(temp)),
    angleExtent = (ux * vy - uy * vx < 0 ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt(temp * (vx * vx + vy * vy)));
  isNaN(angleExtent) && (angleExtent = PI); //rare edge case. Math.cos(-1) is NaN.
  if (!sweepFlag && angleExtent > 0) {
    angleExtent -= TWOPI;
  } else if (sweepFlag && angleExtent < 0) {
    angleExtent += TWOPI;
  }
  angleStart %= TWOPI;
  angleExtent %= TWOPI;
  var segments = Math.ceil(_abs(angleExtent) / (TWOPI / 4)),
    rawPath = [],
    angleIncrement = angleExtent / segments,
    controlLength = 4 / 3 * _sin(angleIncrement / 2) / (1 + _cos(angleIncrement / 2)),
    ma = cosAngle * rx,
    mb = sinAngle * rx,
    mc = sinAngle * -ry,
    md = cosAngle * ry,
    i;
  for (i = 0; i < segments; i++) {
    angle = angleStart + i * angleIncrement;
    x1 = _cos(angle);
    y1 = _sin(angle);
    ux = _cos(angle += angleIncrement);
    uy = _sin(angle);
    rawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);
  }
  //now transform according to the actual size of the ellipse/arc (the beziers were noramlized, between 0 and 1 on a circle).
  for (i = 0; i < rawPath.length; i += 2) {
    x1 = rawPath[i];
    y1 = rawPath[i + 1];
    rawPath[i] = x1 * ma + y1 * mc + cx;
    rawPath[i + 1] = x1 * mb + y1 * md + cy;
  }
  rawPath[i - 2] = x; //always set the end to exactly where it's supposed to be
  rawPath[i - 1] = y;
  return rawPath;
}

//Spits back a RawPath with absolute coordinates. Each segment starts with a "moveTo" command (x coordinate, then y) and then 2 control points (x, y, x, y), then anchor. The goal is to minimize memory and maximize speed.
function stringToRawPath(d) {
  var a = (d + "").replace(_scientific, function (m) {
      var n = +m;
      return n < 0.0001 && n > -0.0001 ? 0 : n;
    }).match(_svgPathExp) || [],
    //some authoring programs spit out very small numbers in scientific notation like "1e-5", so make sure we round that down to 0 first.
    path = [],
    relativeX = 0,
    relativeY = 0,
    twoThirds = 2 / 3,
    elements = a.length,
    points = 0,
    errorMessage = "ERROR: malformed path: " + d,
    i,
    j,
    x,
    y,
    command,
    isRelative,
    segment,
    startX,
    startY,
    difX,
    difY,
    beziers,
    prevCommand,
    flag1,
    flag2,
    line = function line(sx, sy, ex, ey) {
      difX = (ex - sx) / 3;
      difY = (ey - sy) / 3;
      segment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);
    };
  if (!d || !isNaN(a[0]) || isNaN(a[1])) {
    console.log(errorMessage);
    return path;
  }
  for (i = 0; i < elements; i++) {
    prevCommand = command;
    if (isNaN(a[i])) {
      command = a[i].toUpperCase();
      isRelative = command !== a[i]; //lower case means relative
    } else {
      //commands like "C" can be strung together without any new command characters between.
      i--;
    }
    x = +a[i + 1];
    y = +a[i + 2];
    if (isRelative) {
      x += relativeX;
      y += relativeY;
    }
    if (!i) {
      startX = x;
      startY = y;
    }

    // "M" (move)
    if (command === "M") {
      if (segment) {
        if (segment.length < 8) {
          //if the path data was funky and just had a M with no actual drawing anywhere, skip it.
          path.length -= 1;
        } else {
          points += segment.length;
        }
      }
      relativeX = startX = x;
      relativeY = startY = y;
      segment = [x, y];
      path.push(segment);
      i += 2;
      command = "L"; //an "M" with more than 2 values gets interpreted as "lineTo" commands ("L").

      // "C" (cubic bezier)
    } else if (command === "C") {
      if (!segment) {
        segment = [0, 0];
      }
      if (!isRelative) {
        relativeX = relativeY = 0;
      }
      //note: "*1" is just a fast/short way to cast the value as a Number. WAAAY faster in Chrome, slightly slower in Firefox.
      segment.push(x, y, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, relativeX += a[i + 5] * 1, relativeY += a[i + 6] * 1);
      i += 6;

      // "S" (continuation of cubic bezier)
    } else if (command === "S") {
      difX = relativeX;
      difY = relativeY;
      if (prevCommand === "C" || prevCommand === "S") {
        difX += relativeX - segment[segment.length - 4];
        difY += relativeY - segment[segment.length - 3];
      }
      if (!isRelative) {
        relativeX = relativeY = 0;
      }
      segment.push(difX, difY, x, y, relativeX += a[i + 3] * 1, relativeY += a[i + 4] * 1);
      i += 4;

      // "Q" (quadratic bezier)
    } else if (command === "Q") {
      difX = relativeX + (x - relativeX) * twoThirds;
      difY = relativeY + (y - relativeY) * twoThirds;
      if (!isRelative) {
        relativeX = relativeY = 0;
      }
      relativeX += a[i + 3] * 1;
      relativeY += a[i + 4] * 1;
      segment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);
      i += 4;

      // "T" (continuation of quadratic bezier)
    } else if (command === "T") {
      difX = relativeX - segment[segment.length - 4];
      difY = relativeY - segment[segment.length - 3];
      segment.push(relativeX + difX, relativeY + difY, x + (relativeX + difX * 1.5 - x) * twoThirds, y + (relativeY + difY * 1.5 - y) * twoThirds, relativeX = x, relativeY = y);
      i += 2;

      // "H" (horizontal line)
    } else if (command === "H") {
      line(relativeX, relativeY, relativeX = x, relativeY);
      i += 1;

      // "V" (vertical line)
    } else if (command === "V") {
      //adjust values because the first (and only one) isn't x in this case, it's y.
      line(relativeX, relativeY, relativeX, relativeY = x + (isRelative ? relativeY - relativeX : 0));
      i += 1;

      // "L" (line) or "Z" (close)
    } else if (command === "L" || command === "Z") {
      if (command === "Z") {
        x = startX;
        y = startY;
        segment.closed = true;
      }
      if (command === "L" || _abs(relativeX - x) > 0.5 || _abs(relativeY - y) > 0.5) {
        line(relativeX, relativeY, x, y);
        if (command === "L") {
          i += 2;
        }
      }
      relativeX = x;
      relativeY = y;

      // "A" (arc)
    } else if (command === "A") {
      flag1 = a[i + 4];
      flag2 = a[i + 5];
      difX = a[i + 6];
      difY = a[i + 7];
      j = 7;
      if (flag1.length > 1) {
        // for cases when the flags are merged, like "a8 8 0 018 8" (the 0 and 1 flags are WITH the x value of 8, but it could also be "a8 8 0 01-8 8" so it may include x or not)
        if (flag1.length < 3) {
          difY = difX;
          difX = flag2;
          j--;
        } else {
          difY = flag2;
          difX = flag1.substr(2);
          j -= 2;
        }
        flag2 = flag1.charAt(1);
        flag1 = flag1.charAt(0);
      }
      beziers = arcToSegment(relativeX, relativeY, +a[i + 1], +a[i + 2], +a[i + 3], +flag1, +flag2, (isRelative ? relativeX : 0) + difX * 1, (isRelative ? relativeY : 0) + difY * 1);
      i += j;
      if (beziers) {
        for (j = 0; j < beziers.length; j++) {
          segment.push(beziers[j]);
        }
      }
      relativeX = segment[segment.length - 2];
      relativeY = segment[segment.length - 1];
    } else {
      console.log(errorMessage);
    }
  }
  i = segment.length;
  if (i < 6) {
    //in case there's odd SVG like a M0,0 command at the very end.
    path.pop();
    i = 0;
  } else if (segment[0] === segment[i - 2] && segment[1] === segment[i - 1]) {
    segment.closed = true;
  }
  path.totalPoints = points + i;
  return path;
}

//populates the points array in alternating x/y values (like [x, y, x, y...] instead of individual point objects [{x, y}, {x, y}...] to conserve memory and stay in line with how we're handling segment arrays
function bezierToPoints(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {
  var x12 = (x1 + x2) / 2,
    y12 = (y1 + y2) / 2,
    x23 = (x2 + x3) / 2,
    y23 = (y2 + y3) / 2,
    x34 = (x3 + x4) / 2,
    y34 = (y3 + y4) / 2,
    x123 = (x12 + x23) / 2,
    y123 = (y12 + y23) / 2,
    x234 = (x23 + x34) / 2,
    y234 = (y23 + y34) / 2,
    x1234 = (x123 + x234) / 2,
    y1234 = (y123 + y234) / 2,
    dx = x4 - x1,
    dy = y4 - y1,
    d2 = _abs((x2 - x4) * dy - (y2 - y4) * dx),
    d3 = _abs((x3 - x4) * dy - (y3 - y4) * dx),
    length;
  if (!points) {
    points = [x1, y1, x4, y4];
    index = 2;
  }
  points.splice(index || points.length - 2, 0, x1234, y1234);
  if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {
    length = points.length;
    bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);
    bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 2 + (points.length - length));
  }
  return points;
}

/*
function getAngleBetweenPoints(x0, y0, x1, y1, x2, y2) { //angle between 3 points in radians
	var dx1 = x1 - x0,
		dy1 = y1 - y0,
		dx2 = x2 - x1,
		dy2 = y2 - y1,
		dx3 = x2 - x0,
		dy3 = y2 - y0,
		a = dx1 * dx1 + dy1 * dy1,
		b = dx2 * dx2 + dy2 * dy2,
		c = dx3 * dx3 + dy3 * dy3;
	return Math.acos( (a + b - c) / _sqrt(4 * a * b) );
},
*/

//pointsToSegment() doesn't handle flat coordinates (where y is always 0) the way we need (the resulting control points are always right on top of the anchors), so this function basically makes the control points go directly up and down, varying in length based on the curviness (more curvy, further control points)
function flatPointsToSegment(points) {
  var curviness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var x = points[0],
    y = 0,
    segment = [x, y],
    i = 2;
  for (; i < points.length; i += 2) {
    segment.push(x, y, points[i], y = (points[i] - x) * curviness / 2, x = points[i], -y);
  }
  return segment;
}

//points is an array of x/y points, like [x, y, x, y, x, y]
function pointsToSegment(points, curviness, cornerThreshold) {
  //points = simplifyPoints(points, tolerance);
  _abs(points[0] - points[2]) < 1e-4 && _abs(points[1] - points[3]) < 1e-4 && (points = points.slice(2)); // if the first two points are super close, dump the first one.
  var l = points.length - 2,
    x = +points[0],
    y = +points[1],
    nextX = +points[2],
    nextY = +points[3],
    segment = [x, y, x, y],
    dx2 = nextX - x,
    dy2 = nextY - y,
    closed = Math.abs(points[l] - x) < 0.001 && Math.abs(points[l + 1] - y) < 0.001,
    prevX,
    prevY,
    angle,
    slope,
    i,
    dx1,
    dx3,
    dy1,
    dy3,
    d1,
    d2,
    a,
    b,
    c;
  if (isNaN(cornerThreshold)) {
    cornerThreshold = Math.PI / 10;
  }
  if (closed) {
    // if the start and end points are basically on top of each other, close the segment by adding the 2nd point to the end, and the 2nd-to-last point to the beginning (we'll remove them at the end, but this allows the curvature to look perfect)
    points.push(nextX, nextY);
    nextX = x;
    nextY = y;
    x = points[l - 2];
    y = points[l - 1];
    points.unshift(x, y);
    l += 4;
  }
  curviness = curviness || curviness === 0 ? +curviness : 1;
  for (i = 2; i < l; i += 2) {
    prevX = x;
    prevY = y;
    x = nextX;
    y = nextY;
    nextX = +points[i + 2];
    nextY = +points[i + 3];
    if (x === nextX && y === nextY) {
      continue;
    }
    dx1 = dx2;
    dy1 = dy2;
    dx2 = nextX - x;
    dy2 = nextY - y;
    dx3 = nextX - prevX;
    dy3 = nextY - prevY;
    a = dx1 * dx1 + dy1 * dy1;
    b = dx2 * dx2 + dy2 * dy2;
    c = dx3 * dx3 + dy3 * dy3;
    angle = Math.acos((a + b - c) / _sqrt(4 * a * b)); //angle between the 3 points
    d2 = angle / Math.PI * curviness; //temporary precalculation for speed (reusing d2 variable)
    d1 = _sqrt(a) * d2; //the tighter the angle, the shorter we make the handles in proportion.
    d2 *= _sqrt(b);
    if (x !== prevX || y !== prevY) {
      if (angle > cornerThreshold) {
        slope = _atan2(dy3, dx3);
        segment.push(_round(x - _cos(slope) * d1),
        //first control point
        _round(y - _sin(slope) * d1), _round(x),
        //anchor
        _round(y), _round(x + _cos(slope) * d2),
        //second control point
        _round(y + _sin(slope) * d2));
      } else {
        slope = _atan2(dy1, dx1);
        segment.push(_round(x - _cos(slope) * d1),
        //first control point
        _round(y - _sin(slope) * d1));
        slope = _atan2(dy2, dx2);
        segment.push(_round(x),
        //anchor
        _round(y), _round(x + _cos(slope) * d2),
        //second control point
        _round(y + _sin(slope) * d2));
      }
    }
  }
  x !== nextX || y !== nextY || segment.length < 4 ? segment.push(_round(nextX), _round(nextY), _round(nextX), _round(nextY)) : segment.length -= 2;
  if (closed) {
    segment.splice(0, 6);
    segment.length = segment.length - 6;
  }
  return segment;
}

//returns the squared distance between an x/y coordinate and a segment between x1/y1 and x2/y2
function pointToSegDist(x, y, x1, y1, x2, y2) {
  var dx = x2 - x1,
    dy = y2 - y1,
    t;
  if (dx || dy) {
    t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return Math.pow(x - x1, 2) + Math.pow(y - y1, 2);
}
function simplifyStep(points, first, last, tolerance, simplified) {
  var maxSqDist = tolerance,
    firstX = points[first],
    firstY = points[first + 1],
    lastX = points[last],
    lastY = points[last + 1],
    index,
    i,
    d;
  for (i = first + 2; i < last; i += 2) {
    d = pointToSegDist(points[i], points[i + 1], firstX, firstY, lastX, lastY);
    if (d > maxSqDist) {
      index = i;
      maxSqDist = d;
    }
  }
  if (maxSqDist > tolerance) {
    index - first > 2 && simplifyStep(points, first, index, tolerance, simplified);
    simplified.push(points[index], points[index + 1]);
    last - index > 2 && simplifyStep(points, index, last, tolerance, simplified);
  }
}

//points is an array of x/y values like [x, y, x, y, x, y]
function simplifyPoints(points, tolerance) {
  var prevX = parseFloat(points[0]),
    prevY = parseFloat(points[1]),
    temp = [prevX, prevY],
    l = points.length - 2,
    i,
    x,
    y,
    dx,
    dy,
    result,
    last;
  tolerance = Math.pow(tolerance || 1, 2);
  for (i = 2; i < l; i += 2) {
    x = parseFloat(points[i]);
    y = parseFloat(points[i + 1]);
    dx = prevX - x;
    dy = prevY - y;
    if (dx * dx + dy * dy > tolerance) {
      temp.push(x, y);
      prevX = x;
      prevY = y;
    }
  }
  temp.push(parseFloat(points[l]), parseFloat(points[l + 1]));
  last = temp.length - 2;
  result = [temp[0], temp[1]];
  simplifyStep(temp, 0, last, tolerance, result);
  result.push(temp[last], temp[last + 1]);
  return result;
}
function getClosestProgressOnBezier(iterations, px, py, start, end, slices, x0, y0, x1, y1, x2, y2, x3, y3) {
  var inc = (end - start) / slices,
    best = 0,
    t = start,
    x,
    y,
    d,
    dx,
    dy,
    inv;
  _bestDistance = _largeNum;
  while (t <= end) {
    inv = 1 - t;
    x = inv * inv * inv * x0 + 3 * inv * inv * t * x1 + 3 * inv * t * t * x2 + t * t * t * x3;
    y = inv * inv * inv * y0 + 3 * inv * inv * t * y1 + 3 * inv * t * t * y2 + t * t * t * y3;
    dx = x - px;
    dy = y - py;
    d = dx * dx + dy * dy;
    if (d < _bestDistance) {
      _bestDistance = d;
      best = t;
    }
    t += inc;
  }
  return iterations > 1 ? getClosestProgressOnBezier(iterations - 1, px, py, Math.max(best - inc, 0), Math.min(best + inc, 1), slices, x0, y0, x1, y1, x2, y2, x3, y3) : best;
}
function getClosestData(rawPath, x, y, slices) {
  //returns an object with the closest j, i, and t (j is the segment index, i is the index of the point in that segment, and t is the time/progress along that bezier)
  var closest = {
      j: 0,
      i: 0,
      t: 0
    },
    bestDistance = _largeNum,
    i,
    j,
    t,
    segment;
  for (j = 0; j < rawPath.length; j++) {
    segment = rawPath[j];
    for (i = 0; i < segment.length; i += 6) {
      t = getClosestProgressOnBezier(1, x, y, 0, 1, slices || 20, segment[i], segment[i + 1], segment[i + 2], segment[i + 3], segment[i + 4], segment[i + 5], segment[i + 6], segment[i + 7]);
      if (bestDistance > _bestDistance) {
        bestDistance = _bestDistance;
        closest.j = j;
        closest.i = i;
        closest.t = t;
      }
    }
  }
  return closest;
}

//subdivide a Segment closest to a specific x,y coordinate
function subdivideSegmentNear(x, y, segment, slices, iterations) {
  var l = segment.length,
    bestDistance = _largeNum,
    bestT = 0,
    bestSegmentIndex = 0,
    t,
    i;
  slices = slices || 20;
  iterations = iterations || 3;
  for (i = 0; i < l; i += 6) {
    t = getClosestProgressOnBezier(1, x, y, 0, 1, slices, segment[i], segment[i + 1], segment[i + 2], segment[i + 3], segment[i + 4], segment[i + 5], segment[i + 6], segment[i + 7]);
    if (bestDistance > _bestDistance) {
      bestDistance = _bestDistance;
      bestT = t;
      bestSegmentIndex = i;
    }
  }
  t = getClosestProgressOnBezier(iterations, x, y, bestT - 0.05, bestT + 0.05, slices, segment[bestSegmentIndex], segment[bestSegmentIndex + 1], segment[bestSegmentIndex + 2], segment[bestSegmentIndex + 3], segment[bestSegmentIndex + 4], segment[bestSegmentIndex + 5], segment[bestSegmentIndex + 6], segment[bestSegmentIndex + 7]);
  subdivideSegment(segment, bestSegmentIndex, t);
  return bestSegmentIndex + 6;
}

/*
Takes any of the following and converts it to an all Cubic Bezier SVG data string:
- A <path> data string like "M0,0 L2,4 v20,15 H100"
- A RawPath, like [[x, y, x, y, x, y, x, y][[x, y, x, y, x, y, x, y]]
- A Segment, like [x, y, x, y, x, y, x, y]

Note: all numbers are rounded down to the closest 0.001 to minimize memory, maximize speed, and avoid odd numbers like 1e-13
*/
function rawPathToString(rawPath) {
  if (_isNumber(rawPath[0])) {
    //in case a segment is passed in instead
    rawPath = [rawPath];
  }
  var result = "",
    l = rawPath.length,
    sl,
    s,
    i,
    segment;
  for (s = 0; s < l; s++) {
    segment = rawPath[s];
    result += "M" + _round(segment[0]) + "," + _round(segment[1]) + " C";
    sl = segment.length;
    for (i = 2; i < sl; i++) {
      result += _round(segment[i++]) + "," + _round(segment[i++]) + " " + _round(segment[i++]) + "," + _round(segment[i++]) + " " + _round(segment[i++]) + "," + _round(segment[i]) + " ";
    }
    if (segment.closed) {
      result += "z";
    }
  }
  return result;
}

/*
// takes a segment with coordinates [x, y, x, y, ...] and converts the control points into angles and lengths [x, y, angle, length, angle, length, x, y, angle, length, ...] so that it animates more cleanly and avoids odd breaks/kinks. For example, if you animate from 1 o'clock to 6 o'clock, it'd just go directly/linearly rather than around. So the length would be very short in the middle of the tween.
export function cpCoordsToAngles(segment, copy) {
	var result = copy ? segment.slice(0) : segment,
		x, y, i;
	for (i = 0; i < segment.length; i+=6) {
		x = segment[i+2] - segment[i];
		y = segment[i+3] - segment[i+1];
		result[i+2] = Math.atan2(y, x);
		result[i+3] = Math.sqrt(x * x + y * y);
		x = segment[i+6] - segment[i+4];
		y = segment[i+7] - segment[i+5];
		result[i+4] = Math.atan2(y, x);
		result[i+5] = Math.sqrt(x * x + y * y);
	}
	return result;
}

// takes a segment that was converted with cpCoordsToAngles() to have angles and lengths instead of coordinates for the control points, and converts it BACK into coordinates.
export function cpAnglesToCoords(segment, copy) {
	var result = copy ? segment.slice(0) : segment,
		length = segment.length,
		rnd = 1000,
		angle, l, i, j;
	for (i = 0; i < length; i+=6) {
		angle = segment[i+2];
		l = segment[i+3]; //length
		result[i+2] = (((segment[i] + Math.cos(angle) * l) * rnd) | 0) / rnd;
		result[i+3] = (((segment[i+1] + Math.sin(angle) * l) * rnd) | 0) / rnd;
		angle = segment[i+4];
		l = segment[i+5]; //length
		result[i+4] = (((segment[i+6] - Math.cos(angle) * l) * rnd) | 0) / rnd;
		result[i+5] = (((segment[i+7] - Math.sin(angle) * l) * rnd) | 0) / rnd;
	}
	return result;
}

//adds an "isSmooth" array to each segment and populates it with a boolean value indicating whether or not it's smooth (the control points have basically the same slope). For any smooth control points, it converts the coordinates into angle (x, in radians) and length (y) and puts them into the same index value in a smoothData array.
export function populateSmoothData(rawPath) {
	let j = rawPath.length,
		smooth, segment, x, y, x2, y2, i, l, a, a2, isSmooth, smoothData;
	while (--j > -1) {
		segment = rawPath[j];
		isSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];
		smoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];
		isSmooth.length = 4;
		l = segment.length - 2;
		for (i = 6; i < l; i += 6) {
			x = segment[i] - segment[i - 2];
			y = segment[i + 1] - segment[i - 1];
			x2 = segment[i + 2] - segment[i];
			y2 = segment[i + 3] - segment[i + 1];
			a = _atan2(y, x);
			a2 = _atan2(y2, x2);
			smooth = (Math.abs(a - a2) < 0.09);
			if (smooth) {
				smoothData[i - 2] = a;
				smoothData[i + 2] = a2;
				smoothData[i - 1] = _sqrt(x * x + y * y);
				smoothData[i + 3] = _sqrt(x2 * x2 + y2 * y2);
			}
			isSmooth.push(smooth, smooth, 0, 0, smooth, smooth);
		}
		//if the first and last points are identical, check to see if there's a smooth transition. We must handle this a bit differently due to their positions in the array.
		if (segment[l] === segment[0] && segment[l+1] === segment[1]) {
			x = segment[0] - segment[l-2];
			y = segment[1] - segment[l-1];
			x2 = segment[2] - segment[0];
			y2 = segment[3] - segment[1];
			a = _atan2(y, x);
			a2 = _atan2(y2, x2);
			if (Math.abs(a - a2) < 0.09) {
				smoothData[l-2] = a;
				smoothData[2] = a2;
				smoothData[l-1] = _sqrt(x * x + y * y);
				smoothData[3] = _sqrt(x2 * x2 + y2 * y2);
				isSmooth[l-2] = isSmooth[l-1] = true; //don't change indexes 2 and 3 because we'll trigger everything from the END, and this will optimize file size a bit.
			}
		}
	}
	return rawPath;
}
export function pointToScreen(svgElement, point) {
	if (arguments.length < 2) { //by default, take the first set of coordinates in the path as the point
		let rawPath = getRawPath(svgElement);
		point = svgElement.ownerSVGElement.createSVGPoint();
		point.x = rawPath[0][0];
		point.y = rawPath[0][1];
	}
	return point.matrixTransform(svgElement.getScreenCTM());
}

*/

/***/ }),

/***/ "./src/components/Banner.vue":
/*!***********************************!*\
  !*** ./src/components/Banner.vue ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Banner_vue_vue_type_template_id_a2fea148__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Banner.vue?vue&type=template&id=a2fea148 */ "./src/components/Banner.vue?vue&type=template&id=a2fea148");
/* harmony import */ var _Banner_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Banner.vue?vue&type=script&lang=js */ "./src/components/Banner.vue?vue&type=script&lang=js");
/* harmony import */ var _Banner_vue_vue_type_style_index_0_id_a2fea148_lang_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Banner.vue?vue&type=style&index=0&id=a2fea148&lang=scss */ "./src/components/Banner.vue?vue&type=style&index=0&id=a2fea148&lang=scss");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _Banner_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  _Banner_vue_vue_type_template_id_a2fea148__WEBPACK_IMPORTED_MODULE_0__.render,
  _Banner_vue_vue_type_template_id_a2fea148__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) // removed by dead control flow
{ var api; }
component.options.__file = "src/components/Banner.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/components/Banner.vue?vue&type=script&lang=js":
/*!***********************************************************!*\
  !*** ./src/components/Banner.vue?vue&type=script&lang=js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_Banner_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Banner.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Banner.vue?vue&type=script&lang=js");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_Banner_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/components/Banner.vue?vue&type=style&index=0&id=a2fea148&lang=scss":
/*!********************************************************************************!*\
  !*** ./src/components/Banner.vue?vue&type=style&index=0&id=a2fea148&lang=scss ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_2_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_Banner_vue_vue_type_style_index_0_id_a2fea148_lang_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/dist/cjs.js!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Banner.vue?vue&type=style&index=0&id=a2fea148&lang=scss */ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Banner.vue?vue&type=style&index=0&id=a2fea148&lang=scss");


/***/ }),

/***/ "./src/components/Banner.vue?vue&type=template&id=a2fea148":
/*!*****************************************************************!*\
  !*** ./src/components/Banner.vue?vue&type=template&id=a2fea148 ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Banner_vue_vue_type_template_id_a2fea148__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   staticRenderFns: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Banner_vue_vue_type_template_id_a2fea148__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Banner_vue_vue_type_template_id_a2fea148__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!../../node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Banner.vue?vue&type=template&id=a2fea148 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Banner.vue?vue&type=template&id=a2fea148");


/***/ }),

/***/ "./src/components/Bio.vue":
/*!********************************!*\
  !*** ./src/components/Bio.vue ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Bio_vue_vue_type_template_id_0fae41f0__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bio.vue?vue&type=template&id=0fae41f0 */ "./src/components/Bio.vue?vue&type=template&id=0fae41f0");
/* harmony import */ var _Bio_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bio.vue?vue&type=script&lang=js */ "./src/components/Bio.vue?vue&type=script&lang=js");
/* harmony import */ var _Bio_vue_vue_type_style_index_0_id_0fae41f0_lang_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bio.vue?vue&type=style&index=0&id=0fae41f0&lang=scss */ "./src/components/Bio.vue?vue&type=style&index=0&id=0fae41f0&lang=scss");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _Bio_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  _Bio_vue_vue_type_template_id_0fae41f0__WEBPACK_IMPORTED_MODULE_0__.render,
  _Bio_vue_vue_type_template_id_0fae41f0__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) // removed by dead control flow
{ var api; }
component.options.__file = "src/components/Bio.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/components/Bio.vue?vue&type=script&lang=js":
/*!********************************************************!*\
  !*** ./src/components/Bio.vue?vue&type=script&lang=js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_Bio_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Bio.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Bio.vue?vue&type=script&lang=js");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_Bio_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/components/Bio.vue?vue&type=style&index=0&id=0fae41f0&lang=scss":
/*!*****************************************************************************!*\
  !*** ./src/components/Bio.vue?vue&type=style&index=0&id=0fae41f0&lang=scss ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_2_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_Bio_vue_vue_type_style_index_0_id_0fae41f0_lang_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/dist/cjs.js!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Bio.vue?vue&type=style&index=0&id=0fae41f0&lang=scss */ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Bio.vue?vue&type=style&index=0&id=0fae41f0&lang=scss");


/***/ }),

/***/ "./src/components/Bio.vue?vue&type=template&id=0fae41f0":
/*!**************************************************************!*\
  !*** ./src/components/Bio.vue?vue&type=template&id=0fae41f0 ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Bio_vue_vue_type_template_id_0fae41f0__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   staticRenderFns: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Bio_vue_vue_type_template_id_0fae41f0__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Bio_vue_vue_type_template_id_0fae41f0__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!../../node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Bio.vue?vue&type=template&id=0fae41f0 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Bio.vue?vue&type=template&id=0fae41f0");


/***/ }),

/***/ "./src/components/Contact.vue":
/*!************************************!*\
  !*** ./src/components/Contact.vue ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Contact_vue_vue_type_template_id_cf6573c0__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Contact.vue?vue&type=template&id=cf6573c0 */ "./src/components/Contact.vue?vue&type=template&id=cf6573c0");
/* harmony import */ var _Contact_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Contact.vue?vue&type=script&lang=js */ "./src/components/Contact.vue?vue&type=script&lang=js");
/* harmony import */ var _Contact_vue_vue_type_style_index_0_id_cf6573c0_lang_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Contact.vue?vue&type=style&index=0&id=cf6573c0&lang=scss */ "./src/components/Contact.vue?vue&type=style&index=0&id=cf6573c0&lang=scss");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _Contact_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  _Contact_vue_vue_type_template_id_cf6573c0__WEBPACK_IMPORTED_MODULE_0__.render,
  _Contact_vue_vue_type_template_id_cf6573c0__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) // removed by dead control flow
{ var api; }
component.options.__file = "src/components/Contact.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/components/Contact.vue?vue&type=script&lang=js":
/*!************************************************************!*\
  !*** ./src/components/Contact.vue?vue&type=script&lang=js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_Contact_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Contact.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Contact.vue?vue&type=script&lang=js");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_Contact_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/components/Contact.vue?vue&type=style&index=0&id=cf6573c0&lang=scss":
/*!*********************************************************************************!*\
  !*** ./src/components/Contact.vue?vue&type=style&index=0&id=cf6573c0&lang=scss ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_2_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_Contact_vue_vue_type_style_index_0_id_cf6573c0_lang_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/dist/cjs.js!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Contact.vue?vue&type=style&index=0&id=cf6573c0&lang=scss */ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Contact.vue?vue&type=style&index=0&id=cf6573c0&lang=scss");


/***/ }),

/***/ "./src/components/Contact.vue?vue&type=template&id=cf6573c0":
/*!******************************************************************!*\
  !*** ./src/components/Contact.vue?vue&type=template&id=cf6573c0 ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Contact_vue_vue_type_template_id_cf6573c0__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   staticRenderFns: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Contact_vue_vue_type_template_id_cf6573c0__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Contact_vue_vue_type_template_id_cf6573c0__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!../../node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Contact.vue?vue&type=template&id=cf6573c0 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Contact.vue?vue&type=template&id=cf6573c0");


/***/ }),

/***/ "./src/components/Geometry.vue":
/*!*************************************!*\
  !*** ./src/components/Geometry.vue ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Geometry_vue_vue_type_template_id_6dfac0bc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry.vue?vue&type=template&id=6dfac0bc */ "./src/components/Geometry.vue?vue&type=template&id=6dfac0bc");
/* harmony import */ var _Geometry_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Geometry.vue?vue&type=script&lang=js */ "./src/components/Geometry.vue?vue&type=script&lang=js");
/* harmony import */ var _Geometry_vue_vue_type_style_index_0_id_6dfac0bc_lang_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Geometry.vue?vue&type=style&index=0&id=6dfac0bc&lang=scss */ "./src/components/Geometry.vue?vue&type=style&index=0&id=6dfac0bc&lang=scss");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _Geometry_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  _Geometry_vue_vue_type_template_id_6dfac0bc__WEBPACK_IMPORTED_MODULE_0__.render,
  _Geometry_vue_vue_type_template_id_6dfac0bc__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) // removed by dead control flow
{ var api; }
component.options.__file = "src/components/Geometry.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/components/Geometry.vue?vue&type=script&lang=js":
/*!*************************************************************!*\
  !*** ./src/components/Geometry.vue?vue&type=script&lang=js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_Geometry_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Geometry.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Geometry.vue?vue&type=script&lang=js");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_Geometry_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/components/Geometry.vue?vue&type=style&index=0&id=6dfac0bc&lang=scss":
/*!**********************************************************************************!*\
  !*** ./src/components/Geometry.vue?vue&type=style&index=0&id=6dfac0bc&lang=scss ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_2_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_Geometry_vue_vue_type_style_index_0_id_6dfac0bc_lang_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/dist/cjs.js!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Geometry.vue?vue&type=style&index=0&id=6dfac0bc&lang=scss */ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Geometry.vue?vue&type=style&index=0&id=6dfac0bc&lang=scss");


/***/ }),

/***/ "./src/components/Geometry.vue?vue&type=template&id=6dfac0bc":
/*!*******************************************************************!*\
  !*** ./src/components/Geometry.vue?vue&type=template&id=6dfac0bc ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Geometry_vue_vue_type_template_id_6dfac0bc__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   staticRenderFns: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Geometry_vue_vue_type_template_id_6dfac0bc__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Geometry_vue_vue_type_template_id_6dfac0bc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!../../node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Geometry.vue?vue&type=template&id=6dfac0bc */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Geometry.vue?vue&type=template&id=6dfac0bc");


/***/ }),

/***/ "./src/components/PortfolioList.vue":
/*!******************************************!*\
  !*** ./src/components/PortfolioList.vue ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _PortfolioList_vue_vue_type_template_id_13a0d706__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PortfolioList.vue?vue&type=template&id=13a0d706 */ "./src/components/PortfolioList.vue?vue&type=template&id=13a0d706");
/* harmony import */ var _PortfolioList_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PortfolioList.vue?vue&type=script&lang=js */ "./src/components/PortfolioList.vue?vue&type=script&lang=js");
/* harmony import */ var _PortfolioList_vue_vue_type_style_index_0_id_13a0d706_lang_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PortfolioList.vue?vue&type=style&index=0&id=13a0d706&lang=scss */ "./src/components/PortfolioList.vue?vue&type=style&index=0&id=13a0d706&lang=scss");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _PortfolioList_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  _PortfolioList_vue_vue_type_template_id_13a0d706__WEBPACK_IMPORTED_MODULE_0__.render,
  _PortfolioList_vue_vue_type_template_id_13a0d706__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) // removed by dead control flow
{ var api; }
component.options.__file = "src/components/PortfolioList.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/components/PortfolioList.vue?vue&type=script&lang=js":
/*!******************************************************************!*\
  !*** ./src/components/PortfolioList.vue?vue&type=script&lang=js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_PortfolioList_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./PortfolioList.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/PortfolioList.vue?vue&type=script&lang=js");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_PortfolioList_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/components/PortfolioList.vue?vue&type=style&index=0&id=13a0d706&lang=scss":
/*!***************************************************************************************!*\
  !*** ./src/components/PortfolioList.vue?vue&type=style&index=0&id=13a0d706&lang=scss ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_2_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_PortfolioList_vue_vue_type_style_index_0_id_13a0d706_lang_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/dist/cjs.js!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./PortfolioList.vue?vue&type=style&index=0&id=13a0d706&lang=scss */ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/PortfolioList.vue?vue&type=style&index=0&id=13a0d706&lang=scss");


/***/ }),

/***/ "./src/components/PortfolioList.vue?vue&type=template&id=13a0d706":
/*!************************************************************************!*\
  !*** ./src/components/PortfolioList.vue?vue&type=template&id=13a0d706 ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_PortfolioList_vue_vue_type_template_id_13a0d706__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   staticRenderFns: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_PortfolioList_vue_vue_type_template_id_13a0d706__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_PortfolioList_vue_vue_type_template_id_13a0d706__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!../../node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./PortfolioList.vue?vue&type=template&id=13a0d706 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/PortfolioList.vue?vue&type=template&id=13a0d706");


/***/ }),

/***/ "./src/components/portfolio/CodePenCard.vue":
/*!**************************************************!*\
  !*** ./src/components/portfolio/CodePenCard.vue ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CodePenCard_vue_vue_type_template_id_1b12f855__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CodePenCard.vue?vue&type=template&id=1b12f855 */ "./src/components/portfolio/CodePenCard.vue?vue&type=template&id=1b12f855");
/* harmony import */ var _CodePenCard_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CodePenCard.vue?vue&type=script&lang=js */ "./src/components/portfolio/CodePenCard.vue?vue&type=script&lang=js");
/* harmony import */ var _CodePenCard_vue_vue_type_style_index_0_id_1b12f855_lang_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CodePenCard.vue?vue&type=style&index=0&id=1b12f855&lang=scss */ "./src/components/portfolio/CodePenCard.vue?vue&type=style&index=0&id=1b12f855&lang=scss");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _CodePenCard_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  _CodePenCard_vue_vue_type_template_id_1b12f855__WEBPACK_IMPORTED_MODULE_0__.render,
  _CodePenCard_vue_vue_type_template_id_1b12f855__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) // removed by dead control flow
{ var api; }
component.options.__file = "src/components/portfolio/CodePenCard.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/components/portfolio/CodePenCard.vue?vue&type=script&lang=js":
/*!**************************************************************************!*\
  !*** ./src/components/portfolio/CodePenCard.vue?vue&type=script&lang=js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_CodePenCard_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CodePenCard.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/portfolio/CodePenCard.vue?vue&type=script&lang=js");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_CodePenCard_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/components/portfolio/CodePenCard.vue?vue&type=style&index=0&id=1b12f855&lang=scss":
/*!***********************************************************************************************!*\
  !*** ./src/components/portfolio/CodePenCard.vue?vue&type=style&index=0&id=1b12f855&lang=scss ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_2_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_CodePenCard_vue_vue_type_style_index_0_id_1b12f855_lang_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/mini-css-extract-plugin/dist/loader.js!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CodePenCard.vue?vue&type=style&index=0&id=1b12f855&lang=scss */ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-2.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/portfolio/CodePenCard.vue?vue&type=style&index=0&id=1b12f855&lang=scss");


/***/ }),

/***/ "./src/components/portfolio/CodePenCard.vue?vue&type=template&id=1b12f855":
/*!********************************************************************************!*\
  !*** ./src/components/portfolio/CodePenCard.vue?vue&type=template&id=1b12f855 ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_CodePenCard_vue_vue_type_template_id_1b12f855__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   staticRenderFns: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_CodePenCard_vue_vue_type_template_id_1b12f855__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_CodePenCard_vue_vue_type_template_id_1b12f855__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CodePenCard.vue?vue&type=template&id=1b12f855 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/portfolio/CodePenCard.vue?vue&type=template&id=1b12f855");


/***/ }),

/***/ "./src/mixins/Gsap.vue":
/*!*****************************!*\
  !*** ./src/mixins/Gsap.vue ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Gsap_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Gsap.vue?vue&type=script&lang=js */ "./src/mixins/Gsap.vue?vue&type=script&lang=js");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns
;



/* normalize component */
;
var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _Gsap_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) // removed by dead control flow
{ var api; }
component.options.__file = "src/mixins/Gsap.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/mixins/Gsap.vue?vue&type=script&lang=js":
/*!*****************************************************!*\
  !*** ./src/mixins/Gsap.vue?vue&type=script&lang=js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_Gsap_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Gsap.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/mixins/Gsap.vue?vue&type=script&lang=js");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_Gsap_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/mixins/cssVariables.vue":
/*!*************************************!*\
  !*** ./src/mixins/cssVariables.vue ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cssVariables_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cssVariables.vue?vue&type=script&lang=js */ "./src/mixins/cssVariables.vue?vue&type=script&lang=js");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns
;



/* normalize component */
;
var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _cssVariables_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) // removed by dead control flow
{ var api; }
component.options.__file = "src/mixins/cssVariables.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/mixins/cssVariables.vue?vue&type=script&lang=js":
/*!*************************************************************!*\
  !*** ./src/mixins/cssVariables.vue?vue&type=script&lang=js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_cssVariables_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./cssVariables.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/mixins/cssVariables.vue?vue&type=script&lang=js");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_cssVariables_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/mixins/utils.vue":
/*!******************************!*\
  !*** ./src/mixins/utils.vue ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.vue?vue&type=script&lang=js */ "./src/mixins/utils.vue?vue&type=script&lang=js");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns
;



/* normalize component */
;
var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _utils_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) // removed by dead control flow
{ var api; }
component.options.__file = "src/mixins/utils.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/mixins/utils.vue?vue&type=script&lang=js":
/*!******************************************************!*\
  !*** ./src/mixins/utils.vue?vue&type=script&lang=js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_utils_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./utils.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/mixins/utils.vue?vue&type=script&lang=js");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_lib_index_js_vue_loader_options_utils_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/store/actions.js":
/*!******************************!*\
  !*** ./src/store/actions.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getCountriesAll: () => (/* binding */ getCountriesAll)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! axios */ "./node_modules/axios/lib/axios.js");





function getCountriesAll(_x, _x2) {
  return _getCountriesAll.apply(this, arguments);
}
function _getCountriesAll() {
  _getCountriesAll = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(/*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee(_ref, data) {
    var state, commit, rootState, response, _t;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function (_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          state = _ref.state, commit = _ref.commit, rootState = _ref.rootState;
          _context.prev = 1;
          _context.next = 2;
          return (0,axios__WEBPACK_IMPORTED_MODULE_2__["default"])({
            method: 'get',
            url: 'http://restcountries.eu/rest/v2/all'
          });
        case 2:
          response = _context.sent;
          if (response && response.data) {
            commit('UPDATE_COUNTRIES_ALL', response.data);
          }
          _context.next = 4;
          break;
        case 3:
          _context.prev = 3;
          _t = _context["catch"](1);
          console.log('API call err', _t);
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[1, 3]]);
  }));
  return _getCountriesAll.apply(this, arguments);
}

/***/ }),

/***/ "./src/store/store.js":
/*!****************************!*\
  !*** ./src/store/store.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actions */ "./src/store/actions.js");
/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vuex */ "./node_modules/vuex/dist/vuex.esm.js");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");



vue__WEBPACK_IMPORTED_MODULE_2__["default"].use(vuex__WEBPACK_IMPORTED_MODULE_1__["default"]);
var store = new vuex__WEBPACK_IMPORTED_MODULE_1__["default"].Store({
  state: {
    countriesAll: null
  },
  mutations: {
    UPDATE_COUNTRIES_ALL: function UPDATE_COUNTRIES_ALL(state, payload) {
      state.countriesAll = payload;
    }
  },
  getters: {
    countriesAll: function countriesAll(state) {
      return state.countriesAll;
    }
  },
  actions: _actions__WEBPACK_IMPORTED_MODULE_0__,
  modules: {}
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (store);

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/JordanKlaers/";
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");
/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App */ "./src/App.vue");
/* harmony import */ var _store_store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! _store_/store */ "./src/store/store.js");
/* harmony import */ var _mixins_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! _mixins_/utils */ "./src/mixins/utils.vue");
/* harmony import */ var _mixins_Gsap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! _mixins_/Gsap */ "./src/mixins/Gsap.vue");







vue__WEBPACK_IMPORTED_MODULE_0__["default"].mixin(_mixins_utils__WEBPACK_IMPORTED_MODULE_3__["default"]);
vue__WEBPACK_IMPORTED_MODULE_0__["default"].mixin(_mixins_Gsap__WEBPACK_IMPORTED_MODULE_4__["default"]);
new vue__WEBPACK_IMPORTED_MODULE_0__["default"]({
  el: '#crazyapp',
  components: {
    App: _App__WEBPACK_IMPORTED_MODULE_1__["default"]
  },
  store: _store_store__WEBPACK_IMPORTED_MODULE_2__["default"],
  render: function render(createElement) {
    return createElement(_App__WEBPACK_IMPORTED_MODULE_1__["default"]);
  }
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_store_store__WEBPACK_IMPORTED_MODULE_2__["default"]);
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxXQUFXLGNBQWM7QUFDNUIsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7O0FBR0EsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxdkJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsaUVBQWU7RUFDZk0sSUFBQTtFQUNBQyxVQUFBO0lBQ0FQLEdBQUEsRUFBQUEsdURBQUE7SUFDQUMsTUFBQSxFQUFBQSwwREFBQTtJQUNBRyxPQUFBLEVBQUFBLDJEQUFBO0lBQ0FGLFFBQUEsRUFBQUEsNERBQUE7SUFDQUMsYUFBQSxFQUFBQSxpRUFBQUE7RUFDQTtFQUNBSyxJQUFBLFdBQUFBLEtBQUE7SUFDQTtNQUNBQyxZQUFBO01BQ0FDLFVBQUE7UUFDQUMsT0FBQTtRQUNBQyxLQUFBO1FBQ0FDLEtBQUE7UUFDQUMsR0FBQTtRQUNBQyxJQUFBO1VBQ0FDLE1BQUE7VUFDQUMsUUFBQTtZQUFBQyxHQUFBO1lBQUFDLEdBQUE7VUFBQTtVQUNBQyxLQUFBO1FBQ0E7TUFDQTtNQUNBQyxPQUFBO01BQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUUzSCxFQUFFLEVBQUU7SUFBcUI7RUFBRSxDQUFDLEVBQ3ZDLENBQ0V3SCxFQUFFLENBQUMsTUFBTSxFQUFFO0lBQUVFLFdBQVcsRUFBRTtFQUFnQyxDQUFDLENBQUMsRUFDNURILEdBQUcsQ0FBQ0ssRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUNYSixFQUFFLENBQUMsTUFBTSxFQUFFO0lBQUVFLFdBQVcsRUFBRTtFQUF5QixDQUFDLENBQUMsRUFDckRILEdBQUcsQ0FBQ0ssRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUNYSixFQUFFLENBQUMsTUFBTSxFQUFFO0lBQUVFLFdBQVcsRUFBRTtFQUFnQyxDQUFDLENBQUMsRUFDNURILEdBQUcsQ0FBQ0ssRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUNYSixFQUFFLENBQUMsTUFBTSxFQUFFO0lBQUVFLFdBQVcsRUFBRTtFQUF5QixDQUFDLENBQUMsRUFDckRILEdBQUcsQ0FBQ0ssRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUNYSixFQUFFLENBQUMsTUFBTSxFQUFFO0lBQUVFLFdBQVcsRUFBRTtFQUFnQyxDQUFDLENBQUMsRUFDNURILEdBQUcsQ0FBQ0ssRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUNYSixFQUFFLENBQUMsTUFBTSxFQUFFO0lBQUVFLFdBQVcsRUFBRTtFQUF5QixDQUFDLENBQUMsRUFDckRILEdBQUcsQ0FBQ0ssRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUNYSixFQUFFLENBQUMsTUFBTSxFQUFFO0lBQUVFLFdBQVcsRUFBRTtFQUFnQyxDQUFDLENBQUMsRUFDNURILEdBQUcsQ0FBQ0ssRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUNYSixFQUFFLENBQUMsTUFBTSxFQUFFO0lBQUVFLFdBQVcsRUFBRTtFQUF5QixDQUFDLENBQUMsRUFDckRILEdBQUcsQ0FBQ0ssRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUNYSixFQUFFLENBQUMsTUFBTSxFQUFFO0lBQUVFLFdBQVcsRUFBRTtFQUFnQyxDQUFDLENBQUMsRUFDNURILEdBQUcsQ0FBQ0ssRUFBRSxDQUFDLEdBQUcsQ0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3REFBUTtBQUNkO0FBQ0E7QUFDQSxNQUFNLHdEQUFRO0FBQ2Q7QUFDQSxZQUFZLHdEQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3REFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFFBQVEsRUFBQzs7Ozs7Ozs7Ozs7OztBQy9EeEI7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBLCtDQUErQyxpQ0FBaUMsbUJBQW1CO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxvQ0FBb0M7QUFDekYsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFxQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7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QXFDLEtBQXFDLDhDQUE4QyxDQUFJO0FBQzVIO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFxQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdURBQXVEO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQseURBQXlEO0FBQ3pEO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQXFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsWUFBWSxLQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBcUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEtBQXFDLHdCQUF3QixDQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBcUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsSUFBSSxJQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0Msc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNGQUFzRjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsSUFBSSxJQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQSx3REFBd0QseUJBQXlCO0FBQ2pGO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Rjs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxJQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFBQSxFQUVKO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFxQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFxQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0EsYUFBYTtBQUFBLEVBRUo7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFlBQVksS0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFxQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDRCQUE0QjtBQUM1RSxTQUFTO0FBQ1Q7QUFDQSxnREFBZ0QsNkJBQTZCO0FBQzdFLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxxQ0FBcUM7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELDZCQUE2QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0NBQWdDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwwQ0FBMEM7QUFDOUY7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDhDQUE4QztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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cGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL092ZXJsb2FkWWllbGQuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5TGlrZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aEhvbGVzLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3luY1RvR2VuZXJhdG9yLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjay5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXQuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3N1cGVyUHJvcEJhc2UuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1ByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Qcm9wZXJ0eUtleS5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvckFzeW5jLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3JlZ2VuZXJhdG9yQXN5bmNHZW4uanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcmVnZW5lcmF0b3JBc3luY0l0ZXJhdG9yLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3JlZ2VuZXJhdG9yRGVmaW5lLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3JlZ2VuZXJhdG9yS2V5cy5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvclJ1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcmVnZW5lcmF0b3JWYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL2FkYXB0ZXJzLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMvZmV0Y2guanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxlZEVycm9yLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3NFcnJvci5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3NIZWFkZXJzLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL2luZGV4LmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMvdHJhbnNpdGlvbmFsLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZW52L2RhdGEuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL0F4aW9zVVJMU2VhcmNoUGFyYW1zLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9IdHRwU3RhdHVzQ29kZS5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21wb3NlU2lnbmFscy5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9udWxsLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlUHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3Byb2dyZXNzRXZlbnRSZWR1Y2VyLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9yZXNvbHZlQ29uZmlnLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcGVlZG9tZXRlci5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy90aHJvdHRsZS5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdG9Gb3JtRGF0YS5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdG9VUkxFbmNvZGVkRm9ybS5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdHJhY2tTdHJlYW0uanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3ZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2Jyb3dzZXIvY2xhc3Nlcy9CbG9iLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vYnJvd3Nlci9jbGFzc2VzL0Zvcm1EYXRhLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vYnJvd3Nlci9jbGFzc2VzL1VSTFNlYXJjaFBhcmFtcy5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2Jyb3dzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9jb21tb24vdXRpbHMuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9pbmRleC5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwid2VicGFjazovL3dlYi9zcmMvQXBwLnZ1ZSIsIndlYnBhY2s6Ly93ZWIvc3JjL2NvbXBvbmVudHMvQmFubmVyLnZ1ZSIsIndlYnBhY2s6Ly93ZWIvc3JjL2NvbXBvbmVudHMvQmlvLnZ1ZSIsIndlYnBhY2s6Ly93ZWIvc3JjL2NvbXBvbmVudHMvQ29udGFjdC52dWUiLCJ3ZWJwYWNrOi8vd2ViL3NyYy9jb21wb25lbnRzL0dlb21ldHJ5LnZ1ZSIsIndlYnBhY2s6Ly93ZWIvc3JjL2NvbXBvbmVudHMvUG9ydGZvbGlvTGlzdC52dWUiLCJ3ZWJwYWNrOi8vd2ViL3NyYy9jb21wb25lbnRzL3BvcnRmb2xpby9Db2RlUGVuQ2FyZC52dWUiLCJ3ZWJwYWNrOi8vd2ViL3NyYy9taXhpbnMvR3NhcC52dWUiLCJ3ZWJwYWNrOi8vd2ViL3NyYy9taXhpbnMvY3NzVmFyaWFibGVzLnZ1ZSIsIndlYnBhY2s6Ly93ZWIvc3JjL21peGlucy91dGlscy52dWUiLCJ3ZWJwYWNrOi8vd2ViLy4vc3JjL0FwcC52dWUiLCJ3ZWJwYWNrOi8vd2ViLy4vc3JjL2NvbXBvbmVudHMvQmFubmVyLnZ1ZSIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvY29tcG9uZW50cy9CaW8udnVlIiwid2VicGFjazovL3dlYi8uL3NyYy9jb21wb25lbnRzL0NvbnRhY3QudnVlIiwid2VicGFjazovL3dlYi8uL3NyYy9jb21wb25lbnRzL0dlb21ldHJ5LnZ1ZSIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvY29tcG9uZW50cy9Qb3J0Zm9saW9MaXN0LnZ1ZSIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvY29tcG9uZW50cy9wb3J0Zm9saW8vQ29kZVBlbkNhcmQudnVlIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUcmltLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdHJpbW1lZEVuZEluZGV4LmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzU3ltYm9sLmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbm93LmpzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdGhyb3R0bGUuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b051bWJlci5qcyIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvQXBwLnZ1ZT8xZjBkIiwid2VicGFjazovL3dlYi8uL3NyYy9BcHAudnVlP2M1MzAiLCJ3ZWJwYWNrOi8vd2ViLy4vc3JjL2NvbXBvbmVudHMvQmFubmVyLnZ1ZT82ZWY5Iiwid2VicGFjazovL3dlYi8uL3NyYy9jb21wb25lbnRzL0Jpby52dWU/ZTZhYiIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvY29tcG9uZW50cy9Db250YWN0LnZ1ZT81MWY3Iiwid2VicGFjazovL3dlYi8uL3NyYy9jb21wb25lbnRzL0dlb21ldHJ5LnZ1ZT9hOTBhIiwid2VicGFjazovL3dlYi8uL3NyYy9jb21wb25lbnRzL1BvcnRmb2xpb0xpc3QudnVlP2JlNmYiLCJ3ZWJwYWNrOi8vd2ViLy4vc3JjL2NvbXBvbmVudHMvcG9ydGZvbGlvL0NvZGVQZW5DYXJkLnZ1ZT84YmJlIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5ydW50aW1lLmVzbS5qcyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvdnVleC9kaXN0L3Z1ZXguZXNtLmpzIiwid2VicGFjazovL3dlYi8uL3NyYy9BcHAudnVlP2Y1ODEiLCJ3ZWJwYWNrOi8vd2ViLy4vc3JjL0FwcC52dWU/NTU3NiIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvQXBwLnZ1ZT84OGE1Iiwid2VicGFjazovL3dlYi8uL3NyYy9BcHAudnVlPzNkNzkiLCJ3ZWJwYWNrOi8vd2ViLy4vc3JjL0FwcC52dWU/YzZjMyIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvYXNzZXRzL3NjcmlwdHMvZ3NhcC9DU1NQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vd2ViLy4vc3JjL2Fzc2V0cy9zY3JpcHRzL2dzYXAvQ1NTUnVsZVBsdWdpbi5qcyIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvYXNzZXRzL3NjcmlwdHMvZ3NhcC9DdXN0b21FYXNlLmpzIiwid2VicGFjazovL3dlYi8uL3NyYy9hc3NldHMvc2NyaXB0cy9nc2FwL1Njcm9sbFRyaWdnZXIuanMiLCJ3ZWJwYWNrOi8vd2ViLy4vc3JjL2Fzc2V0cy9zY3JpcHRzL2dzYXAvZ3NhcC1jb3JlLmpzIiwid2VicGFjazovL3dlYi8uL3NyYy9hc3NldHMvc2NyaXB0cy9nc2FwL2luZGV4LmpzIiwid2VicGFjazovL3dlYi8uL3NyYy9hc3NldHMvc2NyaXB0cy9nc2FwL3V0aWxzL3BhdGhzLmpzIiwid2VicGFjazovL3dlYi8uL3NyYy9jb21wb25lbnRzL0Jhbm5lci52dWU/NDM2OSIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvY29tcG9uZW50cy9CYW5uZXIudnVlPzI0M2IiLCJ3ZWJwYWNrOi8vd2ViLy4vc3JjL2NvbXBvbmVudHMvQmFubmVyLnZ1ZT9mZTY1Iiwid2VicGFjazovL3dlYi8uL3NyYy9jb21wb25lbnRzL0Jhbm5lci52dWU/MzgwNiIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvY29tcG9uZW50cy9CaW8udnVlPzY5MmYiLCJ3ZWJwYWNrOi8vd2ViLy4vc3JjL2NvbXBvbmVudHMvQmlvLnZ1ZT9hNTY2Iiwid2VicGFjazovL3dlYi8uL3NyYy9jb21wb25lbnRzL0Jpby52dWU/MGE5MiIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvY29tcG9uZW50cy9CaW8udnVlPzRlNTYiLCJ3ZWJwYWNrOi8vd2ViLy4vc3JjL2NvbXBvbmVudHMvQ29udGFjdC52dWU/MWJiOCIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvY29tcG9uZW50cy9Db250YWN0LnZ1ZT8yNjg2Iiwid2VicGFjazovL3dlYi8uL3NyYy9jb21wb25lbnRzL0NvbnRhY3QudnVlP2FlOTAiLCJ3ZWJwYWNrOi8vd2ViLy4vc3JjL2NvbXBvbmVudHMvQ29udGFjdC52dWU/ODNkYSIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvY29tcG9uZW50cy9HZW9tZXRyeS52dWU/Y2EzNiIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvY29tcG9uZW50cy9HZW9tZXRyeS52dWU/M2E0YSIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvY29tcG9uZW50cy9HZW9tZXRyeS52dWU/MzJlNCIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvY29tcG9uZW50cy9HZW9tZXRyeS52dWU/ZjlhMyIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvY29tcG9uZW50cy9Qb3J0Zm9saW9MaXN0LnZ1ZT8xMzVkIiwid2VicGFjazovL3dlYi8uL3NyYy9jb21wb25lbnRzL1BvcnRmb2xpb0xpc3QudnVlPzllMTAiLCJ3ZWJwYWNrOi8vd2ViLy4vc3JjL2NvbXBvbmVudHMvUG9ydGZvbGlvTGlzdC52dWU/MjgzNiIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvY29tcG9uZW50cy9Qb3J0Zm9saW9MaXN0LnZ1ZT8zZmQzIiwid2VicGFjazovL3dlYi8uL3NyYy9jb21wb25lbnRzL3BvcnRmb2xpby9Db2RlUGVuQ2FyZC52dWU/NDZlOCIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvY29tcG9uZW50cy9wb3J0Zm9saW8vQ29kZVBlbkNhcmQudnVlPzMzMTEiLCJ3ZWJwYWNrOi8vd2ViLy4vc3JjL2NvbXBvbmVudHMvcG9ydGZvbGlvL0NvZGVQZW5DYXJkLnZ1ZT9kMWVkIiwid2VicGFjazovL3dlYi8uL3NyYy9jb21wb25lbnRzL3BvcnRmb2xpby9Db2RlUGVuQ2FyZC52dWU/MjE3MyIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvbWl4aW5zL0dzYXAudnVlIiwid2VicGFjazovL3dlYi8uL3NyYy9taXhpbnMvR3NhcC52dWU/MmUzMSIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvbWl4aW5zL2Nzc1ZhcmlhYmxlcy52dWUiLCJ3ZWJwYWNrOi8vd2ViLy4vc3JjL21peGlucy9jc3NWYXJpYWJsZXMudnVlPzU2NjMiLCJ3ZWJwYWNrOi8vd2ViLy4vc3JjL21peGlucy91dGlscy52dWUiLCJ3ZWJwYWNrOi8vd2ViLy4vc3JjL21peGlucy91dGlscy52dWU/MTZhYiIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvc3RvcmUvYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvc3RvcmUvc3RvcmUuanMiLCJ3ZWJwYWNrOi8vd2ViL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3dlYi93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly93ZWIvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3dlYi93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL3dlYi93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3dlYi93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3dlYi93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly93ZWIvLi9zcmMvbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfT3ZlcmxvYWRZaWVsZChlLCBkKSB7XG4gIHRoaXMudiA9IGUsIHRoaXMuayA9IGQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9PdmVybG9hZFlpZWxkLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkge1xuICAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7XG4gIGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdO1xuICByZXR1cm4gbjtcbn1cbmV4cG9ydCB7IF9hcnJheUxpa2VUb0FycmF5IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikge1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7XG59XG5leHBvcnQgeyBfYXJyYXlXaXRoSG9sZXMgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBhcnJheUxpa2VUb0FycmF5IGZyb20gXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIjtcbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShyKTtcbn1cbmV4cG9ydCB7IF9hcnJheVdpdGhvdXRIb2xlcyBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChlKSB7XG4gIGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgcmV0dXJuIGU7XG59XG5leHBvcnQgeyBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAobiwgdCwgZSwgciwgbywgYSwgYykge1xuICB0cnkge1xuICAgIHZhciBpID0gblthXShjKSxcbiAgICAgIHUgPSBpLnZhbHVlO1xuICB9IGNhdGNoIChuKSB7XG4gICAgcmV0dXJuIHZvaWQgZShuKTtcbiAgfVxuICBpLmRvbmUgPyB0KHUpIDogUHJvbWlzZS5yZXNvbHZlKHUpLnRoZW4ociwgbyk7XG59XG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHQgPSB0aGlzLFxuICAgICAgZSA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHIsIG8pIHtcbiAgICAgIHZhciBhID0gbi5hcHBseSh0LCBlKTtcbiAgICAgIGZ1bmN0aW9uIF9uZXh0KG4pIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGEsIHIsIG8sIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCBuKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhuKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChhLCByLCBvLCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIG4pO1xuICAgICAgfVxuICAgICAgX25leHQodm9pZCAwKTtcbiAgICB9KTtcbiAgfTtcbn1cbmV4cG9ydCB7IF9hc3luY1RvR2VuZXJhdG9yIGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikge1xuICBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5leHBvcnQgeyBfY2xhc3NDYWxsQ2hlY2sgYXMgZGVmYXVsdCB9OyIsImltcG9ydCB0b1Byb3BlcnR5S2V5IGZyb20gXCIuL3RvUHJvcGVydHlLZXkuanNcIjtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG8gPSByW3RdO1xuICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7XG4gIHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogITFcbiAgfSksIGU7XG59XG5leHBvcnQgeyBfY3JlYXRlQ2xhc3MgYXMgZGVmYXVsdCB9OyIsImltcG9ydCB0b1Byb3BlcnR5S2V5IGZyb20gXCIuL3RvUHJvcGVydHlLZXkuanNcIjtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IHRvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwge1xuICAgIHZhbHVlOiB0LFxuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgd3JpdGFibGU6ICEwXG4gIH0pIDogZVtyXSA9IHQsIGU7XG59XG5leHBvcnQgeyBfZGVmaW5lUHJvcGVydHkgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBzdXBlclByb3BCYXNlIGZyb20gXCIuL3N1cGVyUHJvcEJhc2UuanNcIjtcbmZ1bmN0aW9uIF9nZXQoKSB7XG4gIHJldHVybiBfZ2V0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmdldCA/IFJlZmxlY3QuZ2V0LmJpbmQoKSA6IGZ1bmN0aW9uIChlLCB0LCByKSB7XG4gICAgdmFyIHAgPSBzdXBlclByb3BCYXNlKGUsIHQpO1xuICAgIGlmIChwKSB7XG4gICAgICB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocCwgdCk7XG4gICAgICByZXR1cm4gbi5nZXQgPyBuLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gZSA6IHIpIDogbi52YWx1ZTtcbiAgICB9XG4gIH0sIF9nZXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cbmV4cG9ydCB7IF9nZXQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZih0KSB7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO1xuICB9LCBfZ2V0UHJvdG90eXBlT2YodCk7XG59XG5leHBvcnQgeyBfZ2V0UHJvdG90eXBlT2YgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBzZXRQcm90b3R5cGVPZiBmcm9tIFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiO1xuZnVuY3Rpb24gX2luaGVyaXRzKHQsIGUpIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiB0LFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgIH1cbiAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6ICExXG4gIH0pLCBlICYmIHNldFByb3RvdHlwZU9mKHQsIGUpO1xufVxuZXhwb3J0IHsgX2luaGVyaXRzIGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KHIpIHtcbiAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBudWxsICE9IHJbU3ltYm9sLml0ZXJhdG9yXSB8fCBudWxsICE9IHJbXCJAQGl0ZXJhdG9yXCJdKSByZXR1cm4gQXJyYXkuZnJvbShyKTtcbn1cbmV4cG9ydCB7IF9pdGVyYWJsZVRvQXJyYXkgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7XG4gIHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChudWxsICE9IHQpIHtcbiAgICB2YXIgZSxcbiAgICAgIG4sXG4gICAgICBpLFxuICAgICAgdSxcbiAgICAgIGEgPSBbXSxcbiAgICAgIGYgPSAhMCxcbiAgICAgIG8gPSAhMTtcbiAgICB0cnkge1xuICAgICAgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkge1xuICAgICAgICBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47XG4gICAgICAgIGYgPSAhMTtcbiAgICAgIH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBvID0gITAsIG4gPSByO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAobykgdGhyb3cgbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbn1cbmV4cG9ydCB7IF9pdGVyYWJsZVRvQXJyYXlMaW1pdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmV4cG9ydCB7IF9ub25JdGVyYWJsZVJlc3QgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5leHBvcnQgeyBfbm9uSXRlcmFibGVTcHJlYWQgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfdHlwZW9mIGZyb20gXCIuL3R5cGVvZi5qc1wiO1xuaW1wb3J0IGFzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tIFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcIjtcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGUpIHtcbiAgaWYgKGUgJiYgKFwib2JqZWN0XCIgPT0gX3R5cGVvZihlKSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHQpO1xufVxuZXhwb3J0IHsgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZih0LCBlKSB7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gPSBlLCB0O1xuICB9LCBfc2V0UHJvdG90eXBlT2YodCwgZSk7XG59XG5leHBvcnQgeyBfc2V0UHJvdG90eXBlT2YgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBhcnJheVdpdGhIb2xlcyBmcm9tIFwiLi9hcnJheVdpdGhIb2xlcy5qc1wiO1xuaW1wb3J0IGl0ZXJhYmxlVG9BcnJheUxpbWl0IGZyb20gXCIuL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzXCI7XG5pbXBvcnQgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgZnJvbSBcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcIjtcbmltcG9ydCBub25JdGVyYWJsZVJlc3QgZnJvbSBcIi4vbm9uSXRlcmFibGVSZXN0LmpzXCI7XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cbmV4cG9ydCB7IF9zbGljZWRUb0FycmF5IGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgZ2V0UHJvdG90eXBlT2YgZnJvbSBcIi4vZ2V0UHJvdG90eXBlT2YuanNcIjtcbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKHQsIG8pIHtcbiAgZm9yICg7ICF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIG8pICYmIG51bGwgIT09ICh0ID0gZ2V0UHJvdG90eXBlT2YodCkpOyk7XG4gIHJldHVybiB0O1xufVxuZXhwb3J0IHsgX3N1cGVyUHJvcEJhc2UgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBhcnJheVdpdGhvdXRIb2xlcyBmcm9tIFwiLi9hcnJheVdpdGhvdXRIb2xlcy5qc1wiO1xuaW1wb3J0IGl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiLi9pdGVyYWJsZVRvQXJyYXkuanNcIjtcbmltcG9ydCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiO1xuaW1wb3J0IG5vbkl0ZXJhYmxlU3ByZWFkIGZyb20gXCIuL25vbkl0ZXJhYmxlU3ByZWFkLmpzXCI7XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkocikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMocikgfHwgaXRlcmFibGVUb0FycmF5KHIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5leHBvcnQgeyBfdG9Db25zdW1hYmxlQXJyYXkgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfdHlwZW9mIGZyb20gXCIuL3R5cGVvZi5qc1wiO1xuZnVuY3Rpb24gdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbmV4cG9ydCB7IHRvUHJpbWl0aXZlIGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiLi90eXBlb2YuanNcIjtcbmltcG9ydCB0b1ByaW1pdGl2ZSBmcm9tIFwiLi90b1ByaW1pdGl2ZS5qc1wiO1xuZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7XG59XG5leHBvcnQgeyB0b1Byb3BlcnR5S2V5IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBfdHlwZW9mKG8pO1xufVxuZXhwb3J0IHsgX3R5cGVvZiBhcyBkZWZhdWx0IH07IiwiaW1wb3J0IGFycmF5TGlrZVRvQXJyYXkgZnJvbSBcIi4vYXJyYXlMaWtlVG9BcnJheS5qc1wiO1xuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHtcbiAgaWYgKHIpIHtcbiAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkociwgYSk7XG4gICAgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTtcbiAgICByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBhcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwO1xuICB9XG59XG5leHBvcnQgeyBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgYXMgZGVmYXVsdCB9OyIsInZhciByZWdlbmVyYXRvckRlZmluZSA9IHJlcXVpcmUoXCIuL3JlZ2VuZXJhdG9yRGVmaW5lLmpzXCIpO1xuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yKCkge1xuICAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL2Jsb2IvbWFpbi9wYWNrYWdlcy9iYWJlbC1oZWxwZXJzL0xJQ0VOU0UgKi9cbiAgdmFyIGUsXG4gICAgdCxcbiAgICByID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSxcbiAgICBuID0gci5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIixcbiAgICBvID0gci50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcbiAgZnVuY3Rpb24gaShyLCBuLCBvLCBpKSB7XG4gICAgdmFyIGMgPSBuICYmIG4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gbiA6IEdlbmVyYXRvcixcbiAgICAgIHUgPSBPYmplY3QuY3JlYXRlKGMucHJvdG90eXBlKTtcbiAgICByZXR1cm4gcmVnZW5lcmF0b3JEZWZpbmUodSwgXCJfaW52b2tlXCIsIGZ1bmN0aW9uIChyLCBuLCBvKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgYyxcbiAgICAgICAgdSxcbiAgICAgICAgZiA9IDAsXG4gICAgICAgIHAgPSBvIHx8IFtdLFxuICAgICAgICB5ID0gITEsXG4gICAgICAgIEcgPSB7XG4gICAgICAgICAgcDogMCxcbiAgICAgICAgICBuOiAwLFxuICAgICAgICAgIHY6IGUsXG4gICAgICAgICAgYTogZCxcbiAgICAgICAgICBmOiBkLmJpbmQoZSwgNCksXG4gICAgICAgICAgZDogZnVuY3Rpb24gZCh0LCByKSB7XG4gICAgICAgICAgICByZXR1cm4gaSA9IHQsIGMgPSAwLCB1ID0gZSwgRy5uID0gciwgYTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICBmdW5jdGlvbiBkKHIsIG4pIHtcbiAgICAgICAgZm9yIChjID0gciwgdSA9IG4sIHQgPSAwOyAheSAmJiBmICYmICFvICYmIHQgPCBwLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgdmFyIG8sXG4gICAgICAgICAgICBpID0gcFt0XSxcbiAgICAgICAgICAgIGQgPSBHLnAsXG4gICAgICAgICAgICBsID0gaVsyXTtcbiAgICAgICAgICByID4gMyA/IChvID0gbCA9PT0gbikgJiYgKHUgPSBpWyhjID0gaVs0XSkgPyA1IDogKGMgPSAzLCAzKV0sIGlbNF0gPSBpWzVdID0gZSkgOiBpWzBdIDw9IGQgJiYgKChvID0gciA8IDIgJiYgZCA8IGlbMV0pID8gKGMgPSAwLCBHLnYgPSBuLCBHLm4gPSBpWzFdKSA6IGQgPCBsICYmIChvID0gciA8IDMgfHwgaVswXSA+IG4gfHwgbiA+IGwpICYmIChpWzRdID0gciwgaVs1XSA9IG4sIEcubiA9IGwsIGMgPSAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8gfHwgciA+IDEpIHJldHVybiBhO1xuICAgICAgICB0aHJvdyB5ID0gITAsIG47XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG8sIHAsIGwpIHtcbiAgICAgICAgaWYgKGYgPiAxKSB0aHJvdyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgICBmb3IgKHkgJiYgMSA9PT0gcCAmJiBkKHAsIGwpLCBjID0gcCwgdSA9IGw7ICh0ID0gYyA8IDIgPyBlIDogdSkgfHwgIXk7KSB7XG4gICAgICAgICAgaSB8fCAoYyA/IGMgPCAzID8gKGMgPiAxICYmIChHLm4gPSAtMSksIGQoYywgdSkpIDogRy5uID0gdSA6IEcudiA9IHUpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDIsIGkpIHtcbiAgICAgICAgICAgICAgaWYgKGMgfHwgKG8gPSBcIm5leHRcIiksIHQgPSBpW29dKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEodCA9IHQuY2FsbChpLCB1KSkpIHRocm93IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgIGlmICghdC5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB1ID0gdC52YWx1ZSwgYyA8IDIgJiYgKGMgPSAwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIDEgPT09IGMgJiYgKHQgPSBpW1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoaSksIGMgPCAyICYmICh1ID0gVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBvICsgXCInIG1ldGhvZFwiKSwgYyA9IDEpO1xuICAgICAgICAgICAgICBpID0gZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHQgPSAoeSA9IEcubiA8IDApID8gdSA6IHIuY2FsbChuLCBHKSkgIT09IGEpIGJyZWFrO1xuICAgICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICAgIGkgPSBlLCBjID0gMSwgdSA9IHQ7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGYgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB0LFxuICAgICAgICAgIGRvbmU6IHlcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfShyLCBvLCBpKSwgITApLCB1O1xuICB9XG4gIHZhciBhID0ge307XG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuICB0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgYyA9IFtdW25dID8gdCh0KFtdW25dKCkpKSA6IChyZWdlbmVyYXRvckRlZmluZSh0ID0ge30sIG4sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pLCB0KSxcbiAgICB1ID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYyk7XG4gIGZ1bmN0aW9uIGYoZSkge1xuICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZSwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKGUuX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHJlZ2VuZXJhdG9yRGVmaW5lKGUsIG8sIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodSksIGU7XG4gIH1cbiAgcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCByZWdlbmVyYXRvckRlZmluZSh1LCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSwgcmVnZW5lcmF0b3JEZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiwgcmVnZW5lcmF0b3JEZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIG8sIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIHJlZ2VuZXJhdG9yRGVmaW5lKHUpLCByZWdlbmVyYXRvckRlZmluZSh1LCBvLCBcIkdlbmVyYXRvclwiKSwgcmVnZW5lcmF0b3JEZWZpbmUodSwgbiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgcmVnZW5lcmF0b3JEZWZpbmUodSwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH0pLCAobW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3IgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHc6IGksXG4gICAgICBtOiBmXG4gICAgfTtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzKSgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3IsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgcmVnZW5lcmF0b3JBc3luY0dlbiA9IHJlcXVpcmUoXCIuL3JlZ2VuZXJhdG9yQXN5bmNHZW4uanNcIik7XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JBc3luYyhuLCBlLCByLCB0LCBvKSB7XG4gIHZhciBhID0gcmVnZW5lcmF0b3JBc3luY0dlbihuLCBlLCByLCB0LCBvKTtcbiAgcmV0dXJuIGEubmV4dCgpLnRoZW4oZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5kb25lID8gbi52YWx1ZSA6IGEubmV4dCgpO1xuICB9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3JlZ2VuZXJhdG9yQXN5bmMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgcmVnZW5lcmF0b3IgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvci5qc1wiKTtcbnZhciByZWdlbmVyYXRvckFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvckFzeW5jSXRlcmF0b3IuanNcIik7XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JBc3luY0dlbihyLCBlLCB0LCBvLCBuKSB7XG4gIHJldHVybiBuZXcgcmVnZW5lcmF0b3JBc3luY0l0ZXJhdG9yKHJlZ2VuZXJhdG9yKCkudyhyLCBlLCB0LCBvKSwgbiB8fCBQcm9taXNlKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3JlZ2VuZXJhdG9yQXN5bmNHZW4sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgT3ZlcmxvYWRZaWVsZCA9IHJlcXVpcmUoXCIuL092ZXJsb2FkWWllbGQuanNcIik7XG52YXIgcmVnZW5lcmF0b3JEZWZpbmUgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvckRlZmluZS5qc1wiKTtcbmZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IodCwgZSkge1xuICBmdW5jdGlvbiBuKHIsIG8sIGksIGYpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGMgPSB0W3JdKG8pLFxuICAgICAgICB1ID0gYy52YWx1ZTtcbiAgICAgIHJldHVybiB1IGluc3RhbmNlb2YgT3ZlcmxvYWRZaWVsZCA/IGUucmVzb2x2ZSh1LnYpLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgbihcIm5leHRcIiwgdCwgaSwgZik7XG4gICAgICB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICBuKFwidGhyb3dcIiwgdCwgaSwgZik7XG4gICAgICB9KSA6IGUucmVzb2x2ZSh1KS50aGVuKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGMudmFsdWUgPSB0LCBpKGMpO1xuICAgICAgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIG4oXCJ0aHJvd1wiLCB0LCBpLCBmKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgIGYodCk7XG4gICAgfVxuICB9XG4gIHZhciByO1xuICB0aGlzLm5leHQgfHwgKHJlZ2VuZXJhdG9yRGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgcmVnZW5lcmF0b3JEZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQGFzeW5jSXRlcmF0b3JcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSksIHJlZ2VuZXJhdG9yRGVmaW5lKHRoaXMsIFwiX2ludm9rZVwiLCBmdW5jdGlvbiAodCwgbywgaSkge1xuICAgIGZ1bmN0aW9uIGYoKSB7XG4gICAgICByZXR1cm4gbmV3IGUoZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgbih0LCBpLCBlLCByKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gciA9IHIgPyByLnRoZW4oZiwgZikgOiBmKCk7XG4gIH0sICEwKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gQXN5bmNJdGVyYXRvciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9yZWdlbmVyYXRvckRlZmluZShlLCByLCBuLCB0KSB7XG4gIHZhciBpID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICB0cnkge1xuICAgIGkoe30sIFwiXCIsIHt9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGkgPSAwO1xuICB9XG4gIG1vZHVsZS5leHBvcnRzID0gX3JlZ2VuZXJhdG9yRGVmaW5lID0gZnVuY3Rpb24gcmVnZW5lcmF0b3JEZWZpbmUoZSwgciwgbiwgdCkge1xuICAgIGZ1bmN0aW9uIG8ociwgbikge1xuICAgICAgX3JlZ2VuZXJhdG9yRGVmaW5lKGUsIHIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UociwgbiwgZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgciA/IGkgPyBpKGUsIHIsIHtcbiAgICAgIHZhbHVlOiBuLFxuICAgICAgZW51bWVyYWJsZTogIXQsXG4gICAgICBjb25maWd1cmFibGU6ICF0LFxuICAgICAgd3JpdGFibGU6ICF0XG4gICAgfSkgOiBlW3JdID0gbiA6IChvKFwibmV4dFwiLCAwKSwgbyhcInRocm93XCIsIDEpLCBvKFwicmV0dXJuXCIsIDIpKTtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBfcmVnZW5lcmF0b3JEZWZpbmUoZSwgciwgbiwgdCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9yZWdlbmVyYXRvckRlZmluZSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9yZWdlbmVyYXRvcktleXMoZSkge1xuICB2YXIgbiA9IE9iamVjdChlKSxcbiAgICByID0gW107XG4gIGZvciAodmFyIHQgaW4gbikgci51bnNoaWZ0KHQpO1xuICByZXR1cm4gZnVuY3Rpb24gZSgpIHtcbiAgICBmb3IgKDsgci5sZW5ndGg7KSBpZiAoKHQgPSByLnBvcCgpKSBpbiBuKSByZXR1cm4gZS52YWx1ZSA9IHQsIGUuZG9uZSA9ICExLCBlO1xuICAgIHJldHVybiBlLmRvbmUgPSAhMCwgZTtcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3JlZ2VuZXJhdG9yS2V5cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBPdmVybG9hZFlpZWxkID0gcmVxdWlyZShcIi4vT3ZlcmxvYWRZaWVsZC5qc1wiKTtcbnZhciByZWdlbmVyYXRvciA9IHJlcXVpcmUoXCIuL3JlZ2VuZXJhdG9yLmpzXCIpO1xudmFyIHJlZ2VuZXJhdG9yQXN5bmMgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvckFzeW5jLmpzXCIpO1xudmFyIHJlZ2VuZXJhdG9yQXN5bmNHZW4gPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvckFzeW5jR2VuLmpzXCIpO1xudmFyIHJlZ2VuZXJhdG9yQXN5bmNJdGVyYXRvciA9IHJlcXVpcmUoXCIuL3JlZ2VuZXJhdG9yQXN5bmNJdGVyYXRvci5qc1wiKTtcbnZhciByZWdlbmVyYXRvcktleXMgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvcktleXMuanNcIik7XG52YXIgcmVnZW5lcmF0b3JWYWx1ZXMgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvclZhbHVlcy5qc1wiKTtcbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciByID0gcmVnZW5lcmF0b3IoKSxcbiAgICBlID0gci5tKF9yZWdlbmVyYXRvclJ1bnRpbWUpLFxuICAgIHQgPSAoT2JqZWN0LmdldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpIDogZS5fX3Byb3RvX18pLmNvbnN0cnVjdG9yO1xuICBmdW5jdGlvbiBuKHIpIHtcbiAgICB2YXIgZSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgciAmJiByLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiAhIWUgJiYgKGUgPT09IHQgfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUpKTtcbiAgfVxuICB2YXIgbyA9IHtcbiAgICBcInRocm93XCI6IDEsXG4gICAgXCJyZXR1cm5cIjogMixcbiAgICBcImJyZWFrXCI6IDMsXG4gICAgXCJjb250aW51ZVwiOiAzXG4gIH07XG4gIGZ1bmN0aW9uIGEocikge1xuICAgIHZhciBlLCB0O1xuICAgIHJldHVybiBmdW5jdGlvbiAobikge1xuICAgICAgZSB8fCAoZSA9IHtcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICByZXR1cm4gdChuLmEsIDIpO1xuICAgICAgICB9LFxuICAgICAgICBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCgpIHtcbiAgICAgICAgICByZXR1cm4gbi52O1xuICAgICAgICB9LFxuICAgICAgICBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdChyLCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHQobi5hLCBvW3JdLCBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChyLCBvLCBhKSB7XG4gICAgICAgICAgcmV0dXJuIGUucmVzdWx0TmFtZSA9IG8sIHQobi5kLCByZWdlbmVyYXRvclZhbHVlcyhyKSwgYSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKHIpIHtcbiAgICAgICAgICByZXR1cm4gdChuLmYsIHIpO1xuICAgICAgICB9XG4gICAgICB9LCB0ID0gZnVuY3Rpb24gdChyLCBfdCwgbykge1xuICAgICAgICBuLnAgPSBlLnByZXYsIG4ubiA9IGUubmV4dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcihfdCwgbyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZS5uZXh0ID0gbi5uO1xuICAgICAgICB9XG4gICAgICB9KSwgZS5yZXN1bHROYW1lICYmIChlW2UucmVzdWx0TmFtZV0gPSBuLnYsIGUucmVzdWx0TmFtZSA9IHZvaWQgMCksIGUuc2VudCA9IG4udiwgZS5uZXh0ID0gbi5uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHIuY2FsbCh0aGlzLCBlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG4ucCA9IGUucHJldiwgbi5uID0gZS5uZXh0O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIChtb2R1bGUuZXhwb3J0cyA9IF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cmFwOiBmdW5jdGlvbiB3cmFwKGUsIHQsIG4sIG8pIHtcbiAgICAgICAgcmV0dXJuIHIudyhhKGUpLCB0LCBuLCBvICYmIG8ucmV2ZXJzZSgpKTtcbiAgICAgIH0sXG4gICAgICBpc0dlbmVyYXRvckZ1bmN0aW9uOiBuLFxuICAgICAgbWFyazogci5tLFxuICAgICAgYXdyYXA6IGZ1bmN0aW9uIGF3cmFwKHIsIGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPdmVybG9hZFlpZWxkKHIsIGUpO1xuICAgICAgfSxcbiAgICAgIEFzeW5jSXRlcmF0b3I6IHJlZ2VuZXJhdG9yQXN5bmNJdGVyYXRvcixcbiAgICAgIGFzeW5jOiBmdW5jdGlvbiBhc3luYyhyLCBlLCB0LCBvLCB1KSB7XG4gICAgICAgIHJldHVybiAobihlKSA/IHJlZ2VuZXJhdG9yQXN5bmNHZW4gOiByZWdlbmVyYXRvckFzeW5jKShhKHIpLCBlLCB0LCBvLCB1KTtcbiAgICAgIH0sXG4gICAgICBrZXlzOiByZWdlbmVyYXRvcktleXMsXG4gICAgICB2YWx1ZXM6IHJlZ2VuZXJhdG9yVmFsdWVzXG4gICAgfTtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzKSgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JSdW50aW1lLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi90eXBlb2YuanNcIilbXCJkZWZhdWx0XCJdO1xuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yVmFsdWVzKGUpIHtcbiAgaWYgKG51bGwgIT0gZSkge1xuICAgIHZhciB0ID0gZVtcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCJdLFxuICAgICAgciA9IDA7XG4gICAgaWYgKHQpIHJldHVybiB0LmNhbGwoZSk7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZS5uZXh0KSByZXR1cm4gZTtcbiAgICBpZiAoIWlzTmFOKGUubGVuZ3RoKSkgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHJldHVybiBlICYmIHIgPj0gZS5sZW5ndGggJiYgKGUgPSB2b2lkIDApLCB7XG4gICAgICAgICAgdmFsdWU6IGUgJiYgZVtyKytdLFxuICAgICAgICAgIGRvbmU6ICFlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKF90eXBlb2YoZSkgKyBcIiBpcyBub3QgaXRlcmFibGVcIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9yZWdlbmVyYXRvclZhbHVlcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBfdHlwZW9mKG8pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiLy8gVE9ETyhCYWJlbCA4KTogUmVtb3ZlIHRoaXMgZmlsZS5cblxudmFyIHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vaGVscGVycy9yZWdlbmVyYXRvclJ1bnRpbWVcIikoKTtcbm1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcblxuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9wYWNrYWdlcy9ydW50aW1lL3J1bnRpbWUuanMjTDczNj1cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gIH0gZWxzZSB7XG4gICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbiAgfVxufVxuIiwiaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBodHRwQWRhcHRlciBmcm9tICcuL2h0dHAuanMnO1xuaW1wb3J0IHhockFkYXB0ZXIgZnJvbSAnLi94aHIuanMnO1xuaW1wb3J0ICogYXMgZmV0Y2hBZGFwdGVyIGZyb20gJy4vZmV0Y2guanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSBcIi4uL2NvcmUvQXhpb3NFcnJvci5qc1wiO1xuXG4vKipcbiAqIEtub3duIGFkYXB0ZXJzIG1hcHBpbmcuXG4gKiBQcm92aWRlcyBlbnZpcm9ubWVudC1zcGVjaWZpYyBhZGFwdGVycyBmb3IgQXhpb3M6XG4gKiAtIGBodHRwYCBmb3IgTm9kZS5qc1xuICogLSBgeGhyYCBmb3IgYnJvd3NlcnNcbiAqIC0gYGZldGNoYCBmb3IgZmV0Y2ggQVBJLWJhc2VkIHJlcXVlc3RzXG4gKiBcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBGdW5jdGlvbnxPYmplY3Q+fVxuICovXG5jb25zdCBrbm93bkFkYXB0ZXJzID0ge1xuICBodHRwOiBodHRwQWRhcHRlcixcbiAgeGhyOiB4aHJBZGFwdGVyLFxuICBmZXRjaDoge1xuICAgIGdldDogZmV0Y2hBZGFwdGVyLmdldEZldGNoLFxuICB9XG59O1xuXG4vLyBBc3NpZ24gYWRhcHRlciBuYW1lcyBmb3IgZWFzaWVyIGRlYnVnZ2luZyBhbmQgaWRlbnRpZmljYXRpb25cbnV0aWxzLmZvckVhY2goa25vd25BZGFwdGVycywgKGZuLCB2YWx1ZSkgPT4ge1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnbmFtZScsIHsgdmFsdWUgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ2FkYXB0ZXJOYW1lJywgeyB2YWx1ZSB9KTtcbiAgfVxufSk7XG5cbi8qKlxuICogUmVuZGVyIGEgcmVqZWN0aW9uIHJlYXNvbiBzdHJpbmcgZm9yIHVua25vd24gb3IgdW5zdXBwb3J0ZWQgYWRhcHRlcnNcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgcmVuZGVyUmVhc29uID0gKHJlYXNvbikgPT4gYC0gJHtyZWFzb259YDtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYWRhcHRlciBpcyByZXNvbHZlZCAoZnVuY3Rpb24sIG51bGwsIG9yIGZhbHNlKVxuICogXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufG51bGx8ZmFsc2V9IGFkYXB0ZXJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc1Jlc29sdmVkSGFuZGxlID0gKGFkYXB0ZXIpID0+IHV0aWxzLmlzRnVuY3Rpb24oYWRhcHRlcikgfHwgYWRhcHRlciA9PT0gbnVsbCB8fCBhZGFwdGVyID09PSBmYWxzZTtcblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IHN1aXRhYmxlIGFkYXB0ZXIgZnJvbSB0aGUgcHJvdmlkZWQgbGlzdC5cbiAqIFRyaWVzIGVhY2ggYWRhcHRlciBpbiBvcmRlciB1bnRpbCBhIHN1cHBvcnRlZCBvbmUgaXMgZm91bmQuXG4gKiBUaHJvd3MgYW4gQXhpb3NFcnJvciBpZiBubyBhZGFwdGVyIGlzIHN1aXRhYmxlLlxuICogXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xGdW5jdGlvbj58c3RyaW5nfEZ1bmN0aW9ufSBhZGFwdGVycyAtIEFkYXB0ZXIocykgYnkgbmFtZSBvciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSBBeGlvcyByZXF1ZXN0IGNvbmZpZ3VyYXRpb25cbiAqIEB0aHJvd3Mge0F4aW9zRXJyb3J9IElmIG5vIHN1aXRhYmxlIGFkYXB0ZXIgaXMgYXZhaWxhYmxlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSByZXNvbHZlZCBhZGFwdGVyIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldEFkYXB0ZXIoYWRhcHRlcnMsIGNvbmZpZykge1xuICBhZGFwdGVycyA9IHV0aWxzLmlzQXJyYXkoYWRhcHRlcnMpID8gYWRhcHRlcnMgOiBbYWRhcHRlcnNdO1xuXG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBhZGFwdGVycztcbiAgbGV0IG5hbWVPckFkYXB0ZXI7XG4gIGxldCBhZGFwdGVyO1xuXG4gIGNvbnN0IHJlamVjdGVkUmVhc29ucyA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBuYW1lT3JBZGFwdGVyID0gYWRhcHRlcnNbaV07XG4gICAgbGV0IGlkO1xuXG4gICAgYWRhcHRlciA9IG5hbWVPckFkYXB0ZXI7XG5cbiAgICBpZiAoIWlzUmVzb2x2ZWRIYW5kbGUobmFtZU9yQWRhcHRlcikpIHtcbiAgICAgIGFkYXB0ZXIgPSBrbm93bkFkYXB0ZXJzWyhpZCA9IFN0cmluZyhuYW1lT3JBZGFwdGVyKSkudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgIGlmIChhZGFwdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoYFVua25vd24gYWRhcHRlciAnJHtpZH0nYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFkYXB0ZXIgJiYgKHV0aWxzLmlzRnVuY3Rpb24oYWRhcHRlcikgfHwgKGFkYXB0ZXIgPSBhZGFwdGVyLmdldChjb25maWcpKSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJlamVjdGVkUmVhc29uc1tpZCB8fCAnIycgKyBpXSA9IGFkYXB0ZXI7XG4gIH1cblxuICBpZiAoIWFkYXB0ZXIpIHtcbiAgICBjb25zdCByZWFzb25zID0gT2JqZWN0LmVudHJpZXMocmVqZWN0ZWRSZWFzb25zKVxuICAgICAgLm1hcCgoW2lkLCBzdGF0ZV0pID0+IGBhZGFwdGVyICR7aWR9IGAgK1xuICAgICAgICAoc3RhdGUgPT09IGZhbHNlID8gJ2lzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGVudmlyb25tZW50JyA6ICdpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBidWlsZCcpXG4gICAgICApO1xuXG4gICAgbGV0IHMgPSBsZW5ndGggP1xuICAgICAgKHJlYXNvbnMubGVuZ3RoID4gMSA/ICdzaW5jZSA6XFxuJyArIHJlYXNvbnMubWFwKHJlbmRlclJlYXNvbikuam9pbignXFxuJykgOiAnICcgKyByZW5kZXJSZWFzb24ocmVhc29uc1swXSkpIDpcbiAgICAgICdhcyBubyBhZGFwdGVyIHNwZWNpZmllZCc7XG5cbiAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgIGBUaGVyZSBpcyBubyBzdWl0YWJsZSBhZGFwdGVyIHRvIGRpc3BhdGNoIHRoZSByZXF1ZXN0IGAgKyBzLFxuICAgICAgJ0VSUl9OT1RfU1VQUE9SVCdcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbi8qKlxuICogRXhwb3J0cyBBeGlvcyBhZGFwdGVycyBhbmQgdXRpbGl0eSB0byByZXNvbHZlIGFuIGFkYXB0ZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogUmVzb2x2ZSBhbiBhZGFwdGVyIGZyb20gYSBsaXN0IG9mIGFkYXB0ZXIgbmFtZXMgb3IgZnVuY3Rpb25zLlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICBnZXRBZGFwdGVyLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VzIGFsbCBrbm93biBhZGFwdGVyc1xuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgRnVuY3Rpb258T2JqZWN0Pn1cbiAgICovXG4gIGFkYXB0ZXJzOiBrbm93bkFkYXB0ZXJzXG59O1xuIiwiaW1wb3J0IHBsYXRmb3JtIGZyb20gXCIuLi9wbGF0Zm9ybS9pbmRleC5qc1wiO1xuaW1wb3J0IHV0aWxzIGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSBcIi4uL2NvcmUvQXhpb3NFcnJvci5qc1wiO1xuaW1wb3J0IGNvbXBvc2VTaWduYWxzIGZyb20gXCIuLi9oZWxwZXJzL2NvbXBvc2VTaWduYWxzLmpzXCI7XG5pbXBvcnQge3RyYWNrU3RyZWFtfSBmcm9tIFwiLi4vaGVscGVycy90cmFja1N0cmVhbS5qc1wiO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tIFwiLi4vY29yZS9BeGlvc0hlYWRlcnMuanNcIjtcbmltcG9ydCB7cHJvZ3Jlc3NFdmVudFJlZHVjZXIsIHByb2dyZXNzRXZlbnREZWNvcmF0b3IsIGFzeW5jRGVjb3JhdG9yfSBmcm9tIFwiLi4vaGVscGVycy9wcm9ncmVzc0V2ZW50UmVkdWNlci5qc1wiO1xuaW1wb3J0IHJlc29sdmVDb25maWcgZnJvbSBcIi4uL2hlbHBlcnMvcmVzb2x2ZUNvbmZpZy5qc1wiO1xuaW1wb3J0IHNldHRsZSBmcm9tIFwiLi4vY29yZS9zZXR0bGUuanNcIjtcblxuY29uc3QgREVGQVVMVF9DSFVOS19TSVpFID0gNjQgKiAxMDI0O1xuXG5jb25zdCB7aXNGdW5jdGlvbn0gPSB1dGlscztcblxuY29uc3QgZ2xvYmFsRmV0Y2hBUEkgPSAoKHtSZXF1ZXN0LCBSZXNwb25zZX0pID0+ICh7XG4gIFJlcXVlc3QsIFJlc3BvbnNlXG59KSkodXRpbHMuZ2xvYmFsKTtcblxuY29uc3Qge1xuICBSZWFkYWJsZVN0cmVhbSwgVGV4dEVuY29kZXJcbn0gPSB1dGlscy5nbG9iYWw7XG5cblxuY29uc3QgdGVzdCA9IChmbiwgLi4uYXJncykgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiAhIWZuKC4uLmFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuY29uc3QgZmFjdG9yeSA9IChlbnYpID0+IHtcbiAgZW52ID0gdXRpbHMubWVyZ2UuY2FsbCh7XG4gICAgc2tpcFVuZGVmaW5lZDogdHJ1ZVxuICB9LCBnbG9iYWxGZXRjaEFQSSwgZW52KTtcblxuICBjb25zdCB7ZmV0Y2g6IGVudkZldGNoLCBSZXF1ZXN0LCBSZXNwb25zZX0gPSBlbnY7XG4gIGNvbnN0IGlzRmV0Y2hTdXBwb3J0ZWQgPSBlbnZGZXRjaCA/IGlzRnVuY3Rpb24oZW52RmV0Y2gpIDogdHlwZW9mIGZldGNoID09PSAnZnVuY3Rpb24nO1xuICBjb25zdCBpc1JlcXVlc3RTdXBwb3J0ZWQgPSBpc0Z1bmN0aW9uKFJlcXVlc3QpO1xuICBjb25zdCBpc1Jlc3BvbnNlU3VwcG9ydGVkID0gaXNGdW5jdGlvbihSZXNwb25zZSk7XG5cbiAgaWYgKCFpc0ZldGNoU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgaXNSZWFkYWJsZVN0cmVhbVN1cHBvcnRlZCA9IGlzRmV0Y2hTdXBwb3J0ZWQgJiYgaXNGdW5jdGlvbihSZWFkYWJsZVN0cmVhbSk7XG5cbiAgY29uc3QgZW5jb2RlVGV4dCA9IGlzRmV0Y2hTdXBwb3J0ZWQgJiYgKHR5cGVvZiBUZXh0RW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAoKGVuY29kZXIpID0+IChzdHIpID0+IGVuY29kZXIuZW5jb2RlKHN0cikpKG5ldyBUZXh0RW5jb2RlcigpKSA6XG4gICAgICBhc3luYyAoc3RyKSA9PiBuZXcgVWludDhBcnJheShhd2FpdCBuZXcgUmVxdWVzdChzdHIpLmFycmF5QnVmZmVyKCkpXG4gICk7XG5cbiAgY29uc3Qgc3VwcG9ydHNSZXF1ZXN0U3RyZWFtID0gaXNSZXF1ZXN0U3VwcG9ydGVkICYmIGlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQgJiYgdGVzdCgoKSA9PiB7XG4gICAgbGV0IGR1cGxleEFjY2Vzc2VkID0gZmFsc2U7XG5cbiAgICBjb25zdCBoYXNDb250ZW50VHlwZSA9IG5ldyBSZXF1ZXN0KHBsYXRmb3JtLm9yaWdpbiwge1xuICAgICAgYm9keTogbmV3IFJlYWRhYmxlU3RyZWFtKCksXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGdldCBkdXBsZXgoKSB7XG4gICAgICAgIGR1cGxleEFjY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICdoYWxmJztcbiAgICAgIH0sXG4gICAgfSkuaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpO1xuXG4gICAgcmV0dXJuIGR1cGxleEFjY2Vzc2VkICYmICFoYXNDb250ZW50VHlwZTtcbiAgfSk7XG5cbiAgY29uc3Qgc3VwcG9ydHNSZXNwb25zZVN0cmVhbSA9IGlzUmVzcG9uc2VTdXBwb3J0ZWQgJiYgaXNSZWFkYWJsZVN0cmVhbVN1cHBvcnRlZCAmJlxuICAgIHRlc3QoKCkgPT4gdXRpbHMuaXNSZWFkYWJsZVN0cmVhbShuZXcgUmVzcG9uc2UoJycpLmJvZHkpKTtcblxuICBjb25zdCByZXNvbHZlcnMgPSB7XG4gICAgc3RyZWFtOiBzdXBwb3J0c1Jlc3BvbnNlU3RyZWFtICYmICgocmVzKSA9PiByZXMuYm9keSlcbiAgfTtcblxuICBpc0ZldGNoU3VwcG9ydGVkICYmICgoKCkgPT4ge1xuICAgIFsndGV4dCcsICdhcnJheUJ1ZmZlcicsICdibG9iJywgJ2Zvcm1EYXRhJywgJ3N0cmVhbSddLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAhcmVzb2x2ZXJzW3R5cGVdICYmIChyZXNvbHZlcnNbdHlwZV0gPSAocmVzLCBjb25maWcpID0+IHtcbiAgICAgICAgbGV0IG1ldGhvZCA9IHJlcyAmJiByZXNbdHlwZV07XG5cbiAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBtZXRob2QuY2FsbChyZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoYFJlc3BvbnNlIHR5cGUgJyR7dHlwZX0nIGlzIG5vdCBzdXBwb3J0ZWRgLCBBeGlvc0Vycm9yLkVSUl9OT1RfU1VQUE9SVCwgY29uZmlnKTtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH0pKCkpO1xuXG4gIGNvbnN0IGdldEJvZHlMZW5ndGggPSBhc3luYyAoYm9keSkgPT4ge1xuICAgIGlmIChib2R5ID09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0Jsb2IoYm9keSkpIHtcbiAgICAgIHJldHVybiBib2R5LnNpemU7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzU3BlY0NvbXBsaWFudEZvcm0oYm9keSkpIHtcbiAgICAgIGNvbnN0IF9yZXF1ZXN0ID0gbmV3IFJlcXVlc3QocGxhdGZvcm0ub3JpZ2luLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5LFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKGF3YWl0IF9yZXF1ZXN0LmFycmF5QnVmZmVyKCkpLmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpIHx8IHV0aWxzLmlzQXJyYXlCdWZmZXIoYm9keSkpIHtcbiAgICAgIHJldHVybiBib2R5LmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGJvZHkpKSB7XG4gICAgICBib2R5ID0gYm9keSArICcnO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc1N0cmluZyhib2R5KSkge1xuICAgICAgcmV0dXJuIChhd2FpdCBlbmNvZGVUZXh0KGJvZHkpKS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVCb2R5TGVuZ3RoID0gYXN5bmMgKGhlYWRlcnMsIGJvZHkpID0+IHtcbiAgICBjb25zdCBsZW5ndGggPSB1dGlscy50b0Zpbml0ZU51bWJlcihoZWFkZXJzLmdldENvbnRlbnRMZW5ndGgoKSk7XG5cbiAgICByZXR1cm4gbGVuZ3RoID09IG51bGwgPyBnZXRCb2R5TGVuZ3RoKGJvZHkpIDogbGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIGFzeW5jIChjb25maWcpID0+IHtcbiAgICBsZXQge1xuICAgICAgdXJsLFxuICAgICAgbWV0aG9kLFxuICAgICAgZGF0YSxcbiAgICAgIHNpZ25hbCxcbiAgICAgIGNhbmNlbFRva2VuLFxuICAgICAgdGltZW91dCxcbiAgICAgIG9uRG93bmxvYWRQcm9ncmVzcyxcbiAgICAgIG9uVXBsb2FkUHJvZ3Jlc3MsXG4gICAgICByZXNwb25zZVR5cGUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgd2l0aENyZWRlbnRpYWxzID0gJ3NhbWUtb3JpZ2luJyxcbiAgICAgIGZldGNoT3B0aW9uc1xuICAgIH0gPSByZXNvbHZlQ29uZmlnKGNvbmZpZyk7XG5cbiAgICBsZXQgX2ZldGNoID0gZW52RmV0Y2ggfHwgZmV0Y2g7XG5cbiAgICByZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGUgPyAocmVzcG9uc2VUeXBlICsgJycpLnRvTG93ZXJDYXNlKCkgOiAndGV4dCc7XG5cbiAgICBsZXQgY29tcG9zZWRTaWduYWwgPSBjb21wb3NlU2lnbmFscyhbc2lnbmFsLCBjYW5jZWxUb2tlbiAmJiBjYW5jZWxUb2tlbi50b0Fib3J0U2lnbmFsKCldLCB0aW1lb3V0KTtcblxuICAgIGxldCByZXF1ZXN0ID0gbnVsbDtcblxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gY29tcG9zZWRTaWduYWwgJiYgY29tcG9zZWRTaWduYWwudW5zdWJzY3JpYmUgJiYgKCgpID0+IHtcbiAgICAgIGNvbXBvc2VkU2lnbmFsLnVuc3Vic2NyaWJlKCk7XG4gICAgfSk7XG5cbiAgICBsZXQgcmVxdWVzdENvbnRlbnRMZW5ndGg7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKFxuICAgICAgICBvblVwbG9hZFByb2dyZXNzICYmIHN1cHBvcnRzUmVxdWVzdFN0cmVhbSAmJiBtZXRob2QgIT09ICdnZXQnICYmIG1ldGhvZCAhPT0gJ2hlYWQnICYmXG4gICAgICAgIChyZXF1ZXN0Q29udGVudExlbmd0aCA9IGF3YWl0IHJlc29sdmVCb2R5TGVuZ3RoKGhlYWRlcnMsIGRhdGEpKSAhPT0gMFxuICAgICAgKSB7XG4gICAgICAgIGxldCBfcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGJvZHk6IGRhdGEsXG4gICAgICAgICAgZHVwbGV4OiBcImhhbGZcIlxuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgY29udGVudFR5cGVIZWFkZXI7XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgJiYgKGNvbnRlbnRUeXBlSGVhZGVyID0gX3JlcXVlc3QuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSkge1xuICAgICAgICAgIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoY29udGVudFR5cGVIZWFkZXIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3JlcXVlc3QuYm9keSkge1xuICAgICAgICAgIGNvbnN0IFtvblByb2dyZXNzLCBmbHVzaF0gPSBwcm9ncmVzc0V2ZW50RGVjb3JhdG9yKFxuICAgICAgICAgICAgcmVxdWVzdENvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgICBwcm9ncmVzc0V2ZW50UmVkdWNlcihhc3luY0RlY29yYXRvcihvblVwbG9hZFByb2dyZXNzKSlcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgZGF0YSA9IHRyYWNrU3RyZWFtKF9yZXF1ZXN0LmJvZHksIERFRkFVTFRfQ0hVTktfU0laRSwgb25Qcm9ncmVzcywgZmx1c2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdXRpbHMuaXNTdHJpbmcod2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgICB3aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHMgPyAnaW5jbHVkZScgOiAnb21pdCc7XG4gICAgICB9XG5cbiAgICAgIC8vIENsb3VkZmxhcmUgV29ya2VycyB0aHJvd3Mgd2hlbiBjcmVkZW50aWFscyBhcmUgZGVmaW5lZFxuICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG91ZGZsYXJlL3dvcmtlcmQvaXNzdWVzLzkwMlxuICAgICAgY29uc3QgaXNDcmVkZW50aWFsc1N1cHBvcnRlZCA9IGlzUmVxdWVzdFN1cHBvcnRlZCAmJiBcImNyZWRlbnRpYWxzXCIgaW4gUmVxdWVzdC5wcm90b3R5cGU7XG5cbiAgICAgIGNvbnN0IHJlc29sdmVkT3B0aW9ucyA9IHtcbiAgICAgICAgLi4uZmV0Y2hPcHRpb25zLFxuICAgICAgICBzaWduYWw6IGNvbXBvc2VkU2lnbmFsLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLm5vcm1hbGl6ZSgpLnRvSlNPTigpLFxuICAgICAgICBib2R5OiBkYXRhLFxuICAgICAgICBkdXBsZXg6IFwiaGFsZlwiLFxuICAgICAgICBjcmVkZW50aWFsczogaXNDcmVkZW50aWFsc1N1cHBvcnRlZCA/IHdpdGhDcmVkZW50aWFscyA6IHVuZGVmaW5lZFxuICAgICAgfTtcblxuICAgICAgcmVxdWVzdCA9IGlzUmVxdWVzdFN1cHBvcnRlZCAmJiBuZXcgUmVxdWVzdCh1cmwsIHJlc29sdmVkT3B0aW9ucyk7XG5cbiAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IChpc1JlcXVlc3RTdXBwb3J0ZWQgPyBfZmV0Y2gocmVxdWVzdCwgZmV0Y2hPcHRpb25zKSA6IF9mZXRjaCh1cmwsIHJlc29sdmVkT3B0aW9ucykpO1xuXG4gICAgICBjb25zdCBpc1N0cmVhbVJlc3BvbnNlID0gc3VwcG9ydHNSZXNwb25zZVN0cmVhbSAmJiAocmVzcG9uc2VUeXBlID09PSAnc3RyZWFtJyB8fCByZXNwb25zZVR5cGUgPT09ICdyZXNwb25zZScpO1xuXG4gICAgICBpZiAoc3VwcG9ydHNSZXNwb25zZVN0cmVhbSAmJiAob25Eb3dubG9hZFByb2dyZXNzIHx8IChpc1N0cmVhbVJlc3BvbnNlICYmIHVuc3Vic2NyaWJlKSkpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgIFsnc3RhdHVzJywgJ3N0YXR1c1RleHQnLCAnaGVhZGVycyddLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgb3B0aW9uc1twcm9wXSA9IHJlc3BvbnNlW3Byb3BdO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZUNvbnRlbnRMZW5ndGggPSB1dGlscy50b0Zpbml0ZU51bWJlcihyZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKSk7XG5cbiAgICAgICAgY29uc3QgW29uUHJvZ3Jlc3MsIGZsdXNoXSA9IG9uRG93bmxvYWRQcm9ncmVzcyAmJiBwcm9ncmVzc0V2ZW50RGVjb3JhdG9yKFxuICAgICAgICAgIHJlc3BvbnNlQ29udGVudExlbmd0aCxcbiAgICAgICAgICBwcm9ncmVzc0V2ZW50UmVkdWNlcihhc3luY0RlY29yYXRvcihvbkRvd25sb2FkUHJvZ3Jlc3MpLCB0cnVlKVxuICAgICAgICApIHx8IFtdO1xuXG4gICAgICAgIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKFxuICAgICAgICAgIHRyYWNrU3RyZWFtKHJlc3BvbnNlLmJvZHksIERFRkFVTFRfQ0hVTktfU0laRSwgb25Qcm9ncmVzcywgKCkgPT4ge1xuICAgICAgICAgICAgZmx1c2ggJiYgZmx1c2goKTtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlICYmIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGUgfHwgJ3RleHQnO1xuXG4gICAgICBsZXQgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzb2x2ZXJzW3V0aWxzLmZpbmRLZXkocmVzb2x2ZXJzLCByZXNwb25zZVR5cGUpIHx8ICd0ZXh0J10ocmVzcG9uc2UsIGNvbmZpZyk7XG5cbiAgICAgICFpc1N0cmVhbVJlc3BvbnNlICYmIHVuc3Vic2NyaWJlICYmIHVuc3Vic2NyaWJlKCk7XG5cbiAgICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHtcbiAgICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgICAgaGVhZGVyczogQXhpb3NIZWFkZXJzLmZyb20ocmVzcG9uc2UuaGVhZGVycyksXG4gICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgcmVxdWVzdFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHVuc3Vic2NyaWJlICYmIHVuc3Vic2NyaWJlKCk7XG5cbiAgICAgIGlmIChlcnIgJiYgZXJyLm5hbWUgPT09ICdUeXBlRXJyb3InICYmIC9Mb2FkIGZhaWxlZHxmZXRjaC9pLnRlc3QoZXJyLm1lc3NhZ2UpKSB7XG4gICAgICAgIHRocm93IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgbmV3IEF4aW9zRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBBeGlvc0Vycm9yLkVSUl9ORVRXT1JLLCBjb25maWcsIHJlcXVlc3QpLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNhdXNlOiBlcnIuY2F1c2UgfHwgZXJyXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHRocm93IEF4aW9zRXJyb3IuZnJvbShlcnIsIGVyciAmJiBlcnIuY29kZSwgY29uZmlnLCByZXF1ZXN0KTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgc2VlZENhY2hlID0gbmV3IE1hcCgpO1xuXG5leHBvcnQgY29uc3QgZ2V0RmV0Y2ggPSAoY29uZmlnKSA9PiB7XG4gIGxldCBlbnYgPSAoY29uZmlnICYmIGNvbmZpZy5lbnYpIHx8IHt9O1xuICBjb25zdCB7ZmV0Y2gsIFJlcXVlc3QsIFJlc3BvbnNlfSA9IGVudjtcbiAgY29uc3Qgc2VlZHMgPSBbXG4gICAgUmVxdWVzdCwgUmVzcG9uc2UsIGZldGNoXG4gIF07XG5cbiAgbGV0IGxlbiA9IHNlZWRzLmxlbmd0aCwgaSA9IGxlbixcbiAgICBzZWVkLCB0YXJnZXQsIG1hcCA9IHNlZWRDYWNoZTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgc2VlZCA9IHNlZWRzW2ldO1xuICAgIHRhcmdldCA9IG1hcC5nZXQoc2VlZCk7XG5cbiAgICB0YXJnZXQgPT09IHVuZGVmaW5lZCAmJiBtYXAuc2V0KHNlZWQsIHRhcmdldCA9IChpID8gbmV3IE1hcCgpIDogZmFjdG9yeShlbnYpKSlcblxuICAgIG1hcCA9IHRhcmdldDtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5jb25zdCBhZGFwdGVyID0gZ2V0RmV0Y2goKTtcblxuZXhwb3J0IGRlZmF1bHQgYWRhcHRlcjtcbiIsImltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBzZXR0bGUgZnJvbSAnLi8uLi9jb3JlL3NldHRsZS5qcyc7XG5pbXBvcnQgdHJhbnNpdGlvbmFsRGVmYXVsdHMgZnJvbSAnLi4vZGVmYXVsdHMvdHJhbnNpdGlvbmFsLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgcGFyc2VQcm90b2NvbCBmcm9tICcuLi9oZWxwZXJzL3BhcnNlUHJvdG9jb2wuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi4vY29yZS9BeGlvc0hlYWRlcnMuanMnO1xuaW1wb3J0IHtwcm9ncmVzc0V2ZW50UmVkdWNlcn0gZnJvbSAnLi4vaGVscGVycy9wcm9ncmVzc0V2ZW50UmVkdWNlci5qcyc7XG5pbXBvcnQgcmVzb2x2ZUNvbmZpZyBmcm9tIFwiLi4vaGVscGVycy9yZXNvbHZlQ29uZmlnLmpzXCI7XG5cbmNvbnN0IGlzWEhSQWRhcHRlclN1cHBvcnRlZCA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmV4cG9ydCBkZWZhdWx0IGlzWEhSQWRhcHRlclN1cHBvcnRlZCAmJiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgY29uc3QgX2NvbmZpZyA9IHJlc29sdmVDb25maWcoY29uZmlnKTtcbiAgICBsZXQgcmVxdWVzdERhdGEgPSBfY29uZmlnLmRhdGE7XG4gICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShfY29uZmlnLmhlYWRlcnMpLm5vcm1hbGl6ZSgpO1xuICAgIGxldCB7cmVzcG9uc2VUeXBlLCBvblVwbG9hZFByb2dyZXNzLCBvbkRvd25sb2FkUHJvZ3Jlc3N9ID0gX2NvbmZpZztcbiAgICBsZXQgb25DYW5jZWxlZDtcbiAgICBsZXQgdXBsb2FkVGhyb3R0bGVkLCBkb3dubG9hZFRocm90dGxlZDtcbiAgICBsZXQgZmx1c2hVcGxvYWQsIGZsdXNoRG93bmxvYWQ7XG5cbiAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgZmx1c2hVcGxvYWQgJiYgZmx1c2hVcGxvYWQoKTsgLy8gZmx1c2ggZXZlbnRzXG4gICAgICBmbHVzaERvd25sb2FkICYmIGZsdXNoRG93bmxvYWQoKTsgLy8gZmx1c2ggZXZlbnRzXG5cbiAgICAgIF9jb25maWcuY2FuY2VsVG9rZW4gJiYgX2NvbmZpZy5jYW5jZWxUb2tlbi51bnN1YnNjcmliZShvbkNhbmNlbGVkKTtcblxuICAgICAgX2NvbmZpZy5zaWduYWwgJiYgX2NvbmZpZy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICB9XG5cbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgcmVxdWVzdC5vcGVuKF9jb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIF9jb25maWcudXJsLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gX2NvbmZpZy50aW1lb3V0O1xuXG4gICAgZnVuY3Rpb24gb25sb2FkZW5kKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShcbiAgICAgICAgJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCAmJiByZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICApO1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gIXJlc3BvbnNlVHlwZSB8fCByZXNwb25zZVR5cGUgPT09ICd0ZXh0JyB8fCByZXNwb25zZVR5cGUgPT09ICdqc29uJyA/XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShmdW5jdGlvbiBfcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgZnVuY3Rpb24gX3JlamVjdChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCdvbmxvYWRlbmQnIGluIHJlcXVlc3QpIHtcbiAgICAgIC8vIFVzZSBvbmxvYWRlbmQgaWYgYXZhaWxhYmxlXG4gICAgICByZXF1ZXN0Lm9ubG9hZGVuZCA9IG9ubG9hZGVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZSB0byBlbXVsYXRlIG9ubG9hZGVuZFxuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWR5c3RhdGUgaGFuZGxlciBpcyBjYWxsaW5nIGJlZm9yZSBvbmVycm9yIG9yIG9udGltZW91dCBoYW5kbGVycyxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGNhbGwgb25sb2FkZW5kIG9uIHRoZSBuZXh0ICd0aWNrJ1xuICAgICAgICBzZXRUaW1lb3V0KG9ubG9hZGVuZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsIGNvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcihldmVudCkge1xuICAgICAgIC8vIEJyb3dzZXJzIGRlbGl2ZXIgYSBQcm9ncmVzc0V2ZW50IGluIFhIUiBvbmVycm9yXG4gICAgICAgLy8gKG1lc3NhZ2UgbWF5IGJlIGVtcHR5OyB3aGVuIHByZXNlbnQsIHN1cmZhY2UgaXQpXG4gICAgICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9lcnJvcl9ldmVudFxuICAgICAgIGNvbnN0IG1zZyA9IGV2ZW50ICYmIGV2ZW50Lm1lc3NhZ2UgPyBldmVudC5tZXNzYWdlIDogJ05ldHdvcmsgRXJyb3InO1xuICAgICAgIGNvbnN0IGVyciA9IG5ldyBBeGlvc0Vycm9yKG1zZywgQXhpb3NFcnJvci5FUlJfTkVUV09SSywgY29uZmlnLCByZXF1ZXN0KTtcbiAgICAgICAvLyBhdHRhY2ggdGhlIHVuZGVybHlpbmcgZXZlbnQgZm9yIGNvbnN1bWVycyB3aG8gd2FudCBkZXRhaWxzXG4gICAgICAgZXJyLmV2ZW50ID0gZXZlbnQgfHwgbnVsbDtcbiAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuICAgIFxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgbGV0IHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBfY29uZmlnLnRpbWVvdXQgPyAndGltZW91dCBvZiAnICsgX2NvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJyA6ICd0aW1lb3V0IGV4Y2VlZGVkJztcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25hbCA9IF9jb25maWcudHJhbnNpdGlvbmFsIHx8IHRyYW5zaXRpb25hbERlZmF1bHRzO1xuICAgICAgaWYgKF9jb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gX2NvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlLFxuICAgICAgICB0cmFuc2l0aW9uYWwuY2xhcmlmeVRpbWVvdXRFcnJvciA/IEF4aW9zRXJyb3IuRVRJTUVET1VUIDogQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgIHJlcXVlc3REYXRhID09PSB1bmRlZmluZWQgJiYgcmVxdWVzdEhlYWRlcnMuc2V0Q29udGVudFR5cGUobnVsbCk7XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycy50b0pTT04oKSwgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoX2NvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhX2NvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChyZXNwb25zZVR5cGUgJiYgcmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gX2NvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmIChvbkRvd25sb2FkUHJvZ3Jlc3MpIHtcbiAgICAgIChbZG93bmxvYWRUaHJvdHRsZWQsIGZsdXNoRG93bmxvYWRdID0gcHJvZ3Jlc3NFdmVudFJlZHVjZXIob25Eb3dubG9hZFByb2dyZXNzLCB0cnVlKSk7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZG93bmxvYWRUaHJvdHRsZWQpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKG9uVXBsb2FkUHJvZ3Jlc3MgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIChbdXBsb2FkVGhyb3R0bGVkLCBmbHVzaFVwbG9hZF0gPSBwcm9ncmVzc0V2ZW50UmVkdWNlcihvblVwbG9hZFByb2dyZXNzKSk7XG5cbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdXBsb2FkVGhyb3R0bGVkKTtcblxuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIGZsdXNoVXBsb2FkKTtcbiAgICB9XG5cbiAgICBpZiAoX2NvbmZpZy5jYW5jZWxUb2tlbiB8fCBfY29uZmlnLnNpZ25hbCkge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICAgIG9uQ2FuY2VsZWQgPSBjYW5jZWwgPT4ge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVqZWN0KCFjYW5jZWwgfHwgY2FuY2VsLnR5cGUgPyBuZXcgQ2FuY2VsZWRFcnJvcihudWxsLCBjb25maWcsIHJlcXVlc3QpIDogY2FuY2VsKTtcbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIF9jb25maWcuY2FuY2VsVG9rZW4gJiYgX2NvbmZpZy5jYW5jZWxUb2tlbi5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICBpZiAoX2NvbmZpZy5zaWduYWwpIHtcbiAgICAgICAgX2NvbmZpZy5zaWduYWwuYWJvcnRlZCA/IG9uQ2FuY2VsZWQoKSA6IF9jb25maWcuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdG9jb2wgPSBwYXJzZVByb3RvY29sKF9jb25maWcudXJsKTtcblxuICAgIGlmIChwcm90b2NvbCAmJiBwbGF0Zm9ybS5wcm90b2NvbHMuaW5kZXhPZihwcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1Vuc3VwcG9ydGVkIHByb3RvY29sICcgKyBwcm90b2NvbCArICc6JywgQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIGNvbmZpZykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSB8fCBudWxsKTtcbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCBiaW5kIGZyb20gJy4vaGVscGVycy9iaW5kLmpzJztcbmltcG9ydCBBeGlvcyBmcm9tICcuL2NvcmUvQXhpb3MuanMnO1xuaW1wb3J0IG1lcmdlQ29uZmlnIGZyb20gJy4vY29yZS9tZXJnZUNvbmZpZy5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9kZWZhdWx0cy9pbmRleC5qcyc7XG5pbXBvcnQgZm9ybURhdGFUb0pTT04gZnJvbSAnLi9oZWxwZXJzL2Zvcm1EYXRhVG9KU09OLmpzJztcbmltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gJy4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IENhbmNlbFRva2VuIGZyb20gJy4vY2FuY2VsL0NhbmNlbFRva2VuLmpzJztcbmltcG9ydCBpc0NhbmNlbCBmcm9tICcuL2NhbmNlbC9pc0NhbmNlbC5qcyc7XG5pbXBvcnQge1ZFUlNJT059IGZyb20gJy4vZW52L2RhdGEuanMnO1xuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi9oZWxwZXJzL3RvRm9ybURhdGEuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IHNwcmVhZCBmcm9tICcuL2hlbHBlcnMvc3ByZWFkLmpzJztcbmltcG9ydCBpc0F4aW9zRXJyb3IgZnJvbSAnLi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gXCIuL2NvcmUvQXhpb3NIZWFkZXJzLmpzXCI7XG5pbXBvcnQgYWRhcHRlcnMgZnJvbSAnLi9hZGFwdGVycy9hZGFwdGVycy5qcyc7XG5pbXBvcnQgSHR0cFN0YXR1c0NvZGUgZnJvbSAnLi9oZWxwZXJzL0h0dHBTdGF0dXNDb2RlLmpzJztcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm5zIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICBjb25zdCBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICBjb25zdCBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0LCB7YWxsT3duS2V5czogdHJ1ZX0pO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQsIG51bGwsIHthbGxPd25LZXlzOiB0cnVlfSk7XG5cbiAgLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuICBpbnN0YW5jZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoZGVmYXVsdENvbmZpZywgaW5zdGFuY2VDb25maWcpKTtcbiAgfTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxuY29uc3QgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWxlZEVycm9yID0gQ2FuY2VsZWRFcnJvcjtcbmF4aW9zLkNhbmNlbFRva2VuID0gQ2FuY2VsVG9rZW47XG5heGlvcy5pc0NhbmNlbCA9IGlzQ2FuY2VsO1xuYXhpb3MuVkVSU0lPTiA9IFZFUlNJT047XG5heGlvcy50b0Zvcm1EYXRhID0gdG9Gb3JtRGF0YTtcblxuLy8gRXhwb3NlIEF4aW9zRXJyb3IgY2xhc3NcbmF4aW9zLkF4aW9zRXJyb3IgPSBBeGlvc0Vycm9yO1xuXG4vLyBhbGlhcyBmb3IgQ2FuY2VsZWRFcnJvciBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuYXhpb3MuQ2FuY2VsID0gYXhpb3MuQ2FuY2VsZWRFcnJvcjtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcblxuYXhpb3Muc3ByZWFkID0gc3ByZWFkO1xuXG4vLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG5heGlvcy5pc0F4aW9zRXJyb3IgPSBpc0F4aW9zRXJyb3I7XG5cbi8vIEV4cG9zZSBtZXJnZUNvbmZpZ1xuYXhpb3MubWVyZ2VDb25maWcgPSBtZXJnZUNvbmZpZztcblxuYXhpb3MuQXhpb3NIZWFkZXJzID0gQXhpb3NIZWFkZXJzO1xuXG5heGlvcy5mb3JtVG9KU09OID0gdGhpbmcgPT4gZm9ybURhdGFUb0pTT04odXRpbHMuaXNIVE1MRm9ybSh0aGluZykgPyBuZXcgRm9ybURhdGEodGhpbmcpIDogdGhpbmcpO1xuXG5heGlvcy5nZXRBZGFwdGVyID0gYWRhcHRlcnMuZ2V0QWRhcHRlcjtcblxuYXhpb3MuSHR0cFN0YXR1c0NvZGUgPSBIdHRwU3RhdHVzQ29kZTtcblxuYXhpb3MuZGVmYXVsdCA9IGF4aW9zO1xuXG4vLyB0aGlzIG1vZHVsZSBzaG91bGQgb25seSBoYXZlIGEgZGVmYXVsdCBleHBvcnRcbmV4cG9ydCBkZWZhdWx0IGF4aW9zXG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gJy4vQ2FuY2VsZWRFcnJvci5qcyc7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKlxuICogQHJldHVybnMge0NhbmNlbFRva2VufVxuICovXG5jbGFzcyBDYW5jZWxUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKGV4ZWN1dG9yKSB7XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGxldCByZXNvbHZlUHJvbWlzZTtcblxuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0b2tlbiA9IHRoaXM7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIHRoaXMucHJvbWlzZS50aGVuKGNhbmNlbCA9PiB7XG4gICAgICBpZiAoIXRva2VuLl9saXN0ZW5lcnMpIHJldHVybjtcblxuICAgICAgbGV0IGkgPSB0b2tlbi5fbGlzdGVuZXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgdG9rZW4uX2xpc3RlbmVyc1tpXShjYW5jZWwpO1xuICAgICAgfVxuICAgICAgdG9rZW4uX2xpc3RlbmVycyA9IG51bGw7XG4gICAgfSk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIHRoaXMucHJvbWlzZS50aGVuID0gb25mdWxmaWxsZWQgPT4ge1xuICAgICAgbGV0IF9yZXNvbHZlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdG9rZW4uc3Vic2NyaWJlKHJlc29sdmUpO1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KS50aGVuKG9uZnVsZmlsbGVkKTtcblxuICAgICAgcHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbiByZWplY3QoKSB7XG4gICAgICAgIHRva2VuLnVuc3Vic2NyaWJlKF9yZXNvbHZlKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSwgY29uZmlnLCByZXF1ZXN0KSB7XG4gICAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWxlZEVycm9yKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCk7XG4gICAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRocm93cyBhIGBDYW5jZWxlZEVycm9yYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICAgKi9cbiAgdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIHRocm93IHRoaXMucmVhc29uO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gdGhlIGNhbmNlbCBzaWduYWxcbiAgICovXG5cbiAgc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICBsaXN0ZW5lcih0aGlzLnJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycykge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbbGlzdGVuZXJdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBmcm9tIHRoZSBjYW5jZWwgc2lnbmFsXG4gICAqL1xuXG4gIHVuc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbiAgdG9BYm9ydFNpZ25hbCgpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXG4gICAgY29uc3QgYWJvcnQgPSAoZXJyKSA9PiB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KGVycik7XG4gICAgfTtcblxuICAgIHRoaXMuc3Vic2NyaWJlKGFib3J0KTtcblxuICAgIGNvbnRyb2xsZXIuc2lnbmFsLnVuc3Vic2NyaWJlID0gKCkgPT4gdGhpcy51bnN1YnNjcmliZShhYm9ydCk7XG5cbiAgICByZXR1cm4gY29udHJvbGxlci5zaWduYWw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICAgKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICAgKi9cbiAgc3RhdGljIHNvdXJjZSgpIHtcbiAgICBsZXQgY2FuY2VsO1xuICAgIGNvbnN0IHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICAgIGNhbmNlbCA9IGM7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuLFxuICAgICAgY2FuY2VsXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW5jZWxUb2tlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8qKlxuICogQSBgQ2FuY2VsZWRFcnJvcmAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdD19IHJlcXVlc3QgVGhlIHJlcXVlc3QuXG4gKlxuICogQHJldHVybnMge0NhbmNlbGVkRXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5mdW5jdGlvbiBDYW5jZWxlZEVycm9yKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgQXhpb3NFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UgPT0gbnVsbCA/ICdjYW5jZWxlZCcgOiBtZXNzYWdlLCBBeGlvc0Vycm9yLkVSUl9DQU5DRUxFRCwgY29uZmlnLCByZXF1ZXN0KTtcbiAgdGhpcy5uYW1lID0gJ0NhbmNlbGVkRXJyb3InO1xufVxuXG51dGlscy5pbmhlcml0cyhDYW5jZWxlZEVycm9yLCBBeGlvc0Vycm9yLCB7XG4gIF9fQ0FOQ0VMX186IHRydWVcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBDYW5jZWxlZEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBidWlsZFVSTCBmcm9tICcuLi9oZWxwZXJzL2J1aWxkVVJMLmpzJztcbmltcG9ydCBJbnRlcmNlcHRvck1hbmFnZXIgZnJvbSAnLi9JbnRlcmNlcHRvck1hbmFnZXIuanMnO1xuaW1wb3J0IGRpc3BhdGNoUmVxdWVzdCBmcm9tICcuL2Rpc3BhdGNoUmVxdWVzdC5qcyc7XG5pbXBvcnQgbWVyZ2VDb25maWcgZnJvbSAnLi9tZXJnZUNvbmZpZy5qcyc7XG5pbXBvcnQgYnVpbGRGdWxsUGF0aCBmcm9tICcuL2J1aWxkRnVsbFBhdGguanMnO1xuaW1wb3J0IHZhbGlkYXRvciBmcm9tICcuLi9oZWxwZXJzL3ZhbGlkYXRvci5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4vQXhpb3NIZWFkZXJzLmpzJztcblxuY29uc3QgdmFsaWRhdG9ycyA9IHZhbGlkYXRvci52YWxpZGF0b3JzO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5jbGFzcyBBeGlvcyB7XG4gIGNvbnN0cnVjdG9yKGluc3RhbmNlQ29uZmlnKSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnIHx8IHt9O1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gY29uZmlnT3JVcmwgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICAgKiBAcGFyYW0gez9PYmplY3R9IGNvbmZpZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gICAqL1xuICBhc3luYyByZXF1ZXN0KGNvbmZpZ09yVXJsLCBjb25maWcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgbGV0IGR1bW15ID0ge307XG5cbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPyBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShkdW1teSkgOiAoZHVtbXkgPSBuZXcgRXJyb3IoKSk7XG5cbiAgICAgICAgLy8gc2xpY2Ugb2ZmIHRoZSBFcnJvcjogLi4uIGxpbmVcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBkdW1teS5zdGFjayA/IGR1bW15LnN0YWNrLnJlcGxhY2UoL14uK1xcbi8sICcnKSA6ICcnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghZXJyLnN0YWNrKSB7XG4gICAgICAgICAgICBlcnIuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgICAgIC8vIG1hdGNoIHdpdGhvdXQgdGhlIDIgdG9wIHN0YWNrIGxpbmVzXG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFjayAmJiAhU3RyaW5nKGVyci5zdGFjaykuZW5kc1dpdGgoc3RhY2sucmVwbGFjZSgvXi4rXFxuLitcXG4vLCAnJykpKSB7XG4gICAgICAgICAgICBlcnIuc3RhY2sgKz0gJ1xcbicgKyBzdGFja1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlnbm9yZSB0aGUgY2FzZSB3aGVyZSBcInN0YWNrXCIgaXMgYW4gdW4td3JpdGFibGUgcHJvcGVydHlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgX3JlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgICBpZiAodHlwZW9mIGNvbmZpZ09yVXJsID09PSAnc3RyaW5nJykge1xuICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgY29uZmlnLnVybCA9IGNvbmZpZ09yVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcgPSBjb25maWdPclVybCB8fCB7fTtcbiAgICB9XG5cbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gICAgY29uc3Qge3RyYW5zaXRpb25hbCwgcGFyYW1zU2VyaWFsaXplciwgaGVhZGVyc30gPSBjb25maWc7XG5cbiAgICBpZiAodHJhbnNpdGlvbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgICAgZm9yY2VkSlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbilcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zU2VyaWFsaXplciAhPSBudWxsKSB7XG4gICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihwYXJhbXNTZXJpYWxpemVyKSkge1xuICAgICAgICBjb25maWcucGFyYW1zU2VyaWFsaXplciA9IHtcbiAgICAgICAgICBzZXJpYWxpemU6IHBhcmFtc1NlcmlhbGl6ZXJcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnMocGFyYW1zU2VyaWFsaXplciwge1xuICAgICAgICAgIGVuY29kZTogdmFsaWRhdG9ycy5mdW5jdGlvbixcbiAgICAgICAgICBzZXJpYWxpemU6IHZhbGlkYXRvcnMuZnVuY3Rpb25cbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IGNvbmZpZy5hbGxvd0Fic29sdXRlVXJsc1xuICAgIGlmIChjb25maWcuYWxsb3dBYnNvbHV0ZVVybHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH0gZWxzZSBpZiAodGhpcy5kZWZhdWx0cy5hbGxvd0Fic29sdXRlVXJscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25maWcuYWxsb3dBYnNvbHV0ZVVybHMgPSB0aGlzLmRlZmF1bHRzLmFsbG93QWJzb2x1dGVVcmxzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcuYWxsb3dBYnNvbHV0ZVVybHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKGNvbmZpZywge1xuICAgICAgYmFzZVVybDogdmFsaWRhdG9ycy5zcGVsbGluZygnYmFzZVVSTCcpLFxuICAgICAgd2l0aFhzcmZUb2tlbjogdmFsaWRhdG9ycy5zcGVsbGluZygnd2l0aFhTUkZUb2tlbicpXG4gICAgfSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICAgIGNvbmZpZy5tZXRob2QgPSAoY29uZmlnLm1ldGhvZCB8fCB0aGlzLmRlZmF1bHRzLm1ldGhvZCB8fCAnZ2V0JykudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICAgIGxldCBjb250ZXh0SGVhZGVycyA9IGhlYWRlcnMgJiYgdXRpbHMubWVyZ2UoXG4gICAgICBoZWFkZXJzLmNvbW1vbixcbiAgICAgIGhlYWRlcnNbY29uZmlnLm1ldGhvZF1cbiAgICApO1xuXG4gICAgaGVhZGVycyAmJiB1dGlscy5mb3JFYWNoKFxuICAgICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgICAobWV0aG9kKSA9PiB7XG4gICAgICAgIGRlbGV0ZSBoZWFkZXJzW21ldGhvZF07XG4gICAgICB9XG4gICAgKTtcblxuICAgIGNvbmZpZy5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmNvbmNhdChjb250ZXh0SGVhZGVycywgaGVhZGVycyk7XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHNraXBwZWQgaW50ZXJjZXB0b3JzXG4gICAgY29uc3QgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgICBsZXQgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gdHJ1ZTtcbiAgICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICAgIGlmICh0eXBlb2YgaW50ZXJjZXB0b3IucnVuV2hlbiA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnRlcmNlcHRvci5ydW5XaGVuKGNvbmZpZykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzICYmIGludGVyY2VwdG9yLnN5bmNocm9ub3VzO1xuXG4gICAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICAgIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICAgIH0pO1xuXG4gICAgbGV0IHByb21pc2U7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBsZW47XG5cbiAgICBpZiAoIXN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycykge1xuICAgICAgY29uc3QgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LmJpbmQodGhpcyksIHVuZGVmaW5lZF07XG4gICAgICBjaGFpbi51bnNoaWZ0KC4uLnJlcXVlc3RJbnRlcmNlcHRvckNoYWluKTtcbiAgICAgIGNoYWluLnB1c2goLi4ucmVzcG9uc2VJbnRlcmNlcHRvckNoYWluKTtcbiAgICAgIGxlbiA9IGNoYWluLmxlbmd0aDtcblxuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluW2krK10sIGNoYWluW2krK10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG5cbiAgICBsZW4gPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5sZW5ndGg7XG5cbiAgICBsZXQgbmV3Q29uZmlnID0gY29uZmlnO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGNvbnN0IG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW5baSsrXTtcbiAgICAgIGNvbnN0IG9uUmVqZWN0ZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbltpKytdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3Q29uZmlnID0gb25GdWxmaWxsZWQobmV3Q29uZmlnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIG9uUmVqZWN0ZWQuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0LmNhbGwodGhpcywgbmV3Q29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpID0gMDtcbiAgICBsZW4gPSByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4ocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluW2krK10sIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbltpKytdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGdldFVyaShjb25maWcpIHtcbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCwgY29uZmlnLmFsbG93QWJzb2x1dGVVcmxzKTtcbiAgICByZXR1cm4gYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKTtcbiAgfVxufVxuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUhUVFBNZXRob2QoaXNGb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBNZXRob2QodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogaXNGb3JtID8ge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgICAgICAgfSA6IHt9LFxuICAgICAgICB1cmwsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pKTtcbiAgICB9O1xuICB9XG5cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBnZW5lcmF0ZUhUVFBNZXRob2QoKTtcblxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kICsgJ0Zvcm0nXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCh0cnVlKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIEF4aW9zRXJyb3IobWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBFcnJvci5jYWxsKHRoaXMpO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuICB9XG5cbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5uYW1lID0gJ0F4aW9zRXJyb3InO1xuICBjb2RlICYmICh0aGlzLmNvZGUgPSBjb2RlKTtcbiAgY29uZmlnICYmICh0aGlzLmNvbmZpZyA9IGNvbmZpZyk7XG4gIHJlcXVlc3QgJiYgKHRoaXMucmVxdWVzdCA9IHJlcXVlc3QpO1xuICBpZiAocmVzcG9uc2UpIHtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgdGhpcy5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXMgPyByZXNwb25zZS5zdGF0dXMgOiBudWxsO1xuICB9XG59XG5cbnV0aWxzLmluaGVyaXRzKEF4aW9zRXJyb3IsIEVycm9yLCB7XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHV0aWxzLnRvSlNPTk9iamVjdCh0aGlzLmNvbmZpZyksXG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzXG4gICAgfTtcbiAgfVxufSk7XG5cbmNvbnN0IHByb3RvdHlwZSA9IEF4aW9zRXJyb3IucHJvdG90eXBlO1xuY29uc3QgZGVzY3JpcHRvcnMgPSB7fTtcblxuW1xuICAnRVJSX0JBRF9PUFRJT05fVkFMVUUnLFxuICAnRVJSX0JBRF9PUFRJT04nLFxuICAnRUNPTk5BQk9SVEVEJyxcbiAgJ0VUSU1FRE9VVCcsXG4gICdFUlJfTkVUV09SSycsXG4gICdFUlJfRlJfVE9PX01BTllfUkVESVJFQ1RTJyxcbiAgJ0VSUl9ERVBSRUNBVEVEJyxcbiAgJ0VSUl9CQURfUkVTUE9OU0UnLFxuICAnRVJSX0JBRF9SRVFVRVNUJyxcbiAgJ0VSUl9DQU5DRUxFRCcsXG4gICdFUlJfTk9UX1NVUFBPUlQnLFxuICAnRVJSX0lOVkFMSURfVVJMJ1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbl0uZm9yRWFjaChjb2RlID0+IHtcbiAgZGVzY3JpcHRvcnNbY29kZV0gPSB7dmFsdWU6IGNvZGV9O1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEF4aW9zRXJyb3IsIGRlc2NyaXB0b3JzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsICdpc0F4aW9zRXJyb3InLCB7dmFsdWU6IHRydWV9KTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbkF4aW9zRXJyb3IuZnJvbSA9IChlcnJvciwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSwgY3VzdG9tUHJvcHMpID0+IHtcbiAgY29uc3QgYXhpb3NFcnJvciA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlKTtcblxuICB1dGlscy50b0ZsYXRPYmplY3QoZXJyb3IsIGF4aW9zRXJyb3IsIGZ1bmN0aW9uIGZpbHRlcihvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBFcnJvci5wcm90b3R5cGU7XG4gIH0sIHByb3AgPT4ge1xuICAgIHJldHVybiBwcm9wICE9PSAnaXNBeGlvc0Vycm9yJztcbiAgfSk7XG5cbiAgY29uc3QgbXNnID0gZXJyb3IgJiYgZXJyb3IubWVzc2FnZSA/IGVycm9yLm1lc3NhZ2UgOiAnRXJyb3InO1xuXG4gIC8vIFByZWZlciBleHBsaWNpdCBjb2RlOyBvdGhlcndpc2UgY29weSB0aGUgbG93LWxldmVsIGVycm9yJ3MgY29kZSAoZS5nLiBFQ09OTlJFRlVTRUQpXG4gIGNvbnN0IGVyckNvZGUgPSBjb2RlID09IG51bGwgJiYgZXJyb3IgPyBlcnJvci5jb2RlIDogY29kZTtcbiAgQXhpb3NFcnJvci5jYWxsKGF4aW9zRXJyb3IsIG1zZywgZXJyQ29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSk7XG5cbiAgLy8gQ2hhaW4gdGhlIG9yaWdpbmFsIGVycm9yIG9uIHRoZSBzdGFuZGFyZCBmaWVsZDsgbm9uLWVudW1lcmFibGUgdG8gYXZvaWQgSlNPTiBub2lzZVxuICBpZiAoZXJyb3IgJiYgYXhpb3NFcnJvci5jYXVzZSA9PSBudWxsKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGF4aW9zRXJyb3IsICdjYXVzZScsIHsgdmFsdWU6IGVycm9yLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIH1cblxuICBheGlvc0Vycm9yLm5hbWUgPSAoZXJyb3IgJiYgZXJyb3IubmFtZSkgfHwgJ0Vycm9yJztcblxuICBjdXN0b21Qcm9wcyAmJiBPYmplY3QuYXNzaWduKGF4aW9zRXJyb3IsIGN1c3RvbVByb3BzKTtcblxuICByZXR1cm4gYXhpb3NFcnJvcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgcGFyc2VIZWFkZXJzIGZyb20gJy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzJztcblxuY29uc3QgJGludGVybmFscyA9IFN5bWJvbCgnaW50ZXJuYWxzJyk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpIHtcbiAgcmV0dXJuIGhlYWRlciAmJiBTdHJpbmcoaGVhZGVyKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHV0aWxzLmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKG5vcm1hbGl6ZVZhbHVlKSA6IFN0cmluZyh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9rZW5zKHN0cikge1xuICBjb25zdCB0b2tlbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCB0b2tlbnNSRSA9IC8oW15cXHMsOz1dKylcXHMqKD86PVxccyooW14sO10rKSk/L2c7XG4gIGxldCBtYXRjaDtcblxuICB3aGlsZSAoKG1hdGNoID0gdG9rZW5zUkUuZXhlYyhzdHIpKSkge1xuICAgIHRva2Vuc1ttYXRjaFsxXV0gPSBtYXRjaFsyXTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmNvbnN0IGlzVmFsaWRIZWFkZXJOYW1lID0gKHN0cikgPT4gL15bLV9hLXpBLVowLTleYHx+LCEjJCUmJyorLl0rJC8udGVzdChzdHIudHJpbSgpKTtcblxuZnVuY3Rpb24gbWF0Y2hIZWFkZXJWYWx1ZShjb250ZXh0LCB2YWx1ZSwgaGVhZGVyLCBmaWx0ZXIsIGlzSGVhZGVyTmFtZUZpbHRlcikge1xuICBpZiAodXRpbHMuaXNGdW5jdGlvbihmaWx0ZXIpKSB7XG4gICAgcmV0dXJuIGZpbHRlci5jYWxsKHRoaXMsIHZhbHVlLCBoZWFkZXIpO1xuICB9XG5cbiAgaWYgKGlzSGVhZGVyTmFtZUZpbHRlcikge1xuICAgIHZhbHVlID0gaGVhZGVyO1xuICB9XG5cbiAgaWYgKCF1dGlscy5pc1N0cmluZyh2YWx1ZSkpIHJldHVybjtcblxuICBpZiAodXRpbHMuaXNTdHJpbmcoZmlsdGVyKSkge1xuICAgIHJldHVybiB2YWx1ZS5pbmRleE9mKGZpbHRlcikgIT09IC0xO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzUmVnRXhwKGZpbHRlcikpIHtcbiAgICByZXR1cm4gZmlsdGVyLnRlc3QodmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhlYWRlcihoZWFkZXIpIHtcbiAgcmV0dXJuIGhlYWRlci50cmltKClcbiAgICAudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8oW2EtelxcZF0pKFxcdyopL2csICh3LCBjaGFyLCBzdHIpID0+IHtcbiAgICAgIHJldHVybiBjaGFyLnRvVXBwZXJDYXNlKCkgKyBzdHI7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQWNjZXNzb3JzKG9iaiwgaGVhZGVyKSB7XG4gIGNvbnN0IGFjY2Vzc29yTmFtZSA9IHV0aWxzLnRvQ2FtZWxDYXNlKCcgJyArIGhlYWRlcik7XG5cbiAgWydnZXQnLCAnc2V0JywgJ2hhcyddLmZvckVhY2gobWV0aG9kTmFtZSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbWV0aG9kTmFtZSArIGFjY2Vzc29yTmFtZSwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kTmFtZV0uY2FsbCh0aGlzLCBoZWFkZXIsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcbn1cblxuY2xhc3MgQXhpb3NIZWFkZXJzIHtcbiAgY29uc3RydWN0b3IoaGVhZGVycykge1xuICAgIGhlYWRlcnMgJiYgdGhpcy5zZXQoaGVhZGVycyk7XG4gIH1cblxuICBzZXQoaGVhZGVyLCB2YWx1ZU9yUmV3cml0ZSwgcmV3cml0ZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gc2V0SGVhZGVyKF92YWx1ZSwgX2hlYWRlciwgX3Jld3JpdGUpIHtcbiAgICAgIGNvbnN0IGxIZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmICghbEhlYWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hlYWRlciBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkoc2VsZiwgbEhlYWRlcik7XG5cbiAgICAgIGlmKCFrZXkgfHwgc2VsZltrZXldID09PSB1bmRlZmluZWQgfHwgX3Jld3JpdGUgPT09IHRydWUgfHwgKF9yZXdyaXRlID09PSB1bmRlZmluZWQgJiYgc2VsZltrZXldICE9PSBmYWxzZSkpIHtcbiAgICAgICAgc2VsZltrZXkgfHwgX2hlYWRlcl0gPSBub3JtYWxpemVWYWx1ZShfdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNldEhlYWRlcnMgPSAoaGVhZGVycywgX3Jld3JpdGUpID0+XG4gICAgICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIChfdmFsdWUsIF9oZWFkZXIpID0+IHNldEhlYWRlcihfdmFsdWUsIF9oZWFkZXIsIF9yZXdyaXRlKSk7XG5cbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChoZWFkZXIpIHx8IGhlYWRlciBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpIHtcbiAgICAgIHNldEhlYWRlcnMoaGVhZGVyLCB2YWx1ZU9yUmV3cml0ZSlcbiAgICB9IGVsc2UgaWYodXRpbHMuaXNTdHJpbmcoaGVhZGVyKSAmJiAoaGVhZGVyID0gaGVhZGVyLnRyaW0oKSkgJiYgIWlzVmFsaWRIZWFkZXJOYW1lKGhlYWRlcikpIHtcbiAgICAgIHNldEhlYWRlcnMocGFyc2VIZWFkZXJzKGhlYWRlciksIHZhbHVlT3JSZXdyaXRlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KGhlYWRlcikgJiYgdXRpbHMuaXNJdGVyYWJsZShoZWFkZXIpKSB7XG4gICAgICBsZXQgb2JqID0ge30sIGRlc3QsIGtleTtcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgaGVhZGVyKSB7XG4gICAgICAgIGlmICghdXRpbHMuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ09iamVjdCBpdGVyYXRvciBtdXN0IHJldHVybiBhIGtleS12YWx1ZSBwYWlyJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmpba2V5ID0gZW50cnlbMF1dID0gKGRlc3QgPSBvYmpba2V5XSkgP1xuICAgICAgICAgICh1dGlscy5pc0FycmF5KGRlc3QpID8gWy4uLmRlc3QsIGVudHJ5WzFdXSA6IFtkZXN0LCBlbnRyeVsxXV0pIDogZW50cnlbMV07XG4gICAgICB9XG5cbiAgICAgIHNldEhlYWRlcnMob2JqLCB2YWx1ZU9yUmV3cml0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVyICE9IG51bGwgJiYgc2V0SGVhZGVyKHZhbHVlT3JSZXdyaXRlLCBoZWFkZXIsIHJld3JpdGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KGhlYWRlciwgcGFyc2VyKSB7XG4gICAgaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKGhlYWRlcik7XG5cbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHRoaXMsIGhlYWRlcik7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2tleV07XG5cbiAgICAgICAgaWYgKCFwYXJzZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VyID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5zKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHBhcnNlcikpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLmNhbGwodGhpcywgdmFsdWUsIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNSZWdFeHAocGFyc2VyKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuZXhlYyh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJzZXIgbXVzdCBiZSBib29sZWFufHJlZ2V4cHxmdW5jdGlvbicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhcyhoZWFkZXIsIG1hdGNoZXIpIHtcbiAgICBoZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoaGVhZGVyKTtcblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkodGhpcywgaGVhZGVyKTtcblxuICAgICAgcmV0dXJuICEhKGtleSAmJiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCAmJiAoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZSh0aGlzLCB0aGlzW2tleV0sIGtleSwgbWF0Y2hlcikpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBkZWxldGUoaGVhZGVyLCBtYXRjaGVyKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGRlbGV0ZUhlYWRlcihfaGVhZGVyKSB7XG4gICAgICBfaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoX2hlYWRlcikge1xuICAgICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHNlbGYsIF9oZWFkZXIpO1xuXG4gICAgICAgIGlmIChrZXkgJiYgKCFtYXRjaGVyIHx8IG1hdGNoSGVhZGVyVmFsdWUoc2VsZiwgc2VsZltrZXldLCBrZXksIG1hdGNoZXIpKSkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmW2tleV07XG5cbiAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5KGhlYWRlcikpIHtcbiAgICAgIGhlYWRlci5mb3JFYWNoKGRlbGV0ZUhlYWRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZUhlYWRlcihoZWFkZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWxldGVkO1xuICB9XG5cbiAgY2xlYXIobWF0Y2hlcikge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZSh0aGlzLCB0aGlzW2tleV0sIGtleSwgbWF0Y2hlciwgdHJ1ZSkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGV0ZWQ7XG4gIH1cblxuICBub3JtYWxpemUoZm9ybWF0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuXG4gICAgdXRpbHMuZm9yRWFjaCh0aGlzLCAodmFsdWUsIGhlYWRlcikgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleShoZWFkZXJzLCBoZWFkZXIpO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHNlbGZba2V5XSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgZGVsZXRlIHNlbGZbaGVhZGVyXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub3JtYWxpemVkID0gZm9ybWF0ID8gZm9ybWF0SGVhZGVyKGhlYWRlcikgOiBTdHJpbmcoaGVhZGVyKS50cmltKCk7XG5cbiAgICAgIGlmIChub3JtYWxpemVkICE9PSBoZWFkZXIpIHtcbiAgICAgICAgZGVsZXRlIHNlbGZbaGVhZGVyXTtcbiAgICAgIH1cblxuICAgICAgc2VsZltub3JtYWxpemVkXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcblxuICAgICAgaGVhZGVyc1tub3JtYWxpemVkXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbmNhdCguLi50YXJnZXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY29uY2F0KHRoaXMsIC4uLnRhcmdldHMpO1xuICB9XG5cbiAgdG9KU09OKGFzU3RyaW5ncykge1xuICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB1dGlscy5mb3JFYWNoKHRoaXMsICh2YWx1ZSwgaGVhZGVyKSA9PiB7XG4gICAgICB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSAmJiAob2JqW2hlYWRlcl0gPSBhc1N0cmluZ3MgJiYgdXRpbHMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCcsICcpIDogdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLnRvSlNPTigpKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy50b0pTT04oKSkubWFwKChbaGVhZGVyLCB2YWx1ZV0pID0+IGhlYWRlciArICc6ICcgKyB2YWx1ZSkuam9pbignXFxuJyk7XG4gIH1cblxuICBnZXRTZXRDb29raWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwic2V0LWNvb2tpZVwiKSB8fCBbXTtcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ0F4aW9zSGVhZGVycyc7XG4gIH1cblxuICBzdGF0aWMgZnJvbSh0aGluZykge1xuICAgIHJldHVybiB0aGluZyBpbnN0YW5jZW9mIHRoaXMgPyB0aGluZyA6IG5ldyB0aGlzKHRoaW5nKTtcbiAgfVxuXG4gIHN0YXRpYyBjb25jYXQoZmlyc3QsIC4uLnRhcmdldHMpIHtcbiAgICBjb25zdCBjb21wdXRlZCA9IG5ldyB0aGlzKGZpcnN0KTtcblxuICAgIHRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiBjb21wdXRlZC5zZXQodGFyZ2V0KSk7XG5cbiAgICByZXR1cm4gY29tcHV0ZWQ7XG4gIH1cblxuICBzdGF0aWMgYWNjZXNzb3IoaGVhZGVyKSB7XG4gICAgY29uc3QgaW50ZXJuYWxzID0gdGhpc1skaW50ZXJuYWxzXSA9ICh0aGlzWyRpbnRlcm5hbHNdID0ge1xuICAgICAgYWNjZXNzb3JzOiB7fVxuICAgIH0pO1xuXG4gICAgY29uc3QgYWNjZXNzb3JzID0gaW50ZXJuYWxzLmFjY2Vzc29ycztcbiAgICBjb25zdCBwcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIGRlZmluZUFjY2Vzc29yKF9oZWFkZXIpIHtcbiAgICAgIGNvbnN0IGxIZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmICghYWNjZXNzb3JzW2xIZWFkZXJdKSB7XG4gICAgICAgIGJ1aWxkQWNjZXNzb3JzKHByb3RvdHlwZSwgX2hlYWRlcik7XG4gICAgICAgIGFjY2Vzc29yc1tsSGVhZGVyXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXRpbHMuaXNBcnJheShoZWFkZXIpID8gaGVhZGVyLmZvckVhY2goZGVmaW5lQWNjZXNzb3IpIDogZGVmaW5lQWNjZXNzb3IoaGVhZGVyKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbkF4aW9zSGVhZGVycy5hY2Nlc3NvcihbJ0NvbnRlbnQtVHlwZScsICdDb250ZW50LUxlbmd0aCcsICdBY2NlcHQnLCAnQWNjZXB0LUVuY29kaW5nJywgJ1VzZXItQWdlbnQnLCAnQXV0aG9yaXphdGlvbiddKTtcblxuLy8gcmVzZXJ2ZWQgbmFtZXMgaG90Zml4XG51dGlscy5yZWR1Y2VEZXNjcmlwdG9ycyhBeGlvc0hlYWRlcnMucHJvdG90eXBlLCAoe3ZhbHVlfSwga2V5KSA9PiB7XG4gIGxldCBtYXBwZWQgPSBrZXlbMF0udG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKTsgLy8gbWFwIGBzZXRgID0+IGBTZXRgXG4gIHJldHVybiB7XG4gICAgZ2V0OiAoKSA9PiB2YWx1ZSxcbiAgICBzZXQoaGVhZGVyVmFsdWUpIHtcbiAgICAgIHRoaXNbbWFwcGVkXSA9IGhlYWRlclZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG5cbnV0aWxzLmZyZWV6ZU1ldGhvZHMoQXhpb3NIZWFkZXJzKTtcblxuZXhwb3J0IGRlZmF1bHQgQXhpb3NIZWFkZXJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbmNsYXNzIEludGVyY2VwdG9yTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICAgKi9cbiAgdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgICAgZnVsZmlsbGVkLFxuICAgICAgcmVqZWN0ZWQsXG4gICAgICBzeW5jaHJvbm91czogb3B0aW9ucyA/IG9wdGlvbnMuc3luY2hyb25vdXMgOiBmYWxzZSxcbiAgICAgIHJ1bldoZW46IG9wdGlvbnMgPyBvcHRpb25zLnJ1bldoZW4gOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGVqZWN0KGlkKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBpbnRlcmNlcHRvcnMgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjbGVhcigpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVycykge1xuICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICAgKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmb3JFYWNoKGZuKSB7XG4gICAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgICBmbihoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBpc0Fic29sdXRlVVJMIGZyb20gJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyc7XG5pbXBvcnQgY29tYmluZVVSTHMgZnJvbSAnLi4vaGVscGVycy9jb21iaW5lVVJMcy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZEZ1bGxQYXRoKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCwgYWxsb3dBYnNvbHV0ZVVybHMpIHtcbiAgbGV0IGlzUmVsYXRpdmVVcmwgPSAhaXNBYnNvbHV0ZVVSTChyZXF1ZXN0ZWRVUkwpO1xuICBpZiAoYmFzZVVSTCAmJiAoaXNSZWxhdGl2ZVVybCB8fCBhbGxvd0Fic29sdXRlVXJscyA9PSBmYWxzZSkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdHJhbnNmb3JtRGF0YSBmcm9tICcuL3RyYW5zZm9ybURhdGEuanMnO1xuaW1wb3J0IGlzQ2FuY2VsIGZyb20gJy4uL2NhbmNlbC9pc0NhbmNlbC5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vZGVmYXVsdHMvaW5kZXguanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tICcuLi9jb3JlL0F4aW9zSGVhZGVycy5qcyc7XG5pbXBvcnQgYWRhcHRlcnMgZnJvbSBcIi4uL2FkYXB0ZXJzL2FkYXB0ZXJzLmpzXCI7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cblxuICBpZiAoY29uZmlnLnNpZ25hbCAmJiBjb25maWcuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgQ2FuY2VsZWRFcnJvcihudWxsLCBjb25maWcpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgY29uZmlnLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShjb25maWcuaGVhZGVycyk7XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICBjb25maWcsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICBpZiAoWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLmluZGV4T2YoY29uZmlnLm1ldGhvZCkgIT09IC0xKSB7XG4gICAgY29uZmlnLmhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsIGZhbHNlKTtcbiAgfVxuXG4gIGNvbnN0IGFkYXB0ZXIgPSBhZGFwdGVycy5nZXRBZGFwdGVyKGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXIsIGNvbmZpZyk7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICBjb25maWcsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICByZXNwb25zZVxuICAgICk7XG5cbiAgICByZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVzcG9uc2UuaGVhZGVycyk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVhc29uLnJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4vQXhpb3NIZWFkZXJzLmpzXCI7XG5cbmNvbnN0IGhlYWRlcnNUb09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgaW5zdGFuY2VvZiBBeGlvc0hlYWRlcnMgPyB7IC4uLnRoaW5nIH0gOiB0aGluZztcblxuLyoqXG4gKiBDb25maWctc3BlY2lmaWMgbWVyZ2UtZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBjb25maWctb2JqZWN0XG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gKlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcbiAgY29uc3QgY29uZmlnID0ge307XG5cbiAgZnVuY3Rpb24gZ2V0TWVyZ2VkVmFsdWUodGFyZ2V0LCBzb3VyY2UsIHByb3AsIGNhc2VsZXNzKSB7XG4gICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiB1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZS5jYWxsKHtjYXNlbGVzc30sIHRhcmdldCwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHt9LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhhLCBiLCBwcm9wLCBjYXNlbGVzcykge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYikpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZShhLCBiLCBwcm9wLCBjYXNlbGVzcyk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGEsIHByb3AsIGNhc2VsZXNzKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihhLCBiKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYik7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIoYSwgYikge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYikpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGIpO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGEpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gbWVyZ2VEaXJlY3RLZXlzKGEsIGIsIHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUoYSwgYik7XG4gICAgfSBlbHNlIGlmIChwcm9wIGluIGNvbmZpZzEpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGEpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG1lcmdlTWFwID0ge1xuICAgIHVybDogdmFsdWVGcm9tQ29uZmlnMixcbiAgICBtZXRob2Q6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgZGF0YTogdmFsdWVGcm9tQ29uZmlnMixcbiAgICBiYXNlVVJMOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zZm9ybVJlcXVlc3Q6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdHJhbnNmb3JtUmVzcG9uc2U6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgcGFyYW1zU2VyaWFsaXplcjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0aW1lb3V0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRpbWVvdXRNZXNzYWdlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHdpdGhDcmVkZW50aWFsczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB3aXRoWFNSRlRva2VuOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGFkYXB0ZXI6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgcmVzcG9uc2VUeXBlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHhzcmZDb29raWVOYW1lOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHhzcmZIZWFkZXJOYW1lOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgb25Eb3dubG9hZFByb2dyZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGRlY29tcHJlc3M6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgbWF4Q29udGVudExlbmd0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBtYXhCb2R5TGVuZ3RoOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGJlZm9yZVJlZGlyZWN0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zcG9ydDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBodHRwQWdlbnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgaHR0cHNBZ2VudDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBjYW5jZWxUb2tlbjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBzb2NrZXRQYXRoOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHJlc3BvbnNlRW5jb2Rpbmc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdmFsaWRhdGVTdGF0dXM6IG1lcmdlRGlyZWN0S2V5cyxcbiAgICBoZWFkZXJzOiAoYSwgYiwgcHJvcCkgPT4gbWVyZ2VEZWVwUHJvcGVydGllcyhoZWFkZXJzVG9PYmplY3QoYSksIGhlYWRlcnNUb09iamVjdChiKSwgcHJvcCwgdHJ1ZSlcbiAgfTtcblxuICB1dGlscy5mb3JFYWNoKE9iamVjdC5rZXlzKHsuLi5jb25maWcxLCAuLi5jb25maWcyfSksIGZ1bmN0aW9uIGNvbXB1dGVDb25maWdWYWx1ZShwcm9wKSB7XG4gICAgY29uc3QgbWVyZ2UgPSBtZXJnZU1hcFtwcm9wXSB8fCBtZXJnZURlZXBQcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNvbmZpZ1ZhbHVlID0gbWVyZ2UoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSwgcHJvcCk7XG4gICAgKHV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZ1ZhbHVlKSAmJiBtZXJnZSAhPT0gbWVyZ2VEaXJlY3RLZXlzKSB8fCAoY29uZmlnW3Byb3BdID0gY29uZmlnVmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gY29uZmlnO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuL0F4aW9zRXJyb3IuanMnO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSByZXNwb25zZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgY29uc3QgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIFtBeGlvc0Vycm9yLkVSUl9CQURfUkVRVUVTVCwgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFXVtNYXRoLmZsb29yKHJlc3BvbnNlLnN0YXR1cyAvIDEwMCkgLSA0XSxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9kZWZhdWx0cy9pbmRleC5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHBhcmFtIHs/T2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2Ugb2JqZWN0XG4gKlxuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGZucywgcmVzcG9uc2UpIHtcbiAgY29uc3QgY29uZmlnID0gdGhpcyB8fCBkZWZhdWx0cztcbiAgY29uc3QgY29udGV4dCA9IHJlc3BvbnNlIHx8IGNvbmZpZztcbiAgY29uc3QgaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKGNvbnRleHQuaGVhZGVycyk7XG4gIGxldCBkYXRhID0gY29udGV4dC5kYXRhO1xuXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4uY2FsbChjb25maWcsIGRhdGEsIGhlYWRlcnMubm9ybWFsaXplKCksIHJlc3BvbnNlID8gcmVzcG9uc2Uuc3RhdHVzIDogdW5kZWZpbmVkKTtcbiAgfSk7XG5cbiAgaGVhZGVycy5ub3JtYWxpemUoKTtcblxuICByZXR1cm4gZGF0YTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgdHJhbnNpdGlvbmFsRGVmYXVsdHMgZnJvbSAnLi90cmFuc2l0aW9uYWwuanMnO1xuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi4vaGVscGVycy90b0Zvcm1EYXRhLmpzJztcbmltcG9ydCB0b1VSTEVuY29kZWRGb3JtIGZyb20gJy4uL2hlbHBlcnMvdG9VUkxFbmNvZGVkRm9ybS5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuaW1wb3J0IGZvcm1EYXRhVG9KU09OIGZyb20gJy4uL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMnO1xuXG4vKipcbiAqIEl0IHRha2VzIGEgc3RyaW5nLCB0cmllcyB0byBwYXJzZSBpdCwgYW5kIGlmIGl0IGZhaWxzLCBpdCByZXR1cm5zIHRoZSBzdHJpbmdpZmllZCB2ZXJzaW9uXG4gKiBvZiB0aGUgaW5wdXRcbiAqXG4gKiBAcGFyYW0ge2FueX0gcmF3VmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgc3RyaW5naWZpZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXJzZXIgLSBBIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGEgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZ2lmaWVkIHZlcnNpb24gb2YgdGhlIHJhd1ZhbHVlLlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxuY29uc3QgZGVmYXVsdHMgPSB7XG5cbiAgdHJhbnNpdGlvbmFsOiB0cmFuc2l0aW9uYWxEZWZhdWx0cyxcblxuICBhZGFwdGVyOiBbJ3hocicsICdodHRwJywgJ2ZldGNoJ10sXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXRDb250ZW50VHlwZSgpIHx8ICcnO1xuICAgIGNvbnN0IGhhc0pTT05Db250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xO1xuICAgIGNvbnN0IGlzT2JqZWN0UGF5bG9hZCA9IHV0aWxzLmlzT2JqZWN0KGRhdGEpO1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCAmJiB1dGlscy5pc0hUTUxGb3JtKGRhdGEpKSB7XG4gICAgICBkYXRhID0gbmV3IEZvcm1EYXRhKGRhdGEpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzRm9ybURhdGEgPSB1dGlscy5pc0Zvcm1EYXRhKGRhdGEpO1xuXG4gICAgaWYgKGlzRm9ybURhdGEpIHtcbiAgICAgIHJldHVybiBoYXNKU09OQ29udGVudFR5cGUgPyBKU09OLnN0cmluZ2lmeShmb3JtRGF0YVRvSlNPTihkYXRhKSkgOiBkYXRhO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1JlYWRhYmxlU3RyZWFtKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnLCBmYWxzZSk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGxldCBpc0ZpbGVMaXN0O1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCkge1xuICAgICAgaWYgKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRvVVJMRW5jb2RlZEZvcm0oZGF0YSwgdGhpcy5mb3JtU2VyaWFsaXplcikudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChpc0ZpbGVMaXN0ID0gdXRpbHMuaXNGaWxlTGlzdChkYXRhKSkgfHwgY29udGVudFR5cGUuaW5kZXhPZignbXVsdGlwYXJ0L2Zvcm0tZGF0YScpID4gLTEpIHtcbiAgICAgICAgY29uc3QgX0Zvcm1EYXRhID0gdGhpcy5lbnYgJiYgdGhpcy5lbnYuRm9ybURhdGE7XG5cbiAgICAgICAgcmV0dXJuIHRvRm9ybURhdGEoXG4gICAgICAgICAgaXNGaWxlTGlzdCA/IHsnZmlsZXNbXSc6IGRhdGF9IDogZGF0YSxcbiAgICAgICAgICBfRm9ybURhdGEgJiYgbmV3IF9Gb3JtRGF0YSgpLFxuICAgICAgICAgIHRoaXMuZm9ybVNlcmlhbGl6ZXJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkIHx8IGhhc0pTT05Db250ZW50VHlwZSApIHtcbiAgICAgIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL2pzb24nLCBmYWxzZSk7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5U2FmZWx5KGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICBjb25zdCB0cmFuc2l0aW9uYWwgPSB0aGlzLnRyYW5zaXRpb25hbCB8fCBkZWZhdWx0cy50cmFuc2l0aW9uYWw7XG4gICAgY29uc3QgZm9yY2VkSlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLmZvcmNlZEpTT05QYXJzaW5nO1xuICAgIGNvbnN0IEpTT05SZXF1ZXN0ZWQgPSB0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nO1xuXG4gICAgaWYgKHV0aWxzLmlzUmVzcG9uc2UoZGF0YSkgfHwgdXRpbHMuaXNSZWFkYWJsZVN0cmVhbShkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgJiYgdXRpbHMuaXNTdHJpbmcoZGF0YSkgJiYgKChmb3JjZWRKU09OUGFyc2luZyAmJiAhdGhpcy5yZXNwb25zZVR5cGUpIHx8IEpTT05SZXF1ZXN0ZWQpKSB7XG4gICAgICBjb25zdCBzaWxlbnRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuc2lsZW50SlNPTlBhcnNpbmc7XG4gICAgICBjb25zdCBzdHJpY3RKU09OUGFyc2luZyA9ICFzaWxlbnRKU09OUGFyc2luZyAmJiBKU09OUmVxdWVzdGVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhLCB0aGlzLnBhcnNlUmV2aXZlcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChzdHJpY3RKU09OUGFyc2luZykge1xuICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IEF4aW9zRXJyb3IuZnJvbShlLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0UsIHRoaXMsIG51bGwsIHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuICBtYXhCb2R5TGVuZ3RoOiAtMSxcblxuICBlbnY6IHtcbiAgICBGb3JtRGF0YTogcGxhdGZvcm0uY2xhc3Nlcy5Gb3JtRGF0YSxcbiAgICBCbG9iOiBwbGF0Zm9ybS5jbGFzc2VzLkJsb2JcbiAgfSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9LFxuXG4gIGhlYWRlcnM6IHtcbiAgICBjb21tb246IHtcbiAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJyxcbiAgICAgICdDb250ZW50LVR5cGUnOiB1bmRlZmluZWRcbiAgICB9XG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgKG1ldGhvZCkgPT4ge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0cztcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBzaWxlbnRKU09OUGFyc2luZzogdHJ1ZSxcbiAgZm9yY2VkSlNPTlBhcnNpbmc6IHRydWUsXG4gIGNsYXJpZnlUaW1lb3V0RXJyb3I6IGZhbHNlXG59O1xuIiwiZXhwb3J0IGNvbnN0IFZFUlNJT04gPSBcIjEuMTMuMVwiOyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi90b0Zvcm1EYXRhLmpzJztcblxuLyoqXG4gKiBJdCBlbmNvZGVzIGEgc3RyaW5nIGJ5IHJlcGxhY2luZyBhbGwgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgaW4gdGhlIHVucmVzZXJ2ZWQgc2V0IHdpdGhcbiAqIHRoZWlyIHBlcmNlbnQtZW5jb2RlZCBlcXVpdmFsZW50c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGVuY29kZS5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShzdHIpIHtcbiAgY29uc3QgY2hhck1hcCA9IHtcbiAgICAnISc6ICclMjEnLFxuICAgIFwiJ1wiOiAnJTI3JyxcbiAgICAnKCc6ICclMjgnLFxuICAgICcpJzogJyUyOScsXG4gICAgJ34nOiAnJTdFJyxcbiAgICAnJTIwJzogJysnLFxuICAgICclMDAnOiAnXFx4MDAnXG4gIH07XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKX5dfCUyMHwlMDAvZywgZnVuY3Rpb24gcmVwbGFjZXIobWF0Y2gpIHtcbiAgICByZXR1cm4gY2hhck1hcFttYXRjaF07XG4gIH0pO1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgcGFyYW1zIG9iamVjdCBhbmQgY29udmVydHMgaXQgdG8gYSBGb3JtRGF0YSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIHRvIGJlIGNvbnZlcnRlZCB0byBhIEZvcm1EYXRhIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBwYXNzZWQgdG8gdGhlIEF4aW9zIGNvbnN0cnVjdG9yLlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBBeGlvc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgdGhpcy5fcGFpcnMgPSBbXTtcblxuICBwYXJhbXMgJiYgdG9Gb3JtRGF0YShwYXJhbXMsIHRoaXMsIG9wdGlvbnMpO1xufVxuXG5jb25zdCBwcm90b3R5cGUgPSBBeGlvc1VSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQobmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5fcGFpcnMucHVzaChbbmFtZSwgdmFsdWVdKTtcbn07XG5cbnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGVuY29kZXIpIHtcbiAgY29uc3QgX2VuY29kZSA9IGVuY29kZXIgPyBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBlbmNvZGVyLmNhbGwodGhpcywgdmFsdWUsIGVuY29kZSk7XG4gIH0gOiBlbmNvZGU7XG5cbiAgcmV0dXJuIHRoaXMuX3BhaXJzLm1hcChmdW5jdGlvbiBlYWNoKHBhaXIpIHtcbiAgICByZXR1cm4gX2VuY29kZShwYWlyWzBdKSArICc9JyArIF9lbmNvZGUocGFpclsxXSk7XG4gIH0sICcnKS5qb2luKCcmJyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvc1VSTFNlYXJjaFBhcmFtcztcbiIsImNvbnN0IEh0dHBTdGF0dXNDb2RlID0ge1xuICBDb250aW51ZTogMTAwLFxuICBTd2l0Y2hpbmdQcm90b2NvbHM6IDEwMSxcbiAgUHJvY2Vzc2luZzogMTAyLFxuICBFYXJseUhpbnRzOiAxMDMsXG4gIE9rOiAyMDAsXG4gIENyZWF0ZWQ6IDIwMSxcbiAgQWNjZXB0ZWQ6IDIwMixcbiAgTm9uQXV0aG9yaXRhdGl2ZUluZm9ybWF0aW9uOiAyMDMsXG4gIE5vQ29udGVudDogMjA0LFxuICBSZXNldENvbnRlbnQ6IDIwNSxcbiAgUGFydGlhbENvbnRlbnQ6IDIwNixcbiAgTXVsdGlTdGF0dXM6IDIwNyxcbiAgQWxyZWFkeVJlcG9ydGVkOiAyMDgsXG4gIEltVXNlZDogMjI2LFxuICBNdWx0aXBsZUNob2ljZXM6IDMwMCxcbiAgTW92ZWRQZXJtYW5lbnRseTogMzAxLFxuICBGb3VuZDogMzAyLFxuICBTZWVPdGhlcjogMzAzLFxuICBOb3RNb2RpZmllZDogMzA0LFxuICBVc2VQcm94eTogMzA1LFxuICBVbnVzZWQ6IDMwNixcbiAgVGVtcG9yYXJ5UmVkaXJlY3Q6IDMwNyxcbiAgUGVybWFuZW50UmVkaXJlY3Q6IDMwOCxcbiAgQmFkUmVxdWVzdDogNDAwLFxuICBVbmF1dGhvcml6ZWQ6IDQwMSxcbiAgUGF5bWVudFJlcXVpcmVkOiA0MDIsXG4gIEZvcmJpZGRlbjogNDAzLFxuICBOb3RGb3VuZDogNDA0LFxuICBNZXRob2ROb3RBbGxvd2VkOiA0MDUsXG4gIE5vdEFjY2VwdGFibGU6IDQwNixcbiAgUHJveHlBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA0MDcsXG4gIFJlcXVlc3RUaW1lb3V0OiA0MDgsXG4gIENvbmZsaWN0OiA0MDksXG4gIEdvbmU6IDQxMCxcbiAgTGVuZ3RoUmVxdWlyZWQ6IDQxMSxcbiAgUHJlY29uZGl0aW9uRmFpbGVkOiA0MTIsXG4gIFBheWxvYWRUb29MYXJnZTogNDEzLFxuICBVcmlUb29Mb25nOiA0MTQsXG4gIFVuc3VwcG9ydGVkTWVkaWFUeXBlOiA0MTUsXG4gIFJhbmdlTm90U2F0aXNmaWFibGU6IDQxNixcbiAgRXhwZWN0YXRpb25GYWlsZWQ6IDQxNyxcbiAgSW1BVGVhcG90OiA0MTgsXG4gIE1pc2RpcmVjdGVkUmVxdWVzdDogNDIxLFxuICBVbnByb2Nlc3NhYmxlRW50aXR5OiA0MjIsXG4gIExvY2tlZDogNDIzLFxuICBGYWlsZWREZXBlbmRlbmN5OiA0MjQsXG4gIFRvb0Vhcmx5OiA0MjUsXG4gIFVwZ3JhZGVSZXF1aXJlZDogNDI2LFxuICBQcmVjb25kaXRpb25SZXF1aXJlZDogNDI4LFxuICBUb29NYW55UmVxdWVzdHM6IDQyOSxcbiAgUmVxdWVzdEhlYWRlckZpZWxkc1Rvb0xhcmdlOiA0MzEsXG4gIFVuYXZhaWxhYmxlRm9yTGVnYWxSZWFzb25zOiA0NTEsXG4gIEludGVybmFsU2VydmVyRXJyb3I6IDUwMCxcbiAgTm90SW1wbGVtZW50ZWQ6IDUwMSxcbiAgQmFkR2F0ZXdheTogNTAyLFxuICBTZXJ2aWNlVW5hdmFpbGFibGU6IDUwMyxcbiAgR2F0ZXdheVRpbWVvdXQ6IDUwNCxcbiAgSHR0cFZlcnNpb25Ob3RTdXBwb3J0ZWQ6IDUwNSxcbiAgVmFyaWFudEFsc29OZWdvdGlhdGVzOiA1MDYsXG4gIEluc3VmZmljaWVudFN0b3JhZ2U6IDUwNyxcbiAgTG9vcERldGVjdGVkOiA1MDgsXG4gIE5vdEV4dGVuZGVkOiA1MTAsXG4gIE5ldHdvcmtBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA1MTEsXG4gIFdlYlNlcnZlcklzRG93bjogNTIxLFxuICBDb25uZWN0aW9uVGltZWRPdXQ6IDUyMixcbiAgT3JpZ2luSXNVbnJlYWNoYWJsZTogNTIzLFxuICBUaW1lb3V0T2NjdXJyZWQ6IDUyNCxcbiAgU3NsSGFuZHNoYWtlRmFpbGVkOiA1MjUsXG4gIEludmFsaWRTc2xDZXJ0aWZpY2F0ZTogNTI2LFxufTtcblxuT2JqZWN0LmVudHJpZXMoSHR0cFN0YXR1c0NvZGUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICBIdHRwU3RhdHVzQ29kZVt2YWx1ZV0gPSBrZXk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgSHR0cFN0YXR1c0NvZGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlIGEgYm91bmQgdmVyc2lvbiBvZiBhIGZ1bmN0aW9uIHdpdGggYSBzcGVjaWZpZWQgYHRoaXNgIGNvbnRleHRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBiaW5kXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgLSBUaGUgdmFsdWUgdG8gYmUgcGFzc2VkIGFzIHRoZSBgdGhpc2AgcGFyYW1ldGVyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgYHRoaXNgIGNvbnRleHRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc1VSTFNlYXJjaFBhcmFtcyBmcm9tICcuLi9oZWxwZXJzL0F4aW9zVVJMU2VhcmNoUGFyYW1zLmpzJztcblxuLyoqXG4gKiBJdCByZXBsYWNlcyBhbGwgaW5zdGFuY2VzIG9mIHRoZSBjaGFyYWN0ZXJzIGA6YCwgYCRgLCBgLGAsIGArYCwgYFtgLCBhbmQgYF1gIHdpdGggdGhlaXJcbiAqIFVSSSBlbmNvZGVkIGNvdW50ZXJwYXJ0c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWwgVGhlIHZhbHVlIHRvIGJlIGVuY29kZWQuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGVuY29kZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHBhcmFtIHs/KG9iamVjdHxGdW5jdGlvbil9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgb3B0aW9ucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIFxuICBjb25zdCBfZW5jb2RlID0gb3B0aW9ucyAmJiBvcHRpb25zLmVuY29kZSB8fCBlbmNvZGU7XG5cbiAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgc2VyaWFsaXplOiBvcHRpb25zXG4gICAgfTtcbiAgfSBcblxuICBjb25zdCBzZXJpYWxpemVGbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemU7XG5cbiAgbGV0IHNlcmlhbGl6ZWRQYXJhbXM7XG5cbiAgaWYgKHNlcmlhbGl6ZUZuKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHNlcmlhbGl6ZUZuKHBhcmFtcywgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykgP1xuICAgICAgcGFyYW1zLnRvU3RyaW5nKCkgOlxuICAgICAgbmV3IEF4aW9zVVJMU2VhcmNoUGFyYW1zKHBhcmFtcywgb3B0aW9ucykudG9TdHJpbmcoX2VuY29kZSk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIGNvbnN0IGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XG5cbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLz9cXC8kLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59XG4iLCJpbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tIFwiLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanNcIjtcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gXCIuLi9jb3JlL0F4aW9zRXJyb3IuanNcIjtcbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbmNvbnN0IGNvbXBvc2VTaWduYWxzID0gKHNpZ25hbHMsIHRpbWVvdXQpID0+IHtcbiAgY29uc3Qge2xlbmd0aH0gPSAoc2lnbmFscyA9IHNpZ25hbHMgPyBzaWduYWxzLmZpbHRlcihCb29sZWFuKSA6IFtdKTtcblxuICBpZiAodGltZW91dCB8fCBsZW5ndGgpIHtcbiAgICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblxuICAgIGxldCBhYm9ydGVkO1xuXG4gICAgY29uc3Qgb25hYm9ydCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmICghYWJvcnRlZCkge1xuICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgY29uc3QgZXJyID0gcmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyByZWFzb24gOiB0aGlzLnJlYXNvbjtcbiAgICAgICAgY29udHJvbGxlci5hYm9ydChlcnIgaW5zdGFuY2VvZiBBeGlvc0Vycm9yID8gZXJyIDogbmV3IENhbmNlbGVkRXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IGVycikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB0aW1lciA9IHRpbWVvdXQgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgICBvbmFib3J0KG5ldyBBeGlvc0Vycm9yKGB0aW1lb3V0ICR7dGltZW91dH0gb2YgbXMgZXhjZWVkZWRgLCBBeGlvc0Vycm9yLkVUSU1FRE9VVCkpXG4gICAgfSwgdGltZW91dClcblxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgaWYgKHNpZ25hbHMpIHtcbiAgICAgICAgdGltZXIgJiYgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICBzaWduYWxzLmZvckVhY2goc2lnbmFsID0+IHtcbiAgICAgICAgICBzaWduYWwudW5zdWJzY3JpYmUgPyBzaWduYWwudW5zdWJzY3JpYmUob25hYm9ydCkgOiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbmFib3J0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNpZ25hbHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNpZ25hbHMuZm9yRWFjaCgoc2lnbmFsKSA9PiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbmFib3J0KSk7XG5cbiAgICBjb25zdCB7c2lnbmFsfSA9IGNvbnRyb2xsZXI7XG5cbiAgICBzaWduYWwudW5zdWJzY3JpYmUgPSAoKSA9PiB1dGlscy5hc2FwKHVuc3Vic2NyaWJlKTtcblxuICAgIHJldHVybiBzaWduYWw7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY29tcG9zZVNpZ25hbHM7XG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICB7XG4gICAgd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlLCBzYW1lU2l0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcblxuICAgICAgY29uc3QgY29va2llID0gW2Ake25hbWV9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gXTtcblxuICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgIGNvb2tpZS5wdXNoKGBleHBpcmVzPSR7bmV3IERhdGUoZXhwaXJlcykudG9VVENTdHJpbmcoKX1gKTtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICBjb29raWUucHVzaChgcGF0aD0ke3BhdGh9YCk7XG4gICAgICB9XG4gICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICBjb29raWUucHVzaChgZG9tYWluPSR7ZG9tYWlufWApO1xuICAgICAgfVxuICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICB9XG4gICAgICBpZiAodXRpbHMuaXNTdHJpbmcoc2FtZVNpdGUpKSB7XG4gICAgICAgIGNvb2tpZS5wdXNoKGBTYW1lU2l0ZT0ke3NhbWVTaXRlfWApO1xuICAgICAgfVxuXG4gICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICB9LFxuXG4gICAgcmVhZChuYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoPzpefDsgKScgKyBuYW1lICsgJz0oW147XSopJykpO1xuICAgICAgcmV0dXJuIG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzFdKSA6IG51bGw7XG4gICAgfSxcblxuICAgIHJlbW92ZShuYW1lKSB7XG4gICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDAsICcvJyk7XG4gICAgfVxuICB9XG5cbiAgOlxuXG4gIC8vIE5vbi1zdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAge1xuICAgIHdyaXRlKCkge30sXG4gICAgcmVhZCgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgcmVtb3ZlKCkge31cbiAgfTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEl0IHRha2VzIGEgc3RyaW5nIGxpa2UgYGZvb1t4XVt5XVt6XWAgYW5kIHJldHVybnMgYW4gYXJyYXkgbGlrZSBgWydmb28nLCAneCcsICd5JywgJ3onXVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzdHJpbmdzLlxuICovXG5mdW5jdGlvbiBwYXJzZVByb3BQYXRoKG5hbWUpIHtcbiAgLy8gZm9vW3hdW3ldW3pdXG4gIC8vIGZvby54LnkuelxuICAvLyBmb28teC15LXpcbiAgLy8gZm9vIHggeSB6XG4gIHJldHVybiB1dGlscy5tYXRjaEFsbCgvXFx3K3xcXFsoXFx3KildL2csIG5hbWUpLm1hcChtYXRjaCA9PiB7XG4gICAgcmV0dXJuIG1hdGNoWzBdID09PSAnW10nID8gJycgOiBtYXRjaFsxXSB8fCBtYXRjaFswXTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBhcnJheSB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnIgLSBUaGUgYXJyYXkgdG8gY29udmVydCB0byBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhbmQgdmFsdWVzIGFzIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb09iamVjdChhcnIpIHtcbiAgY29uc3Qgb2JqID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcnIpO1xuICBsZXQgaTtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGxldCBrZXk7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgb2JqW2tleV0gPSBhcnJba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgRm9ybURhdGEgb2JqZWN0IGFuZCByZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybURhdGEgVGhlIEZvcm1EYXRhIG9iamVjdCB0byBjb252ZXJ0IHRvIEpTT04uXG4gKlxuICogQHJldHVybnMge09iamVjdDxzdHJpbmcsIGFueT4gfCBudWxsfSBUaGUgY29udmVydGVkIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZm9ybURhdGFUb0pTT04oZm9ybURhdGEpIHtcbiAgZnVuY3Rpb24gYnVpbGRQYXRoKHBhdGgsIHZhbHVlLCB0YXJnZXQsIGluZGV4KSB7XG4gICAgbGV0IG5hbWUgPSBwYXRoW2luZGV4KytdO1xuXG4gICAgaWYgKG5hbWUgPT09ICdfX3Byb3RvX18nKSByZXR1cm4gdHJ1ZTtcblxuICAgIGNvbnN0IGlzTnVtZXJpY0tleSA9IE51bWJlci5pc0Zpbml0ZSgrbmFtZSk7XG4gICAgY29uc3QgaXNMYXN0ID0gaW5kZXggPj0gcGF0aC5sZW5ndGg7XG4gICAgbmFtZSA9ICFuYW1lICYmIHV0aWxzLmlzQXJyYXkodGFyZ2V0KSA/IHRhcmdldC5sZW5ndGggOiBuYW1lO1xuXG4gICAgaWYgKGlzTGFzdCkge1xuICAgICAgaWYgKHV0aWxzLmhhc093blByb3AodGFyZ2V0LCBuYW1lKSkge1xuICAgICAgICB0YXJnZXRbbmFtZV0gPSBbdGFyZ2V0W25hbWVdLCB2YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICFpc051bWVyaWNLZXk7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRbbmFtZV0gfHwgIXV0aWxzLmlzT2JqZWN0KHRhcmdldFtuYW1lXSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGJ1aWxkUGF0aChwYXRoLCB2YWx1ZSwgdGFyZ2V0W25hbWVdLCBpbmRleCk7XG5cbiAgICBpZiAocmVzdWx0ICYmIHV0aWxzLmlzQXJyYXkodGFyZ2V0W25hbWVdKSkge1xuICAgICAgdGFyZ2V0W25hbWVdID0gYXJyYXlUb09iamVjdCh0YXJnZXRbbmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiAhaXNOdW1lcmljS2V5O1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZm9ybURhdGEpICYmIHV0aWxzLmlzRnVuY3Rpb24oZm9ybURhdGEuZW50cmllcykpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcblxuICAgIHV0aWxzLmZvckVhY2hFbnRyeShmb3JtRGF0YSwgKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICBidWlsZFBhdGgocGFyc2VQcm9wUGF0aChuYW1lKSwgdmFsdWUsIG9iaiwgMCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1EYXRhVG9KU09OO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZCtcXC0uXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zXG4gKlxuICogQHBhcmFtIHsqfSBwYXlsb2FkIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNBeGlvc0Vycm9yKHBheWxvYWQpIHtcbiAgcmV0dXJuIHV0aWxzLmlzT2JqZWN0KHBheWxvYWQpICYmIChwYXlsb2FkLmlzQXhpb3NFcnJvciA9PT0gdHJ1ZSk7XG59XG4iLCJpbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgPyAoKG9yaWdpbiwgaXNNU0lFKSA9PiAodXJsKSA9PiB7XG4gIHVybCA9IG5ldyBVUkwodXJsLCBwbGF0Zm9ybS5vcmlnaW4pO1xuXG4gIHJldHVybiAoXG4gICAgb3JpZ2luLnByb3RvY29sID09PSB1cmwucHJvdG9jb2wgJiZcbiAgICBvcmlnaW4uaG9zdCA9PT0gdXJsLmhvc3QgJiZcbiAgICAoaXNNU0lFIHx8IG9yaWdpbi5wb3J0ID09PSB1cmwucG9ydClcbiAgKTtcbn0pKFxuICBuZXcgVVJMKHBsYXRmb3JtLm9yaWdpbiksXG4gIHBsYXRmb3JtLm5hdmlnYXRvciAmJiAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KHBsYXRmb3JtLm5hdmlnYXRvci51c2VyQWdlbnQpXG4pIDogKCkgPT4gdHJ1ZTtcbiIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzdHJpY3RcbmV4cG9ydCBkZWZhdWx0IG51bGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcblxuLy8gUmF3QXhpb3NIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuLy8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xuY29uc3QgaWdub3JlRHVwbGljYXRlT2YgPSB1dGlscy50b09iamVjdFNldChbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXSk7XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdIZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5leHBvcnQgZGVmYXVsdCByYXdIZWFkZXJzID0+IHtcbiAgY29uc3QgcGFyc2VkID0ge307XG4gIGxldCBrZXk7XG4gIGxldCB2YWw7XG4gIGxldCBpO1xuXG4gIHJhd0hlYWRlcnMgJiYgcmF3SGVhZGVycy5zcGxpdCgnXFxuJykuZm9yRWFjaChmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSBsaW5lLnN1YnN0cmluZygwLCBpKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSBsaW5lLnN1YnN0cmluZyhpICsgMSkudHJpbSgpO1xuXG4gICAgaWYgKCFrZXkgfHwgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mW2tleV0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0pIHtcbiAgICAgICAgcGFyc2VkW2tleV0ucHVzaCh2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBbdmFsXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJzZVByb3RvY29sKHVybCkge1xuICBjb25zdCBtYXRjaCA9IC9eKFstK1xcd117MSwyNX0pKDo/XFwvXFwvfDopLy5leGVjKHVybCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbn1cbiIsImltcG9ydCBzcGVlZG9tZXRlciBmcm9tIFwiLi9zcGVlZG9tZXRlci5qc1wiO1xuaW1wb3J0IHRocm90dGxlIGZyb20gXCIuL3Rocm90dGxlLmpzXCI7XG5pbXBvcnQgdXRpbHMgZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5cbmV4cG9ydCBjb25zdCBwcm9ncmVzc0V2ZW50UmVkdWNlciA9IChsaXN0ZW5lciwgaXNEb3dubG9hZFN0cmVhbSwgZnJlcSA9IDMpID0+IHtcbiAgbGV0IGJ5dGVzTm90aWZpZWQgPSAwO1xuICBjb25zdCBfc3BlZWRvbWV0ZXIgPSBzcGVlZG9tZXRlcig1MCwgMjUwKTtcblxuICByZXR1cm4gdGhyb3R0bGUoZSA9PiB7XG4gICAgY29uc3QgbG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgY29uc3QgdG90YWwgPSBlLmxlbmd0aENvbXB1dGFibGUgPyBlLnRvdGFsIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHByb2dyZXNzQnl0ZXMgPSBsb2FkZWQgLSBieXRlc05vdGlmaWVkO1xuICAgIGNvbnN0IHJhdGUgPSBfc3BlZWRvbWV0ZXIocHJvZ3Jlc3NCeXRlcyk7XG4gICAgY29uc3QgaW5SYW5nZSA9IGxvYWRlZCA8PSB0b3RhbDtcblxuICAgIGJ5dGVzTm90aWZpZWQgPSBsb2FkZWQ7XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgbG9hZGVkLFxuICAgICAgdG90YWwsXG4gICAgICBwcm9ncmVzczogdG90YWwgPyAobG9hZGVkIC8gdG90YWwpIDogdW5kZWZpbmVkLFxuICAgICAgYnl0ZXM6IHByb2dyZXNzQnl0ZXMsXG4gICAgICByYXRlOiByYXRlID8gcmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGVzdGltYXRlZDogcmF0ZSAmJiB0b3RhbCAmJiBpblJhbmdlID8gKHRvdGFsIC0gbG9hZGVkKSAvIHJhdGUgOiB1bmRlZmluZWQsXG4gICAgICBldmVudDogZSxcbiAgICAgIGxlbmd0aENvbXB1dGFibGU6IHRvdGFsICE9IG51bGwsXG4gICAgICBbaXNEb3dubG9hZFN0cmVhbSA/ICdkb3dubG9hZCcgOiAndXBsb2FkJ106IHRydWVcbiAgICB9O1xuXG4gICAgbGlzdGVuZXIoZGF0YSk7XG4gIH0sIGZyZXEpO1xufVxuXG5leHBvcnQgY29uc3QgcHJvZ3Jlc3NFdmVudERlY29yYXRvciA9ICh0b3RhbCwgdGhyb3R0bGVkKSA9PiB7XG4gIGNvbnN0IGxlbmd0aENvbXB1dGFibGUgPSB0b3RhbCAhPSBudWxsO1xuXG4gIHJldHVybiBbKGxvYWRlZCkgPT4gdGhyb3R0bGVkWzBdKHtcbiAgICBsZW5ndGhDb21wdXRhYmxlLFxuICAgIHRvdGFsLFxuICAgIGxvYWRlZFxuICB9KSwgdGhyb3R0bGVkWzFdXTtcbn1cblxuZXhwb3J0IGNvbnN0IGFzeW5jRGVjb3JhdG9yID0gKGZuKSA9PiAoLi4uYXJncykgPT4gdXRpbHMuYXNhcCgoKSA9PiBmbiguLi5hcmdzKSk7XG4iLCJpbXBvcnQgcGxhdGZvcm0gZnJvbSBcIi4uL3BsYXRmb3JtL2luZGV4LmpzXCI7XG5pbXBvcnQgdXRpbHMgZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgaXNVUkxTYW1lT3JpZ2luIGZyb20gXCIuL2lzVVJMU2FtZU9yaWdpbi5qc1wiO1xuaW1wb3J0IGNvb2tpZXMgZnJvbSBcIi4vY29va2llcy5qc1wiO1xuaW1wb3J0IGJ1aWxkRnVsbFBhdGggZnJvbSBcIi4uL2NvcmUvYnVpbGRGdWxsUGF0aC5qc1wiO1xuaW1wb3J0IG1lcmdlQ29uZmlnIGZyb20gXCIuLi9jb3JlL21lcmdlQ29uZmlnLmpzXCI7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gXCIuLi9jb3JlL0F4aW9zSGVhZGVycy5qc1wiO1xuaW1wb3J0IGJ1aWxkVVJMIGZyb20gXCIuL2J1aWxkVVJMLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChjb25maWcpID0+IHtcbiAgY29uc3QgbmV3Q29uZmlnID0gbWVyZ2VDb25maWcoe30sIGNvbmZpZyk7XG5cbiAgbGV0IHsgZGF0YSwgd2l0aFhTUkZUb2tlbiwgeHNyZkhlYWRlck5hbWUsIHhzcmZDb29raWVOYW1lLCBoZWFkZXJzLCBhdXRoIH0gPSBuZXdDb25maWc7XG5cbiAgbmV3Q29uZmlnLmhlYWRlcnMgPSBoZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oaGVhZGVycyk7XG5cbiAgbmV3Q29uZmlnLnVybCA9IGJ1aWxkVVJMKGJ1aWxkRnVsbFBhdGgobmV3Q29uZmlnLmJhc2VVUkwsIG5ld0NvbmZpZy51cmwsIG5ld0NvbmZpZy5hbGxvd0Fic29sdXRlVXJscyksIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKTtcblxuICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gIGlmIChhdXRoKSB7XG4gICAgaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArXG4gICAgICBidG9hKChhdXRoLnVzZXJuYW1lIHx8ICcnKSArICc6JyArIChhdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgucGFzc3dvcmQpKSA6ICcnKSlcbiAgICApO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkpIHtcbiAgICBpZiAocGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyRW52IHx8IHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudikge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSh1bmRlZmluZWQpOyAvLyBicm93c2VyIGhhbmRsZXMgaXRcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzRnVuY3Rpb24oZGF0YS5nZXRIZWFkZXJzKSkge1xuICAgICAgLy8gTm9kZS5qcyBGb3JtRGF0YSAobGlrZSBmb3JtLWRhdGEgcGFja2FnZSlcbiAgICAgIGNvbnN0IGZvcm1IZWFkZXJzID0gZGF0YS5nZXRIZWFkZXJzKCk7XG4gICAgICAvLyBPbmx5IHNldCBzYWZlIGhlYWRlcnMgdG8gYXZvaWQgb3ZlcndyaXRpbmcgc2VjdXJpdHkgaGVhZGVyc1xuICAgICAgY29uc3QgYWxsb3dlZEhlYWRlcnMgPSBbJ2NvbnRlbnQtdHlwZScsICdjb250ZW50LWxlbmd0aCddO1xuICAgICAgT2JqZWN0LmVudHJpZXMoZm9ybUhlYWRlcnMpLmZvckVhY2goKFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgaWYgKGFsbG93ZWRIZWFkZXJzLmluY2x1ZGVzKGtleS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9ICBcblxuICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG5cbiAgaWYgKHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudikge1xuICAgIHdpdGhYU1JGVG9rZW4gJiYgdXRpbHMuaXNGdW5jdGlvbih3aXRoWFNSRlRva2VuKSAmJiAod2l0aFhTUkZUb2tlbiA9IHdpdGhYU1JGVG9rZW4obmV3Q29uZmlnKSk7XG5cbiAgICBpZiAod2l0aFhTUkZUb2tlbiB8fCAod2l0aFhTUkZUb2tlbiAhPT0gZmFsc2UgJiYgaXNVUkxTYW1lT3JpZ2luKG5ld0NvbmZpZy51cmwpKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICBjb25zdCB4c3JmVmFsdWUgPSB4c3JmSGVhZGVyTmFtZSAmJiB4c3JmQ29va2llTmFtZSAmJiBjb29raWVzLnJlYWQoeHNyZkNvb2tpZU5hbWUpO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KHhzcmZIZWFkZXJOYW1lLCB4c3JmVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdDb25maWc7XG59XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDYWxjdWxhdGUgZGF0YSBtYXhSYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW3NhbXBsZXNDb3VudD0gMTBdXG4gKiBAcGFyYW0ge051bWJlcn0gW21pbj0gMTAwMF1cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gc3BlZWRvbWV0ZXIoc2FtcGxlc0NvdW50LCBtaW4pIHtcbiAgc2FtcGxlc0NvdW50ID0gc2FtcGxlc0NvdW50IHx8IDEwO1xuICBjb25zdCBieXRlcyA9IG5ldyBBcnJheShzYW1wbGVzQ291bnQpO1xuICBjb25zdCB0aW1lc3RhbXBzID0gbmV3IEFycmF5KHNhbXBsZXNDb3VudCk7XG4gIGxldCBoZWFkID0gMDtcbiAgbGV0IHRhaWwgPSAwO1xuICBsZXQgZmlyc3RTYW1wbGVUUztcblxuICBtaW4gPSBtaW4gIT09IHVuZGVmaW5lZCA/IG1pbiA6IDEwMDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1c2goY2h1bmtMZW5ndGgpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgY29uc3Qgc3RhcnRlZEF0ID0gdGltZXN0YW1wc1t0YWlsXTtcblxuICAgIGlmICghZmlyc3RTYW1wbGVUUykge1xuICAgICAgZmlyc3RTYW1wbGVUUyA9IG5vdztcbiAgICB9XG5cbiAgICBieXRlc1toZWFkXSA9IGNodW5rTGVuZ3RoO1xuICAgIHRpbWVzdGFtcHNbaGVhZF0gPSBub3c7XG5cbiAgICBsZXQgaSA9IHRhaWw7XG4gICAgbGV0IGJ5dGVzQ291bnQgPSAwO1xuXG4gICAgd2hpbGUgKGkgIT09IGhlYWQpIHtcbiAgICAgIGJ5dGVzQ291bnQgKz0gYnl0ZXNbaSsrXTtcbiAgICAgIGkgPSBpICUgc2FtcGxlc0NvdW50O1xuICAgIH1cblxuICAgIGhlYWQgPSAoaGVhZCArIDEpICUgc2FtcGxlc0NvdW50O1xuXG4gICAgaWYgKGhlYWQgPT09IHRhaWwpIHtcbiAgICAgIHRhaWwgPSAodGFpbCArIDEpICUgc2FtcGxlc0NvdW50O1xuICAgIH1cblxuICAgIGlmIChub3cgLSBmaXJzdFNhbXBsZVRTIDwgbWluKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFzc2VkID0gc3RhcnRlZEF0ICYmIG5vdyAtIHN0YXJ0ZWRBdDtcblxuICAgIHJldHVybiBwYXNzZWQgPyBNYXRoLnJvdW5kKGJ5dGVzQ291bnQgKiAxMDAwIC8gcGFzc2VkKSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3BlZWRvbWV0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufVxuIiwiLyoqXG4gKiBUaHJvdHRsZSBkZWNvcmF0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge051bWJlcn0gZnJlcVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZuLCBmcmVxKSB7XG4gIGxldCB0aW1lc3RhbXAgPSAwO1xuICBsZXQgdGhyZXNob2xkID0gMTAwMCAvIGZyZXE7XG4gIGxldCBsYXN0QXJncztcbiAgbGV0IHRpbWVyO1xuXG4gIGNvbnN0IGludm9rZSA9IChhcmdzLCBub3cgPSBEYXRlLm5vdygpKSA9PiB7XG4gICAgdGltZXN0YW1wID0gbm93O1xuICAgIGxhc3RBcmdzID0gbnVsbDtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgfVxuICAgIGZuKC4uLmFyZ3MpO1xuICB9XG5cbiAgY29uc3QgdGhyb3R0bGVkID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHBhc3NlZCA9IG5vdyAtIHRpbWVzdGFtcDtcbiAgICBpZiAoIHBhc3NlZCA+PSB0aHJlc2hvbGQpIHtcbiAgICAgIGludm9rZShhcmdzLCBub3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0QXJncyA9IGFyZ3M7XG4gICAgICBpZiAoIXRpbWVyKSB7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgIGludm9rZShsYXN0QXJncylcbiAgICAgICAgfSwgdGhyZXNob2xkIC0gcGFzc2VkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBmbHVzaCA9ICgpID0+IGxhc3RBcmdzICYmIGludm9rZShsYXN0QXJncyk7XG5cbiAgcmV0dXJuIFt0aHJvdHRsZWQsIGZsdXNoXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdGhyb3R0bGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuLy8gdGVtcG9yYXJ5IGhvdGZpeCB0byBhdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzIHVudGlsIEF4aW9zVVJMU2VhcmNoUGFyYW1zIGlzIHJlZmFjdG9yZWRcbmltcG9ydCBQbGF0Zm9ybUZvcm1EYXRhIGZyb20gJy4uL3BsYXRmb3JtL25vZGUvY2xhc3Nlcy9Gb3JtRGF0YS5qcyc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gdGhpbmcgaXMgYSBhcnJheSBvciBqcyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRoaW5nIC0gVGhlIG9iamVjdCBvciBhcnJheSB0byBiZSB2aXNpdGVkLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1Zpc2l0YWJsZSh0aGluZykge1xuICByZXR1cm4gdXRpbHMuaXNQbGFpbk9iamVjdCh0aGluZykgfHwgdXRpbHMuaXNBcnJheSh0aGluZyk7XG59XG5cbi8qKlxuICogSXQgcmVtb3ZlcyB0aGUgYnJhY2tldHMgZnJvbSB0aGUgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIHBhcmFtZXRlci5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUga2V5IHdpdGhvdXQgdGhlIGJyYWNrZXRzLlxuICovXG5mdW5jdGlvbiByZW1vdmVCcmFja2V0cyhrZXkpIHtcbiAgcmV0dXJuIHV0aWxzLmVuZHNXaXRoKGtleSwgJ1tdJykgPyBrZXkuc2xpY2UoMCwgLTIpIDoga2V5O1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgcGF0aCwgYSBrZXksIGFuZCBhIGJvb2xlYW4sIGFuZCByZXR1cm5zIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBUaGUgcGF0aCB0byB0aGUgY3VycmVudCBrZXkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgY3VycmVudCBvYmplY3QgYmVpbmcgaXRlcmF0ZWQgb3Zlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkb3RzIC0gSWYgdHJ1ZSwgdGhlIGtleSB3aWxsIGJlIHJlbmRlcmVkIHdpdGggZG90cyBpbnN0ZWFkIG9mIGJyYWNrZXRzLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBwYXRoIHRvIHRoZSBjdXJyZW50IGtleS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyS2V5KHBhdGgsIGtleSwgZG90cykge1xuICBpZiAoIXBhdGgpIHJldHVybiBrZXk7XG4gIHJldHVybiBwYXRoLmNvbmNhdChrZXkpLm1hcChmdW5jdGlvbiBlYWNoKHRva2VuLCBpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdG9rZW4gPSByZW1vdmVCcmFja2V0cyh0b2tlbik7XG4gICAgcmV0dXJuICFkb3RzICYmIGkgPyAnWycgKyB0b2tlbiArICddJyA6IHRva2VuO1xuICB9KS5qb2luKGRvdHMgPyAnLicgOiAnJyk7XG59XG5cbi8qKlxuICogSWYgdGhlIGFycmF5IGlzIGFuIGFycmF5IGFuZCBub25lIG9mIGl0cyBlbGVtZW50cyBhcmUgdmlzaXRhYmxlLCB0aGVuIGl0J3MgYSBmbGF0IGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyIC0gVGhlIGFycmF5IHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmxhdEFycmF5KGFycikge1xuICByZXR1cm4gdXRpbHMuaXNBcnJheShhcnIpICYmICFhcnIuc29tZShpc1Zpc2l0YWJsZSk7XG59XG5cbmNvbnN0IHByZWRpY2F0ZXMgPSB1dGlscy50b0ZsYXRPYmplY3QodXRpbHMsIHt9LCBudWxsLCBmdW5jdGlvbiBmaWx0ZXIocHJvcCkge1xuICByZXR1cm4gL15pc1tBLVpdLy50ZXN0KHByb3ApO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIGRhdGEgb2JqZWN0IHRvIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHs/T2JqZWN0fSBbZm9ybURhdGFdXG4gKiBAcGFyYW0gez9PYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmlzaXRvcl1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWV0YVRva2VucyA9IHRydWVdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRvdHMgPSBmYWxzZV1cbiAqIEBwYXJhbSB7P0Jvb2xlYW59IFtvcHRpb25zLmluZGV4ZXMgPSBmYWxzZV1cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICoqL1xuXG4vKipcbiAqIEl0IGNvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgRm9ybURhdGEgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3Q8YW55LCBhbnk+fSBvYmogLSBUaGUgb2JqZWN0IHRvIGNvbnZlcnQgdG8gZm9ybSBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1EYXRhIC0gVGhlIEZvcm1EYXRhIG9iamVjdCB0byBhcHBlbmQgdG8uXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiB0b0Zvcm1EYXRhKG9iaiwgZm9ybURhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKCF1dGlscy5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGFyZ2V0IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgZm9ybURhdGEgPSBmb3JtRGF0YSB8fCBuZXcgKFBsYXRmb3JtRm9ybURhdGEgfHwgRm9ybURhdGEpKCk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIG9wdGlvbnMgPSB1dGlscy50b0ZsYXRPYmplY3Qob3B0aW9ucywge1xuICAgIG1ldGFUb2tlbnM6IHRydWUsXG4gICAgZG90czogZmFsc2UsXG4gICAgaW5kZXhlczogZmFsc2VcbiAgfSwgZmFsc2UsIGZ1bmN0aW9uIGRlZmluZWQob3B0aW9uLCBzb3VyY2UpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgICByZXR1cm4gIXV0aWxzLmlzVW5kZWZpbmVkKHNvdXJjZVtvcHRpb25dKTtcbiAgfSk7XG5cbiAgY29uc3QgbWV0YVRva2VucyA9IG9wdGlvbnMubWV0YVRva2VucztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIGNvbnN0IHZpc2l0b3IgPSBvcHRpb25zLnZpc2l0b3IgfHwgZGVmYXVsdFZpc2l0b3I7XG4gIGNvbnN0IGRvdHMgPSBvcHRpb25zLmRvdHM7XG4gIGNvbnN0IGluZGV4ZXMgPSBvcHRpb25zLmluZGV4ZXM7XG4gIGNvbnN0IF9CbG9iID0gb3B0aW9ucy5CbG9iIHx8IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBCbG9iO1xuICBjb25zdCB1c2VCbG9iID0gX0Jsb2IgJiYgdXRpbHMuaXNTcGVjQ29tcGxpYW50Rm9ybShmb3JtRGF0YSk7XG5cbiAgaWYgKCF1dGlscy5pc0Z1bmN0aW9uKHZpc2l0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmlzaXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuICcnO1xuXG4gICAgaWYgKHV0aWxzLmlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b0lTT1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0Jvb2xlYW4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoIXVzZUJsb2IgJiYgdXRpbHMuaXNCbG9iKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ0Jsb2IgaXMgbm90IHN1cHBvcnRlZC4gVXNlIGEgQnVmZmVyIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXIodmFsdWUpIHx8IHV0aWxzLmlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB1c2VCbG9iICYmIHR5cGVvZiBCbG9iID09PSAnZnVuY3Rpb24nID8gbmV3IEJsb2IoW3ZhbHVlXSkgOiBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgdmlzaXRvci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGtleVxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZ3xOdW1iZXI+fSBwYXRoXG4gICAqIEB0aGlzIHtGb3JtRGF0YX1cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybiB0cnVlIHRvIHZpc2l0IHRoZSBlYWNoIHByb3Agb2YgdGhlIHZhbHVlIHJlY3Vyc2l2ZWx5XG4gICAqL1xuICBmdW5jdGlvbiBkZWZhdWx0VmlzaXRvcih2YWx1ZSwga2V5LCBwYXRoKSB7XG4gICAgbGV0IGFyciA9IHZhbHVlO1xuXG4gICAgaWYgKHZhbHVlICYmICFwYXRoICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh1dGlscy5lbmRzV2l0aChrZXksICd7fScpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBrZXkgPSBtZXRhVG9rZW5zID8ga2V5IDoga2V5LnNsaWNlKDAsIC0yKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgKHV0aWxzLmlzQXJyYXkodmFsdWUpICYmIGlzRmxhdEFycmF5KHZhbHVlKSkgfHxcbiAgICAgICAgKCh1dGlscy5pc0ZpbGVMaXN0KHZhbHVlKSB8fCB1dGlscy5lbmRzV2l0aChrZXksICdbXScpKSAmJiAoYXJyID0gdXRpbHMudG9BcnJheSh2YWx1ZSkpXG4gICAgICAgICkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGtleSA9IHJlbW92ZUJyYWNrZXRzKGtleSk7XG5cbiAgICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24gZWFjaChlbCwgaW5kZXgpIHtcbiAgICAgICAgICAhKHV0aWxzLmlzVW5kZWZpbmVkKGVsKSB8fCBlbCA9PT0gbnVsbCkgJiYgZm9ybURhdGEuYXBwZW5kKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBpbmRleGVzID09PSB0cnVlID8gcmVuZGVyS2V5KFtrZXldLCBpbmRleCwgZG90cykgOiAoaW5kZXhlcyA9PT0gbnVsbCA/IGtleSA6IGtleSArICdbXScpLFxuICAgICAgICAgICAgY29udmVydFZhbHVlKGVsKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzVmlzaXRhYmxlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9ybURhdGEuYXBwZW5kKHJlbmRlcktleShwYXRoLCBrZXksIGRvdHMpLCBjb252ZXJ0VmFsdWUodmFsdWUpKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHN0YWNrID0gW107XG5cbiAgY29uc3QgZXhwb3NlZEhlbHBlcnMgPSBPYmplY3QuYXNzaWduKHByZWRpY2F0ZXMsIHtcbiAgICBkZWZhdWx0VmlzaXRvcixcbiAgICBjb252ZXJ0VmFsdWUsXG4gICAgaXNWaXNpdGFibGVcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYnVpbGQodmFsdWUsIHBhdGgpIHtcbiAgICBpZiAodXRpbHMuaXNVbmRlZmluZWQodmFsdWUpKSByZXR1cm47XG5cbiAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkIGluICcgKyBwYXRoLmpvaW4oJy4nKSk7XG4gICAgfVxuXG4gICAgc3RhY2sucHVzaCh2YWx1ZSk7XG5cbiAgICB1dGlscy5mb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiBlYWNoKGVsLCBrZXkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9ICEodXRpbHMuaXNVbmRlZmluZWQoZWwpIHx8IGVsID09PSBudWxsKSAmJiB2aXNpdG9yLmNhbGwoXG4gICAgICAgIGZvcm1EYXRhLCBlbCwgdXRpbHMuaXNTdHJpbmcoa2V5KSA/IGtleS50cmltKCkgOiBrZXksIHBhdGgsIGV4cG9zZWRIZWxwZXJzXG4gICAgICApO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgIGJ1aWxkKGVsLCBwYXRoID8gcGF0aC5jb25jYXQoa2V5KSA6IFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0YWNrLnBvcCgpO1xuICB9XG5cbiAgaWYgKCF1dGlscy5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgYnVpbGQob2JqKTtcblxuICByZXR1cm4gZm9ybURhdGE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvRm9ybURhdGE7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuL3RvRm9ybURhdGEuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9VUkxFbmNvZGVkRm9ybShkYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b0Zvcm1EYXRhKGRhdGEsIG5ldyBwbGF0Zm9ybS5jbGFzc2VzLlVSTFNlYXJjaFBhcmFtcygpLCB7XG4gICAgdmlzaXRvcjogZnVuY3Rpb24odmFsdWUsIGtleSwgcGF0aCwgaGVscGVycykge1xuICAgICAgaWYgKHBsYXRmb3JtLmlzTm9kZSAmJiB1dGlscy5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoa2V5LCB2YWx1ZS50b1N0cmluZygnYmFzZTY0JykpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoZWxwZXJzLmRlZmF1bHRWaXNpdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICAuLi5vcHRpb25zXG4gIH0pO1xufVxuIiwiXG5leHBvcnQgY29uc3Qgc3RyZWFtQ2h1bmsgPSBmdW5jdGlvbiogKGNodW5rLCBjaHVua1NpemUpIHtcbiAgbGV0IGxlbiA9IGNodW5rLmJ5dGVMZW5ndGg7XG5cbiAgaWYgKCFjaHVua1NpemUgfHwgbGVuIDwgY2h1bmtTaXplKSB7XG4gICAgeWllbGQgY2h1bms7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IHBvcyA9IDA7XG4gIGxldCBlbmQ7XG5cbiAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgIGVuZCA9IHBvcyArIGNodW5rU2l6ZTtcbiAgICB5aWVsZCBjaHVuay5zbGljZShwb3MsIGVuZCk7XG4gICAgcG9zID0gZW5kO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCByZWFkQnl0ZXMgPSBhc3luYyBmdW5jdGlvbiogKGl0ZXJhYmxlLCBjaHVua1NpemUpIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZWFkU3RyZWFtKGl0ZXJhYmxlKSkge1xuICAgIHlpZWxkKiBzdHJlYW1DaHVuayhjaHVuaywgY2h1bmtTaXplKTtcbiAgfVxufVxuXG5jb25zdCByZWFkU3RyZWFtID0gYXN5bmMgZnVuY3Rpb24qIChzdHJlYW0pIHtcbiAgaWYgKHN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHtcbiAgICB5aWVsZCogc3RyZWFtO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgdHJ5IHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCB7ZG9uZSwgdmFsdWV9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgeWllbGQgdmFsdWU7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IHJlYWRlci5jYW5jZWwoKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdHJhY2tTdHJlYW0gPSAoc3RyZWFtLCBjaHVua1NpemUsIG9uUHJvZ3Jlc3MsIG9uRmluaXNoKSA9PiB7XG4gIGNvbnN0IGl0ZXJhdG9yID0gcmVhZEJ5dGVzKHN0cmVhbSwgY2h1bmtTaXplKTtcblxuICBsZXQgYnl0ZXMgPSAwO1xuICBsZXQgZG9uZTtcbiAgbGV0IF9vbkZpbmlzaCA9IChlKSA9PiB7XG4gICAgaWYgKCFkb25lKSB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIG9uRmluaXNoICYmIG9uRmluaXNoKGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qge2RvbmUsIHZhbHVlfSA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgX29uRmluaXNoKCk7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZW4gPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgIGxldCBsb2FkZWRCeXRlcyA9IGJ5dGVzICs9IGxlbjtcbiAgICAgICAgICBvblByb2dyZXNzKGxvYWRlZEJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfb25GaW5pc2goZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FuY2VsKHJlYXNvbikge1xuICAgICAgX29uRmluaXNoKHJlYXNvbik7XG4gICAgICByZXR1cm4gaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgfVxuICB9LCB7XG4gICAgaGlnaFdhdGVyTWFyazogMlxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge1ZFUlNJT059IGZyb20gJy4uL2Vudi9kYXRhLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5cbmNvbnN0IHZhbGlkYXRvcnMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ2Z1bmN0aW9uJywgJ3N0cmluZycsICdzeW1ib2wnXS5mb3JFYWNoKCh0eXBlLCBpKSA9PiB7XG4gIHZhbGlkYXRvcnNbdHlwZV0gPSBmdW5jdGlvbiB2YWxpZGF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcbiAgfTtcbn0pO1xuXG5jb25zdCBkZXByZWNhdGVkV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBUcmFuc2l0aW9uYWwgb3B0aW9uIHZhbGlkYXRvclxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb258Ym9vbGVhbj99IHZhbGlkYXRvciAtIHNldCB0byBmYWxzZSBpZiB0aGUgdHJhbnNpdGlvbmFsIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkXG4gKiBAcGFyYW0ge3N0cmluZz99IHZlcnNpb24gLSBkZXByZWNhdGVkIHZlcnNpb24gLyByZW1vdmVkIHNpbmNlIHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nP30gbWVzc2FnZSAtIHNvbWUgbWVzc2FnZSB3aXRoIGFkZGl0aW9uYWwgaW5mb1xuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xudmFsaWRhdG9ycy50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbiB0cmFuc2l0aW9uYWwodmFsaWRhdG9yLCB2ZXJzaW9uLCBtZXNzYWdlKSB7XG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XG4gICAgcmV0dXJuICdbQXhpb3MgdicgKyBWRVJTSU9OICsgJ10gVHJhbnNpdGlvbmFsIG9wdGlvbiBcXCcnICsgb3B0ICsgJ1xcJycgKyBkZXNjICsgKG1lc3NhZ2UgPyAnLiAnICsgbWVzc2FnZSA6ICcnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiAodmFsdWUsIG9wdCwgb3B0cykgPT4ge1xuICAgIGlmICh2YWxpZGF0b3IgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShvcHQsICcgaGFzIGJlZW4gcmVtb3ZlZCcgKyAodmVyc2lvbiA/ICcgaW4gJyArIHZlcnNpb24gOiAnJykpLFxuICAgICAgICBBeGlvc0Vycm9yLkVSUl9ERVBSRUNBVEVEXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG52YWxpZGF0b3JzLnNwZWxsaW5nID0gZnVuY3Rpb24gc3BlbGxpbmcoY29ycmVjdFNwZWxsaW5nKSB7XG4gIHJldHVybiAodmFsdWUsIG9wdCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKGAke29wdH0gaXMgbGlrZWx5IGEgbWlzc3BlbGxpbmcgb2YgJHtjb3JyZWN0U3BlbGxpbmd9YCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8qKlxuICogQXNzZXJ0IG9iamVjdCdzIHByb3BlcnRpZXMgdHlwZVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBhbGxvd1Vua25vd25cbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGFzc2VydE9wdGlvbnMob3B0aW9ucywgc2NoZW1hLCBhbGxvd1Vua25vd24pIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0JywgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTl9WQUxVRSk7XG4gIH1cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIGNvbnN0IG9wdCA9IGtleXNbaV07XG4gICAgY29uc3QgdmFsaWRhdG9yID0gc2NoZW1hW29wdF07XG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zW29wdF07XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRpb25zKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ29wdGlvbiAnICsgb3B0ICsgJyBtdXN0IGJlICcgKyByZXN1bHQsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChhbGxvd1Vua25vd24gIT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdVbmtub3duIG9wdGlvbiAnICsgb3B0LCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBhc3NlcnRPcHRpb25zLFxuICB2YWxpZGF0b3JzXG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydCBkZWZhdWx0IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyA/IEJsb2IgOiBudWxsXG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBGb3JtRGF0YSA6IG51bGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBeGlvc1VSTFNlYXJjaFBhcmFtcyBmcm9tICcuLi8uLi8uLi9oZWxwZXJzL0F4aW9zVVJMU2VhcmNoUGFyYW1zLmpzJztcbmV4cG9ydCBkZWZhdWx0IHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnID8gVVJMU2VhcmNoUGFyYW1zIDogQXhpb3NVUkxTZWFyY2hQYXJhbXM7XG4iLCJpbXBvcnQgVVJMU2VhcmNoUGFyYW1zIGZyb20gJy4vY2xhc3Nlcy9VUkxTZWFyY2hQYXJhbXMuanMnXG5pbXBvcnQgRm9ybURhdGEgZnJvbSAnLi9jbGFzc2VzL0Zvcm1EYXRhLmpzJ1xuaW1wb3J0IEJsb2IgZnJvbSAnLi9jbGFzc2VzL0Jsb2IuanMnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNCcm93c2VyOiB0cnVlLFxuICBjbGFzc2VzOiB7XG4gICAgVVJMU2VhcmNoUGFyYW1zLFxuICAgIEZvcm1EYXRhLFxuICAgIEJsb2JcbiAgfSxcbiAgcHJvdG9jb2xzOiBbJ2h0dHAnLCAnaHR0cHMnLCAnZmlsZScsICdibG9iJywgJ3VybCcsICdkYXRhJ11cbn07XG4iLCJjb25zdCBoYXNCcm93c2VyRW52ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuY29uc3QgX25hdmlnYXRvciA9IHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvciB8fCB1bmRlZmluZWQ7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBoYXNTdGFuZGFyZEJyb3dzZXJFbnYgPSBoYXNCcm93c2VyRW52ICYmXG4gICghX25hdmlnYXRvciB8fCBbJ1JlYWN0TmF0aXZlJywgJ05hdGl2ZVNjcmlwdCcsICdOUyddLmluZGV4T2YoX25hdmlnYXRvci5wcm9kdWN0KSA8IDApO1xuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciB3ZWJXb3JrZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBBbHRob3VnaCB0aGUgYGlzU3RhbmRhcmRCcm93c2VyRW52YCBtZXRob2QgaW5kaWNhdGVzIHRoYXRcbiAqIGBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlcmAsIHRoZSBXZWJXb3JrZXIgd2lsbCBzdGlsbCBiZVxuICogZmlsdGVyZWQgb3V0IGR1ZSB0byBpdHMganVkZ21lbnQgc3RhbmRhcmRcbiAqIGB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnYC5cbiAqIFRoaXMgbGVhZHMgdG8gYSBwcm9ibGVtIHdoZW4gYXhpb3MgcG9zdCBgRm9ybURhdGFgIGluIHdlYldvcmtlclxuICovXG5jb25zdCBoYXNTdGFuZGFyZEJyb3dzZXJXZWJXb3JrZXJFbnYgPSAoKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUgJiZcbiAgICB0eXBlb2Ygc2VsZi5pbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nXG4gICk7XG59KSgpO1xuXG5jb25zdCBvcmlnaW4gPSBoYXNCcm93c2VyRW52ICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICdodHRwOi8vbG9jYWxob3N0JztcblxuZXhwb3J0IHtcbiAgaGFzQnJvd3NlckVudixcbiAgaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52LFxuICBoYXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIF9uYXZpZ2F0b3IgYXMgbmF2aWdhdG9yLFxuICBvcmlnaW5cbn1cbiIsImltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL25vZGUvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi9jb21tb24vdXRpbHMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIC4uLnV0aWxzLFxuICAuLi5wbGF0Zm9ybVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgYmluZCBmcm9tICcuL2hlbHBlcnMvYmluZC5qcyc7XG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbmNvbnN0IHt0b1N0cmluZ30gPSBPYmplY3QucHJvdG90eXBlO1xuY29uc3Qge2dldFByb3RvdHlwZU9mfSA9IE9iamVjdDtcbmNvbnN0IHtpdGVyYXRvciwgdG9TdHJpbmdUYWd9ID0gU3ltYm9sO1xuXG5jb25zdCBraW5kT2YgPSAoY2FjaGUgPT4gdGhpbmcgPT4ge1xuICAgIGNvbnN0IHN0ciA9IHRvU3RyaW5nLmNhbGwodGhpbmcpO1xuICAgIHJldHVybiBjYWNoZVtzdHJdIHx8IChjYWNoZVtzdHJdID0gc3RyLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpKTtcbn0pKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG5jb25zdCBraW5kT2ZUZXN0ID0gKHR5cGUpID0+IHtcbiAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuICh0aGluZykgPT4ga2luZE9mKHRoaW5nKSA9PT0gdHlwZVxufVxuXG5jb25zdCB0eXBlT2ZUZXN0ID0gdHlwZSA9PiB0aGluZyA9PiB0eXBlb2YgdGhpbmcgPT09IHR5cGU7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCB7aXNBcnJheX0gPSBBcnJheTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1VuZGVmaW5lZCA9IHR5cGVPZlRlc3QoJ3VuZGVmaW5lZCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIGlzRnVuY3Rpb24odmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKSAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0FycmF5QnVmZmVyID0ga2luZE9mVGVzdCgnQXJyYXlCdWZmZXInKTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIGxldCByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKGlzQXJyYXlCdWZmZXIodmFsLmJ1ZmZlcikpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNTdHJpbmcgPSB0eXBlT2ZUZXN0KCdzdHJpbmcnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Z1bmN0aW9uID0gdHlwZU9mVGVzdCgnZnVuY3Rpb24nKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc051bWJlciA9IHR5cGVPZlRlc3QoJ251bWJlcicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgIT09IG51bGwgJiYgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJvb2xlYW5cbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJvb2xlYW4sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Jvb2xlYW4gPSB0aGluZyA9PiB0aGluZyA9PT0gdHJ1ZSB8fCB0aGluZyA9PT0gZmFsc2U7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHtcbiAgaWYgKGtpbmRPZih2YWwpICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgISh0b1N0cmluZ1RhZyBpbiB2YWwpICYmICEoaXRlcmF0b3IgaW4gdmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBlbXB0eSBvYmplY3QgKHNhZmVseSBoYW5kbGVzIEJ1ZmZlcnMpXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBlbXB0eSBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0VtcHR5T2JqZWN0ID0gKHZhbCkgPT4ge1xuICAvLyBFYXJseSByZXR1cm4gZm9yIG5vbi1vYmplY3RzIG9yIEJ1ZmZlcnMgdG8gcHJldmVudCBSYW5nZUVycm9yXG4gIGlmICghaXNPYmplY3QodmFsKSB8fCBpc0J1ZmZlcih2YWwpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModmFsKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCkgPT09IE9iamVjdC5wcm90b3R5cGU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBGYWxsYmFjayBmb3IgYW55IG90aGVyIG9iamVjdHMgdGhhdCBtaWdodCBjYXVzZSBSYW5nZUVycm9yIHdpdGggT2JqZWN0LmtleXMoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNEYXRlID0ga2luZE9mVGVzdCgnRGF0ZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGaWxlID0ga2luZE9mVGVzdCgnRmlsZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNCbG9iID0ga2luZE9mVGVzdCgnQmxvYicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZUxpc3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRmlsZUxpc3QgPSBraW5kT2ZUZXN0KCdGaWxlTGlzdCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzU3RyZWFtID0gKHZhbCkgPT4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGb3JtRGF0YSA9ICh0aGluZykgPT4ge1xuICBsZXQga2luZDtcbiAgcmV0dXJuIHRoaW5nICYmIChcbiAgICAodHlwZW9mIEZvcm1EYXRhID09PSAnZnVuY3Rpb24nICYmIHRoaW5nIGluc3RhbmNlb2YgRm9ybURhdGEpIHx8IChcbiAgICAgIGlzRnVuY3Rpb24odGhpbmcuYXBwZW5kKSAmJiAoXG4gICAgICAgIChraW5kID0ga2luZE9mKHRoaW5nKSkgPT09ICdmb3JtZGF0YScgfHxcbiAgICAgICAgLy8gZGV0ZWN0IGZvcm0tZGF0YSBpbnN0YW5jZVxuICAgICAgICAoa2luZCA9PT0gJ29iamVjdCcgJiYgaXNGdW5jdGlvbih0aGluZy50b1N0cmluZykgJiYgdGhpbmcudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgRm9ybURhdGFdJylcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzVVJMU2VhcmNoUGFyYW1zID0ga2luZE9mVGVzdCgnVVJMU2VhcmNoUGFyYW1zJyk7XG5cbmNvbnN0IFtpc1JlYWRhYmxlU3RyZWFtLCBpc1JlcXVlc3QsIGlzUmVzcG9uc2UsIGlzSGVhZGVyc10gPSBbJ1JlYWRhYmxlU3RyZWFtJywgJ1JlcXVlc3QnLCAnUmVzcG9uc2UnLCAnSGVhZGVycyddLm1hcChraW5kT2ZUZXN0KTtcblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuY29uc3QgdHJpbSA9IChzdHIpID0+IHN0ci50cmltID9cbiAgc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbYWxsT3duS2V5cyA9IGZhbHNlXVxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuLCB7YWxsT3duS2V5cyA9IGZhbHNlfSA9IHt9KSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGk7XG4gIGxldCBsO1xuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yIChpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBCdWZmZXIgY2hlY2tcbiAgICBpZiAoaXNCdWZmZXIob2JqKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGNvbnN0IGtleXMgPSBhbGxPd25LZXlzID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKSA6IE9iamVjdC5rZXlzKG9iaik7XG4gICAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGtleTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEtleShvYmosIGtleSkge1xuICBpZiAoaXNCdWZmZXIob2JqKSl7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gIGxldCBfa2V5O1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIF9rZXkgPSBrZXlzW2ldO1xuICAgIGlmIChrZXkgPT09IF9rZXkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgcmV0dXJuIF9rZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBfZ2xvYmFsID0gKCgpID0+IHtcbiAgLyplc2xpbnQgbm8tdW5kZWY6MCovXG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGdsb2JhbFRoaXM7XG4gIHJldHVybiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpXG59KSgpO1xuXG5jb25zdCBpc0NvbnRleHREZWZpbmVkID0gKGNvbnRleHQpID0+ICFpc1VuZGVmaW5lZChjb250ZXh0KSAmJiBjb250ZXh0ICE9PSBfZ2xvYmFsO1xuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gIGNvbnN0IHtjYXNlbGVzcywgc2tpcFVuZGVmaW5lZH0gPSBpc0NvbnRleHREZWZpbmVkKHRoaXMpICYmIHRoaXMgfHwge307XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBhc3NpZ25WYWx1ZSA9ICh2YWwsIGtleSkgPT4ge1xuICAgIGNvbnN0IHRhcmdldEtleSA9IGNhc2VsZXNzICYmIGZpbmRLZXkocmVzdWx0LCBrZXkpIHx8IGtleTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXN1bHRbdGFyZ2V0S2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRbdGFyZ2V0S2V5XSA9IG1lcmdlKHJlc3VsdFt0YXJnZXRLZXldLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRbdGFyZ2V0S2V5XSA9IG1lcmdlKHt9LCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXN1bHRbdGFyZ2V0S2V5XSA9IHZhbC5zbGljZSgpO1xuICAgIH0gZWxzZSBpZiAoIXNraXBVbmRlZmluZWQgfHwgIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGFyZ3VtZW50c1tpXSAmJiBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxPd25LZXlzXVxuICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5jb25zdCBleHRlbmQgPSAoYSwgYiwgdGhpc0FyZywge2FsbE93bktleXN9PSB7fSkgPT4ge1xuICBmb3JFYWNoKGIsICh2YWwsIGtleSkgPT4ge1xuICAgIGlmICh0aGlzQXJnICYmIGlzRnVuY3Rpb24odmFsKSkge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9LCB7YWxsT3duS2V5c30pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuY29uc3Qgc3RyaXBCT00gPSAoY29udGVudCkgPT4ge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW3Byb3BzXVxuICogQHBhcmFtIHtvYmplY3R9IFtkZXNjcmlwdG9yc11cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuY29uc3QgaW5oZXJpdHMgPSAoY29uc3RydWN0b3IsIHN1cGVyQ29uc3RydWN0b3IsIHByb3BzLCBkZXNjcmlwdG9ycykgPT4ge1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlLCBkZXNjcmlwdG9ycyk7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc3RydWN0b3IsICdzdXBlcicsIHtcbiAgICB2YWx1ZTogc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGVcbiAgfSk7XG4gIHByb3BzICYmIE9iamVjdC5hc3NpZ24oY29uc3RydWN0b3IucHJvdG90eXBlLCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBvYmplY3Qgd2l0aCBkZWVwIHByb3RvdHlwZSBjaGFpbiB0byBhIGZsYXQgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlT2JqIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGVzdE9ial1cbiAqIEBwYXJhbSB7RnVuY3Rpb258Qm9vbGVhbn0gW2ZpbHRlcl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wRmlsdGVyXVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmNvbnN0IHRvRmxhdE9iamVjdCA9IChzb3VyY2VPYmosIGRlc3RPYmosIGZpbHRlciwgcHJvcEZpbHRlcikgPT4ge1xuICBsZXQgcHJvcHM7XG4gIGxldCBpO1xuICBsZXQgcHJvcDtcbiAgY29uc3QgbWVyZ2VkID0ge307XG5cbiAgZGVzdE9iaiA9IGRlc3RPYmogfHwge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICBpZiAoc291cmNlT2JqID09IG51bGwpIHJldHVybiBkZXN0T2JqO1xuXG4gIGRvIHtcbiAgICBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZU9iaik7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKCghcHJvcEZpbHRlciB8fCBwcm9wRmlsdGVyKHByb3AsIHNvdXJjZU9iaiwgZGVzdE9iaikpICYmICFtZXJnZWRbcHJvcF0pIHtcbiAgICAgICAgZGVzdE9ialtwcm9wXSA9IHNvdXJjZU9ialtwcm9wXTtcbiAgICAgICAgbWVyZ2VkW3Byb3BdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlT2JqID0gZmlsdGVyICE9PSBmYWxzZSAmJiBnZXRQcm90b3R5cGVPZihzb3VyY2VPYmopO1xuICB9IHdoaWxlIChzb3VyY2VPYmogJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKHNvdXJjZU9iaiwgZGVzdE9iaikpICYmIHNvdXJjZU9iaiAhPT0gT2JqZWN0LnByb3RvdHlwZSk7XG5cbiAgcmV0dXJuIGRlc3RPYmo7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3RyaW5nIGVuZHMgd2l0aCB0aGUgY2hhcmFjdGVycyBvZiBhIHNwZWNpZmllZCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uPSAwXVxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBlbmRzV2l0aCA9IChzdHIsIHNlYXJjaFN0cmluZywgcG9zaXRpb24pID0+IHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uID4gc3RyLmxlbmd0aCkge1xuICAgIHBvc2l0aW9uID0gc3RyLmxlbmd0aDtcbiAgfVxuICBwb3NpdGlvbiAtPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICBjb25zdCBsYXN0SW5kZXggPSBzdHIuaW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKTtcbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gLTEgJiYgbGFzdEluZGV4ID09PSBwb3NpdGlvbjtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgbmV3IGFycmF5IGZyb20gYXJyYXkgbGlrZSBvYmplY3Qgb3IgbnVsbCBpZiBmYWlsZWRcbiAqXG4gKiBAcGFyYW0geyp9IFt0aGluZ11cbiAqXG4gKiBAcmV0dXJucyB7P0FycmF5fVxuICovXG5jb25zdCB0b0FycmF5ID0gKHRoaW5nKSA9PiB7XG4gIGlmICghdGhpbmcpIHJldHVybiBudWxsO1xuICBpZiAoaXNBcnJheSh0aGluZykpIHJldHVybiB0aGluZztcbiAgbGV0IGkgPSB0aGluZy5sZW5ndGg7XG4gIGlmICghaXNOdW1iZXIoaSkpIHJldHVybiBudWxsO1xuICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgYXJyW2ldID0gdGhpbmdbaV07XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBDaGVja2luZyBpZiB0aGUgVWludDhBcnJheSBleGlzdHMgYW5kIGlmIGl0IGRvZXMsIGl0IHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0aGVcbiAqIHRoaW5nIHBhc3NlZCBpbiBpcyBhbiBpbnN0YW5jZSBvZiBVaW50OEFycmF5XG4gKlxuICogQHBhcmFtIHtUeXBlZEFycmF5fVxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbmNvbnN0IGlzVHlwZWRBcnJheSA9IChUeXBlZEFycmF5ID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIHRoaW5nID0+IHtcbiAgICByZXR1cm4gVHlwZWRBcnJheSAmJiB0aGluZyBpbnN0YW5jZW9mIFR5cGVkQXJyYXk7XG4gIH07XG59KSh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheSkpO1xuXG4vKipcbiAqIEZvciBlYWNoIGVudHJ5IGluIHRoZSBvYmplY3QsIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGtleSBhbmQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8YW55LCBhbnk+fSBvYmogLSBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggZW50cnkuXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmNvbnN0IGZvckVhY2hFbnRyeSA9IChvYmosIGZuKSA9PiB7XG4gIGNvbnN0IGdlbmVyYXRvciA9IG9iaiAmJiBvYmpbaXRlcmF0b3JdO1xuXG4gIGNvbnN0IF9pdGVyYXRvciA9IGdlbmVyYXRvci5jYWxsKG9iaik7XG5cbiAgbGV0IHJlc3VsdDtcblxuICB3aGlsZSAoKHJlc3VsdCA9IF9pdGVyYXRvci5uZXh0KCkpICYmICFyZXN1bHQuZG9uZSkge1xuICAgIGNvbnN0IHBhaXIgPSByZXN1bHQudmFsdWU7XG4gICAgZm4uY2FsbChvYmosIHBhaXJbMF0sIHBhaXJbMV0pO1xuICB9XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gYW5kIGEgc3RyaW5nLCBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIG1hdGNoZXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnRXhwIC0gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBhZ2FpbnN0LlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gc2VhcmNoLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheTxib29sZWFuPn1cbiAqL1xuY29uc3QgbWF0Y2hBbGwgPSAocmVnRXhwLCBzdHIpID0+IHtcbiAgbGV0IG1hdGNoZXM7XG4gIGNvbnN0IGFyciA9IFtdO1xuXG4gIHdoaWxlICgobWF0Y2hlcyA9IHJlZ0V4cC5leGVjKHN0cikpICE9PSBudWxsKSB7XG4gICAgYXJyLnB1c2gobWF0Y2hlcyk7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufVxuXG4vKiBDaGVja2luZyBpZiB0aGUga2luZE9mVGVzdCBmdW5jdGlvbiByZXR1cm5zIHRydWUgd2hlbiBwYXNzZWQgYW4gSFRNTEZvcm1FbGVtZW50LiAqL1xuY29uc3QgaXNIVE1MRm9ybSA9IGtpbmRPZlRlc3QoJ0hUTUxGb3JtRWxlbWVudCcpO1xuXG5jb25zdCB0b0NhbWVsQ2FzZSA9IHN0ciA9PiB7XG4gIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9cXHNdKFthLXpcXGRdKShcXHcqKS9nLFxuICAgIGZ1bmN0aW9uIHJlcGxhY2VyKG0sIHAxLCBwMikge1xuICAgICAgcmV0dXJuIHAxLnRvVXBwZXJDYXNlKCkgKyBwMjtcbiAgICB9XG4gICk7XG59O1xuXG4vKiBDcmVhdGluZyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBjaGVjayBpZiBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuICovXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9ICgoe2hhc093blByb3BlcnR5fSkgPT4gKG9iaiwgcHJvcCkgPT4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKShPYmplY3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzUmVnRXhwID0ga2luZE9mVGVzdCgnUmVnRXhwJyk7XG5cbmNvbnN0IHJlZHVjZURlc2NyaXB0b3JzID0gKG9iaiwgcmVkdWNlcikgPT4ge1xuICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaik7XG4gIGNvbnN0IHJlZHVjZWREZXNjcmlwdG9ycyA9IHt9O1xuXG4gIGZvckVhY2goZGVzY3JpcHRvcnMsIChkZXNjcmlwdG9yLCBuYW1lKSA9PiB7XG4gICAgbGV0IHJldDtcbiAgICBpZiAoKHJldCA9IHJlZHVjZXIoZGVzY3JpcHRvciwgbmFtZSwgb2JqKSkgIT09IGZhbHNlKSB7XG4gICAgICByZWR1Y2VkRGVzY3JpcHRvcnNbbmFtZV0gPSByZXQgfHwgZGVzY3JpcHRvcjtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iaiwgcmVkdWNlZERlc2NyaXB0b3JzKTtcbn1cblxuLyoqXG4gKiBNYWtlcyBhbGwgbWV0aG9kcyByZWFkLW9ubHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5jb25zdCBmcmVlemVNZXRob2RzID0gKG9iaikgPT4ge1xuICByZWR1Y2VEZXNjcmlwdG9ycyhvYmosIChkZXNjcmlwdG9yLCBuYW1lKSA9PiB7XG4gICAgLy8gc2tpcCByZXN0cmljdGVkIHByb3BzIGluIHN0cmljdCBtb2RlXG4gICAgaWYgKGlzRnVuY3Rpb24ob2JqKSAmJiBbJ2FyZ3VtZW50cycsICdjYWxsZXInLCAnY2FsbGVlJ10uaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IG9ialtuYW1lXTtcblxuICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybjtcblxuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCd3cml0YWJsZScgaW4gZGVzY3JpcHRvcikge1xuICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0ID0gKCkgPT4ge1xuICAgICAgICB0aHJvdyBFcnJvcignQ2FuIG5vdCByZXdyaXRlIHJlYWQtb25seSBtZXRob2QgXFwnJyArIG5hbWUgKyAnXFwnJyk7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IHRvT2JqZWN0U2V0ID0gKGFycmF5T3JTdHJpbmcsIGRlbGltaXRlcikgPT4ge1xuICBjb25zdCBvYmogPSB7fTtcblxuICBjb25zdCBkZWZpbmUgPSAoYXJyKSA9PiB7XG4gICAgYXJyLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgb2JqW3ZhbHVlXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cblxuICBpc0FycmF5KGFycmF5T3JTdHJpbmcpID8gZGVmaW5lKGFycmF5T3JTdHJpbmcpIDogZGVmaW5lKFN0cmluZyhhcnJheU9yU3RyaW5nKS5zcGxpdChkZWxpbWl0ZXIpKTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5jb25zdCBub29wID0gKCkgPT4ge31cblxuY29uc3QgdG9GaW5pdGVOdW1iZXIgPSAodmFsdWUsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUgPSArdmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cblxuXG4vKipcbiAqIElmIHRoZSB0aGluZyBpcyBhIEZvcm1EYXRhIG9iamVjdCwgcmV0dXJuIHRydWUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSB0aGluZyAtIFRoZSB0aGluZyB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTcGVjQ29tcGxpYW50Rm9ybSh0aGluZykge1xuICByZXR1cm4gISEodGhpbmcgJiYgaXNGdW5jdGlvbih0aGluZy5hcHBlbmQpICYmIHRoaW5nW3RvU3RyaW5nVGFnXSA9PT0gJ0Zvcm1EYXRhJyAmJiB0aGluZ1tpdGVyYXRvcl0pO1xufVxuXG5jb25zdCB0b0pTT05PYmplY3QgPSAob2JqKSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gbmV3IEFycmF5KDEwKTtcblxuICBjb25zdCB2aXNpdCA9IChzb3VyY2UsIGkpID0+IHtcblxuICAgIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgICBpZiAoc3RhY2suaW5kZXhPZihzb3VyY2UpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvL0J1ZmZlciBjaGVja1xuICAgICAgaWYgKGlzQnVmZmVyKHNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgIH1cblxuICAgICAgaWYoISgndG9KU09OJyBpbiBzb3VyY2UpKSB7XG4gICAgICAgIHN0YWNrW2ldID0gc291cmNlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBpc0FycmF5KHNvdXJjZSkgPyBbXSA6IHt9O1xuXG4gICAgICAgIGZvckVhY2goc291cmNlLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlZHVjZWRWYWx1ZSA9IHZpc2l0KHZhbHVlLCBpICsgMSk7XG4gICAgICAgICAgIWlzVW5kZWZpbmVkKHJlZHVjZWRWYWx1ZSkgJiYgKHRhcmdldFtrZXldID0gcmVkdWNlZFZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RhY2tbaV0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgcmV0dXJuIHZpc2l0KG9iaiwgMCk7XG59XG5cbmNvbnN0IGlzQXN5bmNGbiA9IGtpbmRPZlRlc3QoJ0FzeW5jRnVuY3Rpb24nKTtcblxuY29uc3QgaXNUaGVuYWJsZSA9ICh0aGluZykgPT5cbiAgdGhpbmcgJiYgKGlzT2JqZWN0KHRoaW5nKSB8fCBpc0Z1bmN0aW9uKHRoaW5nKSkgJiYgaXNGdW5jdGlvbih0aGluZy50aGVuKSAmJiBpc0Z1bmN0aW9uKHRoaW5nLmNhdGNoKTtcblxuLy8gb3JpZ2luYWwgY29kZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0RpZ2l0YWxCcmFpbkpTL0F4aW9zUHJvbWlzZS9ibG9iLzE2ZGVhYjEzNzEwZWMwOTc3OTkyMjEzMWYzZmE1OTU0MzIwZjgzYWIvbGliL3V0aWxzLmpzI0wxMS1MMzRcblxuY29uc3QgX3NldEltbWVkaWF0ZSA9ICgoc2V0SW1tZWRpYXRlU3VwcG9ydGVkLCBwb3N0TWVzc2FnZVN1cHBvcnRlZCkgPT4ge1xuICBpZiAoc2V0SW1tZWRpYXRlU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIHNldEltbWVkaWF0ZTtcbiAgfVxuXG4gIHJldHVybiBwb3N0TWVzc2FnZVN1cHBvcnRlZCA/ICgodG9rZW4sIGNhbGxiYWNrcykgPT4ge1xuICAgIF9nbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKHtzb3VyY2UsIGRhdGF9KSA9PiB7XG4gICAgICBpZiAoc291cmNlID09PSBfZ2xvYmFsICYmIGRhdGEgPT09IHRva2VuKSB7XG4gICAgICAgIGNhbGxiYWNrcy5sZW5ndGggJiYgY2FsbGJhY2tzLnNoaWZ0KCkoKTtcbiAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG5cbiAgICByZXR1cm4gKGNiKSA9PiB7XG4gICAgICBjYWxsYmFja3MucHVzaChjYik7XG4gICAgICBfZ2xvYmFsLnBvc3RNZXNzYWdlKHRva2VuLCBcIipcIik7XG4gICAgfVxuICB9KShgYXhpb3NAJHtNYXRoLnJhbmRvbSgpfWAsIFtdKSA6IChjYikgPT4gc2V0VGltZW91dChjYik7XG59KShcbiAgdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyxcbiAgaXNGdW5jdGlvbihfZ2xvYmFsLnBvc3RNZXNzYWdlKVxuKTtcblxuY29uc3QgYXNhcCA9IHR5cGVvZiBxdWV1ZU1pY3JvdGFzayAhPT0gJ3VuZGVmaW5lZCcgP1xuICBxdWV1ZU1pY3JvdGFzay5iaW5kKF9nbG9iYWwpIDogKCB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5uZXh0VGljayB8fCBfc2V0SW1tZWRpYXRlKTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqXG5cblxuY29uc3QgaXNJdGVyYWJsZSA9ICh0aGluZykgPT4gdGhpbmcgIT0gbnVsbCAmJiBpc0Z1bmN0aW9uKHRoaW5nW2l0ZXJhdG9yXSk7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nLFxuICBpc051bWJlcixcbiAgaXNCb29sZWFuLFxuICBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdCxcbiAgaXNFbXB0eU9iamVjdCxcbiAgaXNSZWFkYWJsZVN0cmVhbSxcbiAgaXNSZXF1ZXN0LFxuICBpc1Jlc3BvbnNlLFxuICBpc0hlYWRlcnMsXG4gIGlzVW5kZWZpbmVkLFxuICBpc0RhdGUsXG4gIGlzRmlsZSxcbiAgaXNCbG9iLFxuICBpc1JlZ0V4cCxcbiAgaXNGdW5jdGlvbixcbiAgaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1R5cGVkQXJyYXksXG4gIGlzRmlsZUxpc3QsXG4gIGZvckVhY2gsXG4gIG1lcmdlLFxuICBleHRlbmQsXG4gIHRyaW0sXG4gIHN0cmlwQk9NLFxuICBpbmhlcml0cyxcbiAgdG9GbGF0T2JqZWN0LFxuICBraW5kT2YsXG4gIGtpbmRPZlRlc3QsXG4gIGVuZHNXaXRoLFxuICB0b0FycmF5LFxuICBmb3JFYWNoRW50cnksXG4gIG1hdGNoQWxsLFxuICBpc0hUTUxGb3JtLFxuICBoYXNPd25Qcm9wZXJ0eSxcbiAgaGFzT3duUHJvcDogaGFzT3duUHJvcGVydHksIC8vIGFuIGFsaWFzIHRvIGF2b2lkIEVTTGludCBuby1wcm90b3R5cGUtYnVpbHRpbnMgZGV0ZWN0aW9uXG4gIHJlZHVjZURlc2NyaXB0b3JzLFxuICBmcmVlemVNZXRob2RzLFxuICB0b09iamVjdFNldCxcbiAgdG9DYW1lbENhc2UsXG4gIG5vb3AsXG4gIHRvRmluaXRlTnVtYmVyLFxuICBmaW5kS2V5LFxuICBnbG9iYWw6IF9nbG9iYWwsXG4gIGlzQ29udGV4dERlZmluZWQsXG4gIGlzU3BlY0NvbXBsaWFudEZvcm0sXG4gIHRvSlNPTk9iamVjdCxcbiAgaXNBc3luY0ZuLFxuICBpc1RoZW5hYmxlLFxuICBzZXRJbW1lZGlhdGU6IF9zZXRJbW1lZGlhdGUsXG4gIGFzYXAsXG4gIGlzSXRlcmFibGVcbn07XG4iLCI8dGVtcGxhdGU+XHJcblx0PGRpdiBpZD1cImFwcFwiIGNsYXNzPVwiaWUtZmFsbGJhY2tcIj5cclxuXHRcdDxiYW5uZXI+PC9iYW5uZXI+XHJcblx0XHQ8Z2VvbWV0cnk+PC9nZW9tZXRyeT5cclxuXHRcdDxzZWN0aW9uIGlkPVwiYmlvXCI+XHJcblx0XHRcdDxiaW8gOnNldENvbnRlbnQ9XCJzZXRDb250ZW50XCI+PC9iaW8+XHJcblx0XHQ8L3NlY3Rpb24+XHJcblx0XHQ8dHJhbnNpdGlvbiBuYW1lPVwiY29udGVudC1mYWRlXCIgQGFmdGVyLWxlYXZlPVwidXBkYXRlQ3VycmVudENvbnRlbnRcIj5cclxuXHRcdFx0PGNvbnRhY3Qgdi1pZj1cImNvbnRlbnQgPT0gJ2NvbnRhY3QnXCI+XHJcblx0XHRcdDwvY29udGFjdD5cclxuICBcdFx0PC90cmFuc2l0aW9uPlxyXG5cdFx0PHRyYW5zaXRpb24gbmFtZT1cImNvbnRlbnQtZmFkZVwiIEBhZnRlci1sZWF2ZT1cInVwZGF0ZUN1cnJlbnRDb250ZW50XCI+XHJcblx0XHRcdDxwb3J0Zm9saW8tbGlzdCA6c3VtbWFyeVRyaWdnZXI9XCJiaW9UcmlnZ2VyXCIgdi1pZj1cImNvbnRlbnQgPT0gJ3BvcnRmb2xpbydcIj5cclxuXHRcdFx0PC9wb3J0Zm9saW8tbGlzdD5cclxuICBcdFx0PC90cmFuc2l0aW9uPlxyXG5cdDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IEJpbyBmcm9tICcuL2NvbXBvbmVudHMvQmlvJztcclxuaW1wb3J0IEJhbm5lciBmcm9tICcuL2NvbXBvbmVudHMvQmFubmVyJztcclxuaW1wb3J0IEdlb21ldHJ5IGZyb20gJy4vY29tcG9uZW50cy9HZW9tZXRyeSc7XHJcbmltcG9ydCBQb3J0Zm9saW9MaXN0IGZyb20gJy4vY29tcG9uZW50cy9Qb3J0Zm9saW9MaXN0JztcclxuaW1wb3J0IENvbnRhY3QgZnJvbSAnLi9jb21wb25lbnRzL0NvbnRhY3QnO1xyXG4vLyBpbXBvcnQgJ2JhYmVsLXBvbHlmaWxsJztcclxuaW1wb3J0IEN1c3RvbUVhc2UgZnJvbSAnX2dzYXBfL0N1c3RvbUVhc2UnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdG5hbWU6ICdhcHAnLFxyXG5cdGNvbXBvbmVudHM6IHtcclxuXHRcdEJpbyxcclxuXHRcdEJhbm5lcixcclxuXHRcdENvbnRhY3QsXHJcblx0XHRHZW9tZXRyeSxcclxuXHRcdFBvcnRmb2xpb0xpc3RcclxuXHR9LFxyXG5cdGRhdGEoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRiaW9BbmltYXRpb246IG51bGwsXHJcblx0XHRcdGJpb1RyaWdnZXI6IHtcclxuXHRcdFx0XHR0cmlnZ2VyOiBcIiNiaW9cIixcclxuXHRcdFx0XHRzY3J1YjogMSxcclxuXHRcdFx0XHRzdGFydDogXCJ0b3AgdG9wXCIsXHJcblx0XHRcdFx0ZW5kOiBcImJvdHRvbSB0b3BcIixcclxuXHRcdFx0XHRzbmFwOiB7XHJcblx0XHRcdFx0XHRzbmFwVG86IFwibGFiZWxzXCIsXHJcblx0XHRcdFx0XHRkdXJhdGlvbjoge21pbjogMC42LCBtYXg6IDAuNn0sXHJcblx0XHRcdFx0XHRkZWxheTogMC4yXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRjb250ZW50OiAncG9ydGZvbGlvJyxcclxuXHRcdFx0LypcclxuXHRcdFx0XHRjb250ZW50UGxhY2Vob2xkZXIgYWxsb3dzIGZvciB0aGUgZGVzaXJlZCBjb250ZW50IHRvIGJlIHNldC9zYXZlZCwgd2hpbGUgd2FpdGluZyBmb3IgdGhlIGxlYXZlIGFuaW1hdGlvblxyXG5cdFx0XHRcdG9mIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIGh0bWwuIFdoZW4gY29tcGxldGUsIHRoZSBjYWxsYmFjayBmcm9tIHRoZSB2dWVcclxuXHRcdFx0XHR0cmFuc2l0aW9uIGVsZW1lbnQgd2lsbCB1cGRhdGUgdGhlIHRoaXMuY29udGVudCB2YWx1ZSB0byB0aGF0IG9mIHRoZSBwbGFjZWhvbGRlciwgdHJpZ2dlcmluZyB0aGVcclxuXHRcdFx0XHRhbmltYXRpb24gdG8gZGlzcGxheSB0aGUgaW50ZW5kZWQgaHRtbC5cclxuXHRcdFx0Ki9cclxuXHRcdFx0Y29udGVudFBsYWNlSG9sZGVyOiAnJ1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0Y29tcHV0ZWQ6IHtcclxuXHR9LFxyXG5cdG1vdW50ZWQoKSB7XHJcblx0XHR0aGlzLmJpb0FuaW1hdGlvbiA9IG5ldyB0aGlzLiRkYXRhLl9nc2FwLlRpbWVsaW5lTWF4KHtcclxuXHRcdFx0XHRzY3JvbGxUcmlnZ2VyOiB0aGlzLmJpb1RyaWdnZXJcclxuXHRcdFx0fSlcclxuXHRcdFx0LmFkZExhYmVsKCdpbicpXHJcblx0XHRcdC5mcm9tVG8oJyNiaW8tY29udGFpbmVyIC5iaW8tYW5pbWF0aW9uLXdyYXBwZXInLFxyXG5cdFx0XHRcdHsgb3BhY2l0eTogMSwgcm90YXRpb25YOiAwLCBzY2FsZTogMSwgeTogMCwgejogMCwgdHJhbnNmb3JtT3JpZ2luOiBcIjUwJSA1MCUgLTEwMHB4XCIgfSxcclxuXHRcdFx0XHR7IG9wYWNpdHk6IDEsIHJvdGF0aW9uWDogOTAsIHk6IDEwMCwgejogLTEwMCwgZWFzZTogQ3VzdG9tRWFzZS5jcmVhdGUoXCJjdXN0b21cIiwgXCJNMCwwIEMwLjEyNiwwLjM4MiAwLjIxNiwwLjY5MiAwLjM3NCwwLjg0IDAuNTY2LDEuMDIgMC44MTgsMS4wMDEgMSwxXCIpIH0pXHJcblx0XHRcdC5mcm9tVG8oJyNiaW8tY29udGFpbmVyIC5iaW8tYW5pbWF0aW9uLXdyYXBwZXInLFxyXG5cdFx0XHRcdHsgaGVpZ2h0OiAnMTYwJyB9LFxyXG5cdFx0XHRcdHsgaGVpZ2h0OiAnMHB4JywgZWFzZTogQ3VzdG9tRWFzZS5jcmVhdGUoXCJjdXN0b21cIiwgXCJNMCwwIEMwLjE3MiwwIDAuMjg4LDAuMTU0IDAuMzQsMC4yMjIgMC43NTYsMC43NjggMC42MDQsMC45ODggMSwxXCIpIH0sXHJcblx0XHRcdFx0Jy09LjUnKVxyXG5cdFx0XHQuYWRkTGFiZWwoJ291dCcpXHJcblx0fSxcclxuXHRtZXRob2RzOiB7XHJcblx0XHR1cGRhdGVDdXJyZW50Q29udGVudCgpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coJ1RoZSBjb250ZW50IGhhcyB1cGRhdGVkIHRvOiAnLCB0aGlzLmNvbnRlbnRQbGFjZUhvbGRlcik7XHJcblx0XHRcdHRoaXMuY29udGVudCA9IHRoaXMuY29udGVudFBsYWNlSG9sZGVyO1xyXG5cdFx0fSxcclxuXHRcdHNldENvbnRlbnQodmFsKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKCdjb250ZW50IGlzIGdvbmUgYW5kIHBsYWNlaG9sZGVyIGlzOiAnLCB2YWwpO1xyXG5cdFx0XHR0aGlzLmNvbnRlbnQgPSAnJztcclxuXHRcdFx0dGhpcy5jb250ZW50UGxhY2VIb2xkZXIgPSB2YWw7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG48L3NjcmlwdD5cclxuPHN0eWxlIGxhbmc9J3Njc3MnIHR5cGU9J3RleHQvY3NzJz5cclxuQGltcG9ydCAnfl9zY3NzXy9hcHAnO1xyXG4jYXBwIHtcclxuXHQmOjpiZWZvcmUge1xyXG5cdFx0Y29udGVudDogJyc7XHJcblx0XHR0cmFuc2l0aW9uOiAxcztcclxuXHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLW5ldXRyYWwtMyk7XHJcblx0XHRwb3NpdGlvbjogZml4ZWQ7XHJcblx0XHQvL3RoaXMgY291bnRlcnMgdGhlIDMwcHggcGFkZGluZ1xyXG5cdFx0dG9wOiAtMzBweDtcclxuXHRcdGxlZnQ6IDA7XHJcblx0XHRyaWdodDogMDtcclxuXHRcdGhlaWdodDogNDcwcHg7XHJcblx0XHR0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0O1xyXG5cdFx0dHJhbnNmb3JtOiBza2V3WSgtMTBkZWcpO1xyXG5cdH1cclxuXHQjYmlvIHtcclxuXHRcdHdpZHRoOiAxMDB2dztcclxuXHRcdC8vIGhlaWdodDogMzByZW07XHJcblx0XHRoZWlnaHQ6IDcwdmg7XHJcblx0XHQvLyBib3JkZXI6IDFweCBzb2xpZCB3aGl0ZTtcclxuXHR9XHJcblx0LmNvbnRlbnQtZmFkZS1lbnRlci1hY3RpdmUsIC5jb250ZW50LWZhZGUtbGVhdmUtYWN0aXZlIHtcclxuICBcdFx0dHJhbnNpdGlvbjogYWxsIC4zcyBlYXNlO1xyXG5cdH1cclxuXHQuY29udGVudC1mYWRlLWxlYXZlLXRvLCAuY29udGVudC1mYWRlLWVudGVyIHtcclxuXHRcdG9wYWNpdHk6IDA7XHJcblx0fVxyXG5cdC5jb250ZW50LWZhZGUtZW50ZXItdG8sIC5jb250ZW50LWZhZGUtbGVhdmUge1xyXG5cdFx0b3BhY2l0eTogMTtcclxuXHR9XHJcbn1cclxuPC9zdHlsZT5cclxuPHN0eWxlIHR5cGU9J3RleHQvY3NzJz5cclxuQGltcG9ydCAnfl9pY29tb29uXy9zdHlsZS5jc3MnO1xyXG48L3N0eWxlPlxyXG4iLCI8dGVtcGxhdGU+XHJcblx0PGRpdiBpZD1cImJhbm5lclwiIGNsYXNzPVwicC0zMFwiPlxyXG5cdFx0PHNwYW5cclxuXHRcdFx0Y2xhc3M9XCJmdC1ub3JtYWwgbS1yZ3QtYXV0byBmdC1zei0xOCBkYXJrLW1vZGVcIlxyXG5cdFx0XHRAY2xpY2s9XCJjbGlja0hhbmRsZXJcIj5cclxuXHRcdFx0PGkgY2xhc3M9J2ljb24tbW9vbi1zdHJva2UgZnQtc3otMTYgcC1yZ3QtMTUnPjwvaT57e2luYWN0aXZlTW9kZX19IE1vZGVcclxuXHRcdDwvc3Bhbj5cclxuXHQ8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCB7IGRlYm91bmNlLCB0aHJvdHRsZSB9IGZyb20gJ2xvZGFzaC1lcyc7XHJcbmltcG9ydCBjc3NWYXJpYWJsZXMgZnJvbSAnX21peGluc18vY3NzVmFyaWFibGVzJztcclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdG5hbWU6ICdiYW5uZXInLFxyXG5cdG1peGluczogWyBjc3NWYXJpYWJsZXMgXSxcclxuXHRkYXRhKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y2xpY2tIYW5kbGVyOiBkZWJvdW5jZSh0aGlzLnRvZ2dsZU1vZGUsIDMwMCwgeyAnbGVhZGluZyc6IHRydWUsICd0cmFpbGluZyc6IGZhbHNlIH0pLFxyXG5cdFx0XHR3aW5kb3dSZXNpemVTY2FsZUhhbmRsZXI6IGRlYm91bmNlKHRoaXMuc2V0U2NhbGUsIDMwMCwgeyAnbGVhZGluZyc6IGZhbHNlLCAndHJhaWxpbmcnOiB0cnVlIH0pLFxyXG5cdFx0XHRtb3VzZW1vdmVIYW5kbGVyOiB0aHJvdHRsZSh0aGlzLm1vdXNlQXZvaWRBbmltYXRpb25IYW5kbGVyLCAxMDApLFxyXG5cdFx0XHRhY3RpdmVNb2RlOiAnZGFyaycsXHJcblx0XHRcdGluYWN0aXZlTW9kZTogJ2xpZ2h0J1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0YmVmb3JlTW91bnQoKSB7XHJcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy53aW5kb3dSZXNpemVTY2FsZUhhbmRsZXIpO1xyXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2Vtb3ZlSGFuZGxlcik7XHJcblx0fSxcclxuXHRtb3VudGVkKCkge1xyXG5cdFx0dGhpcy5zZXRTY2FsZSgpO1xyXG5cdH0sXHJcblx0bWV0aG9kczoge1xyXG5cdFx0dG9nZ2xlTW9kZSgpIHtcclxuXHRcdFx0LypcclxuXHRcdFx0dGhpcy5pc0xpZ2h0ID0gIXRoaXMuaXNMaWdodDtcclxuXHRcdFx0bGV0IHN0eWxlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcHAnKS5zdHlsZTtcclxuXHRcdFx0aWYgKHRoaXMuYWN0aXZlTW9kZSA9PSAnbGlnaHQnKSB7XHJcblx0XHRcdFx0dGhpcy5hY3RpdmVNb2RlID0gJ2RhcmsnO1xyXG5cdFx0XHRcdHRoaXMuaW5hY3RpdmVNb2RlID0gJ2xpZ2h0JztcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmICh0aGlzLmFjdGl2ZU1vZGUgPT0gJ2RhcmsnKSB7XHJcblx0XHRcdFx0dGhpcy5hY3RpdmVNb2RlID0gJ2xpZ2h0JztcclxuXHRcdFx0XHR0aGlzLmluYWN0aXZlTW9kZSA9ICdkYXJrJztcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmFjdGl2ZS5mb3JFYWNoKGFjdGl2ZVN0eWxlID0+IHtcclxuXHRcdFx0XHQvKlxyXG5cdFx0XHRcdFx0aWYgdGhlcmUgaXMgYSBjc3MgdmFyaWFibGUgZm9yIHRoZSBjdXJyZW50IG1vZGUsIHRoYXQgbWF0Y2hlcyB0aGUgbmFtZSBvZiB0aGUgYWN0aXZlIHZhcmlhYmxlLCB1cGRhdGUgdG8gdGhhdCB2YWx1ZVxyXG5cdFx0XHRcdFx0Zm9yIGV4YW1wbGUgaWYgdGhlIGFjdGl2ZSB2YXJpYWJsZSBpcyBcIi0tYWN0aXZlLWJhY2tncm91bmQtY29sb3JcIiBhbmQgdGhlIG1vZGUgaXMgXCJkYXJrXCIsIGxvb2sgZm9yIFwiLS1kYXJrLWJhY2tncm91bmQtY29sb3JcIlxyXG5cdFx0XHRcdFx0dmlhIHRoaXNbJ2RhcmsnXVtcIi0tZGFyay1iYWNrZ3JvdW5kLWNvbG9yXCJdXHJcblx0XHRcdFx0L1xyXG5cdFx0XHRcdGxldCBjdXJyZW50TW9kZUNvbG9yVmFsdWUgPSB0aGlzW3RoaXMuYWN0aXZlTW9kZV1bYWN0aXZlU3R5bGUucmVwbGFjZSgnYWN0aXZlJywgdGhpcy5hY3RpdmVNb2RlKV07XHJcblx0XHRcdFx0aWYgKGN1cnJlbnRNb2RlQ29sb3JWYWx1ZSkge1xyXG5cdFx0XHRcdFx0c3R5bGVzLnNldFByb3BlcnR5KGFjdGl2ZVN0eWxlLCBjdXJyZW50TW9kZUNvbG9yVmFsdWUpO1xyXG5cdFx0XHRcdH0gXHJcblx0XHRcdFx0LypcclxuXHRcdFx0XHRcdElmIHRoZXJlIGlzIG5vdCB2YXJpYWJsZS92YWx1ZSBmb3IgdGhlIGN1cnJlbnQgbW9kZSBtYXRjaGluZyB0aGUgYWN0aXZlIHZhcmlhYmxlIG5hbWUsIHRoZW4gY2hlY2sgaWYgdGhlcmUgaXMgYW4gaW5hY3RpdmUgYW5kIHN3YXAgdG8gdGhhdFxyXG5cdFx0XHRcdFx0VGhpcyBhbGxvd3MgZm9yIGEgXHJcblx0XHRcdFx0L1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5pbmFjdGl2ZS5mb3JFYWNoKGluYWN0aXZlU3R5bGUgPT4ge1xyXG5cdFx0XHRcdHN0eWxlcy5zZXRQcm9wZXJ0eShpbmFjdGl2ZVN0eWxlLCB0aGlzW3RoaXMuaW5hY3RpdmVNb2RlXVtpbmFjdGl2ZVN0eWxlLnJlcGxhY2UoJ2luYWN0aXZlJywgdGhpcy5pbmFjdGl2ZU1vZGUpXSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHQqL1xyXG5cdFx0XHRpZiAodGhpcy5hY3RpdmVNb2RlID09ICdsaWdodCcpIHtcclxuXHRcdFx0XHR0aGlzLmFjdGl2ZU1vZGUgPSAnZGFyayc7XHJcblx0XHRcdFx0dGhpcy5pbmFjdGl2ZU1vZGUgPSAnbGlnaHQnO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHRoaXMuYWN0aXZlTW9kZSA9PSAnZGFyaycpIHtcclxuXHRcdFx0XHR0aGlzLmFjdGl2ZU1vZGUgPSAnbGlnaHQnO1xyXG5cdFx0XHRcdHRoaXMuaW5hY3RpdmVNb2RlID0gJ2RhcmsnO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKCdkYXRhLW1vZGUnLCB0aGlzLmFjdGl2ZU1vZGUpO1xyXG5cdFx0XHRBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5saWdodCcpKS5mb3JFYWNoKGVsID0+IGVsLmNsYXNzTGlzdC50b2dnbGUoJ3Zpc2libGUnKSk7XHJcblx0XHRcdEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRhcmsnKSkuZm9yRWFjaChlbCA9PiBlbC5jbGFzc0xpc3QudG9nZ2xlKCd2aXNpYmxlJykpO1xyXG5cdFx0fSxcclxuXHRcdG1hcCggeCwgIGluX21pbiwgIGluX21heCwgIG91dF9taW4sICBvdXRfbWF4KSB7XHJcblx0XHRcdHJldHVybiAoeCAtIGluX21pbikgKiAob3V0X21heCAtIG91dF9taW4pIC8gKGluX21heCAtIGluX21pbikgKyBvdXRfbWluO1xyXG5cdFx0fSxcclxuXHRcdHNldFNjYWxlKCkge1xyXG5cdFx0XHRsZXQgc3R5bGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpLnN0eWxlO1xyXG5cdFx0XHRsZXQgZ2xvYmFsU2NhbGUgPSAgTWF0aC5taW4od2luZG93LmlubmVyV2lkdGgsIDEwMDApLzEwMDA7XHJcblx0XHRcdHN0eWxlcy5zZXRQcm9wZXJ0eSgnLS1nbG9iYWwtc2NhbGUtdG8td2luZG93LXdpZHRoJywgZ2xvYmFsU2NhbGUpO1xyXG5cclxuXHRcdFx0bGV0IGJpb1NjYWxlID0gTWF0aC5taW4od2luZG93LmlubmVyV2lkdGggKiAwLjIsIDEwMCk7XHJcblx0XHRcdHN0eWxlcy5zZXRQcm9wZXJ0eSgnLS1iaW8tcGxhY2VtZW50JywgYCR7YmlvU2NhbGV9cHhgKTtcclxuXHRcdH0sXHJcblx0XHRtb3VzZUF2b2lkQW5pbWF0aW9uSGFuZGxlcihldmVudCkge1xyXG5cdFx0XHQvL1RoZSB0aW55IHNxdWFyZSBhdCB0aGUgdG9wXHJcblx0XHRcdGxldCBzcXVhcmUyRFN0eWxlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zcXVhcmUtMi1kJyk7XHJcblx0XHRcdGxldCByaWdodFZhbHVlID0gdGhpcy5tYXAoZXZlbnQuY2xpZW50WCwgMCwgd2luZG93LmlubmVyV2lkdGgsIDI0MCwgMjY1KTtcclxuXHJcblx0XHRcdGxldCBjdXJ2ZTFDU3R5bGVzO1xyXG5cdFx0XHRsZXQgY3VydmUxQ1JvdGF0ZVZhbHVlO1xyXG5cdFx0XHRsZXQgc3F1YXJlMkNTdHlsZXM7XHJcblx0XHRcdGxldCBzcXVhcmUyQ1JvdGF0ZVhWYWx1ZTtcclxuXHRcdFx0bGV0IHNxdWFyZTJDVHJhbnNsYXRlWVZhbHVlO1xyXG5cdFx0XHRpZiAoIXRoaXMuaXNJbnRlcm5ldEV4cGxvcmVyKSB7XHJcblx0XHRcdFx0Ly90aGUgYm90dG9tIGxlZnQgY3VydmUgdXNlIGluIGV2ZXJ5dGhpbmcgYnV0IElFXHJcblx0XHRcdFx0Y3VydmUxQ1N0eWxlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjdXJ2ZS0xLWMnKS5zdHlsZVxyXG5cdFx0XHRcdGN1cnZlMUNSb3RhdGVWYWx1ZSA9IHRoaXMubWFwKGV2ZW50LmNsaWVudFgsIDAsIHdpbmRvdy5pbm5lcldpZHRoLCAyMDQsIDEyMyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly9UaGUgYm90dG9tIGxlZnQgY29sb3JlZCBzcXVhcmUgdXNlZCBhcyBhIGZhbGxiYWNrIGZvciBJRVxyXG5cdFx0XHRcdHNxdWFyZTJDU3R5bGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnNxdWFyZS0yLWMnKTtcclxuXHRcdFx0XHRzcXVhcmUyQ1JvdGF0ZVhWYWx1ZSA9IHRoaXMubWFwKGV2ZW50LmNsaWVudFksIDAsIHdpbmRvdy5pbm5lckhlaWdodCwgLTIwLCAyOCk7XHJcblx0XHRcdFx0c3F1YXJlMkNUcmFuc2xhdGVZVmFsdWUgPSB0aGlzLm1hcChldmVudC5jbGllbnRZLCAwLCB3aW5kb3cuaW5uZXJIZWlnaHQsIC01LCAyMCk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly9UaGUgbWVkaXVtIHNpemVkIHNxdWFyZSBvbiB0aGUgcmlnaHRcclxuXHRcdFx0bGV0IHNxdWFyZTFCU3R5bGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnNxdWFyZS0xLWInKTtcclxuXHRcdFx0bGV0IHNxdWFyZTFCUm90YXRlVmFsdWUgPSB0aGlzLm1hcChldmVudC5jbGllbnRYLCAwLCB3aW5kb3cuaW5uZXJXaWR0aCwgLTQ1LCAxMCk7XHJcblxyXG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuXHRcdFx0XHQvL3NldCBib3RoIGxpZ2h0IGFuZCBkYXJrIGluc3RhbmNlIG9mIHRoZSBzcXVhcmVcclxuXHRcdFx0XHRzcXVhcmUyRFN0eWxlc1swXS5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1yaWdodCcsIGAke3JpZ2h0VmFsdWV9cHhgKTtcclxuXHRcdFx0XHRzcXVhcmUyRFN0eWxlc1sxXS5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1yaWdodCcsIGAke3JpZ2h0VmFsdWV9cHhgKTtcclxuXHRcdFx0XHRpZiAoIXRoaXMuaXNJbnRlcm5ldEV4cGxvcmVyKSB7XHJcblx0XHRcdFx0XHRjdXJ2ZTFDU3R5bGVzLnNldFByb3BlcnR5KCctLXJvdGF0ZScsIGAke2N1cnZlMUNSb3RhdGVWYWx1ZX1kZWdgKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3F1YXJlMkNTdHlsZXNbMF0uc3R5bGUuc2V0UHJvcGVydHkoJy0tcm90YXRlWCcsIGAke3NxdWFyZTJDUm90YXRlWFZhbHVlfWRlZ2ApO1xyXG5cdFx0XHRcdFx0c3F1YXJlMkNTdHlsZXNbMV0uc3R5bGUuc2V0UHJvcGVydHkoJy0tdHJhbnNsYXRlWScsIGAke3NxdWFyZTJDVHJhbnNsYXRlWVZhbHVlfXB4YCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzcXVhcmUxQlN0eWxlc1swXS5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1yb3RhdGUnLCBgJHtzcXVhcmUxQlJvdGF0ZVZhbHVlfWRlZ2ApO1xyXG5cdFx0XHRcdHNxdWFyZTFCU3R5bGVzWzFdLnN0eWxlLnNldFByb3BlcnR5KCctLXJvdGF0ZScsIGAke3NxdWFyZTFCUm90YXRlVmFsdWV9ZGVnYCk7XHJcblx0XHRcdFx0XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdH1cclxuXHR9LFxyXG5cdHdhdGNoOiB7fVxyXG59O1xyXG48L3NjcmlwdD5cclxuPHN0eWxlIGxhbmc9J3Njc3MnIHR5cGU9XCJ0ZXh0L3Njc3NcIj5cclxuQGltcG9ydCAnfl9zY3NzXy9fbWl4aW5zJztcclxuI2Jhbm5lciB7XHJcblx0Ly8gdmlzaWJpbGl0eTogaGlkZGVuO1xyXG5cdC8vIEBpbmNsdWRlIGJveC1zaGFkb3coKGNvbG9yOiByZ2JhKDAsMCwwLDAuMDUpKS4uLik7XHJcblx0ZGlzcGxheTogZmxleDtcclxuXHR0cmFuc2l0aW9uOiAxcztcclxuXHRjb2xvcjogdmFyKC0tdGV4dC1jb2xvcik7XHJcblx0cG9zaXRpb246IGZpeGVkO1xyXG5cdHRvcDogMDtcclxuICAgIHotaW5kZXg6IDE7XHJcbiAgICBsZWZ0OiAwO1xyXG4gICAgcmlnaHQ6IDA7XHJcblx0Ly8gJjo6YmVmb3JlIHtcclxuXHQvLyBcdGNvbnRlbnQ6ICcnO1xyXG5cdC8vIFx0dHJhbnNpdGlvbjogMXM7XHJcblx0Ly8gXHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1uZXV0cmFsLTMpO1xyXG5cdC8vIFx0cG9zaXRpb246IGFic29sdXRlO1xyXG5cdC8vIFx0Ly90aGlzIGNvdW50ZXJzIHRoZSAzMHB4IHBhZGRpbmdcclxuXHQvLyBcdHRvcDogLTMwcHg7XHJcblx0Ly8gXHRsZWZ0OiAwO1xyXG5cdC8vIFx0cmlnaHQ6IDA7XHJcblx0Ly8gXHRoZWlnaHQ6IDQ3MHB4O1xyXG5cdC8vIFx0dHJhbnNmb3JtLW9yaWdpbjogbGVmdDtcclxuXHQvLyBcdHRyYW5zZm9ybTogc2tld1koLTEwZGVnKTtcclxuXHQvLyB9XHJcblx0c3BhbiB7XHJcblx0XHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcblx0XHRsaW5lLWhlaWdodDogMjBweDtcclxuXHRcdHotaW5kZXg6IDI7XHJcblx0XHQmLmRhcmstbW9kZSB7XHJcblx0XHRcdGN1cnNvcjogcG9pbnRlcjtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuPC9zdHlsZT5cclxuXHJcblxyXG4iLCI8dGVtcGxhdGU+XHJcblx0PGRpdiBpZD1cImJpby1jb250YWluZXJcIj5cclxuICAgICAgICA8aDE+Sm9yZGFuIEtsYWVyczwvaDE+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImJpby1hbmltYXRpb24td3JhcHBlclwiPlxyXG4gICAgICAgICAgICA8aDE+RnJvbnQtRW5kIFdlYiBEZXZlbG9wZXI8L2gxPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3ViLXRleHRcIiByZWY9XCJzdWItdGV4dFwiPkZ1bGwgc3RhY2sgd2ViIGRldmVsb3BlciBzaW5jZSAyMDE3IHdpdGggYSBwYXNzaW9uIGZvciBmcm9udCBlbmQgZGV2ZWxvcG1lbnQgYW5kIGRlc2lnbjwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJtLXJndC0yMCBtLXRvcC0yMFwiIHYtb246Y2xpY2s9XCIoKSA9PiBzZXRDb250ZW50KCdwb3J0Zm9saW8nKVwiPlBvcnRmb2xpbzwvYnV0dG9uPlxyXG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJtLXRvcC0yMFwiICB2LW9uOmNsaWNrPVwiKCkgPT4gc2V0Q29udGVudCgnY29udGFjdCcpXCI+Q29udGFjdDwvYnV0dG9uPlxyXG5cdDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdG5hbWU6ICdiaW8nLFxyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0b3BPZlBhZ2VUaW1lbGluZTogbnVsbFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIHNldENvbnRlbnQ6e1xyXG4gICAgICAgICAgICB0eXBlOiBGdW5jdGlvblxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblx0Y29tcHV0ZWQ6IHtcclxuXHR9LFxyXG4gICAgbW91bnRlZCgpIHtcclxuICAgIH0sXHJcblx0bWV0aG9kczoge1xyXG5cdH1cclxufTtcclxuPC9zY3JpcHQ+XHJcbjxzdHlsZSBsYW5nPSdzY3NzJyB0eXBlPVwidGV4dC9zY3NzXCI+XHJcbiNiaW8tY29udGFpbmVyIHtcclxuICAgIHRyYW5zaXRpb246IGxlZnQgMXMsIGNvbG9yIDFzO1xyXG4gICAgcG9zaXRpb246IGZpeGVkO1xyXG4gICAgdG9wOiA0cmVtO1xyXG4gICAgei1pbmRleDogMjtcclxuICAgIGNvbG9yOiB2YXIoLS10ZXh0LWNvbG9yKTtcclxuICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1iaW8tcGxhY2VtZW50KTtcclxuICAgIG1heC13aWR0aDogNDAwcHg7XHJcbiAgICB3aWR0aDogNjB2dztcclxuICAgIGgxOmZpcnN0LW9mLXR5cGUge1xyXG4gICAgICAgIG1hcmdpbi1ib3R0b206IDA7XHJcbiAgICB9XHJcbiAgICAuYmlvLWFuaW1hdGlvbi13cmFwcGVyIHtcclxuICAgICAgICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDIwMHB4KTtcclxuICAgICAgICAvLyBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgICAgIGgxIHtcclxuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGl2LnN1Yi10ZXh0IHtcclxuICAgICAgICAgICAgZm9udC1zaXplOiAxLjJlbTsgIFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgYnV0dG9uIHtcclxuICAgICAgICB0cmFuc2l0aW9uOiBhbGwgMXM7XHJcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICAgICAgJjo6YmVmb3JlIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYWxsIDAuNnM7XHJcbiAgICAgICAgICAgIGNvbnRlbnQ6ICcnO1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgICAgICAgIGxlZnQ6IC02MHB4O1xyXG4gICAgICAgICAgICB0b3A6IDA7XHJcbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcclxuICAgICAgICAgICAgd2lkdGg6IDUwcHg7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2tld1goMjBkZWcpO1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwyNTUsMjU1LDAuNSk7XHJcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IC0xcHggMHB4IDEycHggMnB4IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJjpob3ZlciB7XHJcbiAgICAgICAgICAgICY6OmJlZm9yZSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgMC42cztcclxuICAgICAgICAgICAgICAgIGxlZnQ6IGNhbGMoMTAwJSArIDYwcHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgICY6Zmlyc3Qtb2YtdHlwZSB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXNlY29uZGFyeS0xLWMpO1xyXG4gICAgICAgICAgICBjb2xvcjogdmFyKC0tdGV4dC1jb2xvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbjwvc3R5bGU+XHJcblxyXG5cclxuIiwiPHRlbXBsYXRlPlxyXG5cdDxkaXYgaWQ9XCJjb250YWN0LWNvbnRhaW5lclwiPlxyXG4gICAgICAgIDx1bD5cclxuICAgICAgICAgICAgPGxpPlxyXG4gICAgICAgICAgICAgICAgPHN2ZyB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIiBpZD1cImNvZGUtcGVuLWxvZ29cIj5cclxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2U9XCJ3aGl0ZVwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBkPVwiTTEwMCAzNC4yYy0uNC0yLjYtMy4zLTQtNS4zLTUuMy0zLjYtMi40LTcuMS00LjctMTAuNy03LjEtOC41LTUuNy0xNy4xLTExLjQtMjUuNi0xNy4xLTItMS4zLTQtMi43LTYtNC0xLjQtMS0zLjMtMS00LjggMC01LjcgMy44LTExLjUgNy43LTE3LjIgMTEuNUw1LjIgMjlDMyAzMC40LjEgMzEuOCAwIDM0LjhjLS4xIDMuMyAwIDYuNyAwIDEwdjE2YzAgMi45LS42IDYuMyAyLjEgOC4xIDYuNCA0LjQgMTIuOSA4LjYgMTkuNCAxMi45IDggNS4zIDE2IDEwLjcgMjQgMTYgMi4yIDEuNSA0LjQgMy4xIDcuMSAxLjMgMi4zLTEuNSA0LjUtMyA2LjgtNC41IDguOS01LjkgMTcuOC0xMS45IDI2LjctMTcuOGw5LjktNi42Yy42LS40IDEuMy0uOCAxLjktMS4zIDEuNC0xIDItMi40IDItNC4xVjM3LjNjLjEtMS4xLjItMi4xLjEtMy4xIDAtLjEgMCAuMiAwIDB6TTU0LjMgMTIuM0w4OCAzNC44IDczIDQ0LjkgNTQuMyAzMi40VjEyLjN6bS04LjYgMHYyMEwyNy4xIDQ0LjggMTIgMzQuOGwzMy43LTIyLjV6TTguNiA0Mi44TDE5LjMgNTAgOC42IDU3LjJWNDIuOHptMzcuMSA0NC45TDEyIDY1LjJsMTUtMTAuMSAxOC42IDEyLjV2MjAuMXpNNTAgNjAuMkwzNC44IDUwIDUwIDM5LjggNjUuMiA1MCA1MCA2MC4yem00LjMgMjcuNXYtMjBsMTguNi0xMi41IDE1IDEwLjEtMzMuNiAyMi40em0zNy4xLTMwLjVMODAuNyA1MGwxMC44LTcuMi0uMSAxNC40elwiPjwvcGF0aD5cclxuICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cImh0dHBzOi8vY29kZXBlbi5pby9qb3JkYW5rbGFlcnNcIiB0YXJnZXQ9XCJibGFua1wiPlxyXG4gICAgICAgICAgICAgICAgICAgIENvZGUgUGVuXHJcbiAgICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICAgIDxzdmcgaWQ9XCJsaW5rZWQtaW4tbG9nb1wiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjM0XCIgaGVpZ2h0PVwiMzRcIiB2aWV3Qm94PVwiMCAwIDM0IDM0XCIgY2xhc3M9XCJnbG9iYWwtbmF2X19sb2dvXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMzQsMi41djI5QTIuNSwyLjUsMCwwLDEsMzEuNSwzNEgyLjVBMi41LDIuNSwwLDAsMSwwLDMxLjVWMi41QTIuNSwyLjUsMCwwLDEsMi41LDBoMjlBMi41LDIuNSwwLDAsMSwzNCwyLjVaTTEwLDEzSDVWMjloNVptLjQ1LTUuNUEyLjg4LDIuODgsMCwwLDAsNy41OSw0LjZINy41YTIuOSwyLjksMCwwLDAsMCw1LjhoMGEyLjg4LDIuODgsMCwwLDAsMi45NS0yLjgxWk0yOSwxOS4yOGMwLTQuODEtMy4wNi02LjY4LTYuMS02LjY4YTUuNyw1LjcsMCwwLDAtNS4wNiwyLjU4SDE3LjdWMTNIMTNWMjloNVYyMC40OWEzLjMyLDMuMzIsMCwwLDEsMy0zLjU4aC4xOWMxLjU5LDAsMi43NywxLDIuNzcsMy41MlYyOWg1WlwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIj48L3BhdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9nPlxyXG4gICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICA8YSBocmVmPVwiaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL2pvcmRhbi1rbGFlcnMvXCIgdGFyZ2V0PVwiYmxhbmtcIj5MaW5rZWQgSW48L2E+XHJcbiAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XCJnYl90Y1wiIHNyYz1cImh0dHBzOi8vc3NsLmdzdGF0aWMuY29tL3VpL3YxL2ljb25zL21haWwvcmZyL2xvZ29fZ21haWxfbG9ja3VwX2RlZmF1bHRfMXhfcjIucG5nXCIgc3Jjc2V0PVwiaHR0cHM6Ly9zc2wuZ3N0YXRpYy5jb20vdWkvdjEvaWNvbnMvbWFpbC9yZnIvbG9nb19nbWFpbF9sb2NrdXBfZGVmYXVsdF8xeF9yMi5wbmcgMXgsIGh0dHBzOi8vc3NsLmdzdGF0aWMuY29tL3VpL3YxL2ljb25zL21haWwvcmZyL2xvZ29fZ21haWxfbG9ja3VwX2RlZmF1bHRfMnhfcjIucG5nIDJ4IFwiIGFsdD1cIlwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxyXG4gICAgICAgICAgICAgICAgZW1haWw6IEpvcmRhbi5LbGFlcnNAZ21haWwuY29tXHJcbiAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgPC91bD5cclxuXHQ8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRuYW1lOiAnY29udGFjdCcsXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHByb3BzOiB7XHJcbiAgICB9LFxyXG5cdGNvbXB1dGVkOiB7XHJcblx0fSxcclxuICAgIG1vdW50ZWQoKSB7XHJcbiAgICB9LFxyXG5cdG1ldGhvZHM6IHtcclxuXHR9XHJcbn07XHJcbjwvc2NyaXB0PlxyXG48c3R5bGUgbGFuZz0nc2NzcycgdHlwZT1cInRleHQvc2Nzc1wiPlxyXG4jY29udGFjdC1jb250YWluZXIge1xyXG4gICAgcG9zaXRpb246IGZpeGVkO1xyXG4gICAgbGVmdDogY2FsYyh2YXIoLS1iaW8tcGxhY2VtZW50KSArIDIuMnJlbSk7XHJcbiAgICB0b3A6IDUwdmg7XHJcbiAgICBjb2xvcjogd2hpdGU7XHJcbiAgICB1bCB7XHJcbiAgICAgICAgbWFyZ2luOiAwO1xyXG4gICAgICAgIHBhZGRpbmc6IDA7XHJcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcclxuICAgICAgICBsaSwgYSB7XHJcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4ycmVtO1xyXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMS40cmVtO1xyXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XHJcbiAgICAgICAgICAgIGNvbG9yOiB2YXIoLS10ZXh0LWNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGkge1xyXG4gICAgICAgICAgICBtYXJnaW46IDAuNXJlbSAwO1xyXG4gICAgICAgICAgICAjY29kZS1wZW4tbG9nbywgI2xpbmtlZC1pbi1sb2dvIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWChjYWxjKC0xMDAlIC0gMC41cmVtKSk7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMS4ycmVtO1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxLjJyZW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW1nIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMS4ycmVtO1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDMuNzJyZW07XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoY2FsYygtMS4ycmVtIC0gMC41cmVtKSk7XHJcbiAgICAgICAgICAgICAgICBjbGlwLXBhdGg6IGluc2V0KDBweCAyLjUycmVtIDBweCAwcHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGEge1xyXG4gICAgICAgICAgICAgICAgJjpob3ZlciB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbjwvc3R5bGU+XHJcblxyXG5cclxuIiwiPHRlbXBsYXRlPlxyXG5cdDxkaXYgaWQ9XCJnZW9tZXRyeS1jb250YWluZXJcIj5cclxuICAgICAgICA8c3BhbiBjbGFzcz1cImRhcmsgdmlzaWJsZSBzaGFwZSBzcXVhcmUtMS1hXCI+PC9zcGFuPlxyXG4gICAgICAgIDxzcGFuIGNsYXNzPVwibGlnaHQgc2hhcGUgc3F1YXJlLTEtYVwiPjwvc3Bhbj5cclxuICAgICAgICA8c3BhbiBjbGFzcz1cImRhcmsgdmlzaWJsZSBzaGFwZSBzcXVhcmUtMS1iXCI+PC9zcGFuPlxyXG4gICAgICAgIDxzcGFuIGNsYXNzPVwibGlnaHQgc2hhcGUgc3F1YXJlLTEtYlwiPjwvc3Bhbj5cclxuXHJcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJkYXJrIHZpc2libGUgc2hhcGUgc3F1YXJlLTItYVwiPjwvc3Bhbj5cclxuICAgICAgICA8c3BhbiBjbGFzcz1cImxpZ2h0IHNoYXBlIHNxdWFyZS0yLWFcIj48L3NwYW4+XHJcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJkYXJrIHZpc2libGUgc2hhcGUgc3F1YXJlLTItYlwiPjwvc3Bhbj5cclxuICAgICAgICA8c3BhbiBjbGFzcz1cImxpZ2h0IHNoYXBlIHNxdWFyZS0yLWJcIj48L3NwYW4+XHJcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJkYXJrIHZpc2libGUgc2hhcGUgc3F1YXJlLTItY1wiPjwvc3Bhbj5cclxuICAgICAgICA8c3BhbiBjbGFzcz1cImxpZ2h0IHNoYXBlIHNxdWFyZS0yLWNcIj48L3NwYW4+XHJcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJkYXJrIHZpc2libGUgc2hhcGUgc3F1YXJlLTItZFwiPjwvc3Bhbj5cclxuICAgICAgICA8c3BhbiBjbGFzcz1cImxpZ2h0IHNoYXBlIHNxdWFyZS0yLWRcIj48L3NwYW4+XHJcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJzaGFwZSBzcXVhcmUtMy1hXCI+PC9zcGFuPlxyXG4gICAgICAgIDxzcGFuIGNsYXNzPVwic2hhcGUgc3F1YXJlLTMtYlwiPjwvc3Bhbj5cclxuICAgICAgICA8c3BhbiBjbGFzcz1cInNoYXBlIHNxdWFyZS0zLWNcIj48L3NwYW4+XHJcbiAgICAgICAgPHRlbXBsYXRlIHYtaWY9XCIhaXNJbnRlcm5ldEV4cGxvcmVyXCI+XHJcbiAgICAgICAgICAgIDxzcGFuXHJcbiAgICAgICAgICAgICAgICB2LWZvcj1cImN1cnZlIGluIGN1cnZlRWxlbWVudHNcIlxyXG4gICAgICAgICAgICAgICAgOmtleT1cImN1cnZlLmNsYXNzXCJcclxuICAgICAgICAgICAgICAgIGNsYXNzPVwic2hhcGVcIlxyXG4gICAgICAgICAgICAgICAgOmlkPVwiY3VydmUuaWRcIlxyXG4gICAgICAgICAgICAgICAgOnN0eWxlPVwic2V0Q2xpcFBhdGgoY3VydmUuZGVncmVlLCBjdXJ2ZS5zdGFydERlZ3JlZSlcIlxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgPC90ZW1wbGF0ZT5cclxuXHQ8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRuYW1lOiAnZ2VvbWV0cnlDb250YWluZXInLFxyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwYXRoOiAnJyxcclxuICAgICAgICAgICAgY3VydmVFbGVtZW50czogW1xyXG4gICAgICAgICAgICAgICAgeyBpZDogJ2N1cnZlLTEtYScsIGRlZ3JlZTogODAsIHN0YXJ0RGVncmVlOiAwIH0sXHJcbiAgICAgICAgICAgICAgICB7IGlkOiAnY3VydmUtMS1iJywgZGVncmVlOiA4MCwgc3RhcnREZWdyZWU6IDQ1IH0sXHJcbiAgICAgICAgICAgICAgICB7IGlkOiAnY3VydmUtMS1jJywgZGVncmVlOiA4MCwgc3RhcnREZWdyZWU6IDc1IH0sXHJcbiAgICAgICAgICAgICAgICB7IGlkOiAnY3VydmUtMi1hJywgZGVncmVlOiAxMzAsIHN0YXJ0RGVncmVlOiAyMCB9LFxyXG4gICAgICAgICAgICAgICAgeyBpZDogJ2N1cnZlLTItYicsIGRlZ3JlZTogMTMwLCBzdGFydERlZ3JlZTogMjAgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdW50ZWQoKSB7XHJcblxyXG4gICAgfSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBzZXRDbGlwUGF0aChkZWdyZWUsIHN0YXJ0RGVncmVlKSB7XHJcbiAgICAgICAgICAgIC8vc3RhcnQgYXQgY2VudGVyXHJcbiAgICAgICAgICAgIGxldCBwYXRoID0gJzUwJSA1MCUnO1xyXG4gICAgICAgICAgICAvL2FkZCBmaXJzdCBwb2ludCB0aGF0IG1hdGNoZXMgdGhlIHN0YXJ0aW5nIGRlZ3JlZSAoMCA9IGJvdHRvbSwgOTAgPSByaWdodCwgMTgwID0gdG9wLCAyNzAgPSBsZWZ0LCAzNjAgPSBib3R0b20pXHJcbiAgICAgICAgICAgIHBhdGggKz0gYCwke01hdGguZmxvb3IodGhpcy54KHN0YXJ0RGVncmVlLCA1MCkpKzUwfSUgJHtNYXRoLmZsb29yKHRoaXMueShzdGFydERlZ3JlZSwgNTApKSs1MH0lYDtcclxuICAgICAgICAgICAgLy9hZGQgdGhlIGNvcm5lciBwb2ludHMgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBkZWdyZWUsIHRoaXMgcHJldmVudHMgdGhlIGFyYyBmcm9tIGJlaW5nIGN1dCBvZmYgaWYgaXQgZXhjZWVkcyAxODAgZGVncmVlc1xyXG4gICAgICAgICAgICBsZXQgIGNsb3N1cmVQb2ludHMgPSBbJywgMTAwJSAxMDAlJywgJywgMTAwJSAwJScsICAnLCAwJSAwJScsICcsIDAlIDEwMCUnXTtcclxuICAgICAgICAgICAgcGF0aCArPSBjbG9zdXJlUG9pbnRzLnNsaWNlKE1hdGguZmxvb3Ioc3RhcnREZWdyZWUgLyA5MCksIE1hdGguZmxvb3IoKGRlZ3JlZSArIHN0YXJ0RGVncmVlKSAvIDkwKSArIDEpLmpvaW4oJycpO1xyXG4gICAgICAgICAgICAvL2FkZCB0aGUgZmluYWwgcG9pbnRcclxuICAgICAgICAgICAgcGF0aCArPSBgLCR7TWF0aC5mbG9vcih0aGlzLngoZGVncmVlICsgc3RhcnREZWdyZWUsIDUwKSkrNTB9JSAke01hdGguZmxvb3IodGhpcy55KGRlZ3JlZSArIHN0YXJ0RGVncmVlLCA1MCkpKzUwfSVgO1xyXG4gICAgICAgICAgICByZXR1cm4gYGNsaXAtcGF0aDogcG9seWdvbigke3BhdGh9KWA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRDbGlwUGF0aFNWRyhkZWdyZWUsIHN0YXJ0RGVncmVlLCBhc0NsaXBQYXRoT25seSkge1xyXG4gICAgICAgICAgICAvLyByZXR1cm4gJy41IC41LCAwLjUgMSwgMSAxLCAxIC41LCAuNSAuNSc7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL3N0YXJ0IGF0IGNlbnRlclxyXG4gICAgICAgICAgICBsZXQgcGF0aCA9ICcuNSAuNSc7XHJcbiAgICAgICAgICAgIC8vYWRkIGZpcnN0IHBvaW50IHRoYXQgbWF0Y2hlcyB0aGUgc3RhcnRpbmcgZGVncmVlICgwID0gYm90dG9tLCA5MCA9IHJpZ2h0LCAxODAgPSB0b3AsIDI3MCA9IGxlZnQsIDM2MCA9IGJvdHRvbSlcclxuICAgICAgICAgICAgcGF0aCArPSBgLCR7dGhpcy54KHN0YXJ0RGVncmVlLCAuNSkgKy41fSAke3RoaXMueShzdGFydERlZ3JlZSwgLjUpKy41fWA7XHJcbiAgICAgICAgICAgIC8vYWRkIHRoZSBjb3JuZXIgcG9pbnRzIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgZGVncmVlLCB0aGlzIHByZXZlbnRzIHRoZSBhcmMgZnJvbSBiZWluZyBjdXQgb2ZmIGlmIGl0IGV4Y2VlZHMgMTgwIGRlZ3JlZXNcclxuICAgICAgICAgICAgbGV0ICBjbG9zdXJlUG9pbnRzID0gWycsIDEgMScsICcsIDEgMCcsICAnLCAwIDAnLCAnLCAwIDEnXTtcclxuICAgICAgICAgICAgcGF0aCArPSBjbG9zdXJlUG9pbnRzLnNsaWNlKE1hdGguZmxvb3Ioc3RhcnREZWdyZWUgLyA5MCksIE1hdGguZmxvb3IoKGRlZ3JlZSArIHN0YXJ0RGVncmVlKSAvIDkwKSArIDEpLmpvaW4oJycpO1xyXG4gICAgICAgICAgICAvL2FkZCB0aGUgZmluYWwgcG9pbnRcclxuICAgICAgICAgICAgcGF0aCArPSBgLCR7KHRoaXMueChkZWdyZWUgKyBzdGFydERlZ3JlZSwgLjUpKSsuNX0gJHsodGhpcy55KGRlZ3JlZSArIHN0YXJ0RGVncmVlLCAuNSkpKy41fSwgMC41IDAuNWA7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcJS9nLCAnJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB4OiAoZGVncmVlLCByYWRpdXMpID0+IHtcclxuICAgICAgICAgICByZXR1cm4gKE1hdGguc2luKGRlZ3JlZSooTWF0aC5QSS8xODApKSpyYWRpdXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgeTogKGRlZ3JlZSwgcmFkaXVzKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiAoTWF0aC5jb3MoZGVncmVlKihNYXRoLlBJLzE4MCkpKnJhZGl1cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG48L3NjcmlwdD5cclxuPHN0eWxlIGxhbmc9J3Njc3MnIHR5cGU9XCJ0ZXh0L3Njc3NcIj5cclxuQGltcG9ydCAnfl9zY3NzXy9fbWl4aW5zJztcclxuXHJcbiNnZW9tZXRyeS1jb250YWluZXIge1xyXG4gICAgcG9zaXRpb246IGZpeGVkO1xyXG4gICAgei1pbmRleDogMjtcclxuICAgIGhlaWdodDogNzV2aDtcclxuICAgIHdpZHRoOiAwcHg7XHJcbiAgICByaWdodDogMDtcclxuICAgIHRvcDogMDtcclxuICAgIC5zaGFwZSB7XHJcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICAgIEBpbmNsdWRlIHNxdWFyZS1kaWFnb25hbC1zcGxpdCgoXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJzcXVhcmUtMS1hXCIsXHJcbiAgICAgICAgICAgIGhlaWdodDogMTYwLFxyXG4gICAgICAgICAgICB3aWR0aDogMTYwLFxyXG4gICAgICAgICAgICB0b3A6IC0zNSxcclxuICAgICAgICAgICAgcmlnaHQ6IC0yMCxcclxuICAgICAgICAgICAgZGFyay1iZWZvcmUtb25lOiB2YXIoLS1zZWNvbmRhcnktMS1hKSwgICAgZGFyay1iZWZvcmUtdHdvOiB2YXIoLS1zZWNvbmRhcnktMS1iKSxcclxuICAgICAgICAgICAgZGFyay1hZnRlci1vbmU6IHZhcigtLXNlY29uZGFyeS0xLWMpLCAgICAgICBkYXJrLWFmdGVyLXR3bzogdmFyKC0tc2Vjb25kYXJ5LTEtZCksXHJcbiAgICAgICAgICAgIGxpZ2h0LWJlZm9yZS1vbmU6IHZhcigtLXNlY29uZGFyeS0xLWMpLCAgICBsaWdodC1iZWZvcmUtdHdvOiB2YXIoLS1zZWNvbmRhcnktMS1kKSxcclxuICAgICAgICAgICAgbGlnaHQtYWZ0ZXItb25lOiB2YXIoLS1zZWNvbmRhcnktMS1hKSwgICAgICAgbGlnaHQtYWZ0ZXItdHdvOiB2YXIoLS1zZWNvbmRhcnktMS1iKSxcclxuICAgICAgICAgICAgbGlnaHQtYWZ0ZXItZ3JhZGllbnQtZGlyOiB0byBib3R0b21cclxuICAgICAgICApKTtcclxuICAgICAgICBAaW5jbHVkZSBzcXVhcmUtZGlhZ29uYWwtc3BsaXQoKFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6IFwic3F1YXJlLTEtYlwiLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDgwLFxyXG4gICAgICAgICAgICB3aWR0aDogODAsXHJcbiAgICAgICAgICAgIHRvcDogMTgwLFxyXG4gICAgICAgICAgICByaWdodDogMTUsXHJcbiAgICAgICAgICAgIHJvdGF0ZTogNDVkZWcsXHJcbiAgICAgICAgICAgIGRhcmstYmVmb3JlLW9uZTogdmFyKC0tc2Vjb25kYXJ5LTEtYSksICAgIGRhcmstYmVmb3JlLXR3bzogdmFyKC0tc2Vjb25kYXJ5LTEtYiksXHJcbiAgICAgICAgICAgIGRhcmstYWZ0ZXItb25lOiB2YXIoLS1zZWNvbmRhcnktMS1jKSwgICAgICAgZGFyay1hZnRlci10d286IHZhcigtLXNlY29uZGFyeS0xLWQpLFxyXG4gICAgICAgICAgICBsaWdodC1iZWZvcmUtb25lOiB2YXIoLS1zZWNvbmRhcnktMS1jKSwgICAgbGlnaHQtYmVmb3JlLXR3bzogdmFyKC0tc2Vjb25kYXJ5LTEtZCksXHJcbiAgICAgICAgICAgIGxpZ2h0LWFmdGVyLW9uZTogdmFyKC0tc2Vjb25kYXJ5LTEtYSksICAgICAgIGxpZ2h0LWFmdGVyLXR3bzogdmFyKC0tc2Vjb25kYXJ5LTEtYiksXHJcbiAgICAgICAgICAgIGxpZ2h0LWFmdGVyLWdyYWRpZW50LWRpcjogdG8gYm90dG9tLFxyXG4gICAgICAgICAgICB6LWluZGV4OiAyXHJcbiAgICAgICAgKSk7XHJcbiAgICAgICAgJi5zcXVhcmUtMS1iIHtcclxuICAgICAgICAgICAgLS1yb3RhdGU6IDBkZWc7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoNDAwcHgpIHJvdGF0ZVkodmFyKC0tcm90YXRlKSkgcm90YXRlWig0NWRlZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBpbmNsdWRlIHNxdWFyZS1kaWFnb25hbC1zcGxpdCgoXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJzcXVhcmUtMi1hXCIsXHJcbiAgICAgICAgICAgIGhlaWdodDogMTMwLFxyXG4gICAgICAgICAgICB3aWR0aDogMTMwLFxyXG4gICAgICAgICAgICB0b3A6IDY4LFxyXG4gICAgICAgICAgICByaWdodDogMTA3LFxyXG4gICAgICAgICAgICByb3RhdGU6IC0xMzVkZWcsXHJcbiAgICAgICAgICAgIGRhcmstYmVmb3JlLW9uZTogdmFyKC0tcHJpbWFyeS0xLWEpLCAgICBkYXJrLWJlZm9yZS10d286IHZhcigtLXByaW1hcnktMS1iKSxcclxuICAgICAgICAgICAgZGFyay1hZnRlci1vbmU6IHZhcigtLXByaW1hcnktMS1jKSwgICAgICAgZGFyay1hZnRlci10d286IHZhcigtLXByaW1hcnktMS1kKSxcclxuICAgICAgICAgICAgbGlnaHQtYmVmb3JlLW9uZTogdmFyKC0tcHJpbWFyeS0xLWEpLCAgICAgICBsaWdodC1iZWZvcmUtdHdvOiB2YXIoLS1wcmltYXJ5LTEtYiksXHJcbiAgICAgICAgICAgIGxpZ2h0LWFmdGVyLW9uZTogdmFyKC0tcHJpbWFyeS0xLWMpLCAgICAgICAgbGlnaHQtYWZ0ZXItdHdvOiB2YXIoLS1wcmltYXJ5LTEtZClcclxuICAgICAgICApKTtcclxuICAgICAgICBAaW5jbHVkZSBzcXVhcmUtZGlhZ29uYWwtc3BsaXQoKFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6IFwic3F1YXJlLTItYlwiLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDExMCxcclxuICAgICAgICAgICAgd2lkdGg6IDExMCxcclxuICAgICAgICAgICAgdG9wOiAyMzAsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAxMTcsXHJcbiAgICAgICAgICAgIHJvdGF0ZTogMTM1ZGVnLFxyXG4gICAgICAgICAgICBkYXJrLWJlZm9yZS1vbmU6IHZhcigtLXByaW1hcnktMS1hKSwgICAgZGFyay1iZWZvcmUtdHdvOiB2YXIoLS1wcmltYXJ5LTEtYiksXHJcbiAgICAgICAgICAgIGRhcmstYWZ0ZXItb25lOiB2YXIoLS1wcmltYXJ5LTEtYyksICAgICAgIGRhcmstYWZ0ZXItdHdvOiB2YXIoLS1wcmltYXJ5LTEtZCksXHJcbiAgICAgICAgICAgIGxpZ2h0LWJlZm9yZS1vbmU6IHZhcigtLXByaW1hcnktMS1hKSwgICAgICAgbGlnaHQtYmVmb3JlLXR3bzogdmFyKC0tcHJpbWFyeS0xLWIpLFxyXG4gICAgICAgICAgICBsaWdodC1hZnRlci1vbmU6IHZhcigtLXByaW1hcnktMS1jKSwgICAgICAgIGxpZ2h0LWFmdGVyLXR3bzogdmFyKC0tcHJpbWFyeS0xLWQpLFxyXG4gICAgICAgICAgICB6LWluZGV4OiAyXHJcbiAgICAgICAgKSk7XHJcbiAgICAgICAgQGluY2x1ZGUgc3F1YXJlLWRpYWdvbmFsLXNwbGl0KChcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInNxdWFyZS0yLWNcIixcclxuICAgICAgICAgICAgaGVpZ2h0OiA2MCxcclxuICAgICAgICAgICAgd2lkdGg6IDYwLFxyXG4gICAgICAgICAgICB0b3A6IDI3MCxcclxuICAgICAgICAgICAgcmlnaHQ6IDI2MCxcclxuICAgICAgICAgICAgcm90YXRlOiAtMjVkZWcsXHJcbiAgICAgICAgICAgIGRhcmstYmVmb3JlLW9uZTogdmFyKC0tcHJpbWFyeS0xLWEpLCAgICBkYXJrLWJlZm9yZS10d286IHZhcigtLXByaW1hcnktMS1iKSxcclxuICAgICAgICAgICAgZGFyay1hZnRlci1vbmU6IHZhcigtLXByaW1hcnktMS1jKSwgICAgICAgZGFyay1hZnRlci10d286IHZhcigtLXByaW1hcnktMS1kKSxcclxuICAgICAgICAgICAgbGlnaHQtYmVmb3JlLW9uZTogdmFyKC0tcHJpbWFyeS0xLWEpLCAgICAgICBsaWdodC1iZWZvcmUtdHdvOiB2YXIoLS1wcmltYXJ5LTEtYiksXHJcbiAgICAgICAgICAgIGxpZ2h0LWFmdGVyLW9uZTogdmFyKC0tcHJpbWFyeS0xLWMpLCAgICAgICAgbGlnaHQtYWZ0ZXItdHdvOiB2YXIoLS1wcmltYXJ5LTEtZClcclxuICAgICAgICApKTtcclxuICAgICAgICAmLnNxdWFyZS0yLWMge1xyXG4gICAgICAgICAgICAtLXJvdGF0ZVg6IDBkZWc7XHJcbiAgICAgICAgICAgIC0tdHJhbnNsYXRlWTogMHB4O1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZVooLTI1ZGVnKSBwZXJzcGVjdGl2ZSg0MDBweCkgcm90YXRlWCh2YXIoLS1yb3RhdGVYKSkgdHJhbnNsYXRlWSh2YXIoLS10cmFuc2xhdGVZKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBpbmNsdWRlIHNxdWFyZS1kaWFnb25hbC1zcGxpdCgoXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJzcXVhcmUtMi1kXCIsXHJcbiAgICAgICAgICAgIGhlaWdodDogMjAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAyMCxcclxuICAgICAgICAgICAgdG9wOiAyNSxcclxuICAgICAgICAgICAgcmlnaHQ6IDI1NSxcclxuICAgICAgICAgICAgcm90YXRlOiAtNTBkZWcsXHJcbiAgICAgICAgICAgIGRhcmstYmVmb3JlLW9uZTogdmFyKC0tcHJpbWFyeS0xLWEpLCAgICBkYXJrLWJlZm9yZS10d286IHZhcigtLXByaW1hcnktMS1iKSxcclxuICAgICAgICAgICAgZGFyay1hZnRlci1vbmU6IHZhcigtLXByaW1hcnktMS1jKSwgICAgICAgZGFyay1hZnRlci10d286IHZhcigtLXByaW1hcnktMS1kKSxcclxuICAgICAgICAgICAgbGlnaHQtYmVmb3JlLW9uZTogdmFyKC0tcHJpbWFyeS0xLWEpLCAgICAgICBsaWdodC1iZWZvcmUtdHdvOiB2YXIoLS1wcmltYXJ5LTEtYiksXHJcbiAgICAgICAgICAgIGxpZ2h0LWFmdGVyLW9uZTogdmFyKC0tcHJpbWFyeS0xLWMpLCAgICAgICAgbGlnaHQtYWZ0ZXItdHdvOiB2YXIoLS1wcmltYXJ5LTEtZClcclxuICAgICAgICApKTtcclxuICAgICAgICAmLnNxdWFyZS0yLWQge1xyXG4gICAgICAgICAgICAtLXJpZ2h0OiAyNTVweDtcclxuICAgICAgICAgICAgcmlnaHQ6IHZhcigtLXJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJi5zcXVhcmUtMy1hIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjdzIGxpbmVhciwgYm94LXNoYWRvdyAwLjdzIGxpbmVhciwgdHJhbnNpdGlvbiAwLjI4cyBsaW5lYXIsIHRvcCAwLjI4cyBsaW5lYXI7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICAgICAgei1pbmRleDogMjtcclxuICAgICAgICAgICAgaGVpZ2h0OiAxNjBweDtcclxuICAgICAgICAgICAgd2lkdGg6IDE5MHB4O1xyXG4gICAgICAgICAgICB0b3A6IDEyMHB4O1xyXG4gICAgICAgICAgICByaWdodDogMTcycHg7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLW5ldXRyYWwtMik7XHJcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IHZhcigtLW5ldXRyYWwtMi1zaGFkb3cpO1xyXG4gICAgICAgICAgICBvcGFjaXR5OiAxO1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDQwMHB4KSByb3RhdGVZKDE1OWRlZykgc2tld1goLTdkZWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAmLnNxdWFyZS0zLWIge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgMC43cyBsaW5lYXI7XHJcbiAgICAgICAgICAgIHotaW5kZXg6IDM7XHJcbiAgICAgICAgICAgIGhlaWdodDogOTBweDtcclxuICAgICAgICAgICAgd2lkdGg6IDkwcHg7XHJcbiAgICAgICAgICAgIHRvcDogOTBweDtcclxuICAgICAgICAgICAgcmlnaHQ6IDExNXB4O1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1uZXV0cmFsLTIpO1xyXG4gICAgICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1uZXV0cmFsLTItc2hhZG93KTtcclxuICAgICAgICAgICAgb3BhY2l0eTogMTtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGVaKDI1ZGVnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJi5zcXVhcmUtMy1jIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYWxsIDAuN3MgbGluZWFyO1xyXG4gICAgICAgICAgICB6LWluZGV4OiA2O1xyXG4gICAgICAgICAgICBoZWlnaHQ6IDM1cHg7XHJcbiAgICAgICAgICAgIHdpZHRoOiAzNXB4O1xyXG4gICAgICAgICAgICB0b3A6IDE4MHB4O1xyXG4gICAgICAgICAgICByaWdodDogMzcwcHg7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLW5ldXRyYWwtMik7XHJcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IHZhcigtLW5ldXRyYWwtMi1zaGFkb3cpO1xyXG4gICAgICAgICAgICBvcGFjaXR5OiAxO1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZVooMjVkZWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBAaW5jbHVkZSBjdXJ2ZSgoXHJcbiAgICAgICAgICAgIGlkOiBcImN1cnZlLTEtYVwiLFxyXG4gICAgICAgICAgICB0b3A6IDgwcHgsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAzMzBweCxcclxuICAgICAgICAgICAgd2lkdGg6IDE1MHB4LFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDEwMHB4LFxyXG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA1MCUsXHJcbiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHZhcigtLXByaW1hcnktbGluZS0xKSxcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMjhkZWcpLFxyXG4gICAgICAgICAgICB6LWluZGV4OiAxXHJcbiAgICAgICAgKSk7XHJcbiAgICAgICAgQGluY2x1ZGUgY3VydmUoKFxyXG4gICAgICAgICAgICBpZDogXCJjdXJ2ZS0xLWJcIixcclxuICAgICAgICAgICAgdG9wOiAtODBweCxcclxuICAgICAgICAgICAgcmlnaHQ6IDIyNXB4LFxyXG4gICAgICAgICAgICB3aWR0aDogODBweCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAzMDBweCxcclxuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlLFxyXG4gICAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCB2YXIoLS1wcmltYXJ5LWxpbmUtMSksXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKC0yMTVkZWcpLFxyXG4gICAgICAgICAgICB6LWluZGV4OiAxXHJcbiAgICAgICAgKSk7XHJcbiAgICAgICAgQGluY2x1ZGUgY3VydmUoKFxyXG4gICAgICAgICAgICBpZDogXCJjdXJ2ZS0xLWNcIixcclxuICAgICAgICAgICAgdG9wOiAyMTVweCxcclxuICAgICAgICAgICAgcmlnaHQ6IDI0MHB4LFxyXG4gICAgICAgICAgICB3aWR0aDogMTQwcHgsXHJcbiAgICAgICAgICAgIGhlaWdodDogMTQwcHgsXHJcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJSxcclxuICAgICAgICAgICAgYm9yZGVyOiAycHggc29saWQgdmFyKC0tcHJpbWFyeS1saW5lLTEpLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpLFxyXG4gICAgICAgICAgICB6LWluZGV4OiAxXHJcbiAgICAgICAgKSk7XHJcbiAgICAgICAgJiNjdXJ2ZS0xLWMge1xyXG4gICAgICAgICAgICAtLXJvdGF0ZTogMTgwZGVnO1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSh2YXIoLS1yb3RhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgQGluY2x1ZGUgY3VydmUoKFxyXG4gICAgICAgICAgICBpZDogXCJjdXJ2ZS0yLWFcIixcclxuICAgICAgICAgICAgdG9wOiAxMzBweCxcclxuICAgICAgICAgICAgcmlnaHQ6IDIwcHgsXHJcbiAgICAgICAgICAgIHdpZHRoOiA2MHB4LFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDkwcHgsXHJcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJSxcclxuICAgICAgICAgICAgYm9yZGVyOiAycHggc29saWQgdmFyKC0tc2Vjb25kYXJ5LWxpbmUtMSksXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDExMGRlZyksXHJcbiAgICAgICAgICAgIHotaW5kZXg6IDFcclxuICAgICAgICApKTtcclxuICAgICAgICBAaW5jbHVkZSBjdXJ2ZSgoXHJcbiAgICAgICAgICAgIGlkOiBcImN1cnZlLTItYlwiLFxyXG4gICAgICAgICAgICB0b3A6IDI3MHB4LFxyXG4gICAgICAgICAgICByaWdodDogMTYwcHgsXHJcbiAgICAgICAgICAgIHdpZHRoOiAzMHB4LFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDEzMHB4LFxyXG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA1MCUsXHJcbiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHZhcigtLXNlY29uZGFyeS1saW5lLTEpLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtMzBkZWcpLFxyXG4gICAgICAgICAgICB6LWluZGV4OiAxXHJcbiAgICAgICAgKSk7XHJcbiAgICB9XHJcbn1cclxuPC9zdHlsZT5cclxuXHJcblxyXG4iLCI8dGVtcGxhdGU+XHJcblx0PGRpdj5cclxuXHRcdDxkaXYgaWQ9XCJzY3JvbGwtcmVmZXJlbmNlXCI+XHJcblx0XHRcdDx0ZW1wbGF0ZSB2LWZvcj1cIihjYXJkLCBpbmRleCkgaW4gIGNvZGVQZW5DYXJkc1wiPlxyXG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiZGFyayB2aXNpYmxlIGxvY2F0aW9uLXRyYWNlciB0cmFjZXItc3F1YXJlXCIgOmtleT1cImBkYXJrLXNxdWFyZS0ke2luZGV4fWBcIj48L3NwYW4+XHJcblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJsaWdodCBsb2NhdGlvbi10cmFjZXIgdHJhY2VyLXNxdWFyZVwiIDprZXk9XCJgbGlnaHQtc3F1YXJlLSR7aW5kZXh9YFwiPjwvc3Bhbj5cclxuXHRcdFx0PC90ZW1wbGF0ZT5cclxuXHRcdFx0PGRpdiBjbGFzcz1cImFycm93LWRvd24taW5kaWNhdG9yXCI+PC9kaXY+XHJcblx0XHRcdDx0ZW1wbGF0ZSB2LWZvcj1cIihjYXJkLCBpbmRleCkgaW4gQXJyYXkuYXBwbHkobnVsbCwgeyBsZW5ndGg6IGNvZGVQZW5DYXJkcy5sZW5ndGggLSAxIH0pXCI+XHJcblx0XHRcdFx0PGRpdiBjbGFzcz1cImFycm93LXVwXCIgOmtleT1cImBkb3duLSR7aW5kZXh9YFwiPjwvZGl2PlxyXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJhcnJvdy1kb3duXCIgOmtleT1cImB1cC0ke2luZGV4fWBcIiA+PC9kaXY+XHJcblx0XHRcdDwvdGVtcGxhdGU+XHJcblx0XHRcdDxkaXYgY2xhc3M9XCJwb3J0Zm9saW8tc3VtbWFyeVwiPlxyXG5cdFx0XHRcdEEgY29sbGVjdGlvbiBvZiB3b3JrIGJyaWVmbHkgZGVtb25zdHJhdGluZyBzb21lIG9mIG15IGNhcGFiaWxpdGllcyBpbiBmcm9udCBlbmQgZGV2ZWxvcG1lbnQuXHJcblx0XHRcdDwvZGl2PlxyXG5cdFx0PC9kaXY+XHJcblx0XHQ8dGVtcGxhdGUgdi1mb3I9XCIoY2FyZCwgaW5kZXgpIGluIGNvZGVQZW5DYXJkc1wiPlxyXG5cdFx0XHQ8c2VjdGlvbiBjbGFzcz1cImNvZGUtZXhhbXBsZVwiIDprZXk9XCJpbmRleFwiIHJlZj1cInNlY3Rpb25zXCI+XHJcblx0XHRcdFx0PGNvbXBvbmVudCA6aXM9XCJjYXJkLm1vZHVsZVwiIDp0aXRsZT1cImNhcmQudGl0bGVcIiA6aWQ9XCJjYXJkLmlkXCIgOnVybD1cImNhcmQudXJsXCIgOmltZ1VybD1cImNhcmQuaW1nVXJsXCIgOnRyaWdnZXI9XCJzY3JvbGxUcmlnZ2Vyc1tpbmRleF1cIiA6ZGVzY3JpcHRpb249XCJjYXJkLmRlc2NyaXB0aW9uXCIgOmlzTGFzdE1vZHVsZT1cImNvZGVQZW5DYXJkcy5sZW5ndGggLSAxID09IGluZGV4XCI+PC9jb21wb25lbnQ+XHJcblx0XHRcdDwvc2VjdGlvbj5cclxuXHRcdFx0PGRpdiBjbGFzcz1cInNwYWNlclwiIDprZXk9XCJgc3BhY2VyLSR7aW5kZXh9YFwiPjwvZGl2PlxyXG5cdFx0PC90ZW1wbGF0ZT5cclxuXHRcdDxkaXYgc3R5bGU9XCJoZWlnaHQ6IDEwMHZoXCI+PC9kaXY+XHJcblx0PC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgQ29kZVBlbkNhcmQgZnJvbSAnLi9wb3J0Zm9saW8vQ29kZVBlbkNhcmQudnVlJztcclxuaW1wb3J0IEFuaWFtdGlvbkRlbW8gZnJvbSAnX2ltYWdlc18vQW5pbWF0aW9uRGVtby5QTkcnO1xyXG5pbXBvcnQgQnJpZ2h0bGFuZCBmcm9tICdfaW1hZ2VzXy9icmlnaHRsYW5kLmpwZyc7XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRuYW1lOiAncG9ydGZvbGlvLWxpc3QnLFxyXG5cdGNvbXBvbmVudHM6IHtcclxuXHRcdCdDb2RlUGVuQ2FyZCc6IENvZGVQZW5DYXJkXHJcblx0fSxcclxuXHRwcm9wczoge1xyXG5cdFx0c3VtbWFyeVRyaWdnZXI6IHtcclxuXHRcdFx0Ly9UaGUgc2Nyb2xsIHRyaWdnZXIgZm9yIHRoZSB0ZXh0IGF0IHRoZSBiZWdpbm5pbmcgaXMgdGhlIHNhbWUgYXMgdGhlIGJpbyB0cmlnZ2VyLlxyXG5cdFx0XHQvL0JvdGggdGhlIGJpbyBhbmQgdGhlIHBvcnRmb2xpbyBzdW1tYXJ5IHRleHQgc2hvdWxkIGFuaW1hdGlvbiBmcm9tIHRoZSBzYW1lIHRyaWdnZXIuXHJcblx0XHRcdHR5cGU6IE9iamVjdFxyXG5cdFx0fVxyXG5cdH0sXHJcblx0ZGF0YSgpIHtcclxuXHRcdHJldHVybiAge1xyXG5cdFx0XHRjb2RlUGVuQ2FyZHM6IFtcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRtb2R1bGU6IENvZGVQZW5DYXJkLFxyXG5cdFx0XHRcdFx0dXJsOiAnaHR0cHM6Ly9icmlnaHRsYW5kbGlnaHRzLmNvbS8nLFxyXG5cdFx0XHRcdFx0aW1nVXJsOiBCcmlnaHRsYW5kLFxyXG5cdFx0XHRcdFx0dGl0bGU6ICdCcmlnaHRsYW5kJyxcclxuXHRcdFx0XHRcdGlkOiAnYnJpZ2h0bGFuZCcsXHJcblx0XHRcdFx0XHRkZXNjcmlwdGlvbjogJ0EgY2xpZW50IHByb2plY3QgdG8gcHJvbW90ZSB0aGVpciBsaWdodGluZyBkZWNvcmF0aW9uIGJ1c2luZXNzLidcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdG1vZHVsZTogQ29kZVBlbkNhcmQsXHJcblx0XHRcdFx0XHR1cmw6ICdodHRwczovL2pvcmRhbmtsYWVycy5naXRodWIuaW8vYW5pbWF0aW9uRGVtb25zdHJhdGlvbi8nLFxyXG5cdFx0XHRcdFx0aW1nVXJsOiBBbmlhbXRpb25EZW1vLFxyXG5cdFx0XHRcdFx0dGl0bGU6ICdBbmltYXRpb24gRGVtbycsXHJcblx0XHRcdFx0XHRpZDogJ2FuaW1hdGlvbi1kZW1vJyxcclxuXHRcdFx0XHRcdGRlc2NyaXB0aW9uOiAnQSBDb2xsZWN0aW9uIG9mIGFuaW1hdGlvbnM7IHRyYW5zaXRpb25zLCBrZXlmcmFtZSwgYW5kIHJlcXVlc3RBbmltYXRpb25GcmFtZS4gRm9yIHVzZSBpbiBhIGtub3dsZWRnZSBzaGFyZSBwcmVzZW50YXRpb24uJ1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0bW9kdWxlOiBDb2RlUGVuQ2FyZCxcclxuXHRcdFx0XHRcdHVybDogJ2h0dHBzOi8vY29kZXBlbi5pby9qb3JkYW5rbGFlcnMvcGVuL3h4S0xSZVonLFxyXG5cdFx0XHRcdFx0aW1nVXJsOiAnaHR0cHM6Ly9hc3NldHMuY29kZXBlbi5pby8xMzc5OTQxL2ludGVybmFsL3NjcmVlbnNob3RzL3BlbnMveHhLTFJlWi5kZWZhdWx0LnBuZz9maXQ9Y292ZXImZm9ybWF0PWF1dG8maGE9ZmFsc2UmaGVpZ2h0PTU0MCZxdWFsaXR5PTc1JnY9MiZ2ZXJzaW9uPTE1ODcwNTc5NTUmd2lkdGg9OTYwJyxcclxuXHRcdFx0XHRcdHRpdGxlOiAnTm90aWZpY2F0aW9uIFdpZGdldCcsXHJcblx0XHRcdFx0XHRpZDogJ25vdGlmaWNhdGlvbi13aWRnZXQnLFxyXG5cdFx0XHRcdFx0ZGVzY3JpcHRpb246IFwiQSBDU1MgY2hhbGxlbmdlIHRvIGNyZWF0ZSBjb250ZW50IGZyb20gYW4gaW1hZ2UuIEltcGxlbWVudGVkIGEgY2FudmFzIGFuaW1hdGlvbiB0byBhZGQgc29tZSBleHRyYSBmbGFpci5cIlxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0bW9kdWxlOiBDb2RlUGVuQ2FyZCxcclxuXHRcdFx0XHRcdHVybDogJ2h0dHBzOi8vY29kZXBlbi5pby9qb3JkYW5rbGFlcnMvcGVuL3FCV1JnalAnLFxyXG5cdFx0XHRcdFx0aW1nVXJsOiAnaHR0cHM6Ly9hc3NldHMuY29kZXBlbi5pby8xMzc5OTQxL2ludGVybmFsL3NjcmVlbnNob3RzL3BlbnMvcUJXUmdqUC5kZWZhdWx0LnBuZz9maXQ9Y292ZXImZm9ybWF0PWF1dG8maGE9ZmFsc2UmaGVpZ2h0PTU0MCZxdWFsaXR5PTc1JnY9MiZ2ZXJzaW9uPTE2MjQ3NDgwMTQmd2lkdGg9OTYwJyxcclxuXHRcdFx0XHRcdHRpdGxlOiAnVGhlcm1vc3RhdCcsXHJcblx0XHRcdFx0XHRpZDogJ3RoZXJtb3N0YXQnLFxyXG5cdFx0XHRcdFx0ZGVzY3JpcHRpb246IFwiQSBDU1MgY2hhbGxlbmdlIHRvIGNyZWF0ZSBhIHRoZXJtb3N0YXQuXCJcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdG1vZHVsZTogQ29kZVBlbkNhcmQsXHJcblx0XHRcdFx0XHR1cmw6ICdodHRwczovL2NkcG4uaW8vam9yZGFua2xhZXJzL2Z1bGxjcGdyaWQvYWdWR2pSJyxcclxuXHRcdFx0XHRcdGltZ1VybDogJ2h0dHBzOi8vYXNzZXRzLmNvZGVwZW4uaW8vMTM3OTk0MS9pbnRlcm5hbC9zY3JlZW5zaG90cy9wZW5zL2FnVkdqUi5kZWZhdWx0LnBuZz9maXQ9Y292ZXImZm9ybWF0PWF1dG8maGE9dHJ1ZSZoZWlnaHQ9NTQwJnF1YWxpdHk9NzUmdj0yJnZlcnNpb249MTU4NzA1ODg3NSZ3aWR0aD05NjAnLFxyXG5cdFx0XHRcdFx0dGl0bGU6ICdIb3ZlciBSb3RhdGlvbiBBbmltYXRpb25zJyxcclxuXHRcdFx0XHRcdGlkOiAnaG92ZXItcm90YXRpb24tYW5pbWF0aW9uJyxcclxuXHRcdFx0XHRcdGRlc2NyaXB0aW9uOiBcIkEgQ1NTIGNoYWxsZW5nZSB0byBjcmVhdGUgY29udGVudCBmcm9tIGFuIGltYWdlLiBBZGRlZCBzb21lIDNEIGFuaW1hdGlvbiB0byBhZGQgc29tZSBmbGFpci5cIlxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyB7XHJcblx0XHRcdFx0Ly8gXHRtb2R1bGU6ICcnLFxyXG5cdFx0XHRcdC8vIFx0dXJsOiAnJ1xyXG5cdFx0XHRcdC8vIFx0aW1nVXJsOiAnJyxcclxuXHRcdFx0XHQvLyBcdHRpdGxlOiAnJyxcclxuXHRcdFx0XHQvLyBcdGlkOiAnJ1xyXG5cdFx0XHRcdC8vIH1cclxuXHRcdFx0XSxcclxuXHRcdFx0c2Nyb2xsVHJpZ2dlcnM6IFtdXHJcblx0XHR9XHJcblx0fSxcclxuXHRtb3VudGVkKCkge1xyXG5cdFx0Ly9UaGUgc2Nyb2xsIHRyaWdnZXJzIGFzc29jaWF0ZWQgdG8gZWFjaCBzZWN0aW9uLCB3cmFwcGluZyB0aGUgY29udGVudCwgYXJlIGdlbmVyYXRlZCBoZXJlLCBhbmQgcGFzc2VkIHRvIHRoZSBDb2RlUGVuQ2FyZCBtb2R1bGUsIHNvIGVhY2ggbW9kdWxlIGdlbmVyYXRlcyBpdHMgb3duIGFuaW1hdGlvblxyXG5cdFx0Ly9UaGUgYW5pbWF0aW9ucyBvZiB0aGUgYXJyb3dzIGFuZCBkb3QgdGhhdCB0cmFjayB0aGUgc2Nyb2xsIHByb2dyZXNzIGFyZSBjcmVhdGVkIGhlcmUsIGFuZCB1c2UgdGhlIHNhbWUgc2Nyb2xsIHRyaWdnZXIgcGFzc2VkIHRvIGVhY2ggY2FyZFxyXG5cdFx0Y29uc3QgbGlnaHRUcmFjZXJTcXVhcmVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3Njcm9sbC1yZWZlcmVuY2UgLmxpZ2h0LnRyYWNlci1zcXVhcmUnKTtcclxuXHRcdGNvbnN0IGRhcmtUcmFjZXJTcXVhcmVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3Njcm9sbC1yZWZlcmVuY2UgLmRhcmsudHJhY2VyLXNxdWFyZScpO1xyXG5cdFx0Y29uc3QgdXBBcnJvd3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjc2Nyb2xsLXJlZmVyZW5jZSAuYXJyb3ctdXAnKTtcclxuXHRcdGNvbnN0IGRvd25BcnJvd3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjc2Nyb2xsLXJlZmVyZW5jZSAuYXJyb3ctZG93bicpO1xyXG5cdFx0dGhpcy4kcmVmcy5zZWN0aW9ucy5mb3JFYWNoKChzZWN0aW9uLCBpbmRleCkgPT4ge1xyXG5cdFx0XHR0aGlzLnNjcm9sbFRyaWdnZXJzLnB1c2goe1xyXG5cdFx0XHRcdHRyaWdnZXI6IHNlY3Rpb24sXHJcblx0XHRcdFx0c3RhcnQ6IFwidG9wIHRvcFwiLFxyXG5cdFx0XHRcdGVuZDogXCJib3R0b20gdG9wXCIsXHJcblx0XHRcdFx0c2NydWI6IDAuNyxcclxuXHRcdFx0XHRzbmFwOiB7XHJcblx0XHRcdFx0XHRzbmFwVG86IFwibGFiZWxzXCIsXHJcblx0XHRcdFx0XHRkdXJhdGlvbjoge21pbjogMC42LCBtYXg6IDAuNn0sXHJcblx0XHRcdFx0XHRkZWxheTogMC4yXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5jcmVhdGVTY3JvbGxUcmFjZXJBbmltYXRpb24obGlnaHRUcmFjZXJTcXVhcmVzW2luZGV4XSwgaW5kZXgpO1xyXG5cdFx0XHR0aGlzLmNyZWF0ZVNjcm9sbFRyYWNlckFuaW1hdGlvbihkYXJrVHJhY2VyU3F1YXJlc1tpbmRleF0sIGluZGV4KTtcclxuXHRcdFx0Ly91cEFycm93IGluZGV4aW5nIHdvdWxkIHJlc3VsdCBpbiBzY3JvbGwgdHJpZ2dlciBmb3IgdGhlIHNlY29uZCBjYXJkIHRvIHVzZSB0aGUgZmlyc3QgdXBBcnJvdyBlbGVtZW50LlxyXG5cdFx0XHQvL0Rvd24gYXJyb3dzIHdvdWxkIHJlc3VsdCBpbiBubyBlbGVtZW50IHRvIGFzc29jaWF0ZSB0byB0aGUgbGFzdCBzY3JvbFRyaWdnZXIgKGJlY2F1c2UgdGhlcmUgaXMgbm8gbW9yZSB0byBzY3JvbGwgZG93bilcclxuXHRcdFx0dGhpcy5jcmVhdGVBcnJvd0luZGljYXRvckFuaW1hdGlvbih1cEFycm93c1tpbmRleCAtIDFdIHx8IG51bGwsIGRvd25BcnJvd3NbaW5kZXhdIHx8IG51bGwsIGluZGV4KTtcclxuXHRcdH0pO1xyXG5cdFx0Ly8tLXNhbWUgbm90ZSBmcm9tIHRoZSBwcm9wcy0tXHJcblx0XHQvL1RoZSBzY3JvbGwgdHJpZ2dlciBmb3IgdGhlIHRleHQgYXQgdGhlIGJlZ2lubmluZyBpcyB0aGUgc2FtZSBhcyB0aGUgYmlvIHRyaWdnZXIuXHJcblx0XHQvL0JvdGggdGhlIGJpbyBhbmQgdGhlIHBvcnRmb2xpbyBzdW1tYXJ5IHRleHQgc2hvdWxkIGFuaW1hdGlvbiBmcm9tIHRoZSBzYW1lIHRyaWdnZXIuXHJcblx0XHRuZXcgdGhpcy4kZGF0YS5fZ3NhcC5UaW1lbGluZU1heCh7XHJcblx0XHRcdFx0c2Nyb2xsVHJpZ2dlcjogdGhpcy5zdW1tYXJ5VHJpZ2dlclxyXG5cdFx0XHR9KVxyXG5cdFx0XHQuYWRkTGFiZWwoJ2luJylcclxuXHRcdFx0LmZyb21UbygnI3Njcm9sbC1yZWZlcmVuY2UgLnBvcnRmb2xpby1zdW1tYXJ5JywgXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0b3BhY2l0eTogMVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0b3BhY2l0eTogMFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0KVxyXG5cdFx0XHQuZnJvbVRvKCcjc2Nyb2xsLXJlZmVyZW5jZSAuYXJyb3ctZG93bi1pbmRpY2F0b3InLFxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHk6ICcwcmVtJyxcclxuXHRcdFx0XHRcdG9wYWNpdHk6IDFcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHk6ICctNy4xMjVyZW0nLFxyXG5cdFx0XHRcdFx0b3BhY2l0eTogMFxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0JzwnXHJcblx0XHRcdClcclxuXHRcdFx0LmFkZExhYmVsKCdvdXQnKVxyXG5cdH0sXHJcblx0bWV0aG9kczoge1xyXG5cdFx0Y3JlYXRlU2Nyb2xsVHJhY2VyQW5pbWF0aW9uKGVsLCBpbmRleCkge1xyXG5cdFx0XHQvL1RoaXMgaXMgdGhlIGFuaW1hdGlvbiBhbmQgdHJpZ2dlciBmb3IgdGhlIGJsdWUgc3F1YXJlXHJcblx0XHRcdGNvbnN0IHRpbWVsaW5lID0gbmV3IHRoaXMuJGRhdGEuX2dzYXAuVGltZWxpbmVNYXgoe1xyXG5cdFx0XHRcdFx0c2Nyb2xsVHJpZ2dlcjogdGhpcy5zY3JvbGxUcmlnZ2Vyc1tpbmRleF1cclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5hZGRMYWJlbCgndG9wT3V0JylcclxuXHRcdFx0XHQuZnJvbVRvKGVsLFxyXG5cdFx0XHRcdFx0eyB5OiAnMTQuMjVyZW0nLCBvcGFjaXR5OiAwIH0sXHJcblx0XHRcdFx0XHR7IHk6ICc3LjEyNXJlbScsIG9wYWNpdHk6IDEsIGR1cmF0aW9uOiAyIH1cclxuXHRcdFx0XHQpXHJcblx0XHRcdFx0LmFkZExhYmVsKCd0b3BJbicpXHJcblx0XHRcdFx0LnRvKGVsLCB7IHk6ICc3LjEyNXJlbScsIG9wYWNpdHk6IDEsIGR1cmF0aW9uOiAxLjUgfSlcclxuXHRcdFx0XHQuYWRkTGFiZWwoJ21pZGRsZUluJylcclxuXHRcdFx0XHQudG8oZWwsIHsgeTogJzcuMTI1cmVtJywgb3BhY2l0eTogMSwgZHVyYXRpb246IDEuNSB9KVxyXG5cdFx0XHRcdC5hZGRMYWJlbCgnYm90dG9tSW4nKVxyXG5cdFx0XHRpZiAoaW5kZXggPT0gdGhpcy4kcmVmcy5zZWN0aW9ucy5sZW5ndGggLSAxKSB0aW1lbGluZS50byhlbCwgeyB5OiAnNy4xMjVyZW0nLCBvcGFjaXR5OiAxLCBkdXJhdGlvbjogMiB9KTtcclxuXHRcdFx0ZWxzZSB0aW1lbGluZS50byhlbCwgeyB5OiAnMHJlbScsIG9wYWNpdHk6IDAsIGR1cmF0aW9uOiAyIH0pO1xyXG5cdFx0XHRcdC8vIC5hZGRMYWJlbCgnYm90dG9tT3V0JylcclxuXHRcdH0sXHJcblx0XHRjcmVhdGVBcnJvd0luZGljYXRvckFuaW1hdGlvbih0b3BBcnJvd0VsLCBib3R0b21BcnJvd0VsLCBpbmRleCkge1xyXG5cdFx0XHRpZiAoYm90dG9tQXJyb3dFbCkge1xyXG5cdFx0XHRcdGNvbnN0IGJvdHRvbUFycm93VGltZWxpbmUgPSBuZXcgdGhpcy4kZGF0YS5fZ3NhcC5UaW1lbGluZU1heCh7XHJcblx0XHRcdFx0XHRzY3JvbGxUcmlnZ2VyOiB0aGlzLnNjcm9sbFRyaWdnZXJzW2luZGV4XVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdGJvdHRvbUFycm93VGltZWxpbmVcclxuXHRcdFx0XHRcdC5mcm9tVG8oYm90dG9tQXJyb3dFbCwgXHJcblx0XHRcdFx0XHRcdHsgeTogJzE2LjI1cmVtJywgb3BhY2l0eTogMCB9LFxyXG5cdFx0XHRcdFx0XHR7IHk6ICc5LjEyNXJlbScsIG9wYWNpdHk6IDEsIGR1cmF0aW9uOiAyIH1cclxuXHRcdFx0XHRcdClcclxuXHRcdFx0XHRcdC5hZGRMYWJlbCgndG9wSW4nKVxyXG5cdFx0XHRcdFx0LnRvKGJvdHRvbUFycm93RWwsIHsgeTogJzkuMTI1cmVtJywgb3BhY2l0eTogMSwgZHVyYXRpb246IDEuNSB9KVxyXG5cdFx0XHRcdFx0LmFkZExhYmVsKCdtaWRkbGVJbicpXHJcblx0XHRcdFx0XHQudG8oYm90dG9tQXJyb3dFbCwgeyB5OiAnOS4xMjVyZW0nLCBvcGFjaXR5OiAxLCBkdXJhdGlvbjogMS41IH0pXHJcblx0XHRcdFx0XHQuYWRkTGFiZWwoJ2JvdHRvbUluJylcclxuXHRcdFx0XHRcdC50byhib3R0b21BcnJvd0VsLCB7IHk6ICcycmVtJywgb3BhY2l0eTogMCwgZHVyYXRpb246IDIgfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gaWYgYW55IGNhcmQgb3RoZXIgdGhlbiB0aGUgZmlyc3QsIHRoZW4gYW4gYXJyb3cgdG8gc2Nyb2xsIHVwIHNob3VsZCBleGlzdFxyXG5cdFx0XHRpZiAoaW5kZXggIT0gMCkge1xyXG5cdFx0XHRcdGNvbnN0IHRvcEFycm93VGltZWxpbmUgPSBuZXcgdGhpcy4kZGF0YS5fZ3NhcC5UaW1lbGluZU1heCh7XHJcblx0XHRcdFx0XHRzY3JvbGxUcmlnZ2VyOiB0aGlzLnNjcm9sbFRyaWdnZXJzW2luZGV4XVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHRvcEFycm93VGltZWxpbmVcclxuXHRcdFx0XHRcdC5mcm9tVG8odG9wQXJyb3dFbCwgXHJcblx0XHRcdFx0XHRcdHsgeTogJzEyLjI1cmVtJywgb3BhY2l0eTogMCB9LFxyXG5cdFx0XHRcdFx0XHR7IHk6ICc1LjEyNXJlbScsIG9wYWNpdHk6IDEsIGR1cmF0aW9uOiAyIH1cclxuXHRcdFx0XHRcdClcclxuXHRcdFx0XHRcdC5hZGRMYWJlbCgndG9wSW4nKVxyXG5cdFx0XHRcdFx0LnRvKHRvcEFycm93RWwsIHsgeTogJzUuMTI1cmVtJywgb3BhY2l0eTogMSwgZHVyYXRpb246IDEuNSB9KVxyXG5cdFx0XHRcdFx0LmFkZExhYmVsKCdtaWRkbGVJbicpXHJcblx0XHRcdFx0XHQudG8odG9wQXJyb3dFbCwgeyB5OiAnNS4xMjVyZW0nLCBvcGFjaXR5OiAxLCBkdXJhdGlvbjogMS41IH0pXHJcblx0XHRcdFx0XHQuYWRkTGFiZWwoJ2JvdHRvbUluJylcclxuXHRcdFx0XHRcdC50byh0b3BBcnJvd0VsLCB7IHk6ICctMnJlbScsIG9wYWNpdHk6IDAsIGR1cmF0aW9uOiAyIH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG48L3NjcmlwdD5cclxuPHN0eWxlIGxhbmc9J3Njc3MnIHR5cGU9XCJ0ZXh0L3Njc3NcIj5cclxuQGltcG9ydCAnfl9zY3NzXy92YXJpYWJsZXMnO1xyXG5AaW1wb3J0ICd+X3Njc3NfL19taXhpbnMnO1xyXG4jc2Nyb2xsLXJlZmVyZW5jZSB7XHJcblx0cG9zaXRpb246IGZpeGVkO1xyXG5cdHRvcDogMjdyZW07XHJcblx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0yNSUpO1xyXG5cdHdpZHRoOiAwLjI1cmVtO1xyXG5cdGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20sIHRyYW5zcGFyZW50LCB2YXIoLS1zZWNvbmRhcnktMS1jKSAyMCUsIHZhcigtLXNlY29uZGFyeS0xLWMpIDgwJSwgdHJhbnNwYXJlbnQpO1xyXG5cdGhlaWdodDogMTQuMjVyZW07XHJcblx0bGVmdDogY2FsYyh2YXIoLS1iaW8tcGxhY2VtZW50KSArIDFyZW0pO1xyXG5cdC5sb2NhdGlvbi10cmFjZXIge1xyXG5cdFx0ZGlzcGxheTogbm9uZTtcclxuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuXHRcdEBpbmNsdWRlIHNxdWFyZS1kaWFnb25hbC1zcGxpdC1yZW0oKFxyXG5cdFx0XHRjbGFzc05hbWU6IFwidHJhY2VyLXNxdWFyZVwiLFxyXG5cdFx0XHRoZWlnaHQ6IDEuNSxcclxuXHRcdFx0d2lkdGg6IDEuNSxcclxuXHRcdFx0dG9wOiAtMS41LFxyXG5cdFx0XHRyaWdodDogLS42MjUsXHJcblx0XHRcdHJvdGF0ZTogLTQ1ZGVnLFxyXG5cdFx0XHRkYXJrLWJlZm9yZS1vbmU6IHZhcigtLXByaW1hcnktMS1hKSwgICAgZGFyay1iZWZvcmUtdHdvOiB2YXIoLS1wcmltYXJ5LTEtYiksXHJcblx0XHRcdGRhcmstYWZ0ZXItb25lOiB2YXIoLS1wcmltYXJ5LTEtYyksICAgICAgIGRhcmstYWZ0ZXItdHdvOiB2YXIoLS1wcmltYXJ5LTEtZCksXHJcblx0XHRcdGxpZ2h0LWJlZm9yZS1vbmU6IHZhcigtLXByaW1hcnktMS1hKSwgICAgICAgbGlnaHQtYmVmb3JlLXR3bzogdmFyKC0tcHJpbWFyeS0xLWIpLFxyXG5cdFx0XHRsaWdodC1hZnRlci1vbmU6IHZhcigtLXByaW1hcnktMS1jKSwgICAgICAgIGxpZ2h0LWFmdGVyLXR3bzogdmFyKC0tcHJpbWFyeS0xLWQpXHJcblx0XHQpKTtcclxuXHR9XHJcblx0LmFycm93LWRvd24sIC5hcnJvdy11cCwgLmFycm93LWRvd24taW5kaWNhdG9yIHtcclxuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuXHRcdGhlaWdodDogMS41cmVtO1xyXG5cdFx0d2lkdGg6IDEuNXJlbTtcclxuXHRcdHJpZ2h0OiAtMC42MjVyZW07XHJcblx0XHRib3JkZXI6IDAuMnJlbSBzb2xpZDtcclxuXHRcdHRvcDogLTEuNXJlbTtcclxuXHRcdG9wYWNpdHk6IDA7XHJcblx0XHRib3JkZXItY29sb3I6IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHZhcigtLXNlY29uZGFyeS1saW5lLTEpIHZhcigtLXNlY29uZGFyeS1saW5lLTEpO1xyXG5cdH1cclxuXHQuYXJyb3ctdXAge1xyXG5cdFx0dHJhbnNmb3JtOiByb3RhdGUoMTM1ZGVnKTtcclxuXHR9XHJcblx0LmFycm93LWRvd24ge1xyXG5cdFx0dHJhbnNmb3JtOiByb3RhdGUoLTQ1ZGVnKTtcclxuXHR9XHJcblx0LmFycm93LWRvd24taW5kaWNhdG9yIHtcclxuXHRcdHRyYW5zZm9ybTogcm90YXRlKC00NWRlZyk7XHJcblx0XHR0b3A6IDUuNjI1cmVtO1xyXG5cdFx0b3BhY2l0eTogMTtcclxuXHR9XHJcblx0LnBvcnRmb2xpby1zdW1tYXJ5IHtcclxuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuXHRcdGNvbG9yOiB3aGl0ZTtcclxuXHRcdGxlZnQ6IDJyZW07XHJcblx0XHR0b3A6IDcuMTI1cmVtO1xyXG5cdFx0d2lkdGg6IDM1cmVtO1xyXG5cdFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xyXG5cdFx0Zm9udC1zaXplOiAxLjJyZW07XHJcbiAgICAgICAgbGluZS1oZWlnaHQ6IDEuNHJlbTtcclxuXHR9XHJcbn1cclxuLmNvZGUtZXhhbXBsZSB7XHJcblx0aGVpZ2h0OiAxMDB2aDtcclxuXHR3aWR0aDogMTAwdnc7XHJcblx0Ly8gYm9yZGVyOiAxcHggc29saWQgeWVsbG93O1xyXG59XHJcbi5zcGFjZXIge1xyXG5cdHdpZHRoOiAxMDB2dztcclxuXHQvLyBoZWlnaHQ6IDM1dmg7XHJcbn1cclxuPC9zdHlsZT5cclxuIiwiPHRlbXBsYXRlPlxyXG5cdDxhIDppZD1cImlkXCIgY2xhc3M9XCJjb2RlLXBlbi1jYXJkXCIgOmhyZWY9XCJ1cmxcIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCI+XHJcbiAgICAgICAgPGltZyA6c3JjPVwiaW1nVXJsXCIvPlxyXG5cdFx0PGRpdiBjbGFzcz1cImJhY2tncm91bmRcIj48L2Rpdj5cclxuXHRcdDxzcGFuIGNsYXNzPVwidGl0bGVcIj57e3RpdGxlfX08L3NwYW4+XHJcblx0XHQ8c3BhbiBjbGFzcz1cImRlc2NyaXB0aW9uXCI+e3tkZXNjcmlwdGlvbn19PC9zcGFuPlxyXG4gICAgPC9hPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IHsgdGhyb3R0bGUgfSBmcm9tICdsb2Rhc2gtZXMnO1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0bmFtZTogJ0NvZGVQZW5DYXJkJyxcclxuXHRwcm9wczoge1xyXG5cdFx0dXJsOiB7XHJcblx0XHRcdHR5cGU6IFN0cmluZ1xyXG5cdFx0fSxcclxuXHRcdGltZ1VybDoge1xyXG5cdFx0XHR0eXBlOiBTdHJpbmdcclxuXHRcdH0sXHJcblx0XHR0aXRsZToge1xyXG5cdFx0XHR0eXBlOiBTdHJpbmdcclxuXHRcdH0sXHJcblx0XHRpZDoge1xyXG5cdFx0XHR0eXBlOiBTdHJpbmdcclxuXHRcdH0sXHJcblx0XHR0cmlnZ2VyOiB7XHJcblx0XHRcdHR5cGU6IE9iamVjdFxyXG5cdFx0fSxcclxuXHRcdGRlc2NyaXB0aW9uOiB7XHJcblx0XHRcdHR5cGU6IFN0cmluZ1xyXG5cdFx0fSxcclxuXHRcdGlzTGFzdE1vZHVsZToge1xyXG5cdFx0XHR0eXBlOiBCb29sZWFuXHJcblx0XHR9XHJcblx0fSxcclxuICAgIGRhdGEoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRzY3JvbGxEaXJlY3Rpb246IG51bGwsXHJcblx0XHRcdHRvZ2dsZUFjdGl2Q2xhc3NIYW5kbGVyOiB0aHJvdHRsZSh0aGlzLnRvZ2dsZUFjdGl2ZUNsYXNzLCAxMDApXHJcblx0XHR9XHJcbiAgICB9LFxyXG5cdG1vdW50ZWQoKSB7XHJcblx0XHRjb25zdCB0bCA9IG5ldyB0aGlzLiRkYXRhLl9nc2FwLlRpbWVsaW5lTWF4KHtcclxuXHRcdFx0cGF1c2VkOiB0cnVlLFxyXG5cdFx0fSk7XHJcblx0XHRjb25zdCBkZXNjcmlwdGlvbkhlaWdodCA9IHRoaXMuY29udmVydFBpeGVsc1RvUmVtKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke3RoaXMuaWR9IC5kZXNjcmlwdGlvbmApKS5oZWlnaHQpO1xyXG5cdFx0Y29uc3QgYmFja2dyb3VuZEhlaWdodCA9IHRoaXMuY29udmVydFBpeGVsc1RvUmVtKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke3RoaXMuaWR9IC5iYWNrZ3JvdW5kYCkpLmhlaWdodCk7XHJcblx0XHRjb25zdCBob3ZlclNjYWxlID0gdGwudG8oYCMke3RoaXMuaWR9IC5iYWNrZ3JvdW5kYCwge1xyXG5cdFx0XHQvL2FkZCAyIHJlbSB0byB0aGUgdG9wIGFuZCAxIHRvIHRoZSBib3R0b20gZm9yIHRoZSBkZXNjcmlwdGlvbiB0ZXh0IHNwYWNlLCBwbHVzIHRoZSBoZWlnaHQgb2YgdGhlIGRlc2NyaXB0aW9uIHRleHRcclxuXHRcdFx0aGVpZ2h0OiBgJHtiYWNrZ3JvdW5kSGVpZ2h0ICsgNCArIGRlc2NyaXB0aW9uSGVpZ2h0fXJlbWAsXHJcblx0XHRcdHdpZHRoOiAnMjRyZW0nLFxyXG5cdFx0XHR0b3A6ICctMnJlbScsXHJcblx0XHRcdGR1cmF0aW9uOiAwLjMsXHJcblx0XHRcdGVhc2U6IFwicG93ZXIyLm91dFwiXHJcblx0XHR9KVxyXG5cdFx0LnRvKGAjJHt0aGlzLmlkfSAuZGVzY3JpcHRpb25gLCB7XHJcblx0XHRcdG9wYWNpdHk6IDEsXHJcblx0XHRcdGR1cmF0aW9uOiAwLjMsXHJcblx0XHRcdGVhc2U6IFwicG93ZXIyLm91dFwiXHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgKCkgPT4gaG92ZXJTY2FsZS5wbGF5KCkpO1xyXG4gIFx0XHR0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgKCkgPT4gaG92ZXJTY2FsZS5yZXZlcnNlKCkpO1xyXG5cdH0sXHJcblx0bWV0aG9kczoge1xyXG5cdFx0dG9nZ2xlQWN0aXZlQ2xhc3Moc2VsZikge1xyXG5cdFx0XHQvL1RoZXJlIGFyZSA3IHVuaXRzIGRpdmlkZWQgYW1vbmdzdCB0aGUgNCBzdGFnZXMgb2YgdGhlIGFuaW1hdGlvbi4gMiB1bml0cyBhcmUgZ2l2ZW4gdG8gdGhlIGludHJvIGFuZCBvdXRyby5cclxuXHRcdFx0Ly9JZiB0aGUgcHJvZ3Jlc3MgaXMgd2l0aGluIHRoZSBtaWRkbGUgMyB1bml0cywgdGhlIGNhcmQgaXMgdGVjaG5pY2FsbHkgaW4gdmlldywgdGhlcmZvcmUgYWN0aXZlXHJcblx0XHRcdGlmICgoc2VsZi5wcm9ncmVzcyA+PSAoKDIvNykgLSAgMC4wMSkpICYmIChzZWxmLnByb2dyZXNzIDw9ICgoNS83KSArIDAuMDEpKSkge1xyXG5cdFx0XHRcdHRoaXMuJGVsLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuJGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHR3YXRjaDoge1xyXG5cdFx0dHJpZ2dlcih2YWwpIHtcclxuXHRcdFx0dmFsWydvblVwZGF0ZSddID0gdGhyb3R0bGUodGhpcy50b2dnbGVBY3RpdmVDbGFzcywgMTAwKTtcclxuXHRcdFx0Y29uc3QgdGltZWxpbmUgPSBuZXcgdGhpcy4kZGF0YS5fZ3NhcC5UaW1lbGluZU1heCh7XHJcblx0XHRcdFx0XHRzY3JvbGxUcmlnZ2VyOiB2YWxcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC8vIC5hZGRMYWJlbCgndG9wT3V0JylcclxuXHRcdFx0XHQuZnJvbVRvKHRoaXMuJGVsLFxyXG5cdFx0XHRcdFx0eyBvcGFjaXR5OiAwLCByb3RhdGlvblg6IC00NSwgeTogMjAwLCB6OiAtMTAwLCB0cmFuc2Zvcm1PcmlnaW46IFwiNTAlIDUwJSAtMTAwcHhcIiB9LFxyXG5cdFx0XHRcdFx0eyBvcGFjaXR5OiAxLCByb3RhdGlvblg6IDAsIHk6IDAsIHo6IDAsIGR1cmF0aW9uOiAyIH1cclxuXHRcdFx0XHQpXHJcblx0XHRcdFx0LmFkZExhYmVsKCd0b3BJbicpXHJcblx0XHRcdFx0LnRvKHRoaXMuJGVsLCB7IG9wYWNpdHk6IDEsIGR1cmF0aW9uOiAxLjUgfSlcclxuXHRcdFx0XHQuYWRkTGFiZWwoJ21pZGRsZUluJylcclxuXHRcdFx0XHQudG8odGhpcy4kZWwsIHsgb3BhY2l0eTogMSwgZHVyYXRpb246IDEuNSB9KVxyXG5cdFx0XHRcdC5hZGRMYWJlbCgnYm90dG9tSW4nKVxyXG5cdFx0XHRpZiAodGhpcy5pc0xhc3RNb2R1bGUpIHRpbWVsaW5lLnRvKHRoaXMuJGVsLCB7IG9wYWNpdHk6IDEsIGR1cmF0aW9uOiAyIH0pO1xyXG5cdFx0XHRlbHNlIHRpbWVsaW5lLnRvKHRoaXMuJGVsLCB7IHk6IC0xMDAsIG9wYWNpdHk6IDAsIGR1cmF0aW9uOiAyIH0pO1xyXG5cdFx0XHRcdC8vIC5hZGRMYWJlbCgnYm90dG9tT3V0JylcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcbjwvc2NyaXB0PlxyXG48c3R5bGUgbGFuZz0nc2NzcycgdHlwZT1cInRleHQvc2Nzc1wiPlxyXG5AdXNlICd+X3Njc3NfL3ZhcmlhYmxlcyc7XHJcbkB1c2UgJ35fc2Nzc18vX21peGlucyc7XHJcbi5jb2RlLXBlbi1jYXJkIHtcclxuXHQkY2FyZC1oZWlnaHQ6IDE0LjI1cmVtO1xyXG5cdCRjYXJkLXdpZHRoOiAyMnJlbTtcclxuXHRwb3NpdGlvbjogZml4ZWQ7XHJcblx0dG9wOiAyNXJlbTtcclxuXHRsZWZ0OiBjYWxjKCh2YXIoLS1iaW8tcGxhY2VtZW50KSAqIDIpICsgMXJlbSk7XHJcblx0aGVpZ2h0OiAkY2FyZC1oZWlnaHQ7XHJcbiAgICB3aWR0aDogJGNhcmQtd2lkdGg7XHJcblx0dHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSgyMDBweCk7XHJcblx0b3BhY2l0eTogMDtcclxuXHR0ZXh0LWRlY29yYXRpb246IG5vbmU7XHJcblx0Ji5hY3RpdmUge1xyXG5cdFx0Y3Vyc29yOiBwb2ludGVyO1xyXG5cdH1cclxuXHQuYmFja2dyb3VuZCB7XHJcblx0XHRjb250ZW50OiAnJztcclxuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuXHRcdHRyYW5zZm9ybS1vcmlnaW46IGJvdHRvbSByaWdodDtcclxuXHRcdGJvdHRvbTogMDtcclxuXHRcdHJpZ2h0OiAwO1xyXG5cdFx0d2lkdGg6ICRjYXJkLXdpZHRoO1xyXG5cdFx0aGVpZ2h0OiAkY2FyZC1oZWlnaHQ7XHJcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1zZWNvbmRhcnktMS1jKTtcclxuXHRcdHotaW5kZXg6IC0xO1xyXG5cdFx0Ym9yZGVyLXJhZGl1czogMC43cmVtO1xyXG5cdFx0ZGlzcGxheTogZmxleDtcclxuXHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XHJcblx0fVxyXG5cdCY6aG92ZXIgLnRpdGxlIHtcclxuXHRcdHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xyXG5cdH1cclxuXHQudGl0bGUge1xyXG5cdFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xyXG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xyXG5cdFx0Ym90dG9tOiAxcmVtO1xyXG5cdFx0cmlnaHQ6IDA7XHJcblx0XHR3aWR0aDogY2FsYygxMDAlIC0gMS41cmVtKTtcclxuXHRcdGNvbG9yOiB3aGl0ZTtcclxuXHRcdGZvbnQtc2l6ZTogMS41cmVtO1xyXG5cdH1cclxuXHRpbWcge1xyXG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xyXG5cdFx0Ym90dG9tOiA0cmVtO1xyXG5cdFx0bGVmdDogLTFyZW07XHJcblx0XHR3aWR0aDogMjByZW07XHJcblx0XHRoZWlnaHQ6IDExLjI1cmVtO1xyXG5cdFx0Ym9yZGVyLXJhZGl1czogMC43cmVtO1xyXG5cdH1cclxuXHQuZGVzY3JpcHRpb24ge1xyXG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xyXG5cdFx0Ym90dG9tOiAwO1xyXG5cdFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDEwMCUpO1xyXG5cdFx0Y29sb3I6IHdoaXRlO1xyXG5cdFx0b3BhY2l0eTogMDtcclxuXHRcdHJpZ2h0OiAxLjVyZW07XHJcblx0XHR3aWR0aDogY2FsYygxMDAlIC0gM3JlbSk7XHJcblx0XHQvLyBib3JkZXI6IDFweCBzb2xpZCB3aGl0ZTtcclxuXHR9XHJcbn1cclxuPC9zdHlsZT5cclxuIiwiPHNjcmlwdD5cclxuaW1wb3J0ICogYXMgX2dzYXAgZnJvbSAnX2dzYXBfJztcclxuaW1wb3J0IFNjcm9sbFRyaWdnZXIgZnJvbSAnX2dzYXBfL1Njcm9sbFRyaWdnZXInO1xyXG5pbXBvcnQgQ3VzdG9tRWFzZSBmcm9tICdfZ3NhcF8vQ3VzdG9tRWFzZSc7XHJcbmltcG9ydCBDU1NSdWxlUGx1Z2luIGZyb20gJ19nc2FwXy9DU1NSdWxlUGx1Z2luJztcclxuaW1wb3J0IENTU1BsdWdpbiBmcm9tICdfZ3NhcF8vQ1NTUGx1Z2luJztcclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdG5hbWU6ICdHc2FwJyxcclxuXHRkYXRhKCkge1xyXG4gICAgICAgIF9nc2FwLmdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVHJpZ2dlcik7XHJcblx0XHRfZ3NhcC5nc2FwLnJlZ2lzdGVyUGx1Z2luKEN1c3RvbUVhc2UpO1xyXG4gICAgICAgIF9nc2FwLmdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUGx1Z2luKTtcclxuICAgICAgICBfZ3NhcC5nc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1J1bGVQbHVnaW4pO1xyXG4gICAgICAgIC8vZ2V0IGp1c3QgdGhlIGJhc2UgdmFsdWVzIGFuZCByZW1vdmUgdGhlIG5lc3RlZCBnc2FwXHJcbiAgICAgICAgY29uc3QgZ3NhcCA9IHsuLi5fZ3NhcH07XHJcbiAgICAgICAgLy8gZGVsZXRlIGdzYXAuZ3NhcFxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8vY29tYmluZSB0aGUgYmFzZSB2YWx1ZXMgYW5kIHRoZSBuZXN0ZWQgZ3NhcCB2YWx1ZXMgaW50byBhIHNpbmdsZSBvYmplY3RcclxuICAgICAgICAgICAgX2dzYXA6IHsgLi4uZ3NhcCwgLi4uX2dzYXAuZ3NhcCB9LFxyXG4gICAgICAgICAgICBfc2Nyb2xsVHJpZ2dlcjogU2Nyb2xsVHJpZ2dlcixcclxuICAgICAgICAgICAgX2N1c3RvbUVhc2U6IEN1c3RvbUVhc2UsXHJcbiAgICAgICAgICAgIF9jc3NSdWxlUGx1Z2luOiBDU1NSdWxlUGx1Z2luXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG48L3NjcmlwdD4iLCI8c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0bmFtZTogJ2Nzcy12YXJpYWJsZXMnLFxyXG5cdGRhdGEoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHQvL2NvbnRhaW5zIHRoZSBsaWdodC9kYXJrIHZhcmlhYmxlcyBhbmQgdGhlaXIgdmFsdWVzXHJcblx0XHRcdGxpZ2h0OiB7fSxcclxuXHRcdFx0ZGFyazoge30sXHJcblx0XHRcdC8vY29udGFpbnMganVzdCB0aGUgY3NzIHZhcmlhYmxlcyB0aGF0IGhhdmUgdGhlIG5hbWUgYWN0aXZlIG9yIGluYWN0aXZlIGluIGl0XHJcblx0XHRcdGFjdGl2ZTogW10sXHJcblx0XHRcdGluYWN0aXZlOiBbXVxyXG5cdFx0fVxyXG5cdH0sXHJcblx0bW91bnRlZCgpIHtcclxuXHRcdC8qXHJcblx0XHRcdGNvbnNvbGUubG9nKFwic3RhcnRcIiwgdGhpcy5pc0ludGVybmV0RXhwbG9yZXIpO1xyXG5cdFx0XHRjb25zdCBwcm9wZXJ0aWVzID0gdGhpcy5pc0ludGVybmV0RXhwbG9yZXIgPyB0aGlzLmdldENTU0N1c3RvbVByb3BJbmRleEZhbGxCYWNrKCkgOiB0aGlzLmdldENTU0N1c3RvbVByb3BJbmRleCgpO1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcImNzcyBwcm9wZXJ0aWVzOiBcIiwgcHJvcGVydGllcyk7XHJcblx0XHRcdHByb3BlcnRpZXMgJiYgcHJvcGVydGllcy5mb3JFYWNoKHZhcmlhYmxlID0+IHtcclxuXHRcdFx0XHRpZiAodmFyaWFibGVbMF0uaW5jbHVkZXMoJy0tbGlnaHQtJykpIHRoaXMubGlnaHRbdmFyaWFibGVbMF1dID0gdmFyaWFibGVbMV07XHJcblx0XHRcdFx0aWYgKHZhcmlhYmxlWzBdLmluY2x1ZGVzKCctLWRhcmstJykpIHRoaXMuZGFya1t2YXJpYWJsZVswXV0gPSB2YXJpYWJsZVsxXTtcclxuXHRcdFx0XHRpZiAodmFyaWFibGVbMF0uaW5jbHVkZXMoJy0tYWN0aXZlLScpICYmICF0aGlzLmFjdGl2ZS5pbmNsdWRlcyh2YXJpYWJsZVswXSkpIHRoaXMuYWN0aXZlLnB1c2godmFyaWFibGVbMF0pO1xyXG5cdFx0XHRcdGlmICh2YXJpYWJsZVswXS5pbmNsdWRlcygnLS1pbmFjdGl2ZS0nKSAmJiAhdGhpcy5pbmFjdGl2ZS5pbmNsdWRlcyh2YXJpYWJsZVswXSkpIHRoaXMuaW5hY3RpdmUucHVzaCh2YXJpYWJsZVswXSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcImxpZ2h0OiBcIiwgdGhpcy5saWdodCk7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiZGFyayA6XCIsIHRoaXMuZGFyayk7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiYWN0aXZlOiBcIiwgdGhpcy5hY3RpdmUpO1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcImluYWN0aXZlOiBcIiwgdGhpcy5pbmFjdGl2ZSk7XHJcblx0XHQqL1xyXG5cdH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgaXNTYW1lRG9tYWluKHN0eWxlU2hlZXQpIHtcclxuXHRcdFx0Ly8gSW50ZXJuYWwgc3R5bGUgYmxvY2tzIHdvbid0IGhhdmUgYW4gaHJlZiB2YWx1ZVxyXG5cdFx0XHRpZiAoIXN0eWxlU2hlZXQuaHJlZikge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBzdHlsZVNoZWV0LmhyZWYuaW5kZXhPZih3aW5kb3cubG9jYXRpb24ub3JpZ2luKSA9PT0gMDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhbGwgY3VzdG9tIHByb3BlcnRpZXMgb24gYSBwYWdlXHJcbiAgICAgICAgICogQHJldHVybiBhcnJheTxhcnJheVtzdHJpbmcsIHN0cmluZ10+XHJcbiAgICAgICAgICogZXg7IFtbXCItLWNvbG9yLWFjY2VudFwiLCBcIiNiOWY1MDBcIl0sIFtcIi0tY29sb3ItdGV4dFwiLCBcIiMyNTI1MjVcIl0sIC4uLl1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRDU1NDdXN0b21Qcm9wSW5kZXgoKSB7XHJcblx0XHRcdC8vIHN0eWxlU2hlZXRzIGlzIGFycmF5LWxpa2UsIHNvIHdlIGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkuXHJcblx0XHRcdC8vIEZpbHRlciBvdXQgYW55IHN0eWxlc2hlZXRzIG5vdCBvbiB0aGlzIGRvbWFpblxyXG5cdFx0XHRjb25zdCB0aGF0ID0gdGhpcztcclxuXHRcdFx0cmV0dXJuIFsuLi5kb2N1bWVudC5zdHlsZVNoZWV0c10uZmlsdGVyKHRoYXQuaXNTYW1lRG9tYWluKS5yZWR1Y2UoKGZpbmFsQXJyLCBzaGVldCkgPT4ge1xyXG5cdFx0XHRcdHJldHVybiBmaW5hbEFyci5jb25jYXQoXHJcblx0XHRcdFx0XHQvLyBjc3NSdWxlcyBpcyBhcnJheS1saWtlLCBzbyB3ZSBjb252ZXJ0IGl0IHRvIGFuIGFycmF5XHJcblx0XHRcdFx0XHRbLi4uc2hlZXQuY3NzUnVsZXNdLnJlZHVjZSgocHJvcFZhbEFyciwgcnVsZSkgPT4ge1xyXG5cdFx0XHRcdFx0XHQvL2lmIHRoZSBydWxlIGRvZXNudCBoYXZlIHN0eWxlLCBpdCB3b250IGhhdmUgdGhlIGNzcyB2YXJpYWJsZVxyXG5cdFx0XHRcdFx0XHRpZiAoIXJ1bGUuc3R5bGUpIHJldHVybiBwcm9wVmFsQXJyO1xyXG5cdFx0XHRcdFx0XHRjb25zdCBwcm9wcyA9IFsuLi5ydWxlLnN0eWxlXS5tYXAoKHByb3BOYW1lKSA9PiB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRcdFx0XHRcdHByb3BOYW1lLnRyaW0oKSxcclxuXHRcdFx0XHRcdFx0XHRcdHJ1bGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wTmFtZSkudHJpbSgpXHJcblx0XHRcdFx0XHRcdFx0XVxyXG5cdFx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdFx0XHQvLyBEaXNjYXJkIGFueSBwcm9wcyB0aGF0IGRvbid0IHN0YXJ0IHdpdGggXCItLVwiLiBDdXN0b20gcHJvcHMgYXJlIHJlcXVpcmVkIHRvLlxyXG5cdFx0XHRcdFx0XHQuZmlsdGVyKChbcHJvcE5hbWVdKSA9PiB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChwcm9wTmFtZS5pbmRleE9mKFwiLS1cIikgPT09IDAgfHwgcHJvcE5hbWUuaW5kZXhPZihcIi1pZVZhci1cIikgPT09IDAgfHwgcHJvcE5hbWUuaW5kZXhPZihcIi1pZS1cIikgPT09IDAgfHwgcHJvcE5hbWUuaW5kZXhPZihcImllY3BcIikgPT09IDApXHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gWy4uLnByb3BWYWxBcnIsIC4uLnByb3BzXTtcclxuXHRcdFx0XHRcdH0sIFtdKVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH0sW10pO1xyXG5cdFx0fSxcclxuXHRcdGdldENTU0N1c3RvbVByb3BJbmRleEZhbGxCYWNrKCkge1xyXG5cdFx0fVxyXG4gICAgfVxyXG59O1xyXG48L3NjcmlwdD5cclxuIiwiPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdG5hbWU6ICdicm93c2VyLWNoZWNrJyxcclxuXHRjb21wdXRlZDoge1xyXG5cdFx0aXNJbnRlcm5ldEV4cGxvcmVyKCkge1xyXG5cdFx0XHR2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcclxuXHJcblx0XHRcdHZhciBtc2llID0gdWEuaW5kZXhPZignTVNJRSAnKTtcclxuXHRcdFx0aWYgKG1zaWUgPiAwKSB7XHJcblx0XHRcdFx0Ly8gSUUgMTAgb3Igb2xkZXIgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXHJcblx0XHRcdFx0cmV0dXJuIHRydWU7IC8vcGFyc2VJbnQodWEuc3Vic3RyaW5nKG1zaWUgKyA1LCB1YS5pbmRleE9mKCcuJywgbXNpZSkpLCAxMCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB0cmlkZW50ID0gdWEuaW5kZXhPZignVHJpZGVudC8nKTtcclxuXHRcdFx0aWYgKHRyaWRlbnQgPiAwKSB7XHJcblx0XHRcdFx0Ly8gSUUgMTEgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXHJcblx0XHRcdFx0dmFyIHJ2ID0gdWEuaW5kZXhPZigncnY6Jyk7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7IC8vcGFyc2VJbnQodWEuc3Vic3RyaW5nKHJ2ICsgMywgdWEuaW5kZXhPZignLicsIHJ2KSksIDEwKTtcclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdC8vdG8gY2hlY2sgaWYgZWRnZVxyXG5cdFx0XHQvLyB2YXIgZWRnZSA9IHVhLmluZGV4T2YoJ0VkZ2UvJyk7XHJcblx0XHRcdC8vIGlmIChlZGdlID4gMCkge1xyXG5cdFx0XHQvLyBcdC8vIEVkZ2UgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXHJcblx0XHRcdC8vIFx0cmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhlZGdlICsgNSwgdWEuaW5kZXhPZignLicsIGVkZ2UpKSwgMTApO1xyXG5cdFx0XHQvLyB9XHJcblxyXG5cdFx0XHQvLyBvdGhlciBicm93c2VyXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdG1ldGhvZHM6IHtcclxuXHRcdGNvbnZlcnRSZW1Ub1BpeGVsczogcmVtID0+IHsgICAgXHJcblx0XHRcdHJldHVybiByZW0gKiBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5mb250U2l6ZSk7XHJcblx0XHR9LFxyXG5cdFx0Y29udmVydFBpeGVsc1RvUmVtOiBweCA9PiB7XHJcblx0XHRcdGlmICh0eXBlb2YgcHggPT0gJ3N0cmluZycgJiYgcHguaW5jbHVkZXMoJ3B4JykpIHtcclxuXHRcdFx0XHRweC5yZXBsYWNlKCdweCcsICcnKTtcclxuXHRcdFx0XHRweCA9IHBhcnNlSW50KHB4LCAxMCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHB4IC8gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZm9udFNpemUpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuPC9zY3JpcHQ+IiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgdmFyIF92bSA9IHRoaXMsXG4gICAgX2MgPSBfdm0uX3NlbGYuX2NcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJpZS1mYWxsYmFja1wiLCBhdHRyczogeyBpZDogXCJhcHBcIiB9IH0sXG4gICAgW1xuICAgICAgX2MoXCJiYW5uZXJcIiksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJnZW9tZXRyeVwiKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJzZWN0aW9uXCIsXG4gICAgICAgIHsgYXR0cnM6IHsgaWQ6IFwiYmlvXCIgfSB9LFxuICAgICAgICBbX2MoXCJiaW9cIiwgeyBhdHRyczogeyBzZXRDb250ZW50OiBfdm0uc2V0Q29udGVudCB9IH0pXSxcbiAgICAgICAgMVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJ0cmFuc2l0aW9uXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBhdHRyczogeyBuYW1lOiBcImNvbnRlbnQtZmFkZVwiIH0sXG4gICAgICAgICAgb246IHsgXCJhZnRlci1sZWF2ZVwiOiBfdm0udXBkYXRlQ3VycmVudENvbnRlbnQgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW192bS5jb250ZW50ID09IFwiY29udGFjdFwiID8gX2MoXCJjb250YWN0XCIpIDogX3ZtLl9lKCldLFxuICAgICAgICAxXG4gICAgICApLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcInRyYW5zaXRpb25cIixcbiAgICAgICAge1xuICAgICAgICAgIGF0dHJzOiB7IG5hbWU6IFwiY29udGVudC1mYWRlXCIgfSxcbiAgICAgICAgICBvbjogeyBcImFmdGVyLWxlYXZlXCI6IF92bS51cGRhdGVDdXJyZW50Q29udGVudCB9LFxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX3ZtLmNvbnRlbnQgPT0gXCJwb3J0Zm9saW9cIlxuICAgICAgICAgICAgPyBfYyhcInBvcnRmb2xpby1saXN0XCIsIHtcbiAgICAgICAgICAgICAgICBhdHRyczogeyBzdW1tYXJ5VHJpZ2dlcjogX3ZtLmJpb1RyaWdnZXIgfSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgIF0sXG4gICAgICAgIDFcbiAgICAgICksXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICB2YXIgX3ZtID0gdGhpcyxcbiAgICBfYyA9IF92bS5fc2VsZi5fY1xuICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJwLTMwXCIsIGF0dHJzOiB7IGlkOiBcImJhbm5lclwiIH0gfSwgW1xuICAgIF9jKFxuICAgICAgXCJzcGFuXCIsXG4gICAgICB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiBcImZ0LW5vcm1hbCBtLXJndC1hdXRvIGZ0LXN6LTE4IGRhcmstbW9kZVwiLFxuICAgICAgICBvbjogeyBjbGljazogX3ZtLmNsaWNrSGFuZGxlciB9LFxuICAgICAgfSxcbiAgICAgIFtcbiAgICAgICAgX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiaWNvbi1tb29uLXN0cm9rZSBmdC1zei0xNiBwLXJndC0xNVwiIH0pLFxuICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5pbmFjdGl2ZU1vZGUpICsgXCIgTW9kZVxcblxcdFwiKSxcbiAgICAgIF1cbiAgICApLFxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gIHZhciBfdm0gPSB0aGlzLFxuICAgIF9jID0gX3ZtLl9zZWxmLl9jXG4gIHJldHVybiBfYyhcImRpdlwiLCB7IGF0dHJzOiB7IGlkOiBcImJpby1jb250YWluZXJcIiB9IH0sIFtcbiAgICBfYyhcImgxXCIsIFtfdm0uX3YoXCJKb3JkYW4gS2xhZXJzXCIpXSksXG4gICAgX3ZtLl92KFwiIFwiKSxcbiAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImJpby1hbmltYXRpb24td3JhcHBlclwiIH0sIFtcbiAgICAgIF9jKFwiaDFcIiwgW192bS5fdihcIkZyb250LUVuZCBXZWIgRGV2ZWxvcGVyXCIpXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJkaXZcIiwgeyByZWY6IFwic3ViLXRleHRcIiwgc3RhdGljQ2xhc3M6IFwic3ViLXRleHRcIiB9LCBbXG4gICAgICAgIF92bS5fdihcbiAgICAgICAgICBcIkZ1bGwgc3RhY2sgd2ViIGRldmVsb3BlciBzaW5jZSAyMDE3IHdpdGggYSBwYXNzaW9uIGZvciBmcm9udCBlbmQgZGV2ZWxvcG1lbnQgYW5kIGRlc2lnblwiXG4gICAgICAgICksXG4gICAgICBdKSxcbiAgICBdKSxcbiAgICBfdm0uX3YoXCIgXCIpLFxuICAgIF9jKFxuICAgICAgXCJidXR0b25cIixcbiAgICAgIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6IFwibS1yZ3QtMjAgbS10b3AtMjBcIixcbiAgICAgICAgb246IHsgY2xpY2s6ICgpID0+IF92bS5zZXRDb250ZW50KFwicG9ydGZvbGlvXCIpIH0sXG4gICAgICB9LFxuICAgICAgW192bS5fdihcIlBvcnRmb2xpb1wiKV1cbiAgICApLFxuICAgIF92bS5fdihcIiBcIiksXG4gICAgX2MoXG4gICAgICBcImJ1dHRvblwiLFxuICAgICAge1xuICAgICAgICBzdGF0aWNDbGFzczogXCJtLXRvcC0yMFwiLFxuICAgICAgICBvbjogeyBjbGljazogKCkgPT4gX3ZtLnNldENvbnRlbnQoXCJjb250YWN0XCIpIH0sXG4gICAgICB9LFxuICAgICAgW192bS5fdihcIkNvbnRhY3RcIildXG4gICAgKSxcbiAgXSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICB2YXIgX3ZtID0gdGhpcyxcbiAgICBfYyA9IF92bS5fc2VsZi5fY1xuICByZXR1cm4gX2MoXCJkaXZcIiwgeyBhdHRyczogeyBpZDogXCJjb250YWN0LWNvbnRhaW5lclwiIH0gfSwgW1xuICAgIF9jKFwidWxcIiwgW1xuICAgICAgX2MoXCJsaVwiLCBbXG4gICAgICAgIF9jKFwic3ZnXCIsIHsgYXR0cnM6IHsgdmlld0JveDogXCIwIDAgMTAwIDEwMFwiLCBpZDogXCJjb2RlLXBlbi1sb2dvXCIgfSB9LCBbXG4gICAgICAgICAgX2MoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIHN0cm9rZTogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxuICAgICAgICAgICAgICBkOiBcIk0xMDAgMzQuMmMtLjQtMi42LTMuMy00LTUuMy01LjMtMy42LTIuNC03LjEtNC43LTEwLjctNy4xLTguNS01LjctMTcuMS0xMS40LTI1LjYtMTcuMS0yLTEuMy00LTIuNy02LTQtMS40LTEtMy4zLTEtNC44IDAtNS43IDMuOC0xMS41IDcuNy0xNy4yIDExLjVMNS4yIDI5QzMgMzAuNC4xIDMxLjggMCAzNC44Yy0uMSAzLjMgMCA2LjcgMCAxMHYxNmMwIDIuOS0uNiA2LjMgMi4xIDguMSA2LjQgNC40IDEyLjkgOC42IDE5LjQgMTIuOSA4IDUuMyAxNiAxMC43IDI0IDE2IDIuMiAxLjUgNC40IDMuMSA3LjEgMS4zIDIuMy0xLjUgNC41LTMgNi44LTQuNSA4LjktNS45IDE3LjgtMTEuOSAyNi43LTE3LjhsOS45LTYuNmMuNi0uNCAxLjMtLjggMS45LTEuMyAxLjQtMSAyLTIuNCAyLTQuMVYzNy4zYy4xLTEuMS4yLTIuMS4xLTMuMSAwLS4xIDAgLjIgMCAwek01NC4zIDEyLjNMODggMzQuOCA3MyA0NC45IDU0LjMgMzIuNFYxMi4zem0tOC42IDB2MjBMMjcuMSA0NC44IDEyIDM0LjhsMzMuNy0yMi41ek04LjYgNDIuOEwxOS4zIDUwIDguNiA1Ny4yVjQyLjh6bTM3LjEgNDQuOUwxMiA2NS4ybDE1LTEwLjEgMTguNiAxMi41djIwLjF6TTUwIDYwLjJMMzQuOCA1MCA1MCAzOS44IDY1LjIgNTAgNTAgNjAuMnptNC4zIDI3LjV2LTIwbDE4LjYtMTIuNSAxNSAxMC4xLTMzLjYgMjIuNHptMzcuMS0zMC41TDgwLjcgNTBsMTAuOC03LjItLjEgMTQuNHpcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgIF0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcbiAgICAgICAgICBcImFcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhdHRyczogeyBocmVmOiBcImh0dHBzOi8vY29kZXBlbi5pby9qb3JkYW5rbGFlcnNcIiwgdGFyZ2V0OiBcImJsYW5rXCIgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtfdm0uX3YoXCJcXG4gICAgICAgICAgICAgICAgICAgIENvZGUgUGVuXFxuICAgICAgICAgICAgICAgIFwiKV1cbiAgICAgICAgKSxcbiAgICAgIF0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwibGlcIiwgW1xuICAgICAgICBfYyhcbiAgICAgICAgICBcInN2Z1wiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImdsb2JhbC1uYXZfX2xvZ29cIixcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIGlkOiBcImxpbmtlZC1pbi1sb2dvXCIsXG4gICAgICAgICAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICAgICAgICAgIHdpZHRoOiBcIjM0XCIsXG4gICAgICAgICAgICAgIGhlaWdodDogXCIzNFwiLFxuICAgICAgICAgICAgICB2aWV3Qm94OiBcIjAgMCAzNCAzNFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIF9jKFwiZ1wiLCBbXG4gICAgICAgICAgICAgIF9jKFwicGF0aFwiLCB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgIGQ6IFwiTTM0LDIuNXYyOUEyLjUsMi41LDAsMCwxLDMxLjUsMzRIMi41QTIuNSwyLjUsMCwwLDEsMCwzMS41VjIuNUEyLjUsMi41LDAsMCwxLDIuNSwwaDI5QTIuNSwyLjUsMCwwLDEsMzQsMi41Wk0xMCwxM0g1VjI5aDVabS40NS01LjVBMi44OCwyLjg4LDAsMCwwLDcuNTksNC42SDcuNWEyLjksMi45LDAsMCwwLDAsNS44aDBhMi44OCwyLjg4LDAsMCwwLDIuOTUtMi44MVpNMjksMTkuMjhjMC00LjgxLTMuMDYtNi42OC02LjEtNi42OGE1LjcsNS43LDAsMCwwLTUuMDYsMi41OEgxNy43VjEzSDEzVjI5aDVWMjAuNDlhMy4zMiwzLjMyLDAsMCwxLDMtMy41OGguMTljMS41OSwwLDIuNzcsMSwyLjc3LDMuNTJWMjloNVpcIixcbiAgICAgICAgICAgICAgICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICBdXG4gICAgICAgICksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFxuICAgICAgICAgIFwiYVwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIGhyZWY6IFwiaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL2pvcmRhbi1rbGFlcnMvXCIsXG4gICAgICAgICAgICAgIHRhcmdldDogXCJibGFua1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtfdm0uX3YoXCJMaW5rZWQgSW5cIildXG4gICAgICAgICksXG4gICAgICBdKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfdm0uX20oMCksXG4gICAgXSksXG4gIF0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW1xuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXMsXG4gICAgICBfYyA9IF92bS5fc2VsZi5fY1xuICAgIHJldHVybiBfYyhcImxpXCIsIFtcbiAgICAgIF9jKFwiaW1nXCIsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6IFwiZ2JfdGNcIixcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBzcmM6IFwiaHR0cHM6Ly9zc2wuZ3N0YXRpYy5jb20vdWkvdjEvaWNvbnMvbWFpbC9yZnIvbG9nb19nbWFpbF9sb2NrdXBfZGVmYXVsdF8xeF9yMi5wbmdcIixcbiAgICAgICAgICBzcmNzZXQ6XG4gICAgICAgICAgICBcImh0dHBzOi8vc3NsLmdzdGF0aWMuY29tL3VpL3YxL2ljb25zL21haWwvcmZyL2xvZ29fZ21haWxfbG9ja3VwX2RlZmF1bHRfMXhfcjIucG5nXCIgK1xuICAgICAgICAgICAgXCIgMXgsIFwiICtcbiAgICAgICAgICAgIFwiaHR0cHM6Ly9zc2wuZ3N0YXRpYy5jb20vdWkvdjEvaWNvbnMvbWFpbC9yZnIvbG9nb19nbWFpbF9sb2NrdXBfZGVmYXVsdF8yeF9yMi5wbmdcIiArXG4gICAgICAgICAgICBcIiAyeFwiLFxuICAgICAgICAgIGFsdDogXCJcIixcbiAgICAgICAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgICBfdm0uX3YoXCJcXG4gICAgICAgICAgICAgICAgZW1haWw6IEpvcmRhbi5LbGFlcnNAZ21haWwuY29tXFxuICAgICAgICAgICAgXCIpLFxuICAgIF0pXG4gIH0sXG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gIHZhciBfdm0gPSB0aGlzLFxuICAgIF9jID0gX3ZtLl9zZWxmLl9jXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHsgYXR0cnM6IHsgaWQ6IFwiZ2VvbWV0cnktY29udGFpbmVyXCIgfSB9LFxuICAgIFtcbiAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImRhcmsgdmlzaWJsZSBzaGFwZSBzcXVhcmUtMS1hXCIgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwibGlnaHQgc2hhcGUgc3F1YXJlLTEtYVwiIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImRhcmsgdmlzaWJsZSBzaGFwZSBzcXVhcmUtMS1iXCIgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwibGlnaHQgc2hhcGUgc3F1YXJlLTEtYlwiIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImRhcmsgdmlzaWJsZSBzaGFwZSBzcXVhcmUtMi1hXCIgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwibGlnaHQgc2hhcGUgc3F1YXJlLTItYVwiIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImRhcmsgdmlzaWJsZSBzaGFwZSBzcXVhcmUtMi1iXCIgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwibGlnaHQgc2hhcGUgc3F1YXJlLTItYlwiIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImRhcmsgdmlzaWJsZSBzaGFwZSBzcXVhcmUtMi1jXCIgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwibGlnaHQgc2hhcGUgc3F1YXJlLTItY1wiIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImRhcmsgdmlzaWJsZSBzaGFwZSBzcXVhcmUtMi1kXCIgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwibGlnaHQgc2hhcGUgc3F1YXJlLTItZFwiIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInNoYXBlIHNxdWFyZS0zLWFcIiB9KSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJzaGFwZSBzcXVhcmUtMy1iXCIgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwic2hhcGUgc3F1YXJlLTMtY1wiIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICFfdm0uaXNJbnRlcm5ldEV4cGxvcmVyXG4gICAgICAgID8gX3ZtLl9sKF92bS5jdXJ2ZUVsZW1lbnRzLCBmdW5jdGlvbiAoY3VydmUpIHtcbiAgICAgICAgICAgIHJldHVybiBfYyhcInNwYW5cIiwge1xuICAgICAgICAgICAgICBrZXk6IGN1cnZlLmNsYXNzLFxuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJzaGFwZVwiLFxuICAgICAgICAgICAgICBzdHlsZTogX3ZtLnNldENsaXBQYXRoKGN1cnZlLmRlZ3JlZSwgY3VydmUuc3RhcnREZWdyZWUpLFxuICAgICAgICAgICAgICBhdHRyczogeyBpZDogY3VydmUuaWQgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICBdLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gIHZhciBfdm0gPSB0aGlzLFxuICAgIF9jID0gX3ZtLl9zZWxmLl9jXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIFtcbiAgICAgIF9jKFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7IGF0dHJzOiB7IGlkOiBcInNjcm9sbC1yZWZlcmVuY2VcIiB9IH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfdm0uX2woX3ZtLmNvZGVQZW5DYXJkcywgZnVuY3Rpb24gKGNhcmQsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICBfYyhcInNwYW5cIiwge1xuICAgICAgICAgICAgICAgIGtleTogYGRhcmstc3F1YXJlLSR7aW5kZXh9YCxcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJkYXJrIHZpc2libGUgbG9jYXRpb24tdHJhY2VyIHRyYWNlci1zcXVhcmVcIixcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7XG4gICAgICAgICAgICAgICAga2V5OiBgbGlnaHQtc3F1YXJlLSR7aW5kZXh9YCxcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJsaWdodCBsb2NhdGlvbi10cmFjZXIgdHJhY2VyLXNxdWFyZVwiLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiYXJyb3ctZG93bi1pbmRpY2F0b3JcIiB9KSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF92bS5fbChcbiAgICAgICAgICAgIEFycmF5LmFwcGx5KG51bGwsIHsgbGVuZ3RoOiBfdm0uY29kZVBlbkNhcmRzLmxlbmd0aCAtIDEgfSksXG4gICAgICAgICAgICBmdW5jdGlvbiAoY2FyZCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IGtleTogYGRvd24tJHtpbmRleH1gLCBzdGF0aWNDbGFzczogXCJhcnJvdy11cFwiIH0pLFxuICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBrZXk6IGB1cC0ke2luZGV4fWAsIHN0YXRpY0NsYXNzOiBcImFycm93LWRvd25cIiB9KSxcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInBvcnRmb2xpby1zdW1tYXJ5XCIgfSwgW1xuICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICBcIlxcblxcdFxcdFxcdEEgY29sbGVjdGlvbiBvZiB3b3JrIGJyaWVmbHkgZGVtb25zdHJhdGluZyBzb21lIG9mIG15IGNhcGFiaWxpdGllcyBpbiBmcm9udCBlbmQgZGV2ZWxvcG1lbnQuXFxuXFx0XFx0XCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgXSksXG4gICAgICAgIF0sXG4gICAgICAgIDJcbiAgICAgICksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLl9sKF92bS5jb2RlUGVuQ2FyZHMsIGZ1bmN0aW9uIChjYXJkLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJzZWN0aW9uXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGtleTogaW5kZXgsXG4gICAgICAgICAgICAgIHJlZjogXCJzZWN0aW9uc1wiLFxuICAgICAgICAgICAgICByZWZJbkZvcjogdHJ1ZSxcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiY29kZS1leGFtcGxlXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhjYXJkLm1vZHVsZSwge1xuICAgICAgICAgICAgICAgIHRhZzogXCJjb21wb25lbnRcIixcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgdGl0bGU6IGNhcmQudGl0bGUsXG4gICAgICAgICAgICAgICAgICBpZDogY2FyZC5pZCxcbiAgICAgICAgICAgICAgICAgIHVybDogY2FyZC51cmwsXG4gICAgICAgICAgICAgICAgICBpbWdVcmw6IGNhcmQuaW1nVXJsLFxuICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogX3ZtLnNjcm9sbFRyaWdnZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBjYXJkLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgaXNMYXN0TW9kdWxlOiBfdm0uY29kZVBlbkNhcmRzLmxlbmd0aCAtIDEgPT0gaW5kZXgsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcImRpdlwiLCB7IGtleTogYHNwYWNlci0ke2luZGV4fWAsIHN0YXRpY0NsYXNzOiBcInNwYWNlclwiIH0pLFxuICAgICAgICBdXG4gICAgICB9KSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY1N0eWxlOiB7IGhlaWdodDogXCIxMDB2aFwiIH0gfSksXG4gICAgXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICB2YXIgX3ZtID0gdGhpcyxcbiAgICBfYyA9IF92bS5fc2VsZi5fY1xuICByZXR1cm4gX2MoXG4gICAgXCJhXCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6IFwiY29kZS1wZW4tY2FyZFwiLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgaWQ6IF92bS5pZCxcbiAgICAgICAgaHJlZjogX3ZtLnVybCxcbiAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICByZWw6IFwibm9vcGVuZXIgbm9yZWZlcnJlclwiLFxuICAgICAgfSxcbiAgICB9LFxuICAgIFtcbiAgICAgIF9jKFwiaW1nXCIsIHsgYXR0cnM6IHsgc3JjOiBfdm0uaW1nVXJsIH0gfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJiYWNrZ3JvdW5kXCIgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwidGl0bGVcIiB9LCBbX3ZtLl92KF92bS5fcyhfdm0udGl0bGUpKV0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImRlc2NyaXB0aW9uXCIgfSwgW1xuICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5kZXNjcmlwdGlvbikpLFxuICAgICAgXSksXG4gICAgXVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcbiIsImltcG9ydCB0cmltbWVkRW5kSW5kZXggZnJvbSAnLi9fdHJpbW1lZEVuZEluZGV4LmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbVN0YXJ0ID0gL15cXHMrLztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50cmltYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmdcbiAgICA/IHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKVxuICAgIDogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVHJpbTtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGEgc2luZ2xlIHdoaXRlc3BhY2UgY2hhcmFjdGVyLiAqL1xudmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpIHtcbiAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXgtLSAmJiByZVdoaXRlc3BhY2UudGVzdChzdHJpbmcuY2hhckF0KGluZGV4KSkpIHt9XG4gIHJldHVybiBpbmRleDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdHJpbW1lZEVuZEluZGV4O1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IG5vdyBmcm9tICcuL25vdy5qcyc7XG5pbXBvcnQgdG9OdW1iZXIgZnJvbSAnLi90b051bWJlci5qcyc7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmdcbiAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgIDogdGltZVdhaXRpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkZWJvdW5jZTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdExpa2U7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzU3ltYm9sO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG5vdztcbiIsImltcG9ydCBkZWJvdW5jZSBmcm9tICcuL2RlYm91bmNlLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gKlxuICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdGhyb3R0bGU7XG4iLCJpbXBvcnQgYmFzZVRyaW0gZnJvbSAnLi9fYmFzZVRyaW0uanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gYmFzZVRyaW0odmFsdWUpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9OdW1iZXI7XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyIC8qIHNlcnZlciBvbmx5ICovLFxuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPVxuICAgIHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKHJlbmRlcikge1xuICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9ICdkYXRhLXYtJyArIHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7XG4gICAgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpbmplY3RTdHlsZXMuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAob3B0aW9ucy5mdW5jdGlvbmFsID8gdGhpcy5wYXJlbnQgOiB0aGlzKS4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICA6IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24oaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaykgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG4iLCIvKiFcbiAqIFZ1ZS5qcyB2Mi43LjE2XG4gKiAoYykgMjAxNC0yMDIzIEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nLlxuZnVuY3Rpb24gaXNVbmRlZih2KSB7XG4gICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsO1xufVxuZnVuY3Rpb24gaXNEZWYodikge1xuICAgIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzVHJ1ZSh2KSB7XG4gICAgcmV0dXJuIHYgPT09IHRydWU7XG59XG5mdW5jdGlvbiBpc0ZhbHNlKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gZmFsc2U7XG59XG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZS5cbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyk7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBvYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG59XG4vKipcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUsIGUuZy4sIFtvYmplY3QgT2JqZWN0XS5cbiAqL1xudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5mdW5jdGlvbiB0b1Jhd1R5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKTtcbn1cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5mdW5jdGlvbiBpc1JlZ0V4cCh2KSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4KHZhbCkge1xuICAgIHZhciBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XG4gICAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbCk7XG59XG5mdW5jdGlvbiBpc1Byb21pc2UodmFsKSB7XG4gICAgcmV0dXJuIChpc0RlZih2YWwpICYmXG4gICAgICAgIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgdmFsLmNhdGNoID09PSAnZnVuY3Rpb24nKTtcbn1cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT0gbnVsbFxuICAgICAgICA/ICcnXG4gICAgICAgIDogQXJyYXkuaXNBcnJheSh2YWwpIHx8IChpc1BsYWluT2JqZWN0KHZhbCkgJiYgdmFsLnRvU3RyaW5nID09PSBfdG9TdHJpbmcpXG4gICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpXG4gICAgICAgICAgICA6IFN0cmluZyh2YWwpO1xufVxuZnVuY3Rpb24gcmVwbGFjZXIoX2tleSwgdmFsKSB7XG4gICAgLy8gYXZvaWQgY2lyY3VsYXIgZGVwcyBmcm9tIHYzXG4gICAgaWYgKHZhbCAmJiB2YWwuX192X2lzUmVmKSB7XG4gICAgICAgIHJldHVybiB2YWwudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG4vKipcbiAqIENvbnZlcnQgYW4gaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbCkge1xuICAgIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59XG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBleHBlY3RzTG93ZXJDYXNlKSB7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2UgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9IDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcbi8qKlxuICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICovXG52YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSQyKGFyciwgaXRlbSkge1xuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGlmIChsZW4pIHtcbiAgICAgICAgLy8gZmFzdCBwYXRoIGZvciB0aGUgb25seSAvIGxhc3QgaXRlbVxuICAgICAgICBpZiAoaXRlbSA9PT0gYXJyW2xlbiAtIDFdKSB7XG4gICAgICAgICAgICBhcnIubGVuZ3RoID0gbGVuIC0gMTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093bihvYmosIGtleSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQoZm4pIHtcbiAgICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiBmdW5jdGlvbiBjYWNoZWRGbihzdHIpIHtcbiAgICAgICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgICB9O1xufVxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiAoYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKTsgfSk7XG59KTtcbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59KTtcbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59KTtcbi8qKlxuICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0LFxuICogZS5nLiwgUGhhbnRvbUpTIDEueC4gVGVjaG5pY2FsbHksIHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlXG4gKiBzaW5jZSBuYXRpdmUgYmluZCBpcyBub3cgcGVyZm9ybWFudCBlbm91Z2ggaW4gbW9zdCBicm93c2Vycy5cbiAqIEJ1dCByZW1vdmluZyBpdCB3b3VsZCBtZWFuIGJyZWFraW5nIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW5cbiAqIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcG9seWZpbGxCaW5kKGZuLCBjdHgpIHtcbiAgICBmdW5jdGlvbiBib3VuZEZuKGEpIHtcbiAgICAgICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbFxuICAgICAgICAgICAgPyBsID4gMVxuICAgICAgICAgICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgICAgICAgIDogZm4uY2FsbChjdHgpO1xuICAgIH1cbiAgICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gICAgcmV0dXJuIGJvdW5kRm47XG59XG5mdW5jdGlvbiBuYXRpdmVCaW5kKGZuLCBjdHgpIHtcbiAgICByZXR1cm4gZm4uYmluZChjdHgpO1xufVxuLy8gQHRzLWV4cGVjdC1lcnJvciBiaW5kIGNhbm5vdCBiZSBgdW5kZWZpbmVkYFxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA/IG5hdGl2ZUJpbmQgOiBwb2x5ZmlsbEJpbmQ7XG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIHN0YXJ0KSB7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCh0bywgX2Zyb20pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICAgICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0bztcbn1cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QoYXJyKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJbaV0pIHtcbiAgICAgICAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LykuXG4gKi9cbmZ1bmN0aW9uIG5vb3AoYSwgYiwgYykgeyB9XG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qKlxuICogUmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gICAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICAgIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYS5sZW5ndGggPT09IGIubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgICAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm4gdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgbG9vc2VseSBlcXVhbCB2YWx1ZSBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBhcnJheSAoaWYgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QsIHRoZSBhcnJheSBtdXN0XG4gKiBjb250YWluIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBzaGFwZSksIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICovXG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXMjcG9seWZpbGxcbmZ1bmN0aW9uIGhhc0NoYW5nZWQoeCwgeSkge1xuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgIHJldHVybiB4ID09PSAwICYmIDEgLyB4ICE9PSAxIC8geTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB4ID09PSB4IHx8IHkgPT09IHk7XG4gICAgfVxufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xudmFyIEFTU0VUX1RZUEVTID0gWydjb21wb25lbnQnLCAnZGlyZWN0aXZlJywgJ2ZpbHRlciddO1xudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgICAnYmVmb3JlQ3JlYXRlJyxcbiAgICAnY3JlYXRlZCcsXG4gICAgJ2JlZm9yZU1vdW50JyxcbiAgICAnbW91bnRlZCcsXG4gICAgJ2JlZm9yZVVwZGF0ZScsXG4gICAgJ3VwZGF0ZWQnLFxuICAgICdiZWZvcmVEZXN0cm95JyxcbiAgICAnZGVzdHJveWVkJyxcbiAgICAnYWN0aXZhdGVkJyxcbiAgICAnZGVhY3RpdmF0ZWQnLFxuICAgICdlcnJvckNhcHR1cmVkJyxcbiAgICAnc2VydmVyUHJlZmV0Y2gnLFxuICAgICdyZW5kZXJUcmFja2VkJyxcbiAgICAncmVuZGVyVHJpZ2dlcmVkJ1xuXTtcblxudmFyIGNvbmZpZyA9IHtcbiAgICAvKipcbiAgICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICAgKi9cbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICAgKi9cbiAgICBzaWxlbnQ6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAgICovXG4gICAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgICAqL1xuICAgIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICAgKi9cbiAgICBwZXJmb3JtYW5jZTogZmFsc2UsXG4gICAgLyoqXG4gICAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICAgKi9cbiAgICBlcnJvckhhbmRsZXI6IG51bGwsXG4gICAgLyoqXG4gICAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAgICovXG4gICAgd2FybkhhbmRsZXI6IG51bGwsXG4gICAgLyoqXG4gICAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAgICovXG4gICAgaWdub3JlZEVsZW1lbnRzOiBbXSxcbiAgICAvKipcbiAgICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgICAqL1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICAgKi9cbiAgICBpc1Jlc2VydmVkVGFnOiBubyxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAgICovXG4gICAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAgICovXG4gICAgaXNVbmtub3duRWxlbWVudDogbm8sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgICAqL1xuICAgIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgICAqL1xuICAgIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICAgKi9cbiAgICBtdXN0VXNlUHJvcDogbm8sXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSB1cGRhdGVzIGFzeW5jaHJvbm91c2x5LiBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IFZ1ZSBUZXN0IFV0aWxzXG4gICAgICogVGhpcyB3aWxsIHNpZ25pZmljYW50bHkgcmVkdWNlIHBlcmZvcm1hbmNlIGlmIHNldCB0byBmYWxzZS5cbiAgICAgKi9cbiAgICBhc3luYzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgICAqL1xuICAgIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59O1xuXG4vKipcbiAqIHVuaWNvZGUgbGV0dGVycyB1c2VkIGZvciBwYXJzaW5nIGh0bWwgdGFncywgY29tcG9uZW50IG5hbWVzIGFuZCBwcm9wZXJ0eSBwYXRocy5cbiAqIHVzaW5nIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc2VtYW50aWNzLXNjcmlwdGluZy5odG1sI3BvdGVudGlhbGN1c3RvbWVsZW1lbnRuYW1lXG4gKiBza2lwcGluZyBcXHUxMDAwMC1cXHVFRkZGRiBkdWUgdG8gaXQgZnJlZXppbmcgdXAgUGhhbnRvbUpTXG4gKi9cbnZhciB1bmljb2RlUmVnRXhwID0gL2EtekEtWlxcdTAwQjdcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDNGLVxcdTIwNDBcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkQvO1xuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZChzdHIpIHtcbiAgICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVmO1xufVxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG59XG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gbmV3IFJlZ0V4cChcIlteXCIuY29uY2F0KHVuaWNvZGVSZWdFeHAuc291cmNlLCBcIi4kX1xcXFxkXVwiKSk7XG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICAgIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIW9iailcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbn1cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xuVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMDtcbnZhciBpc0lPUyA9IFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSk7XG5VQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcblVBICYmIC9waGFudG9tanMvLnRlc3QoVUEpO1xudmFyIGlzRkYgPSBVQSAmJiBVQS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pO1xuLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxuLy8gQHRzLWV4cGVjdC1lcnJvciBmaXJlYm94IHN1cHBvcnRcbnZhciBuYXRpdmVXYXRjaCA9IHt9LndhdGNoO1xudmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuaWYgKGluQnJvd3Nlcikge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBvcHRzID0ge307XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG59XG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgICAgICAgX2lzU2VydmVyID1cbiAgICAgICAgICAgICAgICBnbG9iYWxbJ3Byb2Nlc3MnXSAmJiBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2lzU2VydmVyO1xufTtcbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlKEN0b3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSk7XG59XG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBpc05hdGl2ZShTeW1ib2wpICYmXG4gICAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmXG4gICAgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcbnZhciBfU2V0OyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyBpZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAgIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICAgIF9TZXQgPSBTZXQ7XG59XG5lbHNlIHtcbiAgICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gICAgX1NldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2V0KCkge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTZXQ7XG4gICAgfSgpKTtcbn1cblxudmFyIGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XG4vKipcbiAqIFRoaXMgaXMgZXhwb3NlZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHYzIChlLmcuIHNvbWUgZnVuY3Rpb25zIGluIFZ1ZVVzZVxuICogcmVsaWVzIG9uIGl0KS4gRG8gbm90IHVzZSB0aGlzIGludGVybmFsbHksIGp1c3QgdXNlIGBjdXJyZW50SW5zdGFuY2VgLlxuICpcbiAqIEBpbnRlcm5hbCB0aGlzIGZ1bmN0aW9uIG5lZWRzIG1hbnVhbCB0eXBlIGRlY2xhcmF0aW9uIGJlY2F1c2UgaXQgcmVsaWVzXG4gKiBvbiBwcmV2aW91c2x5IG1hbnVhbGx5IGF1dGhvcmVkIHR5cGVzIGZyb20gVnVlIDJcbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudEluc3RhbmNlKCkge1xuICAgIHJldHVybiBjdXJyZW50SW5zdGFuY2UgJiYgeyBwcm94eTogY3VycmVudEluc3RhbmNlIH07XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBzZXRDdXJyZW50SW5zdGFuY2Uodm0pIHtcbiAgICBpZiAodm0gPT09IHZvaWQgMCkgeyB2bSA9IG51bGw7IH1cbiAgICBpZiAoIXZtKVxuICAgICAgICBjdXJyZW50SW5zdGFuY2UgJiYgY3VycmVudEluc3RhbmNlLl9zY29wZS5vZmYoKTtcbiAgICBjdXJyZW50SW5zdGFuY2UgPSB2bTtcbiAgICB2bSAmJiB2bS5fc2NvcGUub24oKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFZOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZOb2RlKHRhZywgZGF0YSwgY2hpbGRyZW4sIHRleHQsIGVsbSwgY29udGV4dCwgY29tcG9uZW50T3B0aW9ucywgYXN5bmNGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuZWxtID0gZWxtO1xuICAgICAgICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJhdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgICAgICAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWTm9kZS5wcm90b3R5cGUsIFwiY2hpbGRcIiwge1xuICAgICAgICAvLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVk5vZGU7XG59KCkpO1xudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIGlmICh0ZXh0ID09PSB2b2lkIDApIHsgdGV4dCA9ICcnOyB9XG4gICAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgICBub2RlLnRleHQgPSB0ZXh0O1xuICAgIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gbm9kZTtcbn07XG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSk7XG59XG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSh2bm9kZSkge1xuICAgIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUodm5vZGUudGFnLCB2bm9kZS5kYXRhLCBcbiAgICAvLyAjNzk3NVxuICAgIC8vIGNsb25lIGNoaWxkcmVuIGFycmF5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGluIGNhc2Ugb2YgY2xvbmluZ1xuICAgIC8vIGEgY2hpbGQuXG4gICAgdm5vZGUuY2hpbGRyZW4gJiYgdm5vZGUuY2hpbGRyZW4uc2xpY2UoKSwgdm5vZGUudGV4dCwgdm5vZGUuZWxtLCB2bm9kZS5jb250ZXh0LCB2bm9kZS5jb21wb25lbnRPcHRpb25zLCB2bm9kZS5hc3luY0ZhY3RvcnkpO1xuICAgIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICAgIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICAgIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gICAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgICBjbG9uZWQuZm5Db250ZXh0ID0gdm5vZGUuZm5Db250ZXh0O1xuICAgIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gICAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgICBjbG9uZWQuYXN5bmNNZXRhID0gdm5vZGUuYXN5bmNNZXRhO1xuICAgIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gICAgcmV0dXJuIGNsb25lZDtcbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbnZhciB1aWQkMiA9IDA7XG52YXIgcGVuZGluZ0NsZWFudXBEZXBzID0gW107XG52YXIgY2xlYW51cERlcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZW5kaW5nQ2xlYW51cERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRlcCA9IHBlbmRpbmdDbGVhbnVwRGVwc1tpXTtcbiAgICAgICAgZGVwLnN1YnMgPSBkZXAuc3Vicy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHM7IH0pO1xuICAgICAgICBkZXAuX3BlbmRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgcGVuZGluZ0NsZWFudXBEZXBzLmxlbmd0aCA9IDA7XG59O1xuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIERlcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXAoKSB7XG4gICAgICAgIC8vIHBlbmRpbmcgc3VicyBjbGVhbnVwXG4gICAgICAgIHRoaXMuX3BlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pZCA9IHVpZCQyKys7XG4gICAgICAgIHRoaXMuc3VicyA9IFtdO1xuICAgIH1cbiAgICBEZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIChzdWIpIHtcbiAgICAgICAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbiAgICB9O1xuICAgIERlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gKHN1Yikge1xuICAgICAgICAvLyAjMTI2OTYgZGVwcyB3aXRoIG1hc3NpdmUgYW1vdW50IG9mIHN1YnNjcmliZXJzIGFyZSBleHRyZW1lbHkgc2xvdyB0b1xuICAgICAgICAvLyBjbGVhbiB1cCBpbiBDaHJvbWl1bVxuICAgICAgICAvLyB0byB3b3JrYXJvdW5kIHRoaXMsIHdlIHVuc2V0IHRoZSBzdWIgZm9yIG5vdywgYW5kIGNsZWFyIHRoZW0gb25cbiAgICAgICAgLy8gbmV4dCBzY2hlZHVsZXIgZmx1c2guXG4gICAgICAgIHRoaXMuc3Vic1t0aGlzLnN1YnMuaW5kZXhPZihzdWIpXSA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5fcGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICBwZW5kaW5nQ2xlYW51cERlcHMucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICAgICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpbmZvICYmIERlcC50YXJnZXQub25UcmFjaykge1xuICAgICAgICAgICAgICAgIERlcC50YXJnZXQub25UcmFjayhfX2Fzc2lnbih7IGVmZmVjdDogRGVwLnRhcmdldCB9LCBpbmZvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgICAgICAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzOyB9KTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbmZpZy5hc3luYykge1xuICAgICAgICAgICAgLy8gc3VicyBhcmVuJ3Qgc29ydGVkIGluIHNjaGVkdWxlciBpZiBub3QgcnVubmluZyBhc3luY1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBzb3J0IHRoZW0gbm93IHRvIG1ha2Ugc3VyZSB0aGV5IGZpcmUgaW4gY29ycmVjdFxuICAgICAgICAgICAgLy8gb3JkZXJcbiAgICAgICAgICAgIHN1YnMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdWIgPSBzdWJzW2ldO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaW5mbykge1xuICAgICAgICAgICAgICAgIHN1Yi5vblRyaWdnZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgc3ViLm9uVHJpZ2dlcihfX2Fzc2lnbih7IGVmZmVjdDogc3Vic1tpXSB9LCBpbmZvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWIudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZXA7XG59KCkpO1xuLy8gVGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gVGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSBvbmx5IG9uZSB3YXRjaGVyXG4vLyBjYW4gYmUgZXZhbHVhdGVkIGF0IGEgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5mdW5jdGlvbiBwdXNoVGFyZ2V0KHRhcmdldCkge1xuICAgIHRhcmdldFN0YWNrLnB1c2godGFyZ2V0KTtcbiAgICBEZXAudGFyZ2V0ID0gdGFyZ2V0O1xufVxuZnVuY3Rpb24gcG9wVGFyZ2V0KCkge1xuICAgIHRhcmdldFN0YWNrLnBvcCgpO1xuICAgIERlcC50YXJnZXQgPSB0YXJnZXRTdGFja1t0YXJnZXRTdGFjay5sZW5ndGggLSAxXTtcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG52YXIgbWV0aG9kc1RvUGF0Y2ggPSBbXG4gICAgJ3B1c2gnLFxuICAgICdwb3AnLFxuICAgICdzaGlmdCcsXG4gICAgJ3Vuc2hpZnQnLFxuICAgICdzcGxpY2UnLFxuICAgICdzb3J0JyxcbiAgICAncmV2ZXJzZSdcbl07XG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5tZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gICAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgICAgIHZhciBpbnNlcnRlZDtcbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc2VydGVkKVxuICAgICAgICAgICAgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTtcbiAgICAgICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgb2IuZGVwLm5vdGlmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheSBtdXRhdGlvblwiIC8qIFRyaWdnZXJPcFR5cGVzLkFSUkFZX01VVEFUSU9OICovLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICBrZXk6IG1ldGhvZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbn0pO1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcbnZhciBOT19JTklUSUFMX1ZBTFVFID0ge307XG4vKipcbiAqIEluIHNvbWUgY2FzZXMgd2UgbWF5IHdhbnQgdG8gZGlzYWJsZSBvYnNlcnZhdGlvbiBpbnNpZGUgYSBjb21wb25lbnQnc1xuICogdXBkYXRlIGNvbXB1dGF0aW9uLlxuICovXG52YXIgc2hvdWxkT2JzZXJ2ZSA9IHRydWU7XG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcodmFsdWUpIHtcbiAgICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XG59XG4vLyBzc3IgbW9jayBkZXBcbnZhciBtb2NrRGVwID0ge1xuICAgIG5vdGlmeTogbm9vcCxcbiAgICBkZXBlbmQ6IG5vb3AsXG4gICAgYWRkU3ViOiBub29wLFxuICAgIHJlbW92ZVN1Yjogbm9vcFxufTtcbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBpcyBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0aGUgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYnNlcnZlcih2YWx1ZSwgc2hhbGxvdywgbW9jaykge1xuICAgICAgICBpZiAoc2hhbGxvdyA9PT0gdm9pZCAwKSB7IHNoYWxsb3cgPSBmYWxzZTsgfVxuICAgICAgICBpZiAobW9jayA9PT0gdm9pZCAwKSB7IG1vY2sgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2hhbGxvdyA9IHNoYWxsb3c7XG4gICAgICAgIHRoaXMubW9jayA9IG1vY2s7XG4gICAgICAgIC8vIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgICAgICB0aGlzLmRlcCA9IG1vY2sgPyBtb2NrRGVwIDogbmV3IERlcCgpO1xuICAgICAgICB0aGlzLnZtQ291bnQgPSAwO1xuICAgICAgICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIW1vY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUHJvdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuX19wcm90b19fID0gYXJyYXlNZXRob2RzO1xuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5S2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBhcnJheUtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYodmFsdWUsIGtleSwgYXJyYXlNZXRob2RzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzaGFsbG93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXYWxrIHRocm91Z2ggYWxsIHByb3BlcnRpZXMgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gICAgICAgICAgICAgKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAgICAgICAgICAgICAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHZhbHVlLCBrZXksIE5PX0lOSVRJQUxfVkFMVUUsIHVuZGVmaW5lZCwgc2hhbGxvdywgbW9jayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gICAgICovXG4gICAgT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgb2JzZXJ2ZSh2YWx1ZVtpXSwgZmFsc2UsIHRoaXMubW9jayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZlcjtcbn0oKSk7XG4vLyBoZWxwZXJzXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlKHZhbHVlLCBzaGFsbG93LCBzc3JNb2NrUmVhY3Rpdml0eSkge1xuICAgIGlmICh2YWx1ZSAmJiBoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gdmFsdWUuX19vYl9fO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICAgICAoc3NyTW9ja1JlYWN0aXZpdHkgfHwgIWlzU2VydmVyUmVuZGVyaW5nKCkpICYmXG4gICAgICAgIChpc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICAgICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAgICAgIXZhbHVlLl9fdl9za2lwIC8qIFJlYWN0aXZlRmxhZ3MuU0tJUCAqLyAmJlxuICAgICAgICAhaXNSZWYodmFsdWUpICYmXG4gICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZlcih2YWx1ZSwgc2hhbGxvdywgc3NyTW9ja1JlYWN0aXZpdHkpO1xuICAgIH1cbn1cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZShvYmosIGtleSwgdmFsLCBjdXN0b21TZXR0ZXIsIHNoYWxsb3csIG1vY2ssIG9ic2VydmVFdmVuSWZTaGFsbG93KSB7XG4gICAgaWYgKG9ic2VydmVFdmVuSWZTaGFsbG93ID09PSB2b2lkIDApIHsgb2JzZXJ2ZUV2ZW5JZlNoYWxsb3cgPSBmYWxzZTsgfVxuICAgIHZhciBkZXAgPSBuZXcgRGVwKCk7XG4gICAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICAgIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG4gICAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiZcbiAgICAgICAgKHZhbCA9PT0gTk9fSU5JVElBTF9WQUxVRSB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSkge1xuICAgICAgICB2YWwgPSBvYmpba2V5XTtcbiAgICB9XG4gICAgdmFyIGNoaWxkT2IgPSBzaGFsbG93ID8gdmFsICYmIHZhbC5fX29iX18gOiBvYnNlcnZlKHZhbCwgZmFsc2UsIG1vY2spO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBkZXAuZGVwZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogb2JqLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1JlZih2YWx1ZSkgJiYgIXNoYWxsb3cgPyB2YWx1ZS52YWx1ZSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyKG5ld1ZhbCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgICAgICAgIGlmICghaGFzQ2hhbmdlZCh2YWx1ZSwgbmV3VmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICAgICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICAgICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGdldHRlcikge1xuICAgICAgICAgICAgICAgIC8vICM3OTgxOiBmb3IgYWNjZXNzb3IgcHJvcGVydGllcyB3aXRob3V0IHNldHRlclxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFzaGFsbG93ICYmIGlzUmVmKHZhbHVlKSAmJiAhaXNSZWYobmV3VmFsKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLnZhbHVlID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkT2IgPSBzaGFsbG93ID8gbmV3VmFsICYmIG5ld1ZhbC5fX29iX18gOiBvYnNlcnZlKG5ld1ZhbCwgZmFsc2UsIG1vY2spO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkZXAubm90aWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogb2JqLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbCxcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXAubm90aWZ5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVwO1xufVxuZnVuY3Rpb24gc2V0KHRhcmdldCwga2V5LCB2YWwpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpKSB7XG4gICAgICAgIHdhcm4oXCJDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIi5jb25jYXQodGFyZ2V0KSk7XG4gICAgfVxuICAgIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFwiU2V0IG9wZXJhdGlvbiBvbiBrZXkgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5cIikpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBvYiA9IHRhcmdldC5fX29iX187XG4gICAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgICAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICAgICAgLy8gd2hlbiBtb2NraW5nIGZvciBTU1IsIGFycmF5IG1ldGhvZHMgYXJlIG5vdCBoaWphY2tlZFxuICAgICAgICBpZiAob2IgJiYgIW9iLnNoYWxsb3cgJiYgb2IubW9jaykge1xuICAgICAgICAgICAgb2JzZXJ2ZSh2YWwsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgIHdhcm4oJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgICAgICAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nKTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgaWYgKCFvYikge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZGVmaW5lUmVhY3RpdmUob2IudmFsdWUsIGtleSwgdmFsLCB1bmRlZmluZWQsIG9iLnNoYWxsb3csIG9iLm1vY2spO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIG9iLmRlcC5ub3RpZnkoe1xuICAgICAgICAgICAgdHlwZTogXCJhZGRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5BREQgKi8sXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgbmV3VmFsdWU6IHZhbCxcbiAgICAgICAgICAgIG9sZFZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBkZWwodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpKSB7XG4gICAgICAgIHdhcm4oXCJDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIi5jb25jYXQodGFyZ2V0KSk7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgICAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG9iID0gdGFyZ2V0Ll9fb2JfXztcbiAgICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgd2FybignQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICAgICAgICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgd2FybihcIkRlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgdGFyZ2V0W2tleV07XG4gICAgaWYgKCFvYikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIG9iLmRlcC5ub3RpZnkoe1xuICAgICAgICAgICAgdHlwZTogXCJkZWxldGVcIiAvKiBUcmlnZ2VyT3BUeXBlcy5ERUxFVEUgKi8sXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIGtleToga2V5XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIH1cbn1cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSh2YWx1ZSkge1xuICAgIGZvciAodmFyIGUgPSB2b2lkIDAsIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGUgPSB2YWx1ZVtpXTtcbiAgICAgICAgaWYgKGUgJiYgZS5fX29iX18pIHtcbiAgICAgICAgICAgIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheShlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlYWN0aXZlKHRhcmdldCkge1xuICAgIG1ha2VSZWFjdGl2ZSh0YXJnZXQsIGZhbHNlKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuLyoqXG4gKiBSZXR1cm4gYSBzaGFsbG93bHktcmVhY3RpdmUgY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LCB3aGVyZSBvbmx5IHRoZSByb290XG4gKiBsZXZlbCBwcm9wZXJ0aWVzIGFyZSByZWFjdGl2ZS4gSXQgYWxzbyBkb2VzIG5vdCBhdXRvLXVud3JhcCByZWZzIChldmVuIGF0IHRoZVxuICogcm9vdCBsZXZlbCkuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dSZWFjdGl2ZSh0YXJnZXQpIHtcbiAgICBtYWtlUmVhY3RpdmUodGFyZ2V0LCB0cnVlKTtcbiAgICBkZWYodGFyZ2V0LCBcIl9fdl9pc1NoYWxsb3dcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1NIQUxMT1cgKi8sIHRydWUpO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBtYWtlUmVhY3RpdmUodGFyZ2V0LCBzaGFsbG93KSB7XG4gICAgLy8gaWYgdHJ5aW5nIHRvIG9ic2VydmUgYSByZWFkb25seSBwcm94eSwgcmV0dXJuIHRoZSByZWFkb25seSB2ZXJzaW9uLlxuICAgIGlmICghaXNSZWFkb25seSh0YXJnZXQpKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgd2FybihcIkF2b2lkIHVzaW5nIEFycmF5IGFzIHJvb3QgdmFsdWUgZm9yIFwiLmNvbmNhdChzaGFsbG93ID8gXCJzaGFsbG93UmVhY3RpdmUoKVwiIDogXCJyZWFjdGl2ZSgpXCIsIFwiIGFzIGl0IGNhbm5vdCBiZSB0cmFja2VkIGluIHdhdGNoKCkgb3Igd2F0Y2hFZmZlY3QoKS4gVXNlIFwiKS5jb25jYXQoc2hhbGxvdyA/IFwic2hhbGxvd1JlZigpXCIgOiBcInJlZigpXCIsIFwiIGluc3RlYWQuIFRoaXMgaXMgYSBWdWUtMi1vbmx5IGxpbWl0YXRpb24uXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBleGlzdGluZ09iID0gdGFyZ2V0ICYmIHRhcmdldC5fX29iX187XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdPYiAmJiBleGlzdGluZ09iLnNoYWxsb3cgIT09IHNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICB3YXJuKFwiVGFyZ2V0IGlzIGFscmVhZHkgYSBcIi5jb25jYXQoZXhpc3RpbmdPYi5zaGFsbG93ID8gXCJcIiA6IFwibm9uLVwiLCBcInNoYWxsb3cgcmVhY3RpdmUgb2JqZWN0LCBhbmQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBcIikuY29uY2F0KHNoYWxsb3cgPyBcIlwiIDogXCJub24tXCIsIFwic2hhbGxvdy5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvYiA9IG9ic2VydmUodGFyZ2V0LCBzaGFsbG93LCBpc1NlcnZlclJlbmRlcmluZygpIC8qIHNzciBtb2NrIHJlYWN0aXZpdHkgKi8pO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhb2IpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgd2FybihcInZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWN0aXZlOiBcIi5jb25jYXQoU3RyaW5nKHRhcmdldCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NvbGxlY3Rpb25UeXBlKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKFwiVnVlIDIgZG9lcyBub3Qgc3VwcG9ydCByZWFjdGl2ZSBjb2xsZWN0aW9uIHR5cGVzIHN1Y2ggYXMgTWFwIG9yIFNldC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1JlYWN0aXZlKHZhbHVlKSB7XG4gICAgaWYgKGlzUmVhZG9ubHkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlW1wiX192X3Jhd1wiIC8qIFJlYWN0aXZlRmxhZ3MuUkFXICovXSk7XG4gICAgfVxuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX29iX18pO1xufVxuZnVuY3Rpb24gaXNTaGFsbG93KHZhbHVlKSB7XG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fdl9pc1NoYWxsb3cpO1xufVxuZnVuY3Rpb24gaXNSZWFkb25seSh2YWx1ZSkge1xuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX3ZfaXNSZWFkb25seSk7XG59XG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWUpIHx8IGlzUmVhZG9ubHkodmFsdWUpO1xufVxuZnVuY3Rpb24gdG9SYXcob2JzZXJ2ZWQpIHtcbiAgICB2YXIgcmF3ID0gb2JzZXJ2ZWQgJiYgb2JzZXJ2ZWRbXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi9dO1xuICAgIHJldHVybiByYXcgPyB0b1JhdyhyYXcpIDogb2JzZXJ2ZWQ7XG59XG5mdW5jdGlvbiBtYXJrUmF3KHZhbHVlKSB7XG4gICAgLy8gbm9uLWV4dGVuc2libGUgb2JqZWN0cyB3b24ndCBiZSBvYnNlcnZlZCBhbnl3YXlcbiAgICBpZiAoT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgZGVmKHZhbHVlLCBcIl9fdl9za2lwXCIgLyogUmVhY3RpdmVGbGFncy5TS0lQICovLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNDb2xsZWN0aW9uVHlwZSh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgICByZXR1cm4gKHR5cGUgPT09ICdNYXAnIHx8IHR5cGUgPT09ICdXZWFrTWFwJyB8fCB0eXBlID09PSAnU2V0JyB8fCB0eXBlID09PSAnV2Vha1NldCcpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVmRmxhZyA9IFwiX192X2lzUmVmXCI7XG5mdW5jdGlvbiBpc1JlZihyKSB7XG4gICAgcmV0dXJuICEhKHIgJiYgci5fX3ZfaXNSZWYgPT09IHRydWUpO1xufVxuZnVuY3Rpb24gcmVmJDEodmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCBmYWxzZSk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVmKHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWYocmF3VmFsdWUsIHNoYWxsb3cpIHtcbiAgICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XG4gICAgICAgIHJldHVybiByYXdWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHJlZiA9IHt9O1xuICAgIGRlZihyZWYsIFJlZkZsYWcsIHRydWUpO1xuICAgIGRlZihyZWYsIFwiX192X2lzU2hhbGxvd1wiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfU0hBTExPVyAqLywgc2hhbGxvdyk7XG4gICAgZGVmKHJlZiwgJ2RlcCcsIGRlZmluZVJlYWN0aXZlKHJlZiwgJ3ZhbHVlJywgcmF3VmFsdWUsIG51bGwsIHNoYWxsb3csIGlzU2VydmVyUmVuZGVyaW5nKCkpKTtcbiAgICByZXR1cm4gcmVmO1xufVxuZnVuY3Rpb24gdHJpZ2dlclJlZihyZWYpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhcmVmLmRlcCkge1xuICAgICAgICB3YXJuKFwicmVjZWl2ZWQgb2JqZWN0IGlzIG5vdCBhIHRyaWdnZXJhYmxlIHJlZi5cIik7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHJlZi5kZXAgJiZcbiAgICAgICAgICAgIHJlZi5kZXAubm90aWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiIC8qIFRyaWdnZXJPcFR5cGVzLlNFVCAqLyxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHJlZixcbiAgICAgICAgICAgICAgICBrZXk6ICd2YWx1ZSdcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVmLmRlcCAmJiByZWYuZGVwLm5vdGlmeSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVucmVmKHJlZikge1xuICAgIHJldHVybiBpc1JlZihyZWYpID8gcmVmLnZhbHVlIDogcmVmO1xufVxuZnVuY3Rpb24gcHJveHlSZWZzKG9iamVjdFdpdGhSZWZzKSB7XG4gICAgaWYgKGlzUmVhY3RpdmUob2JqZWN0V2l0aFJlZnMpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RXaXRoUmVmcztcbiAgICB9XG4gICAgdmFyIHByb3h5ID0ge307XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3RXaXRoUmVmcyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByb3h5V2l0aFJlZlVud3JhcChwcm94eSwgb2JqZWN0V2l0aFJlZnMsIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJveHk7XG59XG5mdW5jdGlvbiBwcm94eVdpdGhSZWZVbndyYXAodGFyZ2V0LCBzb3VyY2UsIGtleSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgaWYgKGlzUmVmKHZhbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG9iID0gdmFsICYmIHZhbC5fX29iX187XG4gICAgICAgICAgICAgICAgaWYgKG9iKVxuICAgICAgICAgICAgICAgICAgICBvYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgaWYgKGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdXJjZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGN1c3RvbVJlZihmYWN0b3J5KSB7XG4gICAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcbiAgICB2YXIgX2EgPSBmYWN0b3J5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGRlcC5kZXBlbmQoe1xuICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLyxcbiAgICAgICAgICAgICAgICBrZXk6ICd2YWx1ZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgZGVwLm5vdGlmeSh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiByZWYsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sXG4gICAgICAgICAgICAgICAga2V5OiAndmFsdWUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICAgICAgfVxuICAgIH0pLCBnZXQgPSBfYS5nZXQsIHNldCA9IF9hLnNldDtcbiAgICB2YXIgcmVmID0ge1xuICAgICAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcbiAgICAgICAgICAgIHNldChuZXdWYWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBkZWYocmVmLCBSZWZGbGFnLCB0cnVlKTtcbiAgICByZXR1cm4gcmVmO1xufVxuZnVuY3Rpb24gdG9SZWZzKG9iamVjdCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFpc1JlYWN0aXZlKG9iamVjdCkpIHtcbiAgICAgICAgd2FybihcInRvUmVmcygpIGV4cGVjdHMgYSByZWFjdGl2ZSBvYmplY3QgYnV0IHJlY2VpdmVkIGEgcGxhaW4gb25lLlwiKTtcbiAgICB9XG4gICAgdmFyIHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgcmV0W2tleV0gPSB0b1JlZihvYmplY3QsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiB0b1JlZihvYmplY3QsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIHZhbCA9IG9iamVjdFtrZXldO1xuICAgIGlmIChpc1JlZih2YWwpKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIHZhciByZWYgPSB7XG4gICAgICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBuZXdWYWw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRlZihyZWYsIFJlZkZsYWcsIHRydWUpO1xuICAgIHJldHVybiByZWY7XG59XG5cbnZhciByYXdUb1JlYWRvbmx5RmxhZyA9IFwiX192X3Jhd1RvUmVhZG9ubHlcIjtcbnZhciByYXdUb1NoYWxsb3dSZWFkb25seUZsYWcgPSBcIl9fdl9yYXdUb1NoYWxsb3dSZWFkb25seVwiO1xuZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRvbmx5KHRhcmdldCwgZmFsc2UpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVhZG9ubHkodGFyZ2V0LCBzaGFsbG93KSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKFwiVnVlIDIgZG9lcyBub3Qgc3VwcG9ydCByZWFkb25seSBhcnJheXMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNDb2xsZWN0aW9uVHlwZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgd2FybihcIlZ1ZSAyIGRvZXMgbm90IHN1cHBvcnQgcmVhZG9ubHkgY29sbGVjdGlvbiB0eXBlcyBzdWNoIGFzIE1hcCBvciBTZXQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2FybihcInZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWRvbmx5OiBcIi5jb25jYXQodHlwZW9mIHRhcmdldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFPYmplY3QuaXNFeHRlbnNpYmxlKHRhcmdldCkpIHtcbiAgICAgICAgd2FybihcIlZ1ZSAyIGRvZXMgbm90IHN1cHBvcnQgY3JlYXRpbmcgcmVhZG9ubHkgcHJveHkgZm9yIG5vbi1leHRlbnNpYmxlIG9iamVjdC5cIik7XG4gICAgfVxuICAgIC8vIGFscmVhZHkgYSByZWFkb25seSBvYmplY3RcbiAgICBpZiAoaXNSZWFkb25seSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8vIGFscmVhZHkgaGFzIGEgcmVhZG9ubHkgcHJveHlcbiAgICB2YXIgZXhpc3RpbmdGbGFnID0gc2hhbGxvdyA/IHJhd1RvU2hhbGxvd1JlYWRvbmx5RmxhZyA6IHJhd1RvUmVhZG9ubHlGbGFnO1xuICAgIHZhciBleGlzdGluZ1Byb3h5ID0gdGFyZ2V0W2V4aXN0aW5nRmxhZ107XG4gICAgaWYgKGV4aXN0aW5nUHJveHkpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nUHJveHk7XG4gICAgfVxuICAgIHZhciBwcm94eSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkpO1xuICAgIGRlZih0YXJnZXQsIGV4aXN0aW5nRmxhZywgcHJveHkpO1xuICAgIGRlZihwcm94eSwgXCJfX3ZfaXNSZWFkb25seVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBRE9OTFkgKi8sIHRydWUpO1xuICAgIGRlZihwcm94eSwgXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi8sIHRhcmdldCk7XG4gICAgaWYgKGlzUmVmKHRhcmdldCkpIHtcbiAgICAgICAgZGVmKHByb3h5LCBSZWZGbGFnLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHNoYWxsb3cgfHwgaXNTaGFsbG93KHRhcmdldCkpIHtcbiAgICAgICAgZGVmKHByb3h5LCBcIl9fdl9pc1NoYWxsb3dcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1NIQUxMT1cgKi8sIHRydWUpO1xuICAgIH1cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlZmluZVJlYWRvbmx5UHJvcGVydHkocHJveHksIHRhcmdldCwga2V5c1tpXSwgc2hhbGxvdyk7XG4gICAgfVxuICAgIHJldHVybiBwcm94eTtcbn1cbmZ1bmN0aW9uIGRlZmluZVJlYWRvbmx5UHJvcGVydHkocHJveHksIHRhcmdldCwga2V5LCBzaGFsbG93KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3h5LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBzaGFsbG93IHx8ICFpc1BsYWluT2JqZWN0KHZhbCkgPyB2YWwgOiByZWFkb25seSh2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB3YXJuKFwiU2V0IG9wZXJhdGlvbiBvbiBrZXkgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5cIikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgYSByZWFjdGl2ZS1jb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QsIHdoZXJlIG9ubHkgdGhlIHJvb3QgbGV2ZWxcbiAqIHByb3BlcnRpZXMgYXJlIHJlYWRvbmx5LCBhbmQgZG9lcyBOT1QgdW53cmFwIHJlZnMgbm9yIHJlY3Vyc2l2ZWx5IGNvbnZlcnRcbiAqIHJldHVybmVkIHByb3BlcnRpZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGNyZWF0aW5nIHRoZSBwcm9wcyBwcm94eSBvYmplY3QgZm9yIHN0YXRlZnVsIGNvbXBvbmVudHMuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dSZWFkb25seSh0YXJnZXQpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVhZG9ubHkodGFyZ2V0LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMpIHtcbiAgICB2YXIgZ2V0dGVyO1xuICAgIHZhciBzZXR0ZXI7XG4gICAgdmFyIG9ubHlHZXR0ZXIgPSBpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucyk7XG4gICAgaWYgKG9ubHlHZXR0ZXIpIHtcbiAgICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zO1xuICAgICAgICBzZXR0ZXIgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCB2YWx1ZSBpcyByZWFkb25seScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBub29wO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcbiAgICAgICAgc2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLnNldDtcbiAgICB9XG4gICAgdmFyIHdhdGNoZXIgPSBpc1NlcnZlclJlbmRlcmluZygpXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IG5ldyBXYXRjaGVyKGN1cnJlbnRJbnN0YW5jZSwgZ2V0dGVyLCBub29wLCB7IGxhenk6IHRydWUgfSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2F0Y2hlciAmJiBkZWJ1Z09wdGlvbnMpIHtcbiAgICAgICAgd2F0Y2hlci5vblRyYWNrID0gZGVidWdPcHRpb25zLm9uVHJhY2s7XG4gICAgICAgIHdhdGNoZXIub25UcmlnZ2VyID0gZGVidWdPcHRpb25zLm9uVHJpZ2dlcjtcbiAgICB9XG4gICAgdmFyIHJlZiA9IHtcbiAgICAgICAgLy8gc29tZSBsaWJzIHJlbHkgb24gdGhlIHByZXNlbmNlIGVmZmVjdCBmb3IgY2hlY2tpbmcgY29tcHV0ZWQgcmVmc1xuICAgICAgICAvLyBmcm9tIG5vcm1hbCByZWZzLCBidXQgdGhlIGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgIGVmZmVjdDogd2F0Y2hlcixcbiAgICAgICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICAgICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIERlcC50YXJnZXQub25UcmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgRGVwLnRhcmdldC5vblRyYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3Q6IERlcC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiByZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ3ZhbHVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcbiAgICAgICAgICAgIHNldHRlcihuZXdWYWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBkZWYocmVmLCBSZWZGbGFnLCB0cnVlKTtcbiAgICBkZWYocmVmLCBcIl9fdl9pc1JlYWRvbmx5XCIgLyogUmVhY3RpdmVGbGFncy5JU19SRUFET05MWSAqLywgb25seUdldHRlcik7XG4gICAgcmV0dXJuIHJlZjtcbn1cblxudmFyIFdBVENIRVIgPSBcIndhdGNoZXJcIjtcbnZhciBXQVRDSEVSX0NCID0gXCJcIi5jb25jYXQoV0FUQ0hFUiwgXCIgY2FsbGJhY2tcIik7XG52YXIgV0FUQ0hFUl9HRVRURVIgPSBcIlwiLmNvbmNhdChXQVRDSEVSLCBcIiBnZXR0ZXJcIik7XG52YXIgV0FUQ0hFUl9DTEVBTlVQID0gXCJcIi5jb25jYXQoV0FUQ0hFUiwgXCIgY2xlYW51cFwiKTtcbi8vIFNpbXBsZSBlZmZlY3QuXG5mdW5jdGlvbiB3YXRjaEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gd2F0Y2hQb3N0RWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgZmx1c2g6ICdwb3N0JyB9KSA6IHsgZmx1c2g6ICdwb3N0JyB9KSk7XG59XG5mdW5jdGlvbiB3YXRjaFN5bmNFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmbHVzaDogJ3N5bmMnIH0pIDogeyBmbHVzaDogJ3N5bmMnIH0pKTtcbn1cbi8vIGluaXRpYWwgdmFsdWUgZm9yIHdhdGNoZXJzIHRvIHRyaWdnZXIgb24gdW5kZWZpbmVkIGluaXRpYWwgdmFsdWVzXG52YXIgSU5JVElBTF9XQVRDSEVSX1ZBTFVFID0ge307XG4vLyBpbXBsZW1lbnRhdGlvblxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuKFwiYHdhdGNoKGZuLCBvcHRpb25zPylgIHNpZ25hdHVyZSBoYXMgYmVlbiBtb3ZlZCB0byBhIHNlcGFyYXRlIEFQSS4gXCIgK1xuICAgICAgICAgICAgXCJVc2UgYHdhdGNoRWZmZWN0KGZuLCBvcHRpb25zPylgIGluc3RlYWQuIGB3YXRjaGAgbm93IG9ubHkgXCIgK1xuICAgICAgICAgICAgXCJzdXBwb3J0cyBgd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucz8pIHNpZ25hdHVyZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZG9XYXRjaChzb3VyY2UsIGNiLCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyBlbXB0eU9iamVjdCA6IF9hLCBpbW1lZGlhdGUgPSBfYi5pbW1lZGlhdGUsIGRlZXAgPSBfYi5kZWVwLCBfYyA9IF9iLmZsdXNoLCBmbHVzaCA9IF9jID09PSB2b2lkIDAgPyAncHJlJyA6IF9jLCBvblRyYWNrID0gX2Iub25UcmFjaywgb25UcmlnZ2VyID0gX2Iub25UcmlnZ2VyO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjYikge1xuICAgICAgICBpZiAoaW1tZWRpYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdhcm4oXCJ3YXRjaCgpIFxcXCJpbW1lZGlhdGVcXFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBcIiArXG4gICAgICAgICAgICAgICAgXCJ3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVlcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3YXJuKFwid2F0Y2goKSBcXFwiZGVlcFxcXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIFwiICtcbiAgICAgICAgICAgICAgICBcIndhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciB3YXJuSW52YWxpZFNvdXJjZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHdhcm4oXCJJbnZhbGlkIHdhdGNoIHNvdXJjZTogXCIuY29uY2F0KHMsIFwiLiBBIHdhdGNoIHNvdXJjZSBjYW4gb25seSBiZSBhIGdldHRlci9lZmZlY3QgXCIpICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24sIGEgcmVmLCBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuXCIpO1xuICAgIH07XG4gICAgdmFyIGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xuICAgIHZhciBjYWxsID0gZnVuY3Rpb24gKGZuLCB0eXBlLCBhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzID09PSB2b2lkIDApIHsgYXJncyA9IG51bGw7IH1cbiAgICAgICAgdmFyIHJlcyA9IGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGZuLCBudWxsLCBhcmdzLCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgICAgIGlmIChkZWVwICYmIHJlcyAmJiByZXMuX19vYl9fKVxuICAgICAgICAgICAgcmVzLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICB2YXIgZ2V0dGVyO1xuICAgIHZhciBmb3JjZVRyaWdnZXIgPSBmYWxzZTtcbiAgICB2YXIgaXNNdWx0aVNvdXJjZSA9IGZhbHNlO1xuICAgIGlmIChpc1JlZihzb3VyY2UpKSB7XG4gICAgICAgIGdldHRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvdXJjZS52YWx1ZTsgfTtcbiAgICAgICAgZm9yY2VUcmlnZ2VyID0gaXNTaGFsbG93KHNvdXJjZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUoc291cmNlKSkge1xuICAgICAgICBnZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzb3VyY2UuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH07XG4gICAgICAgIGRlZXAgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgaXNNdWx0aVNvdXJjZSA9IHRydWU7XG4gICAgICAgIGZvcmNlVHJpZ2dlciA9IHNvdXJjZS5zb21lKGZ1bmN0aW9uIChzKSB7IHJldHVybiBpc1JlYWN0aXZlKHMpIHx8IGlzU2hhbGxvdyhzKTsgfSk7XG4gICAgICAgIGdldHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVmKHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1JlYWN0aXZlKHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHMuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnNlKHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsKHMsIFdBVENIRVJfR0VUVEVSKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybkludmFsaWRTb3VyY2Uocyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIC8vIGdldHRlciB3aXRoIGNiXG4gICAgICAgICAgICBnZXR0ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsKHNvdXJjZSwgV0FUQ0hFUl9HRVRURVIpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gY2IgLT4gc2ltcGxlIGVmZmVjdFxuICAgICAgICAgICAgZ2V0dGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsKHNvdXJjZSwgV0FUQ0hFUiwgW29uQ2xlYW51cF0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2V0dGVyID0gbm9vcDtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuSW52YWxpZFNvdXJjZShzb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoY2IgJiYgZGVlcCkge1xuICAgICAgICB2YXIgYmFzZUdldHRlcl8xID0gZ2V0dGVyO1xuICAgICAgICBnZXR0ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmF2ZXJzZShiYXNlR2V0dGVyXzEoKSk7IH07XG4gICAgfVxuICAgIHZhciBjbGVhbnVwO1xuICAgIHZhciBvbkNsZWFudXAgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgY2xlYW51cCA9IHdhdGNoZXIub25TdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbChmbiwgV0FUQ0hFUl9DTEVBTlVQKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vIGluIFNTUiB0aGVyZSBpcyBubyBuZWVkIHRvIHNldHVwIGFuIGFjdHVhbCBlZmZlY3QsIGFuZCBpdCBzaG91bGQgYmUgbm9vcFxuICAgIC8vIHVubGVzcyBpdCdzIGVhZ2VyXG4gICAgaWYgKGlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgLy8gd2Ugd2lsbCBhbHNvIG5vdCBjYWxsIHRoZSBpbnZhbGlkYXRlIGNhbGxiYWNrICgrIHJ1bm5lciBpcyBub3Qgc2V0IHVwKVxuICAgICAgICBvbkNsZWFudXAgPSBub29wO1xuICAgICAgICBpZiAoIWNiKSB7XG4gICAgICAgICAgICBnZXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgIGNhbGwoY2IsIFdBVENIRVJfQ0IsIFtcbiAgICAgICAgICAgICAgICBnZXR0ZXIoKSxcbiAgICAgICAgICAgICAgICBpc011bHRpU291cmNlID8gW10gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgb25DbGVhbnVwXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcihjdXJyZW50SW5zdGFuY2UsIGdldHRlciwgbm9vcCwge1xuICAgICAgICBsYXp5OiB0cnVlXG4gICAgfSk7XG4gICAgd2F0Y2hlci5ub1JlY3Vyc2UgPSAhY2I7XG4gICAgdmFyIG9sZFZhbHVlID0gaXNNdWx0aVNvdXJjZSA/IFtdIDogSU5JVElBTF9XQVRDSEVSX1ZBTFVFO1xuICAgIC8vIG92ZXJ3cml0ZSBkZWZhdWx0IHJ1blxuICAgIHdhdGNoZXIucnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXdhdGNoZXIuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAvLyB3YXRjaChzb3VyY2UsIGNiKVxuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gd2F0Y2hlci5nZXQoKTtcbiAgICAgICAgICAgIGlmIChkZWVwIHx8XG4gICAgICAgICAgICAgICAgZm9yY2VUcmlnZ2VyIHx8XG4gICAgICAgICAgICAgICAgKGlzTXVsdGlTb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgPyBuZXdWYWx1ZS5zb21lKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzQ2hhbmdlZCh2LCBvbGRWYWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIDogaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgYmVmb3JlIHJ1bm5pbmcgY2IgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGwoY2IsIFdBVENIRVJfQ0IsIFtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID09PSBJTklUSUFMX1dBVENIRVJfVkFMVUUgPyB1bmRlZmluZWQgOiBvbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgb25DbGVhbnVwXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdhdGNoRWZmZWN0XG4gICAgICAgICAgICB3YXRjaGVyLmdldCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoZmx1c2ggPT09ICdzeW5jJykge1xuICAgICAgICB3YXRjaGVyLnVwZGF0ZSA9IHdhdGNoZXIucnVuO1xuICAgIH1cbiAgICBlbHNlIGlmIChmbHVzaCA9PT0gJ3Bvc3QnKSB7XG4gICAgICAgIHdhdGNoZXIucG9zdCA9IHRydWU7XG4gICAgICAgIHdhdGNoZXIudXBkYXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcXVldWVXYXRjaGVyKHdhdGNoZXIpOyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gcHJlXG4gICAgICAgIHdhdGNoZXIudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlID09PSBjdXJyZW50SW5zdGFuY2UgJiYgIWluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmUtd2F0Y2hlciB0cmlnZ2VyZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGluc3RhbmNlLl9wcmVXYXRjaGVycyB8fCAoaW5zdGFuY2UuX3ByZVdhdGNoZXJzID0gW10pO1xuICAgICAgICAgICAgICAgIGlmIChidWZmZXIuaW5kZXhPZih3YXRjaGVyKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHdhdGNoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVldWVXYXRjaGVyKHdhdGNoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXRjaGVyLm9uVHJhY2sgPSBvblRyYWNrO1xuICAgICAgICB3YXRjaGVyLm9uVHJpZ2dlciA9IG9uVHJpZ2dlcjtcbiAgICB9XG4gICAgLy8gaW5pdGlhbCBydW5cbiAgICBpZiAoY2IpIHtcbiAgICAgICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgICAgICAgd2F0Y2hlci5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9sZFZhbHVlID0gd2F0Y2hlci5nZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChmbHVzaCA9PT0gJ3Bvc3QnICYmIGluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlLiRvbmNlKCdob29rOm1vdW50ZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiB3YXRjaGVyLmdldCgpOyB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdhdGNoZXIuZ2V0KCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9O1xufVxuXG52YXIgYWN0aXZlRWZmZWN0U2NvcGU7XG52YXIgRWZmZWN0U2NvcGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWZmZWN0U2NvcGUoZGV0YWNoZWQpIHtcbiAgICAgICAgaWYgKGRldGFjaGVkID09PSB2b2lkIDApIHsgZGV0YWNoZWQgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLmRldGFjaGVkID0gZGV0YWNoZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZmZlY3RzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYW51cHMgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBhY3RpdmVFZmZlY3RTY29wZTtcbiAgICAgICAgaWYgKCFkZXRhY2hlZCAmJiBhY3RpdmVFZmZlY3RTY29wZSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9XG4gICAgICAgICAgICAgICAgKGFjdGl2ZUVmZmVjdFNjb3BlLnNjb3BlcyB8fCAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzID0gW10pKS5wdXNoKHRoaXMpIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBFZmZlY3RTY29wZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRFZmZlY3RTY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IGN1cnJlbnRFZmZlY3RTY29wZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB3YXJuKFwiY2Fubm90IHJ1biBhbiBpbmFjdGl2ZSBlZmZlY3Qgc2NvcGUuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgRWZmZWN0U2NvcGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgRWZmZWN0U2NvcGUucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzLnBhcmVudDtcbiAgICB9O1xuICAgIEVmZmVjdFNjb3BlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKGZyb21QYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHZvaWQgMCwgbCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnRlYXJkb3duKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jbGVhbnVwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXBzW2ldKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zY29wZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5zY29wZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnN0b3AodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbmVzdGVkIHNjb3BlLCBkZXJlZmVyZW5jZSBmcm9tIHBhcmVudCB0byBhdm9pZCBtZW1vcnkgbGVha3NcbiAgICAgICAgICAgIGlmICghdGhpcy5kZXRhY2hlZCAmJiB0aGlzLnBhcmVudCAmJiAhZnJvbVBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIG9wdGltaXplZCBPKDEpIHJlbW92YWxcbiAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHRoaXMucGFyZW50LnNjb3Blcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnNjb3Blc1t0aGlzLmluZGV4XSA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QuaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEVmZmVjdFNjb3BlO1xufSgpKTtcbmZ1bmN0aW9uIGVmZmVjdFNjb3BlKGRldGFjaGVkKSB7XG4gICAgcmV0dXJuIG5ldyBFZmZlY3RTY29wZShkZXRhY2hlZCk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiByZWNvcmRFZmZlY3RTY29wZShlZmZlY3QsIHNjb3BlKSB7XG4gICAgaWYgKHNjb3BlID09PSB2b2lkIDApIHsgc2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZTsgfVxuICAgIGlmIChzY29wZSAmJiBzY29wZS5hY3RpdmUpIHtcbiAgICAgICAgc2NvcGUuZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xuICAgIHJldHVybiBhY3RpdmVFZmZlY3RTY29wZTtcbn1cbmZ1bmN0aW9uIG9uU2NvcGVEaXNwb3NlKGZuKSB7XG4gICAgaWYgKGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlLmNsZWFudXBzLnB1c2goZm4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXCJvblNjb3BlRGlzcG9zZSgpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBlZmZlY3Qgc2NvcGVcIiArXG4gICAgICAgICAgICBcIiB0byBiZSBhc3NvY2lhdGVkIHdpdGguXCIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcHJvdmlkZShrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHdhcm4oXCJwcm92aWRlKCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKS5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRTIGRvZXNuJ3QgYWxsb3cgc3ltYm9sIGFzIGluZGV4IHR5cGVcbiAgICAgICAgcmVzb2x2ZVByb3ZpZGVkKGN1cnJlbnRJbnN0YW5jZSlba2V5XSA9IHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVQcm92aWRlZCh2bSkge1xuICAgIC8vIGJ5IGRlZmF1bHQgYW4gaW5zdGFuY2UgaW5oZXJpdHMgaXRzIHBhcmVudCdzIHByb3ZpZGVzIG9iamVjdFxuICAgIC8vIGJ1dCB3aGVuIGl0IG5lZWRzIHRvIHByb3ZpZGUgdmFsdWVzIG9mIGl0cyBvd24sIGl0IGNyZWF0ZXMgaXRzXG4gICAgLy8gb3duIHByb3ZpZGVzIG9iamVjdCB1c2luZyBwYXJlbnQgcHJvdmlkZXMgb2JqZWN0IGFzIHByb3RvdHlwZS5cbiAgICAvLyB0aGlzIHdheSBpbiBgaW5qZWN0YCB3ZSBjYW4gc2ltcGx5IGxvb2sgdXAgaW5qZWN0aW9ucyBmcm9tIGRpcmVjdFxuICAgIC8vIHBhcmVudCBhbmQgbGV0IHRoZSBwcm90b3R5cGUgY2hhaW4gZG8gdGhlIHdvcmsuXG4gICAgdmFyIGV4aXN0aW5nID0gdm0uX3Byb3ZpZGVkO1xuICAgIHZhciBwYXJlbnRQcm92aWRlcyA9IHZtLiRwYXJlbnQgJiYgdm0uJHBhcmVudC5fcHJvdmlkZWQ7XG4gICAgaWYgKHBhcmVudFByb3ZpZGVzID09PSBleGlzdGluZykge1xuICAgICAgICByZXR1cm4gKHZtLl9wcm92aWRlZCA9IE9iamVjdC5jcmVhdGUocGFyZW50UHJvdmlkZXMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG59XG5mdW5jdGlvbiBpbmplY3Qoa2V5LCBkZWZhdWx0VmFsdWUsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSkge1xuICAgIGlmICh0cmVhdERlZmF1bHRBc0ZhY3RvcnkgPT09IHZvaWQgMCkgeyB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgPSBmYWxzZTsgfVxuICAgIC8vIGZhbGxiYWNrIHRvIGBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2VgIHNvIHRoYXQgdGhpcyBjYW4gYmUgY2FsbGVkIGluXG4gICAgLy8gYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgIHZhciBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgLy8gIzI0MDBcbiAgICAgICAgLy8gdG8gc3VwcG9ydCBgYXBwLnVzZWAgcGx1Z2lucyxcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gYXBwQ29udGV4dCdzIGBwcm92aWRlc2AgaWYgdGhlIGluc3RhbmNlIGlzIGF0IHJvb3RcbiAgICAgICAgdmFyIHByb3ZpZGVzID0gaW5zdGFuY2UuJHBhcmVudCAmJiBpbnN0YW5jZS4kcGFyZW50Ll9wcm92aWRlZDtcbiAgICAgICAgaWYgKHByb3ZpZGVzICYmIGtleSBpbiBwcm92aWRlcykge1xuICAgICAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpXG4gICAgICAgICAgICAgICAgPyBkZWZhdWx0VmFsdWUuY2FsbChpbnN0YW5jZSlcbiAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB3YXJuKFwiaW5qZWN0aW9uIFxcXCJcIi5jb25jYXQoU3RyaW5nKGtleSksIFwiXFxcIiBub3QgZm91bmQuXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXCJpbmplY3QoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cy5cIik7XG4gICAgfVxufVxuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gICAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgICB2YXIgb25jZSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgICBuYW1lID0gb25jZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICAgIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIG9uY2U6IG9uY2UsXG4gICAgICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIoZm5zLCB2bSkge1xuICAgIGZ1bmN0aW9uIGludm9rZXIoKSB7XG4gICAgICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICAgICAgaWYgKGlzQXJyYXkoZm5zKSkge1xuICAgICAgICAgICAgdmFyIGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjbG9uZWRbaV0sIG51bGwsIGFyZ3VtZW50cywgdm0sIFwidi1vbiBoYW5kbGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgICAgICAgIHJldHVybiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhmbnMsIG51bGwsIGFyZ3VtZW50cywgdm0sIFwidi1vbiBoYW5kbGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludm9rZXIuZm5zID0gZm5zO1xuICAgIHJldHVybiBpbnZva2VyO1xufVxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkLCByZW1vdmUsIGNyZWF0ZU9uY2VIYW5kbGVyLCB2bSkge1xuICAgIHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XG4gICAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdO1xuICAgICAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHdhcm4oXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIi5jb25jYXQoZXZlbnQubmFtZSwgXCJcXFwiOiBnb3QgXCIpICsgU3RyaW5nKGN1ciksIHZtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNUcnVlKGV2ZW50Lm9uY2UpKSB7XG4gICAgICAgICAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVPbmNlSGFuZGxlcihldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgICAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgICAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICAgICAgICByZW1vdmUoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayhkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgICBpZiAoZGVmIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgICB9XG4gICAgdmFyIGludm9rZXI7XG4gICAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG4gICAgZnVuY3Rpb24gd3JhcHBlZEhvb2soKSB7XG4gICAgICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgICAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgICAgICByZW1vdmUkMihpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgICAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAgICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgICAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICAgICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZykge1xuICAgIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAgIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAgIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gICAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICAgIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzLCBwcm9wcyA9IGRhdGEucHJvcHM7XG4gICAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IGtleUluTG93ZXJDYXNlICYmIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpcChcIlByb3AgXFxcIlwiLmNvbmNhdChrZXlJbkxvd2VyQ2FzZSwgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIuY29uY2F0KGZvcm1hdENvbXBvbmVudE5hbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRhZyBpcyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZyB8fCBDdG9yKSwgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIuIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIuY29uY2F0KGFsdEtleSwgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiKS5jb25jYXQoa2V5LCBcIlxcXCIuXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICAgICAgICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNoZWNrUHJvcChyZXMsIGhhc2gsIGtleSwgYWx0S2V5LCBwcmVzZXJ2ZSkge1xuICAgIGlmIChpc0RlZihoYXNoKSkge1xuICAgICAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgICAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICAgICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG59XG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgICAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgICAgICA6IGlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICAgICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzVGV4dE5vZGUobm9kZSkge1xuICAgIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIGksIGMsIGxhc3RJbmRleCwgbGFzdDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xuICAgICAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgICAgIC8vICBuZXN0ZWRcbiAgICAgICAgaWYgKGlzQXJyYXkoYykpIHtcbiAgICAgICAgICAgIGlmIChjLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCBcIlwiLmNvbmNhdChuZXN0ZWRJbmRleCB8fCAnJywgXCJfXCIpLmNvbmNhdChpKSk7XG4gICAgICAgICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAgICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgY1swXS50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXMucHVzaC5hcHBseShyZXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICAgICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgICAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgICAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgICAgICAgICAgaWYgKGlzVHJ1ZShjaGlsZHJlbi5faXNWTGlzdCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzRGVmKG5lc3RlZEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiLmNvbmNhdChuZXN0ZWRJbmRleCwgXCJfXCIpLmNvbmNhdChpLCBcIl9fXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXMucHVzaChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QodmFsLCByZW5kZXIpIHtcbiAgICB2YXIgcmV0ID0gbnVsbCwgaSwgbCwga2V5cywga2V5O1xuICAgIGlmIChpc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgICAgICAgIHJldCA9IFtdO1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2gocmVuZGVyKHJlc3VsdC52YWx1ZSwgcmV0Lmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNEZWYocmV0KSkge1xuICAgICAgICByZXQgPSBbXTtcbiAgICB9XG4gICAgcmV0Ll9pc1ZMaXN0ID0gdHJ1ZTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QobmFtZSwgZmFsbGJhY2tSZW5kZXIsIHByb3BzLCBiaW5kT2JqZWN0KSB7XG4gICAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICAgIHZhciBub2RlcztcbiAgICBpZiAoc2NvcGVkU2xvdEZuKSB7XG4gICAgICAgIC8vIHNjb3BlZCBzbG90XG4gICAgICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JywgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZXMgPVxuICAgICAgICAgICAgc2NvcGVkU2xvdEZuKHByb3BzKSB8fFxuICAgICAgICAgICAgICAgIChpc0Z1bmN0aW9uKGZhbGxiYWNrUmVuZGVyKSA/IGZhbGxiYWNrUmVuZGVyKCkgOiBmYWxsYmFja1JlbmRlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlcyA9XG4gICAgICAgICAgICB0aGlzLiRzbG90c1tuYW1lXSB8fFxuICAgICAgICAgICAgICAgIChpc0Z1bmN0aW9uKGZhbGxiYWNrUmVuZGVyKSA/IGZhbGxiYWNrUmVuZGVyKCkgOiBmYWxsYmFja1JlbmRlcik7XG4gICAgfVxuICAgIHZhciB0YXJnZXQgPSBwcm9wcyAmJiBwcm9wcy5zbG90O1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJywgeyBzbG90OiB0YXJnZXQgfSwgbm9kZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlcihpZCkge1xuICAgIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHk7XG59XG5cbmZ1bmN0aW9uIGlzS2V5Tm90TWF0Y2goZXhwZWN0LCBhY3R1YWwpIHtcbiAgICBpZiAoaXNBcnJheShleHBlY3QpKSB7XG4gICAgICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbDtcbiAgICB9XG59XG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqIGV4cG9zZWQgYXMgVnVlLnByb3RvdHlwZS5fa1xuICogcGFzc2luZyBpbiBldmVudEtleU5hbWUgYXMgbGFzdCBhcmd1bWVudCBzZXBhcmF0ZWx5IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMoZXZlbnRLZXlDb2RlLCBrZXksIGJ1aWx0SW5LZXlDb2RlLCBldmVudEtleU5hbWUsIGJ1aWx0SW5LZXlOYW1lKSB7XG4gICAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgICBpZiAoYnVpbHRJbktleU5hbWUgJiYgZXZlbnRLZXlOYW1lICYmICFjb25maWcua2V5Q29kZXNba2V5XSkge1xuICAgICAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWFwcGVkS2V5Q29kZSkge1xuICAgICAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudEtleU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXk7XG4gICAgfVxuICAgIHJldHVybiBldmVudEtleUNvZGUgPT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMoZGF0YSwgdGFnLCB2YWx1ZSwgYXNQcm9wLCBpc1N5bmMpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB3YXJuKCd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaGFzaCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnIHx8IGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGhhc2ggPVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICAgICAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKCEoY2FtZWxpemVkS2V5IGluIGhhc2gpICYmICEoaHlwaGVuYXRlZEtleSBpbiBoYXNoKSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25bXCJ1cGRhdGU6XCIuY29uY2F0KGtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIF9sb29wXzEoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljKGluZGV4LCBpc0luRm9yKSB7XG4gICAgdmFyIGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gICAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gICAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUuXG4gICAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKHRoaXMuX3JlbmRlclByb3h5LCB0aGlzLl9jLCB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICAgKTtcbiAgICBtYXJrU3RhdGljKHRyZWUsIFwiX19zdGF0aWNfX1wiLmNvbmNhdChpbmRleCksIGZhbHNlKTtcbiAgICByZXR1cm4gdHJlZTtcbn1cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSh0cmVlLCBpbmRleCwga2V5KSB7XG4gICAgbWFya1N0YXRpYyh0cmVlLCBcIl9fb25jZV9fXCIuY29uY2F0KGluZGV4KS5jb25jYXQoa2V5ID8gXCJfXCIuY29uY2F0KGtleSkgOiBcIlwiKSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRyZWU7XG59XG5mdW5jdGlvbiBtYXJrU3RhdGljKHRyZWUsIGtleSwgaXNPbmNlKSB7XG4gICAgaWYgKGlzQXJyYXkodHJlZSkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCBcIlwiLmNvbmNhdChrZXksIFwiX1wiKS5jb25jYXQoaSksIGlzT25jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZShub2RlLCBrZXksIGlzT25jZSkge1xuICAgIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICAgIG5vZGUua2V5ID0ga2V5O1xuICAgIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzKGRhdGEsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybigndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgb24gPSAoZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge30pO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyhmbnMsIHJlcywgXG4vLyB0aGUgZm9sbG93aW5nIGFyZSBhZGRlZCBpbiAyLjZcbmhhc0R5bmFtaWNLZXlzLCBjb250ZW50SGFzaEtleSkge1xuICAgIHJlcyA9IHJlcyB8fCB7ICRzdGFibGU6ICFoYXNEeW5hbWljS2V5cyB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzbG90ID0gZm5zW2ldO1xuICAgICAgICBpZiAoaXNBcnJheShzbG90KSkge1xuICAgICAgICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKHNsb3QsIHJlcywgaGFzRHluYW1pY0tleXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNsb3QpIHtcbiAgICAgICAgICAgIC8vIG1hcmtlciBmb3IgcmV2ZXJzZSBwcm94eWluZyB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgaWYgKHNsb3QucHJveHkpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgc2xvdC5mbi5wcm94eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNbc2xvdC5rZXldID0gc2xvdC5mbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGVudEhhc2hLZXkpIHtcbiAgICAgICAgcmVzLiRrZXkgPSBjb250ZW50SGFzaEtleTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gaGVscGVyIHRvIHByb2Nlc3MgZHluYW1pYyBrZXlzIGZvciBkeW5hbWljIGFyZ3VtZW50cyBpbiB2LWJpbmQgYW5kIHYtb24uXG5mdW5jdGlvbiBiaW5kRHluYW1pY0tleXMoYmFzZU9iaiwgdmFsdWVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGtleSA9IHZhbHVlc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleSkge1xuICAgICAgICAgICAgYmFzZU9ialt2YWx1ZXNbaV1dID0gdmFsdWVzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGtleSAhPT0gJycgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBudWxsIGlzIGEgc3BlY2lhbCB2YWx1ZSBmb3IgZXhwbGljaXRseSByZW1vdmluZyBhIGJpbmRpbmdcbiAgICAgICAgICAgIHdhcm4oXCJJbnZhbGlkIHZhbHVlIGZvciBkeW5hbWljIGRpcmVjdGl2ZSBhcmd1bWVudCAoZXhwZWN0ZWQgc3RyaW5nIG9yIG51bGwpOiBcIi5jb25jYXQoa2V5KSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2VPYmo7XG59XG4vLyBoZWxwZXIgdG8gZHluYW1pY2FsbHkgYXBwZW5kIG1vZGlmaWVyIHJ1bnRpbWUgbWFya2VycyB0byBldmVudCBuYW1lcy5cbi8vIGVuc3VyZSBvbmx5IGFwcGVuZCB3aGVuIHZhbHVlIGlzIGFscmVhZHkgc3RyaW5nLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjYXN0XG4vLyB0byBzdHJpbmcgYW5kIGNhdXNlIHRoZSB0eXBlIGNoZWNrIHRvIG1pc3MuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXIodmFsdWUsIHN5bWJvbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3ltYm9sICsgdmFsdWUgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnModGFyZ2V0KSB7XG4gICAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XG4gICAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gICAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XG4gICAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcbiAgICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICAgIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XG4gICAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xuICAgIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xuICAgIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XG4gICAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICAgIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xuICAgIHRhcmdldC5fZCA9IGJpbmREeW5hbWljS2V5cztcbiAgICB0YXJnZXQuX3AgPSBwcmVwZW5kTW9kaWZpZXI7XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBjb250ZXh0KSB7XG4gICAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgdmFyIHNsb3RzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAgICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAgICAgLy8gc2FtZSBjb250ZXh0LlxuICAgICAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZm5Db250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgICAgICAgZGF0YSAmJlxuICAgICAgICAgICAgZGF0YS5zbG90ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSBkYXRhLnNsb3Q7XG4gICAgICAgICAgICB2YXIgc2xvdCA9IHNsb3RzW25hbWVfMV0gfHwgKHNsb3RzW25hbWVfMV0gPSBbXSk7XG4gICAgICAgICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaWdub3JlIHNsb3RzIHRoYXQgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlXG4gICAgZm9yICh2YXIgbmFtZV8yIGluIHNsb3RzKSB7XG4gICAgICAgIGlmIChzbG90c1tuYW1lXzJdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzbG90c1tuYW1lXzJdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbG90cztcbn1cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnO1xufVxuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIobm9kZSkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igbm90IHJlYWxseSBib29sZWFuIHR5cGVcbiAgICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3Rvcnk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKG93bmVyVm0sIHNjb3BlZFNsb3RzLCBub3JtYWxTbG90cywgcHJldlNjb3BlZFNsb3RzKSB7XG4gICAgdmFyIHJlcztcbiAgICB2YXIgaGFzTm9ybWFsU2xvdHMgPSBPYmplY3Qua2V5cyhub3JtYWxTbG90cykubGVuZ3RoID4gMDtcbiAgICB2YXIgaXNTdGFibGUgPSBzY29wZWRTbG90cyA/ICEhc2NvcGVkU2xvdHMuJHN0YWJsZSA6ICFoYXNOb3JtYWxTbG90cztcbiAgICB2YXIga2V5ID0gc2NvcGVkU2xvdHMgJiYgc2NvcGVkU2xvdHMuJGtleTtcbiAgICBpZiAoIXNjb3BlZFNsb3RzKSB7XG4gICAgICAgIHJlcyA9IHt9O1xuICAgIH1cbiAgICBlbHNlIGlmIChzY29wZWRTbG90cy5fbm9ybWFsaXplZCkge1xuICAgICAgICAvLyBmYXN0IHBhdGggMTogY2hpbGQgY29tcG9uZW50IHJlLXJlbmRlciBvbmx5LCBwYXJlbnQgZGlkIG5vdCBjaGFuZ2VcbiAgICAgICAgcmV0dXJuIHNjb3BlZFNsb3RzLl9ub3JtYWxpemVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N0YWJsZSAmJlxuICAgICAgICBwcmV2U2NvcGVkU2xvdHMgJiZcbiAgICAgICAgcHJldlNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJlxuICAgICAgICBrZXkgPT09IHByZXZTY29wZWRTbG90cy4ka2V5ICYmXG4gICAgICAgICFoYXNOb3JtYWxTbG90cyAmJlxuICAgICAgICAhcHJldlNjb3BlZFNsb3RzLiRoYXNOb3JtYWwpIHtcbiAgICAgICAgLy8gZmFzdCBwYXRoIDI6IHN0YWJsZSBzY29wZWQgc2xvdHMgdy8gbm8gbm9ybWFsIHNsb3RzIHRvIHByb3h5LFxuICAgICAgICAvLyBvbmx5IG5lZWQgdG8gbm9ybWFsaXplIG9uY2VcbiAgICAgICAgcmV0dXJuIHByZXZTY29wZWRTbG90cztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXlfMSBpbiBzY29wZWRTbG90cykge1xuICAgICAgICAgICAgaWYgKHNjb3BlZFNsb3RzW2tleV8xXSAmJiBrZXlfMVswXSAhPT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgcmVzW2tleV8xXSA9IG5vcm1hbGl6ZVNjb3BlZFNsb3Qob3duZXJWbSwgbm9ybWFsU2xvdHMsIGtleV8xLCBzY29wZWRTbG90c1trZXlfMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGV4cG9zZSBub3JtYWwgc2xvdHMgb24gc2NvcGVkU2xvdHNcbiAgICBmb3IgKHZhciBrZXlfMiBpbiBub3JtYWxTbG90cykge1xuICAgICAgICBpZiAoIShrZXlfMiBpbiByZXMpKSB7XG4gICAgICAgICAgICByZXNba2V5XzJdID0gcHJveHlOb3JtYWxTbG90KG5vcm1hbFNsb3RzLCBrZXlfMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYXZvcmlheiBzZWVtcyB0byBtb2NrIGEgbm9uLWV4dGVuc2libGUgJHNjb3BlZFNsb3RzIG9iamVjdFxuICAgIC8vIGFuZCB3aGVuIHRoYXQgaXMgcGFzc2VkIGRvd24gdGhpcyB3b3VsZCBjYXVzZSBhbiBlcnJvclxuICAgIGlmIChzY29wZWRTbG90cyAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHNjb3BlZFNsb3RzKSkge1xuICAgICAgICBzY29wZWRTbG90cy5fbm9ybWFsaXplZCA9IHJlcztcbiAgICB9XG4gICAgZGVmKHJlcywgJyRzdGFibGUnLCBpc1N0YWJsZSk7XG4gICAgZGVmKHJlcywgJyRrZXknLCBrZXkpO1xuICAgIGRlZihyZXMsICckaGFzTm9ybWFsJywgaGFzTm9ybWFsU2xvdHMpO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90KHZtLCBub3JtYWxTbG90cywga2V5LCBmbikge1xuICAgIHZhciBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VyID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2Uodm0pO1xuICAgICAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA/IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBmbih7fSk7XG4gICAgICAgIHJlcyA9XG4gICAgICAgICAgICByZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgJiYgIWlzQXJyYXkocmVzKVxuICAgICAgICAgICAgICAgID8gW3Jlc10gLy8gc2luZ2xlIHZub2RlXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVDaGlsZHJlbihyZXMpO1xuICAgICAgICB2YXIgdm5vZGUgPSByZXMgJiYgcmVzWzBdO1xuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3VyKTtcbiAgICAgICAgcmV0dXJuIHJlcyAmJlxuICAgICAgICAgICAgKCF2bm9kZSB8fFxuICAgICAgICAgICAgICAgIChyZXMubGVuZ3RoID09PSAxICYmIHZub2RlLmlzQ29tbWVudCAmJiAhaXNBc3luY1BsYWNlaG9sZGVyKHZub2RlKSkpIC8vICM5NjU4LCAjMTAzOTFcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IHJlcztcbiAgICB9O1xuICAgIC8vIHRoaXMgaXMgYSBzbG90IHVzaW5nIHRoZSBuZXcgdi1zbG90IHN5bnRheCB3aXRob3V0IHNjb3BlLiBhbHRob3VnaCBpdCBpc1xuICAgIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAgIC8vIG9uIHRoaXMuJHNsb3RzIGJlY2F1c2UgdGhlIHVzYWdlIGlzIHNlbWFudGljYWxseSBhIG5vcm1hbCBzbG90LlxuICAgIGlmIChmbi5wcm94eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9ybWFsU2xvdHMsIGtleSwge1xuICAgICAgICAgICAgZ2V0OiBub3JtYWxpemVkLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5mdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzbG90c1trZXldOyB9O1xufVxuXG5mdW5jdGlvbiBpbml0U2V0dXAodm0pIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgIHZhciBzZXR1cCA9IG9wdGlvbnMuc2V0dXA7XG4gICAgaWYgKHNldHVwKSB7XG4gICAgICAgIHZhciBjdHggPSAodm0uX3NldHVwQ29udGV4dCA9IGNyZWF0ZVNldHVwQ29udGV4dCh2bSkpO1xuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2Uodm0pO1xuICAgICAgICBwdXNoVGFyZ2V0KCk7XG4gICAgICAgIHZhciBzZXR1cFJlc3VsdCA9IGludm9rZVdpdGhFcnJvckhhbmRsaW5nKHNldHVwLCBudWxsLCBbdm0uX3Byb3BzIHx8IHNoYWxsb3dSZWFjdGl2ZSh7fSksIGN0eF0sIHZtLCBcInNldHVwXCIpO1xuICAgICAgICBwb3BUYXJnZXQoKTtcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHNldHVwUmVzdWx0KSkge1xuICAgICAgICAgICAgLy8gcmVuZGVyIGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBvcHRpb25zLnJlbmRlciA9IHNldHVwUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHNldHVwUmVzdWx0KSkge1xuICAgICAgICAgICAgLy8gYmluZGluZ3NcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNldHVwUmVzdWx0IGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgICAgICAgICAgICB3YXJuKFwic2V0dXAoKSBzaG91bGQgbm90IHJldHVybiBWTm9kZXMgZGlyZWN0bHkgLSBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwicmV0dXJuIGEgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm0uX3NldHVwU3RhdGUgPSBzZXR1cFJlc3VsdDtcbiAgICAgICAgICAgIC8vIF9fc2ZjIGluZGljYXRlcyBjb21waWxlZCBiaW5kaW5ncyBmcm9tIDxzY3JpcHQgc2V0dXA+XG4gICAgICAgICAgICBpZiAoIXNldHVwUmVzdWx0Ll9fc2ZjKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNldHVwUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm94eVdpdGhSZWZVbndyYXAodm0sIHNldHVwUmVzdWx0LCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oXCJBdm9pZCB1c2luZyB2YXJpYWJsZXMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJCBpbiBzZXR1cCgpLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGV4cG9zZWQgZm9yIGNvbXBpbGVkIHJlbmRlciBmblxuICAgICAgICAgICAgICAgIHZhciBwcm94eSA9ICh2bS5fc2V0dXBQcm94eSA9IHt9KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2V0dXBSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ19fc2ZjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlXaXRoUmVmVW53cmFwKHByb3h5LCBzZXR1cFJlc3VsdCwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNldHVwUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdhcm4oXCJzZXR1cCgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZDogXCIuY29uY2F0KHNldHVwUmVzdWx0ID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHNldHVwUmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVTZXR1cENvbnRleHQodm0pIHtcbiAgICB2YXIgZXhwb3NlQ2FsbGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICAgICAgaWYgKCF2bS5fYXR0cnNQcm94eSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm94eSA9ICh2bS5fYXR0cnNQcm94eSA9IHt9KTtcbiAgICAgICAgICAgICAgICBkZWYocHJveHksICdfdl9hdHRyX3Byb3h5JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc3luY1NldHVwUHJveHkocHJveHksIHZtLiRhdHRycywgZW1wdHlPYmplY3QsIHZtLCAnJGF0dHJzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdm0uX2F0dHJzUHJveHk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBsaXN0ZW5lcnMoKSB7XG4gICAgICAgICAgICBpZiAoIXZtLl9saXN0ZW5lcnNQcm94eSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm94eSA9ICh2bS5fbGlzdGVuZXJzUHJveHkgPSB7fSk7XG4gICAgICAgICAgICAgICAgc3luY1NldHVwUHJveHkocHJveHksIHZtLiRsaXN0ZW5lcnMsIGVtcHR5T2JqZWN0LCB2bSwgJyRsaXN0ZW5lcnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2bS5fbGlzdGVuZXJzUHJveHk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzbG90cygpIHtcbiAgICAgICAgICAgIHJldHVybiBpbml0U2xvdHNQcm94eSh2bSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVtaXQ6IGJpbmQodm0uJGVtaXQsIHZtKSxcbiAgICAgICAgZXhwb3NlOiBmdW5jdGlvbiAoZXhwb3NlZCkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwb3NlQ2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oXCJleHBvc2UoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZSBwZXIgc2V0dXAoKS5cIiwgdm0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBvc2VDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cG9zZWQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhleHBvc2VkKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5V2l0aFJlZlVud3JhcCh2bSwgZXhwb3NlZCwga2V5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBzeW5jU2V0dXBQcm94eSh0bywgZnJvbSwgcHJldiwgaW5zdGFuY2UsIHR5cGUpIHtcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgICAgIGlmICghKGtleSBpbiB0bykpIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgZGVmaW5lUHJveHlBdHRyKHRvLCBrZXksIGluc3RhbmNlLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcm9tW2tleV0gIT09IHByZXZba2V5XSkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHRvKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICBkZWxldGUgdG9ba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGRlZmluZVByb3h5QXR0cihwcm94eSwga2V5LCBpbnN0YW5jZSwgdHlwZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm94eSwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VbdHlwZV1ba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdFNsb3RzUHJveHkodm0pIHtcbiAgICBpZiAoIXZtLl9zbG90c1Byb3h5KSB7XG4gICAgICAgIHN5bmNTZXR1cFNsb3RzKCh2bS5fc2xvdHNQcm94eSA9IHt9KSwgdm0uJHNjb3BlZFNsb3RzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZtLl9zbG90c1Byb3h5O1xufVxuZnVuY3Rpb24gc3luY1NldHVwU2xvdHModG8sIGZyb20pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gdG8pIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGZyb20pKSB7XG4gICAgICAgICAgICBkZWxldGUgdG9ba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsIHVzZSBtYW51YWwgdHlwZSBkZWYgYmVjYXVzZSBwdWJsaWMgc2V0dXAgY29udGV4dCB0eXBlIHJlbGllcyBvblxuICogbGVnYWN5IFZOb2RlIHR5cGVzXG4gKi9cbmZ1bmN0aW9uIHVzZVNsb3RzKCkge1xuICAgIHJldHVybiBnZXRDb250ZXh0KCkuc2xvdHM7XG59XG4vKipcbiAqIEBpbnRlcm5hbCB1c2UgbWFudWFsIHR5cGUgZGVmIGJlY2F1c2UgcHVibGljIHNldHVwIGNvbnRleHQgdHlwZSByZWxpZXMgb25cbiAqIGxlZ2FjeSBWTm9kZSB0eXBlc1xuICovXG5mdW5jdGlvbiB1c2VBdHRycygpIHtcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLmF0dHJzO1xufVxuLyoqXG4gKiBWdWUgMiBvbmx5XG4gKiBAaW50ZXJuYWwgdXNlIG1hbnVhbCB0eXBlIGRlZiBiZWNhdXNlIHB1YmxpYyBzZXR1cCBjb250ZXh0IHR5cGUgcmVsaWVzIG9uXG4gKiBsZWdhY3kgVk5vZGUgdHlwZXNcbiAqL1xuZnVuY3Rpb24gdXNlTGlzdGVuZXJzKCkge1xuICAgIHJldHVybiBnZXRDb250ZXh0KCkubGlzdGVuZXJzO1xufVxuZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY3VycmVudEluc3RhbmNlKSB7XG4gICAgICAgIHdhcm4oXCJ1c2VDb250ZXh0KCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLlwiKTtcbiAgICB9XG4gICAgdmFyIHZtID0gY3VycmVudEluc3RhbmNlO1xuICAgIHJldHVybiB2bS5fc2V0dXBDb250ZXh0IHx8ICh2bS5fc2V0dXBDb250ZXh0ID0gY3JlYXRlU2V0dXBDb250ZXh0KHZtKSk7XG59XG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIGRlZmF1bHQgZGVjbGFyYXRpb25zLiBJbXBvcnRlZCBieSBjb21waWxlZCBjb2RlXG4gKiBvbmx5LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMocmF3LCBkZWZhdWx0cykge1xuICAgIHZhciBwcm9wcyA9IGlzQXJyYXkocmF3KVxuICAgICAgICA/IHJhdy5yZWR1Y2UoZnVuY3Rpb24gKG5vcm1hbGl6ZWQsIHApIHsgcmV0dXJuICgobm9ybWFsaXplZFtwXSA9IHt9KSwgbm9ybWFsaXplZCk7IH0sIHt9KVxuICAgICAgICA6IHJhdztcbiAgICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIG9wdCA9IHByb3BzW2tleV07XG4gICAgICAgIGlmIChvcHQpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IHsgdHlwZTogb3B0LCBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHQuZGVmYXVsdCA9IGRlZmF1bHRzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9wc1trZXldID0geyBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgd2FybihcInByb3BzIGRlZmF1bHQga2V5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgaGFzIG5vIGNvcnJlc3BvbmRpbmcgZGVjbGFyYXRpb24uXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIodm0pIHtcbiAgICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICAgIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgIHZhciBwYXJlbnRWbm9kZSA9ICh2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZSk7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gICAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gICAgdm0uJHNjb3BlZFNsb3RzID0gcGFyZW50Vm5vZGVcbiAgICAgICAgPyBub3JtYWxpemVTY29wZWRTbG90cyh2bS4kcGFyZW50LCBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLCB2bS4kc2xvdHMpXG4gICAgICAgIDogZW1wdHlPYmplY3Q7XG4gICAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gICAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gICAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCQxKHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gICAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gICAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQkMSh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG4gICAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cbiAgICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gICAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCAocGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzKSB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIChwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMpIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgICB9XG59XG52YXIgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbmZ1bmN0aW9uIHJlbmRlck1peGluKFZ1ZSkge1xuICAgIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gICAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG4gICAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKTtcbiAgICB9O1xuICAgIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdm0uJG9wdGlvbnMsIHJlbmRlciA9IF9hLnJlbmRlciwgX3BhcmVudFZub2RlID0gX2EuX3BhcmVudFZub2RlO1xuICAgICAgICBpZiAoX3BhcmVudFZub2RlICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgICAgICAgIHZtLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKHZtLiRwYXJlbnQsIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLCB2bS4kc2xvdHMsIHZtLiRzY29wZWRTbG90cyk7XG4gICAgICAgICAgICBpZiAodm0uX3Nsb3RzUHJveHkpIHtcbiAgICAgICAgICAgICAgICBzeW5jU2V0dXBTbG90cyh2bS5fc2xvdHNQcm94eSwgdm0uJHNjb3BlZFNsb3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgICAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgICAgIC8vIHJlbmRlciBzZWxmXG4gICAgICAgIHZhciBwcmV2SW5zdCA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgICAgdmFyIHByZXZSZW5kZXJJbnN0ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICAgICAgICB2YXIgdm5vZGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2Uodm0pO1xuICAgICAgICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gdm07XG4gICAgICAgICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAgICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgICAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IHByZXZSZW5kZXJJbnN0O1xuICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKHByZXZJbnN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgcmV0dXJuZWQgYXJyYXkgY29udGFpbnMgb25seSBhIHNpbmdsZSBub2RlLCBhbGxvdyBpdFxuICAgICAgICBpZiAoaXNBcnJheSh2bm9kZSkgJiYgdm5vZGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2bm9kZSA9IHZub2RlWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICAgICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgd2FybignTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJywgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHBhcmVudFxuICAgICAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgICAgIHJldHVybiB2bm9kZTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBlbnN1cmVDdG9yKGNvbXAsIGJhc2UpIHtcbiAgICBpZiAoY29tcC5fX2VzTW9kdWxlIHx8IChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJykpIHtcbiAgICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgICB9XG4gICAgcmV0dXJuIGlzT2JqZWN0KGNvbXApID8gYmFzZS5leHRlbmQoY29tcCkgOiBjb21wO1xufVxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihmYWN0b3J5LCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKSB7XG4gICAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICAgIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQoZmFjdG9yeSwgYmFzZUN0b3IpIHtcbiAgICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXA7XG4gICAgfVxuICAgIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZDtcbiAgICB9XG4gICAgdmFyIG93bmVyID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICAgIGlmIChvd25lciAmJiBpc0RlZihmYWN0b3J5Lm93bmVycykgJiYgZmFjdG9yeS5vd25lcnMuaW5kZXhPZihvd25lcikgPT09IC0xKSB7XG4gICAgICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgICAgICBmYWN0b3J5Lm93bmVycy5wdXNoKG93bmVyKTtcbiAgICB9XG4gICAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wO1xuICAgIH1cbiAgICBpZiAob3duZXIgJiYgIWlzRGVmKGZhY3Rvcnkub3duZXJzKSkge1xuICAgICAgICB2YXIgb3duZXJzXzEgPSAoZmFjdG9yeS5vd25lcnMgPSBbb3duZXJdKTtcbiAgICAgICAgdmFyIHN5bmNfMSA9IHRydWU7XG4gICAgICAgIHZhciB0aW1lckxvYWRpbmdfMSA9IG51bGw7XG4gICAgICAgIHZhciB0aW1lclRpbWVvdXRfMSA9IG51bGw7XG4gICAgICAgIG93bmVyLiRvbignaG9vazpkZXN0cm95ZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1vdmUkMihvd25lcnNfMSwgb3duZXIpOyB9KTtcbiAgICAgICAgdmFyIGZvcmNlUmVuZGVyXzEgPSBmdW5jdGlvbiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG93bmVyc18xLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIG93bmVyc18xW2ldLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgIG93bmVyc18xLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVyTG9hZGluZ18xICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lckxvYWRpbmdfMSk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyTG9hZGluZ18xID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVyVGltZW91dF8xICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lclRpbWVvdXRfMSk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyVGltZW91dF8xID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAgICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgICAgICAgIGlmICghc3luY18xKSB7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXJfMSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG93bmVyc18xLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcmVqZWN0XzEgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB3YXJuKFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIi5jb25jYXQoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgICAgICAgICAgICAgIChyZWFzb24gPyBcIlxcblJlYXNvbjogXCIuY29uY2F0KHJlYXNvbikgOiAnJykpO1xuICAgICAgICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyXzEodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcmVzXzEgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdF8xKTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHJlc18xKSkge1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShyZXNfMSkpIHtcbiAgICAgICAgICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzXzEudGhlbihyZXNvbHZlLCByZWplY3RfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNQcm9taXNlKHJlc18xLmNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICByZXNfMS5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3RfMSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKHJlc18xLmVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzXzEuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKHJlc18xLmxvYWRpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlc18xLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc18xLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOb2RlSlMgdGltZW91dCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lckxvYWRpbmdfMSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyTG9hZGluZ18xID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyXzEoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlc18xLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKHJlc18xLnRpbWVvdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTm9kZUpTIHRpbWVvdXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICB0aW1lclRpbWVvdXRfMSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJUaW1lb3V0XzEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RfMShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gXCJ0aW1lb3V0IChcIi5jb25jYXQocmVzXzEudGltZW91dCwgXCJtcylcIikgOiBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgcmVzXzEudGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN5bmNfMSA9IGZhbHNlO1xuICAgICAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmcgPyBmYWN0b3J5LmxvYWRpbmdDb21wIDogZmFjdG9yeS5yZXNvbHZlZDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY2hpbGRyZW4pIHtcbiAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMShjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplKSB7XG4gICAgaWYgKGlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICAgICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICAgICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICAgICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpIHtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5fX29iX18pKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgIHdhcm4oXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkoZGF0YSksIFwiXFxuXCIpICsgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgICAgICB0YWcgPSBkYXRhLmlzO1xuICAgIH1cbiAgICBpZiAoIXRhZykge1xuICAgICAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpKSB7XG4gICAgICAgIHdhcm4oJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pICYmIGlzRnVuY3Rpb24oY2hpbGRyZW5bMF0pKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgICAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIH1cbiAgICB2YXIgdm5vZGUsIG5zO1xuICAgIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgQ3RvciA9IHZvaWQgMDtcbiAgICAgICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgICAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIGlzRGVmKGRhdGEpICYmXG4gICAgICAgICAgICAgICAgaXNEZWYoZGF0YS5uYXRpdmVPbikgJiZcbiAgICAgICAgICAgICAgICBkYXRhLnRhZyAhPT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICAgICAgICB3YXJuKFwiVGhlIC5uYXRpdmUgbW9kaWZpZXIgZm9yIHYtb24gaXMgb25seSB2YWxpZCBvbiBjb21wb25lbnRzIGJ1dCBpdCB3YXMgdXNlZCBvbiA8XCIuY29uY2F0KHRhZywgXCI+LlwiKSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2bm9kZSA9IG5ldyBWTm9kZShjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJlxuICAgICAgICAgICAgaXNEZWYoKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkpIHtcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgICAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAgICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgICAgICAgdm5vZGUgPSBuZXcgVk5vZGUodGFnLCBkYXRhLCBjaGlsZHJlbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHJldHVybiB2bm9kZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgICAgIGlmIChpc0RlZihucykpXG4gICAgICAgICAgICBhcHBseU5TKHZub2RlLCBucyk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSlcbiAgICAgICAgICAgIHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpO1xuICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5TlModm5vZGUsIG5zLCBmb3JjZSkge1xuICAgIHZub2RlLm5zID0gbnM7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgICAgICBucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmXG4gICAgICAgICAgICAgICAgKGlzVW5kZWYoY2hpbGQubnMpIHx8IChpc1RydWUoZm9yY2UpICYmIGNoaWxkLnRhZyAhPT0gJ3N2ZycpKSkge1xuICAgICAgICAgICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyByZWYgIzUzMThcbi8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4vLyA6Y2xhc3MgYXJlIHVzZWQgb24gc2xvdCBub2Rlc1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSkge1xuICAgIGlmIChpc09iamVjdChkYXRhLnN0eWxlKSkge1xuICAgICAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgICAgIHRyYXZlcnNlKGRhdGEuY2xhc3MpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWwgdGhpcyBmdW5jdGlvbiBuZWVkcyBtYW51YWwgcHVibGljIHR5cGUgZGVjbGFyYXRpb24gYmVjYXVzZSBpdCByZWxpZXNcbiAqIG9uIHByZXZpb3VzbHkgbWFudWFsbHkgYXV0aG9yZWQgdHlwZXMgZnJvbSBWdWUgMlxuICovXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIGlmICghY3VycmVudEluc3RhbmNlKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgIHdhcm4oXCJnbG9iYWxseSBpbXBvcnRlZCBoKCkgY2FuIG9ubHkgYmUgaW52b2tlZCB3aGVuIHRoZXJlIGlzIGFuIGFjdGl2ZSBcIiArXG4gICAgICAgICAgICAgICAgXCJjb21wb25lbnQgaW5zdGFuY2UsIGUuZy4gc3luY2hyb25vdXNseSBpbiBhIGNvbXBvbmVudCdzIHJlbmRlciBvciBzZXR1cCBmdW5jdGlvbi5cIik7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50JDEoY3VycmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcywgY2hpbGRyZW4sIDIsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKSB7XG4gICAgLy8gRGVhY3RpdmF0ZSBkZXBzIHRyYWNraW5nIHdoaWxlIHByb2Nlc3NpbmcgZXJyb3IgaGFuZGxlciB0byBhdm9pZCBwb3NzaWJsZSBpbmZpbml0ZSByZW5kZXJpbmcuXG4gICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVleC9pc3N1ZXMvMTUwNVxuICAgIHB1c2hUYXJnZXQoKTtcbiAgICB0cnkge1xuICAgICAgICBpZiAodm0pIHtcbiAgICAgICAgICAgIHZhciBjdXIgPSB2bTtcbiAgICAgICAgICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlciwgY29udGV4dCwgYXJncywgdm0sIGluZm8pIHtcbiAgICB2YXIgcmVzO1xuICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IGFyZ3MgPyBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpIDogaGFuZGxlci5jYWxsKGNvbnRleHQpO1xuICAgICAgICBpZiAocmVzICYmICFyZXMuX2lzVnVlICYmIGlzUHJvbWlzZShyZXMpICYmICFyZXMuX2hhbmRsZWQpIHtcbiAgICAgICAgICAgIHJlcy5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBcIiAoUHJvbWlzZS9hc3luYylcIik7IH0pO1xuICAgICAgICAgICAgcmVzLl9oYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgaW5mbyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKSB7XG4gICAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcbiAgICAgICAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcbiAgICAgICAgICAgIGlmIChlICE9PSBlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dFcnJvcihlLCBudWxsLCAnY29uZmlnLmVycm9ySGFuZGxlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xufVxuZnVuY3Rpb24gbG9nRXJyb3IoZXJyLCB2bSwgaW5mbykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXCJFcnJvciBpbiBcIi5jb25jYXQoaW5mbywgXCI6IFxcXCJcIikuY29uY2F0KGVyci50b1N0cmluZygpLCBcIlxcXCJcIiksIHZtKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufVxuXG4vKiBnbG9iYWxzIE11dGF0aW9uT2JzZXJ2ZXIgKi9cbnZhciBpc1VzaW5nTWljcm9UYXNrID0gZmFsc2U7XG52YXIgY2FsbGJhY2tzID0gW107XG52YXIgcGVuZGluZyA9IGZhbHNlO1xuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29waWVzW2ldKCk7XG4gICAgfVxufVxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBtaWNyb3Rhc2tzLlxuLy8gSW4gMi41IHdlIHVzZWQgKG1hY3JvKSB0YXNrcyAoaW4gY29tYmluYXRpb24gd2l0aCBtaWNyb3Rhc2tzKS5cbi8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XG4vLyAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEFsc28sIHVzaW5nIChtYWNybykgdGFza3MgaW4gZXZlbnQgaGFuZGxlciB3b3VsZCBjYXVzZSBzb21lIHdlaXJkIGJlaGF2aW9yc1xuLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXG4vLyBTbyB3ZSBub3cgdXNlIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYWdhaW4uXG4vLyBBIG1ham9yIGRyYXdiYWNrIG9mIHRoaXMgdHJhZGVvZmYgaXMgdGhhdCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Ncbi8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwLCB3aGljaCBoYXZlIHdvcmthcm91bmRzKVxuLy8gb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lIGV2ZW50ICgjNjU2NikuXG52YXIgdGltZXJGdW5jO1xuLy8gVGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbi8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4vLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICAgIHZhciBwXzEgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBfMS50aGVuKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICAgICAgLy8gSW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgICAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgICAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAgICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgICAgIGlmIChpc0lPUylcbiAgICAgICAgICAgIHNldFRpbWVvdXQobm9vcCk7XG4gICAgfTtcbiAgICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbn1cbmVsc2UgaWYgKCFpc0lFICYmXG4gICAgdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgKGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gICAgICAgIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICAgICAgICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nKSkge1xuICAgIC8vIFVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gICAgLy8gZS5nLiBQaGFudG9tSlMsIGlPUzcsIEFuZHJvaWQgNC40XG4gICAgLy8gKCM2NDY2IE11dGF0aW9uT2JzZXJ2ZXIgaXMgdW5yZWxpYWJsZSBpbiBJRTExKVxuICAgIHZhciBjb3VudGVyXzEgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICB2YXIgdGV4dE5vZGVfMSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyXzEpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlXzEsIHtcbiAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY291bnRlcl8xID0gKGNvdW50ZXJfMSArIDEpICUgMjtcbiAgICAgICAgdGV4dE5vZGVfMS5kYXRhID0gU3RyaW5nKGNvdW50ZXJfMSk7XG4gICAgfTtcbiAgICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbn1cbmVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgICAvLyBGYWxsYmFjayB0byBzZXRJbW1lZGlhdGUuXG4gICAgLy8gVGVjaG5pY2FsbHkgaXQgbGV2ZXJhZ2VzIHRoZSAobWFjcm8pIHRhc2sgcXVldWUsXG4gICAgLy8gYnV0IGl0IGlzIHN0aWxsIGEgYmV0dGVyIGNob2ljZSB0aGFuIHNldFRpbWVvdXQuXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRJbW1lZGlhdGUoZmx1c2hDYWxsYmFja3MpO1xuICAgIH07XG59XG5lbHNlIHtcbiAgICAvLyBGYWxsYmFjayB0byBzZXRUaW1lb3V0LlxuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gICAgfTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG5leHRUaWNrKGNiLCBjdHgpIHtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9yZXNvbHZlKSB7XG4gICAgICAgICAgICBfcmVzb2x2ZShjdHgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdXNlQ3NzTW9kdWxlKG5hbWUpIHtcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSAnJHN0eWxlJzsgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAge1xuICAgICAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFwidXNlQ3NzTW9kdWxlIG11c3QgYmUgY2FsbGVkIGluc2lkZSBzZXR1cCgpXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBtb2QgPSBjdXJyZW50SW5zdGFuY2VbbmFtZV07XG4gICAgICAgIGlmICghbW9kKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgd2FybihcIkN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlIG5hbWVkIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiLlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZDtcbiAgICB9XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIFNGQydzIENTUyB2YXJpYWJsZSBpbmplY3Rpb24gZmVhdHVyZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVzZUNzc1ZhcnMoZ2V0dGVyKSB7XG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgIWZhbHNlKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgd2FybihcInVzZUNzc1ZhcnMgaXMgY2FsbGVkIHdpdGhvdXQgY3VycmVudCBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YXRjaFBvc3RFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWwgPSBpbnN0YW5jZS4kZWw7XG4gICAgICAgIHZhciB2YXJzID0gZ2V0dGVyKGluc3RhbmNlLCBpbnN0YW5jZS5fc2V0dXBQcm94eSk7XG4gICAgICAgIGlmIChlbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gZWwuc3R5bGU7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFycykge1xuICAgICAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KFwiLS1cIi5jb25jYXQoa2V5KSwgdmFyc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIHYzLWNvbXBhdGlibGUgYXN5bmMgY29tcG9uZW50IEFQSS5cbiAqIEBpbnRlcm5hbCB0aGUgdHlwZSBpcyBtYW51YWxseSBkZWNsYXJlZCBpbiA8cm9vdD4vdHlwZXMvdjMtZGVmaW5lLWFzeW5jLWNvbXBvbmVudC5kLnRzXG4gKiBiZWNhdXNlIGl0IHJlbGllcyBvbiBleGlzdGluZyBtYW51YWwgdHlwZXNcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQXN5bmNDb21wb25lbnQoc291cmNlKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgICAgICBzb3VyY2UgPSB7IGxvYWRlcjogc291cmNlIH07XG4gICAgfVxuICAgIHZhciBsb2FkZXIgPSBzb3VyY2UubG9hZGVyLCBsb2FkaW5nQ29tcG9uZW50ID0gc291cmNlLmxvYWRpbmdDb21wb25lbnQsIGVycm9yQ29tcG9uZW50ID0gc291cmNlLmVycm9yQ29tcG9uZW50LCBfYSA9IHNvdXJjZS5kZWxheSwgZGVsYXkgPSBfYSA9PT0gdm9pZCAwID8gMjAwIDogX2EsIHRpbWVvdXQgPSBzb3VyY2UudGltZW91dCwgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XG4gICAgX2IgPSBzb3VyY2Uuc3VzcGVuc2libGUsIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxuICAgIHN1c3BlbnNpYmxlID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2IsIC8vIGluIFZ1ZSAzIGRlZmF1bHQgaXMgdHJ1ZVxuICAgIHVzZXJPbkVycm9yID0gc291cmNlLm9uRXJyb3I7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3VzcGVuc2libGUpIHtcbiAgICAgICAgd2FybihcIlRoZSBzdXNwZW5zaWJsZSBvcHRpb24gZm9yIGFzeW5jIGNvbXBvbmVudHMgaXMgbm90IHN1cHBvcnRlZCBpbiBWdWUyLiBJdCBpcyBpZ25vcmVkLlwiKTtcbiAgICB9XG4gICAgdmFyIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICB2YXIgcmV0cmllcyA9IDA7XG4gICAgdmFyIHJldHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXRyaWVzKys7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGxvYWQoKTtcbiAgICB9O1xuICAgIHZhciBsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhpc1JlcXVlc3Q7XG4gICAgICAgIHJldHVybiAocGVuZGluZ1JlcXVlc3QgfHxcbiAgICAgICAgICAgICh0aGlzUmVxdWVzdCA9IHBlbmRpbmdSZXF1ZXN0ID1cbiAgICAgICAgICAgICAgICBsb2FkZXIoKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyT25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXNlclJldHJ5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZShyZXRyeSgpKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXNlckZhaWwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZWplY3QoZXJyKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyT25FcnJvcihlcnIsIHVzZXJSZXRyeSwgdXNlckZhaWwsIHJldHJpZXMgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNSZXF1ZXN0ICE9PSBwZW5kaW5nUmVxdWVzdCAmJiBwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb21wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKFwiQXN5bmMgY29tcG9uZW50IGxvYWRlciByZXNvbHZlZCB0byB1bmRlZmluZWQuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgcmV0cnkoKSwgbWFrZSBzdXJlIHRvIHJldHVybiBpdHMgcmV0dXJuIHZhbHVlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcm9wIG1vZHVsZSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29tcC5fX2VzTW9kdWxlIHx8IGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbXAgJiYgIWlzT2JqZWN0KGNvbXApICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFzeW5jIGNvbXBvbmVudCBsb2FkIHJlc3VsdDogXCIuY29uY2F0KGNvbXApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcDtcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IGxvYWQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgICAgICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgICAgICAgdGltZW91dDogdGltZW91dCxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgIGxvYWRpbmc6IGxvYWRpbmdDb21wb25lbnRcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaWZlQ3ljbGUoaG9va05hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZuLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7IHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZTsgfVxuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHdhcm4oXCJcIi5jb25jYXQoZm9ybWF0TmFtZShob29rTmFtZSksIFwiIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCJhc3NvY2lhdGVkIHdpdGguIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJMaWZlY3ljbGUgaW5qZWN0aW9uIEFQSXMgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHNldHVwKCkuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmplY3RIb29rKHRhcmdldCwgaG9va05hbWUsIGZuKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZm9ybWF0TmFtZShuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09ICdiZWZvcmVEZXN0cm95Jykge1xuICAgICAgICBuYW1lID0gJ2JlZm9yZVVubW91bnQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAnZGVzdHJveWVkJykge1xuICAgICAgICBuYW1lID0gJ3VubW91bnRlZCc7XG4gICAgfVxuICAgIHJldHVybiBcIm9uXCIuY29uY2F0KG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkpO1xufVxuZnVuY3Rpb24gaW5qZWN0SG9vayhpbnN0YW5jZSwgaG9va05hbWUsIGZuKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBpbnN0YW5jZS4kb3B0aW9ucztcbiAgICBvcHRpb25zW2hvb2tOYW1lXSA9IG1lcmdlTGlmZWN5Y2xlSG9vayhvcHRpb25zW2hvb2tOYW1lXSwgZm4pO1xufVxudmFyIG9uQmVmb3JlTW91bnQgPSBjcmVhdGVMaWZlQ3ljbGUoJ2JlZm9yZU1vdW50Jyk7XG52YXIgb25Nb3VudGVkID0gY3JlYXRlTGlmZUN5Y2xlKCdtb3VudGVkJyk7XG52YXIgb25CZWZvcmVVcGRhdGUgPSBjcmVhdGVMaWZlQ3ljbGUoJ2JlZm9yZVVwZGF0ZScpO1xudmFyIG9uVXBkYXRlZCA9IGNyZWF0ZUxpZmVDeWNsZSgndXBkYXRlZCcpO1xudmFyIG9uQmVmb3JlVW5tb3VudCA9IGNyZWF0ZUxpZmVDeWNsZSgnYmVmb3JlRGVzdHJveScpO1xudmFyIG9uVW5tb3VudGVkID0gY3JlYXRlTGlmZUN5Y2xlKCdkZXN0cm95ZWQnKTtcbnZhciBvbkFjdGl2YXRlZCA9IGNyZWF0ZUxpZmVDeWNsZSgnYWN0aXZhdGVkJyk7XG52YXIgb25EZWFjdGl2YXRlZCA9IGNyZWF0ZUxpZmVDeWNsZSgnZGVhY3RpdmF0ZWQnKTtcbnZhciBvblNlcnZlclByZWZldGNoID0gY3JlYXRlTGlmZUN5Y2xlKCdzZXJ2ZXJQcmVmZXRjaCcpO1xudmFyIG9uUmVuZGVyVHJhY2tlZCA9IGNyZWF0ZUxpZmVDeWNsZSgncmVuZGVyVHJhY2tlZCcpO1xudmFyIG9uUmVuZGVyVHJpZ2dlcmVkID0gY3JlYXRlTGlmZUN5Y2xlKCdyZW5kZXJUcmlnZ2VyZWQnKTtcbnZhciBpbmplY3RFcnJvckNhcHR1cmVkSG9vayA9IGNyZWF0ZUxpZmVDeWNsZSgnZXJyb3JDYXB0dXJlZCcpO1xuZnVuY3Rpb24gb25FcnJvckNhcHR1cmVkKGhvb2ssIHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgeyB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2U7IH1cbiAgICBpbmplY3RFcnJvckNhcHR1cmVkSG9vayhob29rLCB0YXJnZXQpO1xufVxuXG4vKipcbiAqIE5vdGU6IGFsc28gdXBkYXRlIGRpc3QvdnVlLnJ1bnRpbWUubWpzIHdoZW4gYWRkaW5nIG5ldyBleHBvcnRzIHRvIHRoaXMgZmlsZS5cbiAqL1xudmFyIHZlcnNpb24gPSAnMi43LjE2Jztcbi8qKlxuICogQGludGVybmFsIHR5cGUgaXMgbWFudWFsbHkgZGVjbGFyZWQgaW4gPHJvb3Q+L3R5cGVzL3YzLWRlZmluZS1jb21wb25lbnQuZC50c1xuICovXG5mdW5jdGlvbiBkZWZpbmVDb21wb25lbnQob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zO1xufVxuXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlKHZhbCkge1xuICAgIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbiAgICBzZWVuT2JqZWN0cy5jbGVhcigpO1xuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBfdHJhdmVyc2UodmFsLCBzZWVuKSB7XG4gICAgdmFyIGksIGtleXM7XG4gICAgdmFyIGlzQSA9IGlzQXJyYXkodmFsKTtcbiAgICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8XG4gICAgICAgIHZhbC5fX3Zfc2tpcCAvKiBSZWFjdGl2ZUZsYWdzLlNLSVAgKi8gfHxcbiAgICAgICAgT2JqZWN0LmlzRnJvemVuKHZhbCkgfHxcbiAgICAgICAgdmFsIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsLl9fb2JfXykge1xuICAgICAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICAgICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgICB9XG4gICAgaWYgKGlzQSkge1xuICAgICAgICBpID0gdmFsLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgIF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1JlZih2YWwpKSB7XG4gICAgICAgIF90cmF2ZXJzZSh2YWwudmFsdWUsIHNlZW4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgIF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pO1xuICAgIH1cbn1cblxudmFyIHVpZCQxID0gMDtcbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFdhdGNoZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMsIGlzUmVuZGVyV2F0Y2hlcikge1xuICAgICAgICByZWNvcmRFZmZlY3RTY29wZSh0aGlzLCBcbiAgICAgICAgLy8gaWYgdGhlIGFjdGl2ZSBlZmZlY3Qgc2NvcGUgaXMgbWFudWFsbHkgY3JlYXRlZCAobm90IGEgY29tcG9uZW50IHNjb3BlKSxcbiAgICAgICAgLy8gcHJpb3JpdGl6ZSBpdFxuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSAmJiAhYWN0aXZlRWZmZWN0U2NvcGUuX3ZtXG4gICAgICAgICAgICA/IGFjdGl2ZUVmZmVjdFNjb3BlXG4gICAgICAgICAgICA6IHZtXG4gICAgICAgICAgICAgICAgPyB2bS5fc2NvcGVcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICgodGhpcy52bSA9IHZtKSAmJiBpc1JlbmRlcldhdGNoZXIpIHtcbiAgICAgICAgICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpb25zXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICAgICAgICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgICAgICAgICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgICAgICAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgICAgICAgICAgIHRoaXMuYmVmb3JlID0gb3B0aW9ucy5iZWZvcmU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMub25UcmFjayA9IG9wdGlvbnMub25UcmFjaztcbiAgICAgICAgICAgICAgICB0aGlzLm9uVHJpZ2dlciA9IG9wdGlvbnMub25UcmlnZ2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYiA9IGNiO1xuICAgICAgICB0aGlzLmlkID0gKyt1aWQkMTsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMucG9zdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICAgICAgICB0aGlzLmRlcHMgPSBbXTtcbiAgICAgICAgdGhpcy5uZXdEZXBzID0gW107XG4gICAgICAgIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgICAgICAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gZXhwT3JGbi50b1N0cmluZygpIDogJyc7XG4gICAgICAgIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihleHBPckZuKSkge1xuICAgICAgICAgICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgd2FybihcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIuY29uY2F0KGV4cE9yRm4sIFwiXFxcIiBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5ID8gdW5kZWZpbmVkIDogdGhpcy5nZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICAgICAqL1xuICAgIFdhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcHVzaFRhcmdldCh0aGlzKTtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICB2YXIgdm0gPSB0aGlzLnZtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiLmNvbmNhdCh0aGlzLmV4cHJlc3Npb24sIFwiXFxcIlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgICAgICAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3BUYXJnZXQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICAgICAqL1xuICAgIFdhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgdmFyIGlkID0gZGVwLmlkO1xuICAgICAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgICAgICAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgICBXYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICB2YXIgZGVwID0gdGhpcy5kZXBzW2ldO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgICAgICAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICAgICAgICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICAgICAgICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgICAgICAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgICAgICAgdG1wID0gdGhpcy5kZXBzO1xuICAgICAgICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gICAgICAgIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgICAgICAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAgICAgKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIFdhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHRoaXMubGF6eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAgICAgKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICAgICAqL1xuICAgIFdhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAgICAgICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgICAgICAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgICAgICAgICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmRlZXApIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiLmNvbmNhdCh0aGlzLmV4cHJlc3Npb24sIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcodGhpcy5jYiwgdGhpcy52bSwgW3ZhbHVlLCBvbGRWYWx1ZV0sIHRoaXMudm0sIGluZm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gICAgICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICAgICAqL1xuICAgIFdhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gICAgICovXG4gICAgV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gICAgICovXG4gICAgV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnZtICYmICF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZW1vdmUkMih0aGlzLnZtLl9zY29wZS5lZmZlY3RzLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uU3RvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25TdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBXYXRjaGVyO1xufSgpKTtcblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIHBlcmZfMSA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHBlcmZfMSAmJlxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHBlcmZfMS5tYXJrICYmXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcGVyZl8xLm1lYXN1cmUgJiZcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBwZXJmXzEuY2xlYXJNYXJrcyAmJlxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHBlcmZfMS5jbGVhck1lYXN1cmVzKSB7XG4gICAgICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmXzEubWFyayh0YWcpOyB9O1xuICAgICAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgICAgICAgIHBlcmZfMS5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgICAgICAgcGVyZl8xLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgICAgICAgcGVyZl8xLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgICAgICAgIC8vIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyh2bSkge1xuICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgICB9XG59XG52YXIgdGFyZ2V0JDE7XG5mdW5jdGlvbiBhZGQkMShldmVudCwgZm4pIHtcbiAgICB0YXJnZXQkMS4kb24oZXZlbnQsIGZuKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZSQxKGV2ZW50LCBmbikge1xuICAgIHRhcmdldCQxLiRvZmYoZXZlbnQsIGZuKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyJDEoZXZlbnQsIGZuKSB7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTtcbiAgICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIoKSB7XG4gICAgICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfdGFyZ2V0LiRvZmYoZXZlbnQsIG9uY2VIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKSB7XG4gICAgdGFyZ2V0JDEgPSB2bTtcbiAgICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCQxLCByZW1vdmUkMSwgY3JlYXRlT25jZUhhbmRsZXIkMSwgdm0pO1xuICAgIHRhcmdldCQxID0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZXZlbnRzTWl4aW4oVnVlKSB7XG4gICAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICAgIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgICBpZiAoaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdm0uJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgICAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgICAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm07XG4gICAgfTtcbiAgICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgICBmdW5jdGlvbiBvbigpIHtcbiAgICAgICAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgICAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIG9uLmZuID0gZm47XG4gICAgICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgICAgICByZXR1cm4gdm07XG4gICAgfTtcbiAgICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICAgIC8vIGFsbFxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHZtO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgICAgICBpZiAoaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGlfMSA8IGw7IGlfMSsrKSB7XG4gICAgICAgICAgICAgICAgdm0uJG9mZihldmVudFtpXzFdLCBmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdm07XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICAgICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgICAgICBpZiAoIWNicykge1xuICAgICAgICAgICAgcmV0dXJuIHZtO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm4pIHtcbiAgICAgICAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB2bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgICAgIHZhciBjYjtcbiAgICAgICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjYiA9IGNic1tpXTtcbiAgICAgICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm07XG4gICAgfTtcbiAgICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICAgICAgICAgIHRpcChcIkV2ZW50IFxcXCJcIi5jb25jYXQobG93ZXJDYXNlRXZlbnQsIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIikgK1xuICAgICAgICAgICAgICAgICAgICBcIlwiLmNvbmNhdChmb3JtYXRDb21wb25lbnROYW1lKHZtKSwgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIikuY29uY2F0KGV2ZW50LCBcIlxcXCIuIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiLmNvbmNhdChoeXBoZW5hdGUoZXZlbnQpLCBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIpLmNvbmNhdChldmVudCwgXCJcXFwiLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgICAgICBpZiAoY2JzKSB7XG4gICAgICAgICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgICAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgdmFyIGluZm8gPSBcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIi5jb25jYXQoZXZlbnQsIFwiXFxcIlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNic1tpXSwgdm0sIGFyZ3MsIHZtLCBpbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm07XG4gICAgfTtcbn1cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbmZ1bmN0aW9uIHNldEFjdGl2ZUluc3RhbmNlKHZtKSB7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUodm0pIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgICB9XG4gICAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuICAgIHZtLiRjaGlsZHJlbiA9IFtdO1xuICAgIHZtLiRyZWZzID0ge307XG4gICAgdm0uX3Byb3ZpZGVkID0gcGFyZW50ID8gcGFyZW50Ll9wcm92aWRlZCA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICAgIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbihWdWUpIHtcbiAgICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgICAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2Uodm0pO1xuICAgICAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAgICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgICAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgICAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyh2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdXBkYXRlc1xuICAgICAgICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgICAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICAgICAgaWYgKHByZXZFbCkge1xuICAgICAgICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bS4kZWwpIHtcbiAgICAgICAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgICAgICB2YXIgd3JhcHBlciA9IHZtO1xuICAgICAgICB3aGlsZSAod3JhcHBlciAmJlxuICAgICAgICAgICAgd3JhcHBlci4kdm5vZGUgJiZcbiAgICAgICAgICAgIHdyYXBwZXIuJHBhcmVudCAmJlxuICAgICAgICAgICAgd3JhcHBlci4kdm5vZGUgPT09IHdyYXBwZXIuJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgICAgICAgIHdyYXBwZXIuJHBhcmVudC4kZWwgPSB3cmFwcGVyLiRlbDtcbiAgICAgICAgICAgIHdyYXBwZXIgPSB3cmFwcGVyLiRwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgICAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICAgIH07XG4gICAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxIb29rJDEodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICAgICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgICAgICAgIHJlbW92ZSQyKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZWFyZG93biBzY29wZS4gdGhpcyBpbmNsdWRlcyBib3RoIHRoZSByZW5kZXIgd2F0Y2hlciBhbmQgb3RoZXJcbiAgICAgICAgLy8gd2F0Y2hlcnMgY3JlYXRlZFxuICAgICAgICB2bS5fc2NvcGUuc3RvcCgpO1xuICAgICAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgICAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICAgICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICAgICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgICAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgICAgIGNhbGxIb29rJDEodm0sICdkZXN0cm95ZWQnKTtcbiAgICAgICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICAgICAgdm0uJG9mZigpO1xuICAgICAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICAgICAgaWYgKHZtLiRlbCkge1xuICAgICAgICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcbiAgICAgICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQodm0sIGVsLCBoeWRyYXRpbmcpIHtcbiAgICB2bS4kZWwgPSBlbDtcbiAgICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGludmFsaWQgdHlwZVxuICAgICAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICAgICAgICAgIHZtLiRvcHRpb25zLmVsIHx8XG4gICAgICAgICAgICAgICAgZWwpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdhcm4oJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsbEhvb2skMSh2bSwgJ2JlZm9yZU1vdW50Jyk7XG4gICAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgICAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIuY29uY2F0KGlkKTtcbiAgICAgICAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIi5jb25jYXQoaWQpO1xuICAgICAgICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICAgICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICAgICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICAgICAgICBtZWFzdXJlKFwidnVlIFwiLmNvbmNhdChuYW1lLCBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICAgICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgICAgICAgbWVhc3VyZShcInZ1ZSBcIi5jb25jYXQobmFtZSwgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciB3YXRjaGVyT3B0aW9ucyA9IHtcbiAgICAgICAgYmVmb3JlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXRjaGVyT3B0aW9ucy5vblRyYWNrID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGNhbGxIb29rJDEodm0sICdyZW5kZXJUcmFja2VkJywgW2VdKTsgfTtcbiAgICAgICAgd2F0Y2hlck9wdGlvbnMub25UcmlnZ2VyID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGNhbGxIb29rJDEodm0sICdyZW5kZXJUcmlnZ2VyZWQnLCBbZV0pOyB9O1xuICAgIH1cbiAgICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxuICAgIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gICAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICAgIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIHdhdGNoZXJPcHRpb25zLCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gICAgaHlkcmF0aW5nID0gZmFsc2U7XG4gICAgLy8gZmx1c2ggYnVmZmVyIGZvciBmbHVzaDogXCJwcmVcIiB3YXRjaGVycyBxdWV1ZWQgaW4gc2V0dXAoKVxuICAgIHZhciBwcmVXYXRjaGVycyA9IHZtLl9wcmVXYXRjaGVycztcbiAgICBpZiAocHJlV2F0Y2hlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVXYXRjaGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcHJlV2F0Y2hlcnNbaV0ucnVuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICAgIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgICAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZtO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQodm0sIHByb3BzRGF0YSwgbGlzdGVuZXJzLCBwYXJlbnRWbm9kZSwgcmVuZGVyQ2hpbGRyZW4pIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbi5cbiAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgZHluYW1pYyBzY29wZWRTbG90cyAoaGFuZC13cml0dGVuIG9yIGNvbXBpbGVkIGJ1dCB3aXRoXG4gICAgLy8gZHluYW1pYyBzbG90IG5hbWVzKS4gU3RhdGljIHNjb3BlZCBzbG90cyBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGhhcyB0aGVcbiAgICAvLyBcIiRzdGFibGVcIiBtYXJrZXIuXG4gICAgdmFyIG5ld1Njb3BlZFNsb3RzID0gcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cztcbiAgICB2YXIgb2xkU2NvcGVkU2xvdHMgPSB2bS4kc2NvcGVkU2xvdHM7XG4gICAgdmFyIGhhc0R5bmFtaWNTY29wZWRTbG90ID0gISEoKG5ld1Njb3BlZFNsb3RzICYmICFuZXdTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgICAgICAob2xkU2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmICFvbGRTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgICAgICAobmV3U2NvcGVkU2xvdHMgJiYgdm0uJHNjb3BlZFNsb3RzLiRrZXkgIT09IG5ld1Njb3BlZFNsb3RzLiRrZXkpIHx8XG4gICAgICAgICghbmV3U2NvcGVkU2xvdHMgJiYgdm0uJHNjb3BlZFNsb3RzLiRrZXkpKTtcbiAgICAvLyBBbnkgc3RhdGljIHNsb3QgY2hpbGRyZW4gZnJvbSB0aGUgcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgZHVyaW5nIHBhcmVudCdzXG4gICAgLy8gdXBkYXRlLiBEeW5hbWljIHNjb3BlZCBzbG90cyBtYXkgYWxzbyBoYXZlIGNoYW5nZWQuIEluIHN1Y2ggY2FzZXMsIGEgZm9yY2VkXG4gICAgLy8gdXBkYXRlIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgY29ycmVjdG5lc3MuXG4gICAgdmFyIG5lZWRzRm9yY2VVcGRhdGUgPSAhIShyZW5kZXJDaGlsZHJlbiB8fCAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgICAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICAgICAgaGFzRHluYW1pY1Njb3BlZFNsb3QpO1xuICAgIHZhciBwcmV2Vk5vZGUgPSB2bS4kdm5vZGU7XG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gICAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcbiAgICBpZiAodm0uX3Zub2RlKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgICB9XG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG4gICAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gICAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gICAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgICB2YXIgYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICAgIGlmICh2bS5fYXR0cnNQcm94eSkge1xuICAgICAgICAvLyBmb3JjZSB1cGRhdGUgaWYgYXR0cnMgYXJlIGFjY2Vzc2VkIGFuZCBoYXMgY2hhbmdlZCBzaW5jZSBpdCBtYXkgYmVcbiAgICAgICAgLy8gcGFzc2VkIHRvIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAgICBpZiAoc3luY1NldHVwUHJveHkodm0uX2F0dHJzUHJveHksIGF0dHJzLCAocHJldlZOb2RlLmRhdGEgJiYgcHJldlZOb2RlLmRhdGEuYXR0cnMpIHx8IGVtcHR5T2JqZWN0LCB2bSwgJyRhdHRycycpKSB7XG4gICAgICAgICAgICBuZWVkc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2bS4kYXR0cnMgPSBhdHRycztcbiAgICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAgIHZhciBwcmV2TGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICBpZiAodm0uX2xpc3RlbmVyc1Byb3h5KSB7XG4gICAgICAgIHN5bmNTZXR1cFByb3h5KHZtLl9saXN0ZW5lcnNQcm94eSwgbGlzdGVuZXJzLCBwcmV2TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCB2bSwgJyRsaXN0ZW5lcnMnKTtcbiAgICB9XG4gICAgdm0uJGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIHByZXZMaXN0ZW5lcnMpO1xuICAgIC8vIHVwZGF0ZSBwcm9wc1xuICAgIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICAgICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgICAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgICAgICAgIHZhciBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgICAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgICB9XG4gICAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgICBpZiAobmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgICAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgICAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSh2bSkge1xuICAgIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgICAgICBpZiAodm0uX2luYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0sIGRpcmVjdCkge1xuICAgIGlmIChkaXJlY3QpIHtcbiAgICAgICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxIb29rJDEodm0sICdhY3RpdmF0ZWQnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0sIGRpcmVjdCkge1xuICAgIGlmIChkaXJlY3QpIHtcbiAgICAgICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICAgICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxIb29rJDEodm0sICdkZWFjdGl2YXRlZCcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGxIb29rJDEodm0sIGhvb2ssIGFyZ3MsIHNldENvbnRleHQpIHtcbiAgICBpZiAoc2V0Q29udGV4dCA9PT0gdm9pZCAwKSB7IHNldENvbnRleHQgPSB0cnVlOyB9XG4gICAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICAgIHB1c2hUYXJnZXQoKTtcbiAgICB2YXIgcHJldkluc3QgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgdmFyIHByZXZTY29wZSA9IGdldEN1cnJlbnRTY29wZSgpO1xuICAgIHNldENvbnRleHQgJiYgc2V0Q3VycmVudEluc3RhbmNlKHZtKTtcbiAgICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgICB2YXIgaW5mbyA9IFwiXCIuY29uY2F0KGhvb2ssIFwiIGhvb2tcIik7XG4gICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyc1tpXSwgdm0sIGFyZ3MgfHwgbnVsbCwgdm0sIGluZm8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgICB9XG4gICAgaWYgKHNldENvbnRleHQpIHtcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKHByZXZJbnN0KTtcbiAgICAgICAgcHJldlNjb3BlICYmIHByZXZTY29wZS5vbigpO1xuICAgIH1cbiAgICBwb3BUYXJnZXQoKTtcbn1cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG52YXIgcXVldWUgPSBbXTtcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUoKSB7XG4gICAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIGhhcyA9IHt9O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNpcmN1bGFyID0ge307XG4gICAgfVxuICAgIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuLy8gQXN5bmMgZWRnZSBjYXNlICM2NTY2IHJlcXVpcmVzIHNhdmluZyB0aGUgdGltZXN0YW1wIHdoZW4gZXZlbnQgbGlzdGVuZXJzIGFyZVxuLy8gYXR0YWNoZWQuIEhvd2V2ZXIsIGNhbGxpbmcgcGVyZm9ybWFuY2Uubm93KCkgaGFzIGEgcGVyZiBvdmVyaGVhZCBlc3BlY2lhbGx5XG4vLyBpZiB0aGUgcGFnZSBoYXMgdGhvdXNhbmRzIG9mIGV2ZW50IGxpc3RlbmVycy4gSW5zdGVhZCwgd2UgdGFrZSBhIHRpbWVzdGFtcFxuLy8gZXZlcnkgdGltZSB0aGUgc2NoZWR1bGVyIGZsdXNoZXMgYW5kIHVzZSB0aGF0IGZvciBhbGwgZXZlbnQgbGlzdGVuZXJzXG4vLyBhdHRhY2hlZCBkdXJpbmcgdGhhdCBmbHVzaC5cbnZhciBjdXJyZW50Rmx1c2hUaW1lc3RhbXAgPSAwO1xuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cbnZhciBnZXROb3cgPSBEYXRlLm5vdztcbi8vIERldGVybWluZSB3aGF0IGV2ZW50IHRpbWVzdGFtcCB0aGUgYnJvd3NlciBpcyB1c2luZy4gQW5ub3lpbmdseSwgdGhlXG4vLyB0aW1lc3RhbXAgY2FuIGVpdGhlciBiZSBoaS1yZXMgKHJlbGF0aXZlIHRvIHBhZ2UgbG9hZCkgb3IgbG93LXJlc1xuLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXG4vLyBzYW1lIHRpbWVzdGFtcCB0eXBlIHdoZW4gc2F2aW5nIHRoZSBmbHVzaCB0aW1lc3RhbXAuXG4vLyBBbGwgSUUgdmVyc2lvbnMgdXNlIGxvdy1yZXMgZXZlbnQgdGltZXN0YW1wcywgYW5kIGhhdmUgcHJvYmxlbWF0aWMgY2xvY2tcbi8vIGltcGxlbWVudGF0aW9ucyAoIzk2MzIpXG5pZiAoaW5Ccm93c2VyICYmICFpc0lFKSB7XG4gICAgdmFyIHBlcmZvcm1hbmNlXzEgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG4gICAgaWYgKHBlcmZvcm1hbmNlXzEgJiZcbiAgICAgICAgdHlwZW9mIHBlcmZvcm1hbmNlXzEubm93ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIGdldE5vdygpID4gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JykudGltZVN0YW1wKSB7XG4gICAgICAgIC8vIGlmIHRoZSBldmVudCB0aW1lc3RhbXAsIGFsdGhvdWdoIGV2YWx1YXRlZCBBRlRFUiB0aGUgRGF0ZS5ub3coKSwgaXNcbiAgICAgICAgLy8gc21hbGxlciB0aGFuIGl0LCBpdCBtZWFucyB0aGUgZXZlbnQgaXMgdXNpbmcgYSBoaS1yZXMgdGltZXN0YW1wLFxuICAgICAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lciB0aW1lc3RhbXBzIGFzXG4gICAgICAgIC8vIHdlbGwuXG4gICAgICAgIGdldE5vdyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBlcmZvcm1hbmNlXzEubm93KCk7IH07XG4gICAgfVxufVxudmFyIHNvcnRDb21wYXJlRm4gPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLnBvc3QpIHtcbiAgICAgICAgaWYgKCFiLnBvc3QpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYi5wb3N0KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xufTtcbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUoKSB7XG4gICAgY3VycmVudEZsdXNoVGltZXN0YW1wID0gZ2V0Tm93KCk7XG4gICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyLCBpZDtcbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAgIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gICAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gICAgcXVldWUuc29ydChzb3J0Q29tcGFyZUZuKTtcbiAgICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICAgICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICAgICAgICB3YXRjaGVyLmJlZm9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICAgICAgaGFzW2lkXSA9IG51bGw7XG4gICAgICAgIHdhdGNoZXIucnVuKCk7XG4gICAgICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgICAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgICAgICAgICAgd2FybignWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgK1xuICAgICAgICAgICAgICAgICAgICAod2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiLmNvbmNhdCh3YXRjaGVyLmV4cHJlc3Npb24sIFwiXFxcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIiksIHdhdGNoZXIudm0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgICB2YXIgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICAgIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuICAgIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcbiAgICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICAgIGNhbGxVcGRhdGVkSG9va3ModXBkYXRlZFF1ZXVlKTtcbiAgICBjbGVhbnVwRGVwcygpO1xuICAgIC8vIGRldnRvb2wgaG9va1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzKHF1ZXVlKSB7XG4gICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgICAgICB2YXIgdm0gPSB3YXRjaGVyLnZtO1xuICAgICAgICBpZiAodm0gJiYgdm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICBjYWxsSG9vayQxKHZtLCAndXBkYXRlZCcpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KHZtKSB7XG4gICAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAgIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MocXVldWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gICAgfVxufVxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyKHdhdGNoZXIpIHtcbiAgICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGlmIChoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAod2F0Y2hlciA9PT0gRGVwLnRhcmdldCAmJiB3YXRjaGVyLm5vUmVjdXJzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbmZpZy5hc3luYykge1xuICAgICAgICAgICAgZmx1c2hTY2hlZHVsZXJRdWV1ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUodm0pIHtcbiAgICB2YXIgcHJvdmlkZU9wdGlvbiA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gICAgaWYgKHByb3ZpZGVPcHRpb24pIHtcbiAgICAgICAgdmFyIHByb3ZpZGVkID0gaXNGdW5jdGlvbihwcm92aWRlT3B0aW9uKVxuICAgICAgICAgICAgPyBwcm92aWRlT3B0aW9uLmNhbGwodm0pXG4gICAgICAgICAgICA6IHByb3ZpZGVPcHRpb247XG4gICAgICAgIGlmICghaXNPYmplY3QocHJvdmlkZWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZSA9IHJlc29sdmVQcm92aWRlZCh2bSk7XG4gICAgICAgIC8vIElFOSBkb2Vzbid0IHN1cHBvcnQgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgc28gd2UgaGF2ZSB0b1xuICAgICAgICAvLyBpdGVyYXRlIHRoZSBrZXlzIG91cnNlbHZlcy5cbiAgICAgICAgdmFyIGtleXMgPSBoYXNTeW1ib2wgPyBSZWZsZWN0Lm93bktleXMocHJvdmlkZWQpIDogT2JqZWN0LmtleXMocHJvdmlkZWQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvdXJjZSwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3ZpZGVkLCBrZXkpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zKHZtKSB7XG4gICAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgICAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCJcIiksIHZtKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0KGluamVjdCwgdm0pIHtcbiAgICBpZiAoaW5qZWN0KSB7XG4gICAgICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB2YXIga2V5cyA9IGhhc1N5bWJvbCA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdfX29iX18nKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVLZXkgaW4gdm0uX3Byb3ZpZGVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2bS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgnZGVmYXVsdCcgaW4gaW5qZWN0W2tleV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gaXNGdW5jdGlvbihwcm92aWRlRGVmYXVsdClcbiAgICAgICAgICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHdhcm4oXCJJbmplY3Rpb24gXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoZGF0YSwgcHJvcHMsIGNoaWxkcmVuLCBwYXJlbnQsIEN0b3IpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gICAgdmFyIGNvbnRleHRWbTtcbiAgICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgICAgICBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyB0aGUgY29udGV4dCB2bSBwYXNzZWQgaW4gaXMgYSBmdW5jdGlvbmFsIGNvbnRleHQgYXMgd2VsbC5cbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICAgICAgY29udGV4dFZtID0gcGFyZW50O1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fb3JpZ2luYWw7XG4gICAgfVxuICAgIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgICB2YXIgbmVlZE5vcm1hbGl6YXRpb24gPSAhaXNDb21waWxlZDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICAgIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XG4gICAgdGhpcy5zbG90cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFfdGhpcy4kc2xvdHMpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKHBhcmVudCwgZGF0YS5zY29wZWRTbG90cywgKF90aGlzLiRzbG90cyA9IHJlc29sdmVTbG90cyhjaGlsZHJlbiwgcGFyZW50KSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcy4kc2xvdHM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Njb3BlZFNsb3RzJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVTY29wZWRTbG90cyhwYXJlbnQsIGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuc2xvdHMoKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBzdXBwb3J0IGZvciBjb21waWxlZCBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gICAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAgICAgLy8gZXhwb3NpbmcgJG9wdGlvbnMgZm9yIHJlbmRlclN0YXRpYygpXG4gICAgICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgICAgIHRoaXMuJHNsb3RzID0gdGhpcy5zbG90cygpO1xuICAgICAgICB0aGlzLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKHBhcmVudCwgZGF0YS5zY29wZWRTbG90cywgdGhpcy4kc2xvdHMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgICAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIHZhciB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQkMShjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgICAgICAgIGlmICh2bm9kZSAmJiAhaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICAgICAgICAgIHZub2RlLmZuQ29udGV4dCA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2bm9kZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQkMShjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHRWbSwgY2hpbGRyZW4pIHtcbiAgICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICAgIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICAgICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSlcbiAgICAgICAgICAgIG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpXG4gICAgICAgICAgICBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTtcbiAgICB9XG4gICAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoZGF0YSwgcHJvcHMsIGNoaWxkcmVuLCBjb250ZXh0Vm0sIEN0b3IpO1xuICAgIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG4gICAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgdmFyIHZub2RlcyA9IG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlKSB8fCBbXTtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheSh2bm9kZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2RlLCBkYXRhLCBjb250ZXh0Vm0sIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpIHtcbiAgICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAgIC8vIChlLmcuIGl0IHdhcyBmcm9tIGEgY2FjaGVkIG5vcm1hbCBzbG90KSB0aGUgZm5Db250ZXh0IGNhdXNlcyBuYW1lZCBzbG90c1xuICAgIC8vIHRoYXQgc2hvdWxkIG5vdCBiZSBtYXRjaGVkIHRvIG1hdGNoLlxuICAgIHZhciBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgICBjbG9uZS5mbk9wdGlvbnMgPSBvcHRpb25zO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIChjbG9uZS5kZXZ0b29sc01ldGEgPSBjbG9uZS5kZXZ0b29sc01ldGEgfHwge30pLnJlbmRlckNvbnRleHQgPVxuICAgICAgICAgICAgcmVuZGVyQ29udGV4dDtcbiAgICB9XG4gICAgaWYgKGRhdGEuc2xvdCkge1xuICAgICAgICAoY2xvbmUuZGF0YSB8fCAoY2xvbmUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wcyh0bywgZnJvbSkge1xuICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubmFtZSB8fCBvcHRpb25zLl9fbmFtZSB8fCBvcHRpb25zLl9jb21wb25lbnRUYWc7XG59XG4vLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgICAgaWYgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAgICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXG4gICAgICAgICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICAgICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gKHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSh2bm9kZSwgYWN0aXZlSW5zdGFuY2UpKTtcbiAgICAgICAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHByZXBhdGNoOiBmdW5jdGlvbiAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgdmFyIGNoaWxkID0gKHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgICB1cGRhdGVDaGlsZENvbXBvbmVudChjaGlsZCwgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBpbnNlcnQ6IGZ1bmN0aW9uICh2bm9kZSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQsIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICBjYWxsSG9vayQxKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAgICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAgICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgICAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICAgICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKHZub2RlKSB7XG4gICAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZykge1xuICAgIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcbiAgICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICAgICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgICB9XG4gICAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAgIC8vIHJlamVjdC5cbiAgICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHdhcm4oXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIi5jb25jYXQoU3RyaW5nKEN0b3IpKSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBhc3luYyBjb21wb25lbnRcbiAgICB2YXIgYXN5bmNGYWN0b3J5O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICAgICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcbiAgICAgICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yKTtcbiAgICAgICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAgICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihhc3luY0ZhY3RvcnksIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuICAgIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICAgIH1cbiAgICAvLyBleHRyYWN0IHByb3BzXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG4gICAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gICAgfVxuICAgIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gICAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAgIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICAgIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAgICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgICAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuICAgICAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgICAgICBkYXRhID0ge307XG4gICAgICAgIGlmIChzbG90KSB7XG4gICAgICAgICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGluc3RhbGwgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICAgIGluc3RhbGxDb21wb25lbnRIb29rcyhkYXRhKTtcbiAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ3Rvci5vcHRpb25zKSB8fCB0YWc7XG4gICAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBcInZ1ZS1jb21wb25lbnQtXCIuY29uY2F0KEN0b3IuY2lkKS5jb25jYXQobmFtZSA/IFwiLVwiLmNvbmNhdChuYW1lKSA6ICcnKSwgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCwgXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sIGFzeW5jRmFjdG9yeSk7XG4gICAgcmV0dXJuIHZub2RlO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbi8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxudm5vZGUsIFxuLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG5wYXJlbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgICAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgICAgICBwYXJlbnQ6IHBhcmVudFxuICAgIH07XG4gICAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICAgIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICAgICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGluc3RhbGxDb21wb25lbnRIb29rcyhkYXRhKSB7XG4gICAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICAgICAgdmFyIHRvTWVyZ2UgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgaWYgKGV4aXN0aW5nICE9PSB0b01lcmdlICYmICEoZXhpc3RpbmcgJiYgZXhpc3RpbmcuX21lcmdlZCkpIHtcbiAgICAgICAgICAgIGhvb2tzW2tleV0gPSBleGlzdGluZyA/IG1lcmdlSG9vayh0b01lcmdlLCBleGlzdGluZykgOiB0b01lcmdlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VIb29rKGYxLCBmMikge1xuICAgIHZhciBtZXJnZWQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAvLyBmbG93IGNvbXBsYWlucyBhYm91dCBleHRyYSBhcmdzIHdoaWNoIGlzIHdoeSB3ZSB1c2UgYW55XG4gICAgICAgIGYxKGEsIGIpO1xuICAgICAgICBmMihhLCBiKTtcbiAgICB9O1xuICAgIG1lcmdlZC5fbWVyZ2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbChvcHRpb25zLCBkYXRhKSB7XG4gICAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gICAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JztcbiAgICAoZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgdmFyIGV4aXN0aW5nID0gb25bZXZlbnRdO1xuICAgIHZhciBjYWxsYmFjayA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gICAgaWYgKGlzRGVmKGV4aXN0aW5nKSkge1xuICAgICAgICBpZiAoaXNBcnJheShleGlzdGluZylcbiAgICAgICAgICAgID8gZXhpc3RpbmcuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xXG4gICAgICAgICAgICA6IGV4aXN0aW5nICE9PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgb25bZXZlbnRdID0gW2NhbGxiYWNrXS5jb25jYXQoZXhpc3RpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvbltldmVudF0gPSBjYWxsYmFjaztcbiAgICB9XG59XG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2U7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgaGFzQ29uc29sZV8xID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICAgIHZhciBjbGFzc2lmeVJFXzEgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gICAgdmFyIGNsYXNzaWZ5XzEgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShjbGFzc2lmeVJFXzEsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pLnJlcGxhY2UoL1stX10vZywgJycpO1xuICAgIH07XG4gICAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgICAgIGlmICh2bSA9PT0gdm9pZCAwKSB7IHZtID0gY3VycmVudEluc3RhbmNlOyB9XG4gICAgICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcbiAgICAgICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc0NvbnNvbGVfMSAmJiAhY29uZmlnLnNpbGVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltWdWUgd2Fybl06IFwiLmNvbmNhdChtc2cpLmNvbmNhdCh0cmFjZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgICAgICBpZiAoaGFzQ29uc29sZV8xICYmICFjb25maWcuc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiLmNvbmNhdChtc2cpICsgKHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgICAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxSb290Pic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBpc0Z1bmN0aW9uKHZtKSAmJiB2bS5jaWQgIT0gbnVsbFxuICAgICAgICAgICAgPyB2bS5vcHRpb25zXG4gICAgICAgICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICAgICAgICAgID8gdm0uJG9wdGlvbnMgfHwgdm0uY29uc3RydWN0b3Iub3B0aW9uc1xuICAgICAgICAgICAgICAgIDogdm07XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShvcHRpb25zKTtcbiAgICAgICAgdmFyIGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICAgICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKG5hbWUgPyBcIjxcIi5jb25jYXQoY2xhc3NpZnlfMShuYW1lKSwgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAgICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyBcIiBhdCBcIi5jb25jYXQoZmlsZSkgOiAnJykpO1xuICAgIH07XG4gICAgdmFyIHJlcGVhdF8xID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgICAgICB2YXIgcmVzID0gJyc7XG4gICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgICBpZiAobiAlIDIgPT09IDEpXG4gICAgICAgICAgICAgICAgcmVzICs9IHN0cjtcbiAgICAgICAgICAgIGlmIChuID4gMSlcbiAgICAgICAgICAgICAgICBzdHIgKz0gc3RyO1xuICAgICAgICAgICAgbiA+Pj0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgICAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciB0cmVlID0gW107XG4gICAgICAgICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKCdcXG5cXG5mb3VuZCBpblxcblxcbicgK1xuICAgICAgICAgICAgICAgIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0XzEoJyAnLCA1ICsgaSAqIDIpKS5jb25jYXQoaXNBcnJheSh2bSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJcIi5jb25jYXQoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSksIFwiLi4uIChcIikuY29uY2F0KHZtWzFdLCBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxuXFxuKGZvdW5kIGluIFwiLmNvbmNhdChmb3JtYXRDb21wb25lbnROYW1lKHZtKSwgXCIpXCIpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgICAgIGlmICghdm0pIHtcbiAgICAgICAgICAgIHdhcm4oXCJvcHRpb24gXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIikgK1xuICAgICAgICAgICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZCk7XG4gICAgfTtcbn1cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSh0bywgZnJvbSwgcmVjdXJzaXZlKSB7XG4gICAgaWYgKHJlY3Vyc2l2ZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2l2ZSA9IHRydWU7IH1cbiAgICBpZiAoIWZyb20pXG4gICAgICAgIHJldHVybiB0bztcbiAgICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgICA/IFJlZmxlY3Qub3duS2V5cyhmcm9tKVxuICAgICAgICA6IE9iamVjdC5rZXlzKGZyb20pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxuICAgICAgICBpZiAoa2V5ID09PSAnX19vYl9fJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgICAgIGlmICghcmVjdXJzaXZlIHx8ICFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgICAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b1ZhbCAhPT0gZnJvbVZhbCAmJlxuICAgICAgICAgICAgaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiZcbiAgICAgICAgICAgIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgICAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvO1xufVxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRWYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFZhbDtcbiAgICAgICAgfVxuICAgICAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgICAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAgICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpc0Z1bmN0aW9uKGNoaWxkVmFsKSA/IGNoaWxkVmFsLmNhbGwodGhpcywgdGhpcykgOiBjaGlsZFZhbCwgaXNGdW5jdGlvbihwYXJlbnRWYWwpID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWwpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuKCkge1xuICAgICAgICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZURhdGEgPSBpc0Z1bmN0aW9uKGNoaWxkVmFsKVxuICAgICAgICAgICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgICAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0RGF0YSA9IGlzRnVuY3Rpb24ocGFyZW50VmFsKVxuICAgICAgICAgICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICAgICAgICAgIDogcGFyZW50VmFsO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdERhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB3YXJuKCdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICAgICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmluaXRpb25zLicsIHZtKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRWYWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKTtcbn07XG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VMaWZlY3ljbGVIb29rKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICB2YXIgcmVzID0gY2hpbGRWYWxcbiAgICAgICAgPyBwYXJlbnRWYWxcbiAgICAgICAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgICAgICAgIDogaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgICAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgICAgIDogcGFyZW50VmFsO1xuICAgIHJldHVybiByZXMgPyBkZWR1cGVIb29rcyhyZXMpIDogcmVzO1xufVxuZnVuY3Rpb24gZGVkdXBlSG9va3MoaG9va3MpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVzLmluZGV4T2YoaG9va3NbaV0pID09PSAtMSkge1xuICAgICAgICAgICAgcmVzLnB1c2goaG9va3NbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgIHN0cmF0c1tob29rXSA9IG1lcmdlTGlmZWN5Y2xlSG9vaztcbn0pO1xuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0sIGtleSkge1xuICAgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgICBpZiAoY2hpbGRWYWwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0sIGtleSkge1xuICAgIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gICAgLy9AdHMtZXhwZWN0LWVycm9yIHdvcmsgYXJvdW5kXG4gICAgaWYgKHBhcmVudFZhbCA9PT0gbmF0aXZlV2F0Y2gpXG4gICAgICAgIHBhcmVudFZhbCA9IHVuZGVmaW5lZDtcbiAgICAvL0B0cy1leHBlY3QtZXJyb3Igd29yayBhcm91bmRcbiAgICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKVxuICAgICAgICBjaGlsZFZhbCA9IHVuZGVmaW5lZDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkVmFsKVxuICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKVxuICAgICAgICByZXR1cm4gY2hpbGRWYWw7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gICAgZm9yICh2YXIga2V5XzEgaW4gY2hpbGRWYWwpIHtcbiAgICAgICAgdmFyIHBhcmVudF8xID0gcmV0W2tleV8xXTtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5XzFdO1xuICAgICAgICBpZiAocGFyZW50XzEgJiYgIWlzQXJyYXkocGFyZW50XzEpKSB7XG4gICAgICAgICAgICBwYXJlbnRfMSA9IFtwYXJlbnRfMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0W2tleV8xXSA9IHBhcmVudF8xID8gcGFyZW50XzEuY29uY2F0KGNoaWxkKSA6IGlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbiAgICBzdHJhdHMubWV0aG9kcyA9XG4gICAgICAgIHN0cmF0cy5pbmplY3QgPVxuICAgICAgICAgICAgc3RyYXRzLmNvbXB1dGVkID1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0sIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRWYWwgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRWYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRWYWw7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRWYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfTtcbnN0cmF0cy5wcm92aWRlID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICBpZiAoIXBhcmVudFZhbClcbiAgICAgICAgcmV0dXJuIGNoaWxkVmFsO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBtZXJnZURhdGEocmV0LCBpc0Z1bmN0aW9uKHBhcmVudFZhbCkgPyBwYXJlbnRWYWwuY2FsbCh0aGlzKSA6IHBhcmVudFZhbCk7XG4gICAgICAgIGlmIChjaGlsZFZhbCkge1xuICAgICAgICAgICAgbWVyZ2VEYXRhKHJldCwgaXNGdW5jdGlvbihjaGlsZFZhbCkgPyBjaGlsZFZhbC5jYWxsKHRoaXMpIDogY2hpbGRWYWwsIGZhbHNlIC8vIG5vbi1yZWN1cnNpdmVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xufTtcbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWQgPyBwYXJlbnRWYWwgOiBjaGlsZFZhbDtcbn07XG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMob3B0aW9ucykge1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUpIHtcbiAgICBpZiAoIW5ldyBSZWdFeHAoXCJeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV9cIi5jb25jYXQodW5pY29kZVJlZ0V4cC5zb3VyY2UsIFwiXSokXCIpKS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArXG4gICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgICAgICAgJ3Nob3VsZCBjb25mb3JtIHRvIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUgaW4gaHRtbDUgc3BlY2lmaWNhdGlvbi4nKTtcbiAgICB9XG4gICAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhuYW1lKSkge1xuICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAgICAgJ2lkOiAnICtcbiAgICAgICAgICAgIG5hbWUpO1xuICAgIH1cbn1cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhvcHRpb25zLCB2bSkge1xuICAgIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gICAgaWYgKCFwcm9wcylcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgaSwgdmFsLCBuYW1lO1xuICAgIGlmIChpc0FycmF5KHByb3BzKSkge1xuICAgICAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICAgICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKSA/IHZhbCA6IHsgdHlwZTogdmFsIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJwcm9wc1xcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgICAgICAgXCJidXQgZ290IFwiLmNvbmNhdCh0b1Jhd1R5cGUocHJvcHMpLCBcIi5cIiksIHZtKTtcbiAgICB9XG4gICAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3Qob3B0aW9ucywgdm0pIHtcbiAgICB2YXIgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XG4gICAgaWYgKCFpbmplY3QpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgbm9ybWFsaXplZCA9IChvcHRpb25zLmluamVjdCA9IHt9KTtcbiAgICBpZiAoaXNBcnJheShpbmplY3QpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gaW5qZWN0W2tleV07XG4gICAgICAgICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgICAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICAgICAgICBcImJ1dCBnb3QgXCIuY29uY2F0KHRvUmF3VHlwZShpbmplY3QpLCBcIi5cIiksIHZtKTtcbiAgICB9XG59XG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvcHRpb25zKSB7XG4gICAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihkZWYpKSB7XG4gICAgICAgICAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlKG5hbWUsIHZhbHVlLCB2bSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgd2FybihcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIikgK1xuICAgICAgICAgICAgXCJidXQgZ290IFwiLmNvbmNhdCh0b1Jhd1R5cGUodmFsdWUpLCBcIi5cIiksIHZtKTtcbiAgICB9XG59XG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLCB2bSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKGNoaWxkKSkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgICB9XG4gICAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgICBub3JtYWxpemVEaXJlY3RpdmVzJDEoY2hpbGQpO1xuICAgIC8vIEFwcGx5IGV4dGVuZHMgYW5kIG1peGlucyBvbiB0aGUgY2hpbGQgb3B0aW9ucyxcbiAgICAvLyBidXQgb25seSBpZiBpdCBpcyBhIHJhdyBvcHRpb25zIG9iamVjdCB0aGF0IGlzbid0XG4gICAgLy8gdGhlIHJlc3VsdCBvZiBhbm90aGVyIG1lcmdlT3B0aW9ucyBjYWxsLlxuICAgIC8vIE9ubHkgbWVyZ2VkIG9wdGlvbnMgaGFzIHRoZSBfYmFzZSBwcm9wZXJ0eS5cbiAgICBpZiAoIWNoaWxkLl9iYXNlKSB7XG4gICAgICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIga2V5O1xuICAgIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICAgIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lcmdlRmllbGQoa2V5KSB7XG4gICAgICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICAgICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQob3B0aW9ucywgdHlwZSwgaWQsIHdhcm5NaXNzaW5nKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICAgIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpXG4gICAgICAgIHJldHVybiBhc3NldHNbaWRdO1xuICAgIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKVxuICAgICAgICByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXTtcbiAgICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gICAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpXG4gICAgICAgIHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICAgICAgd2FybignRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pIHtcbiAgICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gICAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAgIC8vIGJvb2xlYW4gY2FzdGluZ1xuICAgIHZhciBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICAgICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAgICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgIHZhciBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XG4gICAgICAgICAgICBpZiAoc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgICAgIHZhciBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAgICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KSB7XG4gICAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgICAgICB3YXJuKCdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICtcbiAgICAgICAgICAgIGtleSArXG4gICAgICAgICAgICAnXCI6ICcgK1xuICAgICAgICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLCB2bSk7XG4gICAgfVxuICAgIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gICAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gICAgaWYgKHZtICYmXG4gICAgICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgICAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZtLl9wcm9wc1trZXldO1xuICAgIH1cbiAgICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAgIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgICByZXR1cm4gaXNGdW5jdGlvbihkZWYpICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgICAgICA/IGRlZi5jYWxsKHZtKVxuICAgICAgICA6IGRlZjtcbn1cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wKHByb3AsIG5hbWUsIHZhbHVlLCB2bSwgYWJzZW50KSB7XG4gICAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgICAgIHdhcm4oJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsIHZtKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICAgIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICBpZiAodHlwZSkge1xuICAgICAgICBpZiAoIWlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0sIHZtKTtcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgICAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBoYXZlRXhwZWN0ZWRUeXBlcyA9IGV4cGVjdGVkVHlwZXMuc29tZShmdW5jdGlvbiAodCkgeyByZXR1cm4gdDsgfSk7XG4gICAgaWYgKCF2YWxpZCAmJiBoYXZlRXhwZWN0ZWRUeXBlcykge1xuICAgICAgICB3YXJuKGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcyksIHZtKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLCB2bSk7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2x8QmlnSW50KSQvO1xuZnVuY3Rpb24gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZSwgdm0pIHtcbiAgICB2YXIgdmFsaWQ7XG4gICAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gICAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgICAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgICAgICB2YWxpZCA9IGlzQXJyYXkodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB3YXJuKCdJbnZhbGlkIHByb3AgdHlwZTogXCInICsgU3RyaW5nKHR5cGUpICsgJ1wiIGlzIG5vdCBhIGNvbnN0cnVjdG9yJywgdm0pO1xuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZDogdmFsaWQsXG4gICAgICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gICAgfTtcbn1cbnZhciBmdW5jdGlvblR5cGVDaGVja1JFID0gL15cXHMqZnVuY3Rpb24gKFxcdyspLztcbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUoZm4pIHtcbiAgICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKGZ1bmN0aW9uVHlwZUNoZWNrUkUpO1xuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJyc7XG59XG5mdW5jdGlvbiBpc1NhbWVUeXBlKGEsIGIpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKTtcbn1cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gICAgaWYgKCFpc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwZWN0ZWRUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIuXCIpICtcbiAgICAgICAgXCIgRXhwZWN0ZWQgXCIuY29uY2F0KGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpO1xuICAgIHZhciBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICAgIHZhciByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSBleHBlY3RlZCB2YWx1ZVxuICAgIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxuICAgICAgICBpc0V4cGxpY2FibGUodHlwZW9mIHZhbHVlKSAmJlxuICAgICAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xuICAgICAgICBtZXNzYWdlICs9IFwiIHdpdGggdmFsdWUgXCIuY29uY2F0KHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSkpO1xuICAgIH1cbiAgICBtZXNzYWdlICs9IFwiLCBnb3QgXCIuY29uY2F0KHJlY2VpdmVkVHlwZSwgXCIgXCIpO1xuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxuICAgIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgICAgICBtZXNzYWdlICs9IFwid2l0aCB2YWx1ZSBcIi5jb25jYXQoc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKSwgXCIuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbn1cbmZ1bmN0aW9uIHN0eWxlVmFsdWUodmFsdWUsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdCh2YWx1ZSwgXCJcXFwiXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnTnVtYmVyJykge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoTnVtYmVyKHZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodmFsdWUpO1xuICAgIH1cbn1cbnZhciBFWFBMSUNBQkxFX1RZUEVTID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbmZ1bmN0aW9uIGlzRXhwbGljYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiBFWFBMSUNBQkxFX1RZUEVTLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW07IH0pO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJzsgfSk7XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xudmFyIGluaXRQcm94eTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGFsbG93ZWRHbG9iYWxzXzEgPSBtYWtlTWFwKCdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50LCcgK1xuICAgICAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICAgICk7XG4gICAgdmFyIHdhcm5Ob25QcmVzZW50XzEgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgd2FybihcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIpICtcbiAgICAgICAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcbiAgICAgICAgICAgICdTZWU6IGh0dHBzOi8vdjIudnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLCB0YXJnZXQpO1xuICAgIH07XG4gICAgdmFyIHdhcm5SZXNlcnZlZFByZWZpeF8xID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgICAgIHdhcm4oXCJQcm9wZXJ0eSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIG11c3QgYmUgYWNjZXNzZWQgd2l0aCBcXFwiJGRhdGEuXCIpLmNvbmNhdChrZXksIFwiXFxcIiBiZWNhdXNlIFwiKSArXG4gICAgICAgICAgICAncHJvcGVydGllcyBzdGFydGluZyB3aXRoIFwiJFwiIG9yIFwiX1wiIGFyZSBub3QgcHJveGllZCBpbiB0aGUgVnVlIGluc3RhbmNlIHRvICcgK1xuICAgICAgICAgICAgJ3ByZXZlbnQgY29uZmxpY3RzIHdpdGggVnVlIGludGVybmFscy4gJyArXG4gICAgICAgICAgICAnU2VlOiBodHRwczovL3YyLnZ1ZWpzLm9yZy92Mi9hcGkvI2RhdGEnLCB0YXJnZXQpO1xuICAgIH07XG4gICAgdmFyIGhhc1Byb3h5XzEgPSB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb3h5KTtcbiAgICBpZiAoaGFzUHJveHlfMSkge1xuICAgICAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXJfMSA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICAgICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyXzEoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIuY29uY2F0KGtleSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgaGFzSGFuZGxlcl8xID0ge1xuICAgICAgICBoYXM6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICAgICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHNfMShrZXkpIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgIGtleS5jaGFyQXQoMCkgPT09ICdfJyAmJlxuICAgICAgICAgICAgICAgICAgICAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcbiAgICAgICAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgd2FyblJlc2VydmVkUHJlZml4XzEodGFyZ2V0LCBrZXkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgd2Fybk5vblByZXNlbnRfMSh0YXJnZXQsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBnZXRIYW5kbGVyXzEgPSB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKVxuICAgICAgICAgICAgICAgICAgICB3YXJuUmVzZXJ2ZWRQcmVmaXhfMSh0YXJnZXQsIGtleSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB3YXJuTm9uUHJlc2VudF8xKHRhcmdldCwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5KHZtKSB7XG4gICAgICAgIGlmIChoYXNQcm94eV8xKSB7XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkID8gZ2V0SGFuZGxlcl8xIDogaGFzSGFuZGxlcl8xO1xuICAgICAgICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBub29wLFxuICAgIHNldDogbm9vcFxufTtcbmZ1bmN0aW9uIHByb3h5KHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XTtcbiAgICB9O1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlcih2YWwpIHtcbiAgICAgICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5mdW5jdGlvbiBpbml0U3RhdGUodm0pIHtcbiAgICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICAgIGlmIChvcHRzLnByb3BzKVxuICAgICAgICBpbml0UHJvcHMkMSh2bSwgb3B0cy5wcm9wcyk7XG4gICAgLy8gQ29tcG9zaXRpb24gQVBJXG4gICAgaW5pdFNldHVwKHZtKTtcbiAgICBpZiAob3B0cy5tZXRob2RzKVxuICAgICAgICBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTtcbiAgICBpZiAob3B0cy5kYXRhKSB7XG4gICAgICAgIGluaXREYXRhKHZtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBvYiA9IG9ic2VydmUoKHZtLl9kYXRhID0ge30pKTtcbiAgICAgICAgb2IgJiYgb2Iudm1Db3VudCsrO1xuICAgIH1cbiAgICBpZiAob3B0cy5jb21wdXRlZClcbiAgICAgICAgaW5pdENvbXB1dGVkJDEodm0sIG9wdHMuY29tcHV0ZWQpO1xuICAgIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5pdFByb3BzJDEodm0sIHByb3BzT3B0aW9ucykge1xuICAgIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gICAgdmFyIHByb3BzID0gKHZtLl9wcm9wcyA9IHNoYWxsb3dSZWFjdGl2ZSh7fSkpO1xuICAgIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gICAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gICAgdmFyIGtleXMgPSAodm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW10pO1xuICAgIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgICBpZiAoIWlzUm9vdCkge1xuICAgICAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIH1cbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcbiAgICAgICAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKFwiXFxcIlwiLmNvbmNhdChoeXBoZW5hdGVkS2V5LCBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSwgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmaW5lUmVhY3RpdmUocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUm9vdCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCJcIiksIHZtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0cnVlIC8qIHNoYWxsb3cgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVmaW5lUmVhY3RpdmUocHJvcHMsIGtleSwgdmFsdWUsIHVuZGVmaW5lZCwgdHJ1ZSAvKiBzaGFsbG93ICovKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICAgICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIHtcbiAgICAgICAgX2xvb3BfMShrZXkpO1xuICAgIH1cbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG59XG5mdW5jdGlvbiBpbml0RGF0YSh2bSkge1xuICAgIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgICBkYXRhID0gdm0uX2RhdGEgPSBpc0Z1bmN0aW9uKGRhdGEpID8gZ2V0RGF0YShkYXRhLCB2bSkgOiBkYXRhIHx8IHt9O1xuICAgIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgICBkYXRhID0ge307XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgIHdhcm4oJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgICAgICAgICAgICdodHRwczovL3YyLnZ1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLCB2bSk7XG4gICAgfVxuICAgIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICAgIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICAgICAgICAgIHdhcm4oXCJNZXRob2QgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSwgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB3YXJuKFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsIHZtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9ic2VydmUgZGF0YVxuICAgIHZhciBvYiA9IG9ic2VydmUoZGF0YSk7XG4gICAgb2IgJiYgb2Iudm1Db3VudCsrO1xufVxuZnVuY3Rpb24gZ2V0RGF0YShkYXRhLCB2bSkge1xuICAgIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgICBwdXNoVGFyZ2V0KCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHBvcFRhcmdldCgpO1xuICAgIH1cbn1cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSh2bSwgY29tcHV0ZWQpIHtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB2YXIgd2F0Y2hlcnMgPSAodm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICAgIHZhciBpc1NTUiA9IGlzU2VydmVyUmVuZGVyaW5nKCk7XG4gICAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICAgICAgdmFyIGdldHRlciA9IGlzRnVuY3Rpb24odXNlckRlZikgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB3YXJuKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIuXCIpLCB2bSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1NTUikge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgICAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcih2bSwgZ2V0dGVyIHx8IG5vb3AsIG5vb3AsIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAgICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAgICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgICAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICAgICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgICAgICAgICAgd2FybihcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgd2FybihcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2bS4kb3B0aW9ucy5tZXRob2RzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5tZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgd2FybihcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIG1ldGhvZC5cIiksIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkKHRhcmdldCwga2V5LCB1c2VyRGVmKSB7XG4gICAgdmFyIHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gICAgaWYgKGlzRnVuY3Rpb24odXNlckRlZikpIHtcbiAgICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHNob3VsZENhY2hlXG4gICAgICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmKTtcbiAgICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgICAgICAgID8gc2hvdWxkQ2FjaGUgJiYgdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZi5nZXQpXG4gICAgICAgICAgICA6IG5vb3A7XG4gICAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldCB8fCBub29wO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3YXJuKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyKCkge1xuICAgICAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgICAgICBpZiAod2F0Y2hlcikge1xuICAgICAgICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIERlcC50YXJnZXQub25UcmFjaykge1xuICAgICAgICAgICAgICAgICAgICBEZXAudGFyZ2V0Lm9uVHJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0OiBEZXAudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVHZXR0ZXJJbnZva2VyKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaW5pdE1ldGhvZHModm0sIG1ldGhvZHMpIHtcbiAgICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB3YXJuKFwiTWV0aG9kIFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgaGFzIHR5cGUgXFxcIlwiKS5jb25jYXQodHlwZW9mIG1ldGhvZHNba2V5XSwgXCJcXFwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgd2FybihcIk1ldGhvZCBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5IGluIHZtICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICAgICAgICAgIHdhcm4oXCJNZXRob2QgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIikgK1xuICAgICAgICAgICAgICAgICAgICBcIkF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZtW2tleV0gPSB0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5pdFdhdGNoKHZtLCB3YXRjaCkge1xuICAgIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgICAgIGlmIChpc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgICAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICAgICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gICAgfVxuICAgIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBzdGF0ZU1peGluKFZ1ZSkge1xuICAgIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAgIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAgIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgICB2YXIgZGF0YURlZiA9IHt9O1xuICAgIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9O1xuICAgIHZhciBwcm9wc0RlZiA9IHt9O1xuICAgIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BzO1xuICAgIH07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3YXJuKCdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJywgdGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG4gICAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICAgIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcbiAgICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChleHBPckZuLCBjYiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IFwiY2FsbGJhY2sgZm9yIGltbWVkaWF0ZSB3YXRjaGVyIFxcXCJcIi5jb25jYXQod2F0Y2hlci5leHByZXNzaW9uLCBcIlxcXCJcIik7XG4gICAgICAgICAgICBwdXNoVGFyZ2V0KCk7XG4gICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYiwgdm0sIFt3YXRjaGVyLnZhbHVlXSwgdm0sIGluZm8pO1xuICAgICAgICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbigpIHtcbiAgICAgICAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG52YXIgdWlkID0gMDtcbmZ1bmN0aW9uIGluaXRNaXhpbiQxKFZ1ZSkge1xuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgICAvLyBhIHVpZFxuICAgICAgICB2bS5fdWlkID0gdWlkKys7XG4gICAgICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIi5jb25jYXQodm0uX3VpZCk7XG4gICAgICAgICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIi5jb25jYXQodm0uX3VpZCk7XG4gICAgICAgICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhIGZsYWcgdG8gbWFyayB0aGlzIGFzIGEgVnVlIGluc3RhbmNlIHdpdGhvdXQgaGF2aW5nIHRvIGRvIGluc3RhbmNlb2ZcbiAgICAgICAgLy8gY2hlY2tcbiAgICAgICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAgICAgLy8gYXZvaWQgaW5zdGFuY2VzIGZyb20gYmVpbmcgb2JzZXJ2ZWRcbiAgICAgICAgdm0uX192X3NraXAgPSB0cnVlO1xuICAgICAgICAvLyBlZmZlY3Qgc2NvcGVcbiAgICAgICAgdm0uX3Njb3BlID0gbmV3IEVmZmVjdFNjb3BlKHRydWUgLyogZGV0YWNoZWQgKi8pO1xuICAgICAgICAvLyAjMTMxMzQgZWRnZSBjYXNlIHdoZXJlIGEgY2hpbGQgY29tcG9uZW50IGlzIG1hbnVhbGx5IGNyZWF0ZWQgZHVyaW5nIHRoZVxuICAgICAgICAvLyByZW5kZXIgb2YgYSBwYXJlbnQgY29tcG9uZW50XG4gICAgICAgIHZtLl9zY29wZS5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZtLl9zY29wZS5fdm0gPSB0cnVlO1xuICAgICAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICAgICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMocmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksIG9wdGlvbnMgfHwge30sIHZtKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICAgICAgdm0uX3NlbGYgPSB2bTtcbiAgICAgICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgICAgIGluaXRFdmVudHModm0pO1xuICAgICAgICBpbml0UmVuZGVyKHZtKTtcbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2JlZm9yZUNyZWF0ZScsIHVuZGVmaW5lZCwgZmFsc2UgLyogc2V0Q29udGV4dCAqLyk7XG4gICAgICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2NyZWF0ZWQnKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgICAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgICAgICAgIG1lYXN1cmUoXCJ2dWUgXCIuY29uY2F0KHZtLl9uYW1lLCBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgICAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKSB7XG4gICAgdmFyIG9wdHMgPSAodm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpKTtcbiAgICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICAgIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICAgIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XG4gICAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xuICAgIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgICAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgICAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcikge1xuICAgIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgICAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAgICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICAgICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgICAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgICAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKSB7XG4gICAgdmFyIG1vZGlmaWVkO1xuICAgIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gICAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgICAgICAgIGlmICghbW9kaWZpZWQpXG4gICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB7fTtcbiAgICAgICAgICAgIG1vZGlmaWVkW2tleV0gPSBsYXRlc3Rba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbW9kaWZpZWQ7XG59XG5cbmZ1bmN0aW9uIFZ1ZShvcHRpb25zKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgISh0aGlzIGluc3RhbmNlb2YgVnVlKSkge1xuICAgICAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gICAgfVxuICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG4vL0B0cy1leHBlY3QtZXJyb3IgVnVlIGhhcyBmdW5jdGlvbiB0eXBlXG5pbml0TWl4aW4kMShWdWUpO1xuLy9AdHMtZXhwZWN0LWVycm9yIFZ1ZSBoYXMgZnVuY3Rpb24gdHlwZVxuc3RhdGVNaXhpbihWdWUpO1xuLy9AdHMtZXhwZWN0LWVycm9yIFZ1ZSBoYXMgZnVuY3Rpb24gdHlwZVxuZXZlbnRzTWl4aW4oVnVlKTtcbi8vQHRzLWV4cGVjdC1lcnJvciBWdWUgaGFzIGZ1bmN0aW9uIHR5cGVcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XG4vL0B0cy1leHBlY3QtZXJyb3IgVnVlIGhhcyBmdW5jdGlvbiB0eXBlXG5yZW5kZXJNaXhpbihWdWUpO1xuXG5mdW5jdGlvbiBpbml0VXNlKFZ1ZSkge1xuICAgIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gdGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKTtcbiAgICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihwbHVnaW4uaW5zdGFsbCkpIHtcbiAgICAgICAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihwbHVnaW4pKSB7XG4gICAgICAgICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGluaXRNaXhpbihWdWUpIHtcbiAgICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpbml0RXh0ZW5kKFZ1ZSkge1xuICAgIC8qKlxuICAgICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICAgKi9cbiAgICBWdWUuY2lkID0gMDtcbiAgICB2YXIgY2lkID0gMTtcbiAgICAvKipcbiAgICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgICAqL1xuICAgIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgICAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICAgICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShleHRlbmRPcHRpb25zKSB8fCBnZXRDb21wb25lbnROYW1lKFN1cGVyLm9wdGlvbnMpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudChvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgICAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgICAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFN1cGVyLm9wdGlvbnMsIGV4dGVuZE9wdGlvbnMpO1xuICAgICAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcbiAgICAgICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAgICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAgICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgICAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgICAgIGluaXRQcm9wcyhTdWIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgICAgICAgaW5pdENvbXB1dGVkKFN1Yik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgICAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuICAgICAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICAgICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICAgICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICAgICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcbiAgICAgICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICAgICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgICAgIHJldHVybiBTdWI7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluaXRQcm9wcyhDb21wKSB7XG4gICAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQoQ29tcCkge1xuICAgIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICAgICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgICAqL1xuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBub3QgZXhhY3Qgc2FtZSB0eXBlXG4gICAgICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChpZCwgZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiBpc0Z1bmN0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX2dldENvbXBvbmVudE5hbWUob3B0cykge1xuICAgIHJldHVybiBvcHRzICYmIChnZXRDb21wb25lbnROYW1lKG9wdHMuQ3Rvci5vcHRpb25zKSB8fCBvcHRzLnRhZyk7XG59XG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcbiAgICBpZiAoaXNBcnJheShwYXR0ZXJuKSkge1xuICAgICAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwcnVuZUNhY2hlKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcbiAgICB2YXIgY2FjaGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5jYWNoZSwga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXMsIF92bm9kZSA9IGtlZXBBbGl2ZUluc3RhbmNlLl92bm9kZSwgJHZub2RlID0ga2VlcEFsaXZlSW5zdGFuY2UuJHZub2RlO1xuICAgIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgICAgICB2YXIgZW50cnkgPSBjYWNoZVtrZXldO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSBlbnRyeS5uYW1lO1xuICAgICAgICAgICAgaWYgKG5hbWVfMSAmJiAhZmlsdGVyKG5hbWVfMSkpIHtcbiAgICAgICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAkdm5vZGUuY29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbiA9IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBjdXJyZW50KSB7XG4gICAgdmFyIGVudHJ5ID0gY2FjaGVba2V5XTtcbiAgICBpZiAoZW50cnkgJiYgKCFjdXJyZW50IHx8IGVudHJ5LnRhZyAhPT0gY3VycmVudC50YWcpKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2FuIGJlIHVuZGVmaW5lZFxuICAgICAgICBlbnRyeS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgIH1cbiAgICBjYWNoZVtrZXldID0gbnVsbDtcbiAgICByZW1vdmUkMihrZXlzLCBrZXkpO1xufVxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuLy8gVE9ETyBkZWZpbmVDb21wb25lbnRcbnZhciBLZWVwQWxpdmUgPSB7XG4gICAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICAgIGFic3RyYWN0OiB0cnVlLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICAgICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgICAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgY2FjaGVWTm9kZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcywgY2FjaGUgPSBfYS5jYWNoZSwga2V5cyA9IF9hLmtleXMsIHZub2RlVG9DYWNoZSA9IF9hLnZub2RlVG9DYWNoZSwga2V5VG9DYWNoZSA9IF9hLmtleVRvQ2FjaGU7XG4gICAgICAgICAgICBpZiAodm5vZGVUb0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHZub2RlVG9DYWNoZS50YWcsIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGVUb0NhY2hlLmNvbXBvbmVudEluc3RhbmNlLCBjb21wb25lbnRPcHRpb25zID0gdm5vZGVUb0NhY2hlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgICAgICAgY2FjaGVba2V5VG9DYWNoZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IF9nZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50SW5zdGFuY2U6IGNvbXBvbmVudEluc3RhbmNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5VG9DYWNoZSk7XG4gICAgICAgICAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5c1swXSwga2V5cywgdGhpcy5fdm5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZub2RlVG9DYWNoZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIH0sXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkodGhpcy5jYWNoZSwga2V5LCB0aGlzLmtleXMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2FjaGVWTm9kZSgpO1xuICAgICAgICB0aGlzLiR3YXRjaCgnaW5jbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHBydW5lQ2FjaGUoX3RoaXMsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBwcnVuZUNhY2hlKF90aGlzLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgdXBkYXRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhY2hlVk5vZGUoKTtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XG4gICAgICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgICAgICAgIHZhciBuYW1lXzIgPSBfZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIGluY2x1ZGUgPSBfYS5pbmNsdWRlLCBleGNsdWRlID0gX2EuZXhjbHVkZTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAgICAgKGluY2x1ZGUgJiYgKCFuYW1lXzIgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZV8yKSkpIHx8XG4gICAgICAgICAgICAgICAgLy8gZXhjbHVkZWRcbiAgICAgICAgICAgICAgICAoZXhjbHVkZSAmJiBuYW1lXzIgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lXzIpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2bm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYiA9IHRoaXMsIGNhY2hlID0gX2IuY2FjaGUsIGtleXMgPSBfYi5rZXlzO1xuICAgICAgICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgICAgICAgICAgPyAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gXCI6OlwiLmNvbmNhdChjb21wb25lbnRPcHRpb25zLnRhZykgOiAnJylcbiAgICAgICAgICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgICAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAgICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgICAgICAgICByZW1vdmUkMihrZXlzLCBrZXkpO1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVsYXkgc2V0dGluZyB0aGUgY2FjaGUgdW50aWwgdXBkYXRlXG4gICAgICAgICAgICAgICAgdGhpcy52bm9kZVRvQ2FjaGUgPSB2bm9kZTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleVRvQ2FjaGUgPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNhbiB2bm9kZS5kYXRhIGNhbiBiZSB1bmRlZmluZWRcbiAgICAgICAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSk7XG4gICAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICAgIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJKFZ1ZSkge1xuICAgIC8vIGNvbmZpZ1xuICAgIHZhciBjb25maWdEZWYgPSB7fTtcbiAgICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3YXJuKCdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLicpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcbiAgICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICAgIFZ1ZS51dGlsID0ge1xuICAgICAgICB3YXJuOiB3YXJuLFxuICAgICAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICAgICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZVxuICAgIH07XG4gICAgVnVlLnNldCA9IHNldDtcbiAgICBWdWUuZGVsZXRlID0gZGVsO1xuICAgIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuICAgIC8vIDIuNiBleHBsaWNpdCBvYnNlcnZhYmxlIEFQSVxuICAgIFZ1ZS5vYnNlcnZhYmxlID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBvYnNlcnZlKG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfSk7XG4gICAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAgIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICAgIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuICAgIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG4gICAgaW5pdFVzZShWdWUpO1xuICAgIGluaXRNaXhpbihWdWUpO1xuICAgIGluaXRFeHRlbmQoVnVlKTtcbiAgICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gICAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dDtcbiAgICB9XG59KTtcbi8vIGV4cG9zZSBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCBmb3Igc3NyIHJ1bnRpbWUgaGVscGVyIGluc3RhbGxhdGlvblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ0Z1bmN0aW9uYWxSZW5kZXJDb250ZXh0Jywge1xuICAgIHZhbHVlOiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dFxufSk7XG5WdWUudmVyc2lvbiA9IHZlcnNpb247XG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICAgIHJldHVybiAoKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSAmJiB0eXBlICE9PSAnYnV0dG9uJykgfHxcbiAgICAgICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAgICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJykpO1xufTtcbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG52YXIgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlID0gbWFrZU1hcCgnZXZlbnRzLGNhcmV0LHR5cGluZyxwbGFpbnRleHQtb25seScpO1xudmFyIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgICAgICA/ICdmYWxzZSdcbiAgICAgICAgOiAvLyBhbGxvdyBhcmJpdHJhcnkgc3RyaW5nIHZhbHVlIGZvciBjb250ZW50ZWRpdGFibGVcbiAgICAgICAgICAgIGtleSA9PT0gJ2NvbnRlbnRlZGl0YWJsZScgJiYgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlKHZhbHVlKVxuICAgICAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgICAgICA6ICd0cnVlJztcbn07XG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLCcgK1xuICAgICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJyk7XG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnO1xufTtcbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJztcbn07XG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpIHtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHBhcmVudE5vZGUucGFyZW50IG5vdCBWTm9kZVdpdGhEYXRhXG4gICAgd2hpbGUgKGlzRGVmKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSkge1xuICAgICAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKTtcbn1cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhKGNoaWxkLCBwYXJlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgICAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdIDogcGFyZW50LmNsYXNzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlckNsYXNzKHN0YXRpY0NsYXNzLCBkeW5hbWljQ2xhc3MpIHtcbiAgICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuICcnO1xufVxuZnVuY3Rpb24gY29uY2F0KGEsIGIpIHtcbiAgICByZXR1cm4gYSA/IChiID8gYSArICcgJyArIGIgOiBhKSA6IGIgfHwgJyc7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuICcnO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkodmFsdWUpIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgdmFyIHN0cmluZ2lmaWVkO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChpc0RlZigoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgICAgICAgIGlmIChyZXMpXG4gICAgICAgICAgICAgICAgcmVzICs9ICcgJztcbiAgICAgICAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgICAgICAgaWYgKHJlcylcbiAgICAgICAgICAgICAgICByZXMgKz0gJyAnO1xuICAgICAgICAgICAgcmVzICs9IGtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICAgIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcCgnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAgICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAgICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290Jyk7XG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKCdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICAgJ2ZvcmVpZ25vYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAgICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JywgdHJ1ZSk7XG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKTtcbn07XG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UodGFnKSB7XG4gICAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICAgICAgcmV0dXJuICdzdmcnO1xuICAgIH1cbiAgICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gICAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgICAgIHJldHVybiAnbWF0aCc7XG4gICAgfVxufVxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCh0YWcpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3Nlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddO1xuICAgIH1cbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgICAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9XG4gICAgICAgICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgICAgICAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKTtcbiAgICB9XG59XG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkoZWwpIHtcbiAgICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICAgICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgdm5vZGUpIHtcbiAgICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGVsbTtcbiAgICB9XG4gICAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgICBpZiAodm5vZGUuZGF0YSAmJlxuICAgICAgICB2bm9kZS5kYXRhLmF0dHJzICYmXG4gICAgICAgIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICAgIH1cbiAgICByZXR1cm4gZWxtO1xufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUodGV4dCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQodGV4dCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpO1xufVxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKG5vZGUsIGNoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiBhcHBlbmRDaGlsZChub2RlLCBjaGlsZCkge1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuZnVuY3Rpb24gcGFyZW50Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZTtcbn1cbmZ1bmN0aW9uIG5leHRTaWJsaW5nKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbn1cbmZ1bmN0aW9uIHRhZ05hbWUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnRhZ05hbWU7XG59XG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudChub2RlLCB0ZXh0KSB7XG4gICAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5mdW5jdGlvbiBzZXRTdHlsZVNjb3BlKG5vZGUsIHNjb3BlSWQpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShzY29wZUlkLCAnJyk7XG59XG5cbnZhciBub2RlT3BzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gIGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuICBjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG4gIGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG4gIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuICByZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG4gIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcbiAgbmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuICB0YWdOYW1lOiB0YWdOYW1lLFxuICBzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG4gIHNldFN0eWxlU2NvcGU6IHNldFN0eWxlU2NvcGVcbn0pO1xuXG52YXIgcmVmID0ge1xuICAgIGNyZWF0ZTogZnVuY3Rpb24gKF8sIHZub2RlKSB7XG4gICAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKG9sZFZub2RlLCB2bm9kZSkge1xuICAgICAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICAgICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICh2bm9kZSkge1xuICAgICAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgICB2YXIgcmVmID0gdm5vZGUuZGF0YS5yZWY7XG4gICAgaWYgKCFpc0RlZihyZWYpKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgcmVmVmFsdWUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gICAgdmFyIHZhbHVlID0gaXNSZW1vdmFsID8gbnVsbCA6IHJlZlZhbHVlO1xuICAgIHZhciAkcmVmc1ZhbHVlID0gaXNSZW1vdmFsID8gdW5kZWZpbmVkIDogcmVmVmFsdWU7XG4gICAgaWYgKGlzRnVuY3Rpb24ocmVmKSkge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhyZWYsIHZtLCBbdmFsdWVdLCB2bSwgXCJ0ZW1wbGF0ZSByZWYgZnVuY3Rpb25cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGlzRm9yID0gdm5vZGUuZGF0YS5yZWZJbkZvcjtcbiAgICB2YXIgX2lzU3RyaW5nID0gdHlwZW9mIHJlZiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHJlZiA9PT0gJ251bWJlcic7XG4gICAgdmFyIF9pc1JlZiA9IGlzUmVmKHJlZik7XG4gICAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgICBpZiAoX2lzU3RyaW5nIHx8IF9pc1JlZikge1xuICAgICAgICBpZiAoaXNGb3IpIHtcbiAgICAgICAgICAgIHZhciBleGlzdGluZyA9IF9pc1N0cmluZyA/IHJlZnNbcmVmXSA6IHJlZi52YWx1ZTtcbiAgICAgICAgICAgIGlmIChpc1JlbW92YWwpIHtcbiAgICAgICAgICAgICAgICBpc0FycmF5KGV4aXN0aW5nKSAmJiByZW1vdmUkMihleGlzdGluZywgcmVmVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGV4aXN0aW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZzW3JlZl0gPSBbcmVmVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2V0dXBSZWYodm0sIHJlZiwgcmVmc1tyZWZdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZi52YWx1ZSA9IFtyZWZWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWV4aXN0aW5nLmluY2x1ZGVzKHJlZlZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5wdXNoKHJlZlZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX2lzU3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAoaXNSZW1vdmFsICYmIHJlZnNbcmVmXSAhPT0gcmVmVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWZzW3JlZl0gPSAkcmVmc1ZhbHVlO1xuICAgICAgICAgICAgc2V0U2V0dXBSZWYodm0sIHJlZiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9pc1JlZikge1xuICAgICAgICAgICAgaWYgKGlzUmVtb3ZhbCAmJiByZWYudmFsdWUgIT09IHJlZlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgd2FybihcIkludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6IFwiLmNvbmNhdCh0eXBlb2YgcmVmKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzZXRTZXR1cFJlZihfYSwga2V5LCB2YWwpIHtcbiAgICB2YXIgX3NldHVwU3RhdGUgPSBfYS5fc2V0dXBTdGF0ZTtcbiAgICBpZiAoX3NldHVwU3RhdGUgJiYgaGFzT3duKF9zZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICAgIGlmIChpc1JlZihfc2V0dXBTdGF0ZVtrZXldKSkge1xuICAgICAgICAgICAgX3NldHVwU3RhdGVba2V5XS52YWx1ZSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zZXR1cFN0YXRlW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5mdW5jdGlvbiBzYW1lVm5vZGUoYSwgYikge1xuICAgIHJldHVybiAoYS5rZXkgPT09IGIua2V5ICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICAoKGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpKSB8fFxuICAgICAgICAgICAgKGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiYgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcikpKSk7XG59XG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlKGEsIGIpIHtcbiAgICBpZiAoYS50YWcgIT09ICdpbnB1dCcpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHZhciBpO1xuICAgIHZhciB0eXBlQSA9IGlzRGVmKChpID0gYS5kYXRhKSkgJiYgaXNEZWYoKGkgPSBpLmF0dHJzKSkgJiYgaS50eXBlO1xuICAgIHZhciB0eXBlQiA9IGlzRGVmKChpID0gYi5kYXRhKSkgJiYgaXNEZWYoKGkgPSBpLmF0dHJzKSkgJiYgaS50eXBlO1xuICAgIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgKGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICAgIHZhciBpLCBrZXk7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAgICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICAgICAgaWYgKGlzRGVmKGtleSkpXG4gICAgICAgICAgICBtYXBba2V5XSA9IGk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uKGJhY2tlbmQpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgY2JzID0ge307XG4gICAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXMsIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG4gICAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0KGVsbSkge1xuICAgICAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSbUNiKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgICAgaWYgKC0tcmVtb3ZlLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbW92ZS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgICAgIHJldHVybiByZW1vdmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUoZWwpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgICAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50KHZub2RlLCBpblZQcmUpIHtcbiAgICAgICAgcmV0dXJuICghaW5WUHJlICYmXG4gICAgICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgICAgICEoY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnO1xuICAgICAgICAgICAgICAgIH0pKSAmJlxuICAgICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKSk7XG4gICAgfVxuICAgIHZhciBjcmVhdGluZ0VsbUluVlByZSA9IDA7XG4gICAgZnVuY3Rpb24gY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQsIG93bmVyQXJyYXksIGluZGV4KSB7XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHZub2RlIHdhcyB1c2VkIGluIGEgcHJldmlvdXMgcmVuZGVyIVxuICAgICAgICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXG4gICAgICAgICAgICAvLyBwb3RlbnRpYWwgcGF0Y2ggZXJyb3JzIGRvd24gdGhlIHJvYWQgd2hlbiBpdCdzIHVzZWQgYXMgYW4gaW5zZXJ0aW9uXG4gICAgICAgICAgICAvLyByZWZlcmVuY2Ugbm9kZS4gSW5zdGVhZCwgd2UgY2xvbmUgdGhlIG5vZGUgb24tZGVtYW5kIGJlZm9yZSBjcmVhdGluZ1xuICAgICAgICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXG4gICAgICAgICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICAgICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgICAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICAgICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgICAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgICAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICAgICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICAgICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IGkuaG9vaykpICYmIGlzRGVmKChpID0gaS5pbml0KSkpIHtcbiAgICAgICAgICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgICAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICAgICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAgICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICAgICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAgICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgICAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAgICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICAgICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgICAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gaW5uZXJOb2RlLmRhdGEpKSAmJiBpc0RlZigoaSA9IGkudHJhbnNpdGlvbikpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgICAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluc2VydChwYXJlbnQsIGVsbSwgcmVmKSB7XG4gICAgICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYocmVmKSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlT3BzLnBhcmVudE5vZGUocmVmKSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaV8xID0gMDsgaV8xIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2lfMSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXzFdLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGlfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlKHZub2RlKSB7XG4gICAgICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgICAgZm9yICh2YXIgaV8yID0gMDsgaV8yIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraV8yKSB7XG4gICAgICAgICAgICBjYnMuY3JlYXRlW2lfMl0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICAgICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKVxuICAgICAgICAgICAgICAgIGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgICAgICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSlcbiAgICAgICAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAgIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgICBmdW5jdGlvbiBzZXRTY29wZSh2bm9kZSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKGlzRGVmKChpID0gdm5vZGUuZm5TY29wZUlkKSkpIHtcbiAgICAgICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBhbmNlc3Rvci5jb250ZXh0KSkgJiYgaXNEZWYoKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICAgICAgaWYgKGlzRGVmKChpID0gYWN0aXZlSW5zdGFuY2UpKSAmJlxuICAgICAgICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXG4gICAgICAgICAgICBpc0RlZigoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSkge1xuICAgICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rKHZub2RlKSB7XG4gICAgICAgIHZhciBpLCBqO1xuICAgICAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gZGF0YS5ob29rKSkgJiYgaXNEZWYoKGkgPSBpLmRlc3Ryb3kpKSlcbiAgICAgICAgICAgICAgICBpKHZub2RlKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXSh2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKChpID0gdm5vZGUuY2hpbGRyZW4pKSkge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZVZub2Rlcyh2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgICAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGV4dCBub2RlXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayh2bm9kZSwgcm0pIHtcbiAgICAgICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgICAgICAgdmFyIGlfMztcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuICAgICAgICAgICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICAgICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgICAgICAgaWYgKGlzRGVmKChpXzMgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpICYmXG4gICAgICAgICAgICAgICAgaXNEZWYoKGlfMyA9IGlfMy5fdm5vZGUpKSAmJlxuICAgICAgICAgICAgICAgIGlzRGVmKGlfMy5kYXRhKSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaV8zLCBybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGlfMyA9IDA7IGlfMyA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2lfMykge1xuICAgICAgICAgICAgICAgIGNicy5yZW1vdmVbaV8zXSh2bm9kZSwgcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGVmKChpXzMgPSB2bm9kZS5kYXRhLmhvb2spKSAmJiBpc0RlZigoaV8zID0gaV8zLnJlbW92ZSkpKSB7XG4gICAgICAgICAgICAgICAgaV8zKHZub2RlLCBybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBybSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICAgICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICAgICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICAgICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgICAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgICAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCB2bm9kZVRvTW92ZSwgcmVmRWxtO1xuICAgICAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAgICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgICAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgICAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKG5ld0NoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcbiAgICAgICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICAgICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgICAgICAgICAgY2FuTW92ZSAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgICAgIGNhbk1vdmUgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpXG4gICAgICAgICAgICAgICAgICAgIG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICAgICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXG4gICAgICAgICAgICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNhbWVWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbk1vdmUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgICAgIGZvciAodmFyIGlfNCA9IDA7IGlfNCA8IGNoaWxkcmVuLmxlbmd0aDsgaV80KyspIHtcbiAgICAgICAgICAgIHZhciB2bm9kZSA9IGNoaWxkcmVuW2lfNF07XG4gICAgICAgICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgICAgICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VlbktleXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcIi5jb25jYXQoa2V5LCBcIicuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5cIiksIHZub2RlLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VlbktleXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgICAgICBmb3IgKHZhciBpXzUgPSBzdGFydDsgaV81IDwgZW5kOyBpXzUrKykge1xuICAgICAgICAgICAgdmFyIGMgPSBvbGRDaFtpXzVdO1xuICAgICAgICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaV81O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG93bmVyQXJyYXksIGluZGV4LCByZW1vdmVPbmx5KSB7XG4gICAgICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgICAgICAgLy8gY2xvbmUgcmV1c2VkIHZub2RlXG4gICAgICAgICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsbSA9ICh2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG0pO1xuICAgICAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgICAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAgICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICAgICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgICAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgICAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAgICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSkpIHtcbiAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChpID0gZGF0YS5ob29rKSkgJiYgaXNEZWYoKGkgPSBpLnByZXBhdGNoKSkpIHtcbiAgICAgICAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IGRhdGEuaG9vaykpICYmIGlzRGVmKChpID0gaS51cGRhdGUpKSlcbiAgICAgICAgICAgICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZENoICE9PSBjaClcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICAgICAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVWbm9kZXMob2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IGRhdGEuaG9vaykpICYmIGlzRGVmKChpID0gaS5wb3N0cGF0Y2gpKSlcbiAgICAgICAgICAgICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAgICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaV82ID0gMDsgaV82IDwgcXVldWUubGVuZ3RoOyArK2lfNikge1xuICAgICAgICAgICAgICAgIHF1ZXVlW2lfNl0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXzZdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gICAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICAgIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAgIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICAgIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG4gICAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgICBmdW5jdGlvbiBoeWRyYXRlKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgdGFnID0gdm5vZGUudGFnLCBkYXRhID0gdm5vZGUuZGF0YSwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICAgICAgdm5vZGUuZWxtID0gZWxtO1xuICAgICAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gZGF0YS5ob29rKSkgJiYgaXNEZWYoKGkgPSBpLmluaXQpKSlcbiAgICAgICAgICAgICAgICBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7XG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgICAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB2LWh0bWwgYW5kIGRvbVByb3BzOiBpbm5lckhUTUxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gZGF0YSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RlZigoaSA9IGkuZG9tUHJvcHMpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEZWYoKGkgPSBpLmlubmVySFRNTCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gZWxtLmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzcgPSAwOyBpXzcgPCBjaGlsZHJlbi5sZW5ndGg7IGlfNysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpXzddLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgICAgICAgIHZhciBmdWxsSW52b2tlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgICAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgICAgICAgIHJldHVybiAodm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICghaXNVbmtub3duRWxlbWVudCh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICAgICAgICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gcGF0Y2gob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHkpIHtcbiAgICAgICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKVxuICAgICAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICAgICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgICAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVtb3ZlT25seSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgICAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgICAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRFbG0gPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgICAgICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgXG4gICAgICAgICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKSk7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGF0Y2hhYmxlID0gaXNQYXRjaGFibGUodm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfOCA9IDA7IGlfOCA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpXzgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXzhdKGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzkgPSAwOyBpXzkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpXzkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXzldKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAjNjUxM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnNlcnRfMSA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc2VydF8xLm1lcmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xvbmUgaW5zZXJ0IGhvb2tzIHRvIGF2b2lkIGJlaW5nIG11dGF0ZWQgZHVyaW5nIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgY3VzdG9tZWQgZGlyZWN0aXZlcyB1bmRlciB0cmFuc2l0aW9uIGdyb3VwLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvbmVkID0gaW5zZXJ0XzEuZm5zLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzEwID0gMDsgaV8xMCA8IGNsb25lZC5sZW5ndGg7IGlfMTArKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkW2lfMTBdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgICAgIHJldHVybiB2bm9kZS5lbG07XG4gICAgfTtcbn1cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICAgIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzKHZub2RlKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZW1wdHlOb2RlIGlzIG5vdCBWTm9kZVdpdGhEYXRhXG4gICAgICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXModm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcbiAgICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcbiAgICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICAgICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgICAgICBpZiAoIW9sZERpcikge1xuICAgICAgICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgICAgICAgY2FsbEhvb2soZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICAgICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgICAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgICAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgICAgICAgIGRpci5vbGRBcmcgPSBvbGREaXIuYXJnO1xuICAgICAgICAgICAgY2FsbEhvb2soZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNhbGxIb29rKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsSG9vayhkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0NyZWF0ZSkge1xuICAgICAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICAgICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAgICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgICAgICAgICBjYWxsSG9vayhvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyhkaXJzLCB2bSkge1xuICAgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmICghZGlycykge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgdmFyIGksIGRpcjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkaXIgPSBkaXJzW2ldO1xuICAgICAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgICAgICB9XG4gICAgICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgICAgICBpZiAodm0uX3NldHVwU3RhdGUgJiYgdm0uX3NldHVwU3RhdGUuX19zZmMpIHtcbiAgICAgICAgICAgIHZhciBzZXR1cERlZiA9IGRpci5kZWYgfHwgcmVzb2x2ZUFzc2V0KHZtLCAnX3NldHVwU3RhdGUnLCAndi0nICsgZGlyLm5hbWUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR1cERlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGRpci5kZWYgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmQ6IHNldHVwRGVmLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHNldHVwRGVmLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXIuZGVmID0gc2V0dXBEZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGlyLmRlZiA9IGRpci5kZWYgfHwgcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUoZGlyKSB7XG4gICAgcmV0dXJuIChkaXIucmF3TmFtZSB8fCBcIlwiLmNvbmNhdChkaXIubmFtZSwgXCIuXCIpLmNvbmNhdChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKTtcbn1cbmZ1bmN0aW9uIGNhbGxIb29rKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gICAgaWYgKGZuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCBcImRpcmVjdGl2ZSBcIi5jb25jYXQoZGlyLm5hbWUsIFwiIFwiKS5jb25jYXQoaG9vaywgXCIgaG9va1wiKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtyZWYsIGRpcmVjdGl2ZXNdO1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAgIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gICAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gICAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykgfHwgaXNUcnVlKGF0dHJzLl92X2F0dHJfcHJveHkpKSB7XG4gICAgICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgICAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgICAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgICAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1ciwgdm5vZGUuZGF0YS5wcmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gICAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgICAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgICAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuICAgICAgICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0QXR0cihlbCwga2V5LCB2YWx1ZSwgaXNJblByZSkge1xuICAgIGlmIChpc0luUHJlIHx8IGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAgICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAgICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICAgICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgICAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICAgICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJyA/ICd0cnVlJyA6IGtleTtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgY29udmVydEVudW1lcmF0ZWRWYWx1ZShrZXksIHZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgICAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgICAgICFpc0lFOSAmJlxuICAgICAgICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAgICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmXG4gICAgICAgICAgICB2YWx1ZSAhPT0gJycgJiZcbiAgICAgICAgICAgICFlbC5fX2llcGgpIHtcbiAgICAgICAgICAgIHZhciBibG9ja2VyXzEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyXzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcl8xKTtcbiAgICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgICAgICB9XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG59XG52YXIgYXR0cnMgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmXG4gICAgICAgIChpc1VuZGVmKG9sZERhdGEpIHx8XG4gICAgICAgICAgICAoaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJiBpc1VuZGVmKG9sZERhdGEuY2xhc3MpKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG4gICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICAgIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gICAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICAgICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gICAgfVxuICAgIC8vIHNldCB0aGUgY2xhc3NcbiAgICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgICAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICAgIH1cbn1cbnZhciBrbGFzcyA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICAgIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzKG9uKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAgICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgICAgICB2YXIgZXZlbnRfMSA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgICAgIG9uW2V2ZW50XzFdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRfMV0gfHwgW10pO1xuICAgICAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICAgIH1cbiAgICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAgIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgICAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xuICAgICAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICAgIH1cbn1cbnZhciB0YXJnZXQ7XG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSkge1xuICAgIHZhciBfdGFyZ2V0ID0gdGFyZ2V0OyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICAgIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlcigpIHtcbiAgICAgICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVtb3ZlKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLy8gIzk0NDY6IEZpcmVmb3ggPD0gNTMgKGluIHBhcnRpY3VsYXIsIEVTUiA1MikgaGFzIGluY29ycmVjdCBFdmVudC50aW1lU3RhbXBcbi8vIGltcGxlbWVudGF0aW9uIGFuZCBkb2VzIG5vdCBmaXJlIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbiwgc29cbi8vIHNhZmUgdG8gZXhjbHVkZS5cbnZhciB1c2VNaWNyb3Rhc2tGaXggPSBpc1VzaW5nTWljcm9UYXNrICYmICEoaXNGRiAmJiBOdW1iZXIoaXNGRlsxXSkgPD0gNTMpO1xuZnVuY3Rpb24gYWRkKG5hbWUsIGhhbmRsZXIsIGNhcHR1cmUsIHBhc3NpdmUpIHtcbiAgICAvLyBhc3luYyBlZGdlIGNhc2UgIzY1NjY6IGlubmVyIGNsaWNrIGV2ZW50IHRyaWdnZXJzIHBhdGNoLCBldmVudCBoYW5kbGVyXG4gICAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcbiAgICAvLyBoYXBwZW5zIGJlY2F1c2UgYnJvd3NlcnMgZmlyZSBtaWNyb3Rhc2sgdGlja3MgYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbi5cbiAgICAvLyB0aGUgc29sdXRpb24gaXMgc2ltcGxlOiB3ZSBzYXZlIHRoZSB0aW1lc3RhbXAgd2hlbiBhIGhhbmRsZXIgaXMgYXR0YWNoZWQsXG4gICAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxuICAgIC8vIEFGVEVSIGl0IHdhcyBhdHRhY2hlZC5cbiAgICBpZiAodXNlTWljcm90YXNrRml4KSB7XG4gICAgICAgIHZhciBhdHRhY2hlZFRpbWVzdGFtcF8xID0gY3VycmVudEZsdXNoVGltZXN0YW1wO1xuICAgICAgICB2YXIgb3JpZ2luYWxfMSA9IGhhbmRsZXI7XG4gICAgICAgIC8vQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBoYW5kbGVyID0gb3JpZ2luYWxfMS5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBubyBidWJibGluZywgc2hvdWxkIGFsd2F5cyBmaXJlLlxuICAgICAgICAgICAgLy8gdGhpcyBpcyBqdXN0IGEgc2FmZXR5IG5ldCBpbiBjYXNlIGV2ZW50LnRpbWVTdGFtcCBpcyB1bnJlbGlhYmxlIGluXG4gICAgICAgICAgICAvLyBjZXJ0YWluIHdlaXJkIGVudmlyb25tZW50cy4uLlxuICAgICAgICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fFxuICAgICAgICAgICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxuICAgICAgICAgICAgICAgIGUudGltZVN0YW1wID49IGF0dGFjaGVkVGltZXN0YW1wXzEgfHxcbiAgICAgICAgICAgICAgICAvLyBiYWlsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBoYXZlIGJ1Z2d5IGV2ZW50LnRpbWVTdGFtcCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICAgICAgICAvLyAjOTQ2MiBpT1MgOSBidWc6IGV2ZW50LnRpbWVTdGFtcCBpcyAwIGFmdGVyIGhpc3RvcnkucHVzaFN0YXRlXG4gICAgICAgICAgICAgICAgLy8gIzk2ODEgUXRXZWJFbmdpbmUgZXZlbnQudGltZVN0YW1wIGlzIG5lZ2F0aXZlIHZhbHVlXG4gICAgICAgICAgICAgICAgZS50aW1lU3RhbXAgPD0gMCB8fFxuICAgICAgICAgICAgICAgIC8vICM5NDQ4IGJhaWwgaWYgZXZlbnQgaXMgZmlyZWQgaW4gYW5vdGhlciBkb2N1bWVudCBpbiBhIG11bHRpLXBhZ2VcbiAgICAgICAgICAgICAgICAvLyBlbGVjdHJvbi9udy5qcyBhcHAsIHNpbmNlIGV2ZW50LnRpbWVTdGFtcCB3aWxsIGJlIHVzaW5nIGEgZGlmZmVyZW50XG4gICAgICAgICAgICAgICAgLy8gc3RhcnRpbmcgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgZS50YXJnZXQub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxfMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyLCBzdXBwb3J0c1Bhc3NpdmUgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfSA6IGNhcHR1cmUpO1xufVxuZnVuY3Rpb24gcmVtb3ZlKG5hbWUsIGhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpIHtcbiAgICAoX3RhcmdldCB8fCB0YXJnZXQpLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgXG4gICAgLy9AdHMtZXhwZWN0LWVycm9yXG4gICAgaGFuZGxlci5fd3JhcHBlciB8fCBoYW5kbGVyLCBjYXB0dXJlKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICAgIC8vIHZub2RlIGlzIGVtcHR5IHdoZW4gcmVtb3ZpbmcgYWxsIGxpc3RlbmVycyxcbiAgICAvLyBhbmQgdXNlIG9sZCB2bm9kZSBkb20gZWxlbWVudFxuICAgIHRhcmdldCA9IHZub2RlLmVsbSB8fCBvbGRWbm9kZS5lbG07XG4gICAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQsIHJlbW92ZSwgY3JlYXRlT25jZUhhbmRsZXIsIHZub2RlLmNvbnRleHQpO1xuICAgIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cbnZhciBldmVudHMgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gICAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBlbXB0eU5vZGUgaGFzIGFjdHVhbGx5IGRhdGFcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAodm5vZGUpIHsgcmV0dXJuIHVwZGF0ZURPTUxpc3RlbmVycyh2bm9kZSwgZW1wdHlOb2RlKTsgfVxufTtcblxudmFyIHN2Z0NvbnRhaW5lcjtcbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIga2V5LCBjdXI7XG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAgIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gICAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gICAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykgfHwgaXNUcnVlKHByb3BzLl92X2F0dHJfcHJveHkpKSB7XG4gICAgICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgICAgICBpZiAoIShrZXkgaW4gcHJvcHMpKSB7XG4gICAgICAgICAgICBlbG1ba2V5XSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgICAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgICAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgICAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgICAgICAgIGlmICh2bm9kZS5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgICAgICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgICAgICAgIC8vIHJlcGxhY2VkIGJ5IGlubmVySFRNTC90ZXh0Q29udGVudCByZXRhaW5zIGl0cyBwYXJlbnROb2RlIHByb3BlcnR5XG4gICAgICAgICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmIGVsbS50YWdOYW1lICE9PSAnUFJPR1JFU1MnKSB7XG4gICAgICAgICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgICAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgICAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgJiZcbiAgICAgICAgICAgIGlzU1ZHKGVsbS50YWdOYW1lKSAmJlxuICAgICAgICAgICAgaXNVbmRlZihlbG0uaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgLy8gSUUgZG9lc24ndCBzdXBwb3J0IGlubmVySFRNTCBmb3IgU1ZHIGVsZW1lbnRzXG4gICAgICAgICAgICBzdmdDb250YWluZXIgPSBzdmdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBzdmdDb250YWluZXIuaW5uZXJIVE1MID0gXCI8c3ZnPlwiLmNvbmNhdChjdXIsIFwiPC9zdmc+XCIpO1xuICAgICAgICAgICAgdmFyIHN2ZyA9IHN2Z0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGVsbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChzdmcuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGVsbS5hcHBlbmRDaGlsZChzdmcuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgIC8vIHNraXAgdGhlIHVwZGF0ZSBpZiBvbGQgYW5kIG5ldyBWRE9NIHN0YXRlIGlzIHRoZSBzYW1lLlxuICAgICAgICAvLyBgdmFsdWVgIGlzIGhhbmRsZWQgc2VwYXJhdGVseSBiZWNhdXNlIHRoZSBET00gdmFsdWUgbWF5IGJlIHRlbXBvcmFyaWx5XG4gICAgICAgIC8vIG91dCBvZiBzeW5jIHdpdGggVkRPTSBzdGF0ZSBkdWUgdG8gZm9jdXMsIGNvbXBvc2l0aW9uIGFuZCBtb2RpZmllcnMuXG4gICAgICAgIC8vIFRoaXMgICM0NTIxIGJ5IHNraXBwaW5nIHRoZSB1bm5lY2Vzc2FyeSBgY2hlY2tlZGAgdXBkYXRlLlxuICAgICAgICBjdXIgIT09IG9sZFByb3BzW2tleV0pIHtcbiAgICAgICAgICAgIC8vIHNvbWUgcHJvcGVydHkgdXBkYXRlcyBjYW4gdGhyb3dcbiAgICAgICAgICAgIC8vIGUuZy4gYHZhbHVlYCBvbiA8cHJvZ3Jlc3M+IHcvIG5vbi1maW5pdGUgdmFsdWVcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZShlbG0sIGNoZWNrVmFsKSB7XG4gICAgcmV0dXJuIChcbiAgICAvL0B0cy1leHBlY3QtZXJyb3JcbiAgICAhZWxtLmNvbXBvc2luZyAmJlxuICAgICAgICAoZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgICAgICAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgICAgICAgICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbCkpKTtcbn1cbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHtcbiAgICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gICAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gICAgdmFyIG5vdEluRm9jdXMgPSB0cnVlO1xuICAgIC8vICM2MTU3XG4gICAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gICAgdHJ5IHtcbiAgICAgICAgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWw7XG59XG5mdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIG5ld1ZhbCkge1xuICAgIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xuICAgICAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWw7XG59XG52YXIgZG9tUHJvcHMgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICAgIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gICAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICAgICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xufSk7XG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhKGRhdGEpIHtcbiAgICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gICAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gICAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZSA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSkgOiBzdHlsZTtcbn1cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyhiaW5kaW5nU3R5bGUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSk7XG4gICAgfVxuICAgIHJldHVybiBiaW5kaW5nU3R5bGU7XG59XG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBzdHlsZURhdGE7XG4gICAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgICAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSAmJlxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5kYXRhICYmXG4gICAgICAgICAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gICAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHBhcmVudE5vZGUucGFyZW50IG5vdCBWTm9kZVdpdGhEYXRhXG4gICAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShoeXBoZW5hdGUobmFtZSksIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgICAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgICAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG59O1xudmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gICAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIHByb3AgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgICByZXR1cm4gcHJvcDtcbiAgICB9XG4gICAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lXzEgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgICAgIGlmIChuYW1lXzEgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVfMTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuZnVuY3Rpb24gdXBkYXRlU3R5bGUob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJlxuICAgICAgICBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0eWxlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjdXIsIG5hbWU7XG4gICAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICAgIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gICAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG4gICAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG4gICAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuICAgIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gICAgLy8gdG8gbXV0YXRlIGl0LlxuICAgIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKSA/IGV4dGVuZCh7fSwgc3R5bGUpIDogc3R5bGU7XG4gICAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuICAgIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgICAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgICAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICAgICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbn1cbnZhciBzdHlsZSA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICAgIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbnZhciB3aGl0ZXNwYWNlUkUgPSAvXFxzKy87XG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjbHMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgICAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgY3VyID0gXCIgXCIuY29uY2F0KGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJywgXCIgXCIpO1xuICAgICAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgY2xzKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICAgICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGN1ciA9IFwiIFwiLmNvbmNhdChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycsIFwiIFwiKTtcbiAgICAgICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICAgICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbihkZWYpIHtcbiAgICBpZiAoIWRlZikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHR5cGVvZiBkZWYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgaWYgKGRlZi5jc3MgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYubmFtZSB8fCAndicpKTtcbiAgICAgICAgfVxuICAgICAgICBleHRlbmQocmVzLCBkZWYpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmKTtcbiAgICB9XG59XG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbnRlckNsYXNzOiBcIlwiLmNvbmNhdChuYW1lLCBcIi1lbnRlclwiKSxcbiAgICAgICAgZW50ZXJUb0NsYXNzOiBcIlwiLmNvbmNhdChuYW1lLCBcIi1lbnRlci10b1wiKSxcbiAgICAgICAgZW50ZXJBY3RpdmVDbGFzczogXCJcIi5jb25jYXQobmFtZSwgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgICAgICBsZWF2ZUNsYXNzOiBcIlwiLmNvbmNhdChuYW1lLCBcIi1sZWF2ZVwiKSxcbiAgICAgICAgbGVhdmVUb0NsYXNzOiBcIlwiLmNvbmNhdChuYW1lLCBcIi1sZWF2ZS10b1wiKSxcbiAgICAgICAgbGVhdmVBY3RpdmVDbGFzczogXCJcIi5jb25jYXQobmFtZSwgXCItbGVhdmUtYWN0aXZlXCIpXG4gICAgfTtcbn0pO1xudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICAgICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICAgIH1cbiAgICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgICAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICAgIH1cbn1cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlclxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgICAgIDogc2V0VGltZW91dFxuICAgIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZuKSB7IHJldHVybiBmbigpOyB9O1xuZnVuY3Rpb24gbmV4dEZyYW1lKGZuKSB7XG4gICAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICByYWYoZm4pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgICAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XG4gICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICByZW1vdmUkMihlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gICAgfVxuICAgIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzKGVsLCBleHBlY3RlZFR5cGUsIGNiKSB7XG4gICAgdmFyIF9hID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSksIHR5cGUgPSBfYS50eXBlLCB0aW1lb3V0ID0gX2EudGltZW91dCwgcHJvcENvdW50ID0gX2EucHJvcENvdW50O1xuICAgIGlmICghdHlwZSlcbiAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICAgIHZhciBlbmRlZCA9IDA7XG4gICAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgICAgICBjYigpO1xuICAgIH07XG4gICAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgICAgICAgICAgZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgICAgICAgIGVuZCgpO1xuICAgICAgICB9XG4gICAgfSwgdGltZW91dCArIDEpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gICAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICAgIHZhciBhbmltYXRpb25EZWxheXMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuICAgIHZhciB0eXBlO1xuICAgIHZhciB0aW1lb3V0ID0gMDtcbiAgICB2YXIgcHJvcENvdW50ID0gMDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgICAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICAgICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgICAgICB0eXBlID1cbiAgICAgICAgICAgIHRpbWVvdXQgPiAwXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgICAgICAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgICAgICAgICAgICAgIDogQU5JTUFUSU9OXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICAgICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgICAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgICAgICA6IDA7XG4gICAgfVxuICAgIHZhciBoYXNUcmFuc2Zvcm0gPSB0eXBlID09PSBUUkFOU0lUSU9OICYmIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgICAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRUaW1lb3V0KGRlbGF5cywgZHVyYXRpb25zKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKTtcbiAgICB9KSk7XG59XG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlciBudW1iZXJzXG4vLyBpbiBhIGxvY2FsZS1kZXBlbmRlbnQgd2F5LCB1c2luZyBhIGNvbW1hIGluc3RlYWQgb2YgYSBkb3QuXG4vLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duIChpLmUuIGFjdGluZ1xuLy8gYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xuZnVuY3Rpb24gdG9NcyhzKSB7XG4gICAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKCcsJywgJy4nKSkgKiAxMDAwO1xufVxuXG5mdW5jdGlvbiBlbnRlcih2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICAgIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICAgICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgZWwuX2xlYXZlQ2IoKTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICAgIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjc3MgPSBkYXRhLmNzcywgdHlwZSA9IGRhdGEudHlwZSwgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcywgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3MsIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3MsIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcywgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcywgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzLCBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXIsIGVudGVyID0gZGF0YS5lbnRlciwgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlciwgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkLCBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhciwgYXBwZWFyID0gZGF0YS5hcHBlYXIsIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhciwgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQsIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcbiAgICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gICAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gICAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICAgICAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICB9XG4gICAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuICAgIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzID8gYXBwZWFyQ2xhc3MgOiBlbnRlckNsYXNzO1xuICAgIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICAgIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzcyA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3M7XG4gICAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyID8gYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyIDogYmVmb3JlRW50ZXI7XG4gICAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyID8gKGlzRnVuY3Rpb24oYXBwZWFyKSA/IGFwcGVhciA6IGVudGVyKSA6IGVudGVyO1xuICAgIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyID8gYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlciA6IGFmdGVyRW50ZXI7XG4gICAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgICAgID8gYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkXG4gICAgICAgIDogZW50ZXJDYW5jZWxsZWQ7XG4gICAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKGlzT2JqZWN0KGR1cmF0aW9uKSA/IGR1cmF0aW9uLmVudGVyIDogZHVyYXRpb24pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gICAgfVxuICAgIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gICAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG4gICAgdmFyIGNiID0gKGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gICAgfSkpO1xuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgICAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICAgICAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgICAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH1cbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgY2IoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsZWF2ZSh2bm9kZSwgcm0pIHtcbiAgICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gICAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGVsLl9lbnRlckNiKCk7XG4gICAgfVxuICAgIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgICByZXR1cm4gcm0oKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjc3MgPSBkYXRhLmNzcywgdHlwZSA9IGRhdGEudHlwZSwgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcywgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3MsIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3MsIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZSwgbGVhdmUgPSBkYXRhLmxlYXZlLCBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlLCBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQsIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmUsIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcbiAgICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICAgIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG4gICAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKGlzT2JqZWN0KGR1cmF0aW9uKSA/IGR1cmF0aW9uLmxlYXZlIDogZHVyYXRpb24pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgICB9XG4gICAgdmFyIGNiID0gKGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgICAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBybSgpO1xuICAgICAgICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gICAgfSkpO1xuICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUoKSB7XG4gICAgICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgICAgICBpZiAoIXZub2RlLmRhdGEuc2hvdyAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbdm5vZGUua2V5XSA9XG4gICAgICAgICAgICAgICAgdm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgICAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24odmFsLCBuYW1lLCB2bm9kZSkge1xuICAgIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgICAgICB3YXJuKFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiLmNvbmNhdChuYW1lLCBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIikgK1xuICAgICAgICAgICAgXCJnb3QgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHZhbCksIFwiLlwiKSwgdm5vZGUuY29udGV4dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICAgICAgd2FybihcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIi5jb25jYXQobmFtZSwgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIpICtcbiAgICAgICAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJywgdm5vZGUuY29udGV4dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKTtcbn1cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGZuKSB7XG4gICAgaWYgKGlzVW5kZWYoZm4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICAgIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgICAgICAvLyBpbnZva2VyXG4gICAgICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKEFycmF5LmlzQXJyYXkoaW52b2tlckZucykgPyBpbnZva2VyRm5zWzBdIDogaW52b2tlckZucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZW50ZXIoXywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlKTtcbiAgICB9XG59XG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlclxuICAgID8ge1xuICAgICAgICBjcmVhdGU6IF9lbnRlcixcbiAgICAgICAgYWN0aXZhdGU6IF9lbnRlcixcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAodm5vZGUsIHJtKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA6IHt9O1xuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW2F0dHJzLCBrbGFzcywgZXZlbnRzLCBkb21Qcm9wcywgc3R5bGUsIHRyYW5zaXRpb25dO1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAgIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICAgICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxudmFyIGRpcmVjdGl2ZSA9IHtcbiAgICBpbnNlcnRlZDogZnVuY3Rpb24gKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICAgICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgIC8vICM2OTAzXG4gICAgICAgICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgICAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAgICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgICAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgICAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICAgICAgICB2YXIgcHJldk9wdGlvbnNfMSA9IGVsLl92T3B0aW9ucztcbiAgICAgICAgICAgIHZhciBjdXJPcHRpb25zXzEgPSAoZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpKTtcbiAgICAgICAgICAgIGlmIChjdXJPcHRpb25zXzEuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNfMVtpXSk7IH0pKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICAgICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zXzEpOyB9KVxuICAgICAgICAgICAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9uc18xKTtcbiAgICAgICAgICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKSB7XG4gICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pIHtcbiAgICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICAgIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gICAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgIHdhcm4oXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiLmNvbmNhdChiaW5kaW5nLmV4cHJlc3Npb24sIFwiXFxcIj4gXCIpICtcbiAgICAgICAgICAgICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiLmNvbmNhdChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoOCwgLTEpKSwgdm0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICAgICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSk7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZShvcHRpb24pIHtcbiAgICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uID8gb3B0aW9uLl92YWx1ZSA6IG9wdGlvbi52YWx1ZTtcbn1cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydChlKSB7XG4gICAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQoZSkge1xuICAgIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gICAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpXG4gICAgICAgIHJldHVybjtcbiAgICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cbmZ1bmN0aW9uIHRyaWdnZXIoZWwsIHR5cGUpIHtcbiAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSh2bm9kZSkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgICAgIDogdm5vZGU7XG59XG52YXIgc2hvdyA9IHtcbiAgICBiaW5kOiBmdW5jdGlvbiAoZWwsIF9hLCB2bm9kZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICAgICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IChlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5KTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZWwsIF9hLCB2bm9kZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZSwgb2xkVmFsdWUgPSBfYS5vbGRWYWx1ZTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdW5iaW5kOiBmdW5jdGlvbiAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gICAgICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgICBtb2RlbDogZGlyZWN0aXZlLFxuICAgIHNob3c6IHNob3dcbn07XG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICAgIG5hbWU6IFN0cmluZyxcbiAgICBhcHBlYXI6IEJvb2xlYW4sXG4gICAgY3NzOiBCb29sZWFuLFxuICAgIG1vZGU6IFN0cmluZyxcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZW50ZXJDbGFzczogU3RyaW5nLFxuICAgIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gICAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCh2bm9kZSkge1xuICAgIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2bm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEoY29tcCkge1xuICAgIHZhciBkYXRhID0ge307XG4gICAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAgIC8vIHByb3BzXG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgICB9XG4gICAgLy8gZXZlbnRzLlxuICAgIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICAgIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgZm9yICh2YXIga2V5IGluIGxpc3RlbmVycykge1xuICAgICAgICBkYXRhW2NhbWVsaXplKGtleSldID0gbGlzdGVuZXJzW2tleV07XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgICAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgICAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uKHZub2RlKSB7XG4gICAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWc7XG59XG52YXIgaXNOb3RUZXh0Tm9kZSA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH07XG52YXIgaXNWU2hvd0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfTtcbnZhciBUcmFuc2l0aW9uID0ge1xuICAgIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICAgIGFic3RyYWN0OiB0cnVlLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGlzTm90VGV4dE5vZGUpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHdhcm4oJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLCB0aGlzLiRwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuICAgICAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nKSB7XG4gICAgICAgICAgICB3YXJuKCdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSwgdGhpcy4kcGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgICAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICAgICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICAgICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiByYXdDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgICAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICAgICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIuY29uY2F0KHRoaXMuX3VpZCwgXCItXCIpO1xuICAgICAgICBjaGlsZC5rZXkgPVxuICAgICAgICAgICAgY2hpbGQua2V5ID09IG51bGxcbiAgICAgICAgICAgICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICAgICAgICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgICAgICAgICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgICAgICAgICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgICAgICAgICAgICAgPyBTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjaGlsZC5rZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaWQgKyBjaGlsZC5rZXlcbiAgICAgICAgICAgICAgICAgICAgOiBjaGlsZC5rZXk7XG4gICAgICAgIHZhciBkYXRhID0gKChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID1cbiAgICAgICAgICAgIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKSk7XG4gICAgICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgICAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuICAgICAgICAvLyBtYXJrIHYtc2hvd1xuICAgICAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICAgICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShpc1ZTaG93RGlyZWN0aXZlKSkge1xuICAgICAgICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkQ2hpbGQgJiZcbiAgICAgICAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAgICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcbiAgICAgICAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiZcbiAgICAgICAgICAgICAgICBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAgICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICAgICAgICB2YXIgb2xkRGF0YSA9IChvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpKTtcbiAgICAgICAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkZWxheWVkTGVhdmVfMTtcbiAgICAgICAgICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxheWVkTGVhdmVfMSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXllZExlYXZlXzEgPSBsZWF2ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmF3Q2hpbGQ7XG4gICAgfVxufTtcblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgICB0YWc6IFN0cmluZyxcbiAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcbmRlbGV0ZSBwcm9wcy5tb2RlO1xudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgICBwcm9wczogcHJvcHMsXG4gICAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHVwZGF0ZSA9IHRoaXMuX3VwZGF0ZTtcbiAgICAgICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgICAgICAgIHZhciByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZShfdGhpcyk7XG4gICAgICAgICAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgICAgICAgICBfdGhpcy5fX3BhdGNoX18oX3RoaXMuX3Zub2RlLCBfdGhpcy5rZXB0LCBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICAgICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBfdGhpcy5fdm5vZGUgPSBfdGhpcy5rZXB0O1xuICAgICAgICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgICAgICAgICB1cGRhdGUuY2FsbChfdGhpcywgdm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICAgIH07XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB2YXIgcHJldkNoaWxkcmVuID0gKHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbik7XG4gICAgICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgICAgIHZhciBjaGlsZHJlbiA9ICh0aGlzLmNoaWxkcmVuID0gW10pO1xuICAgICAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgICAgICAgICAgICBtYXBbYy5rZXldID0gYztcbiAgICAgICAgICAgICAgICAgICAgKGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBvcHRzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGdldENvbXBvbmVudE5hbWUob3B0cy5DdG9yLm9wdGlvbnMpIHx8IG9wdHMudGFnIHx8ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGMudGFnO1xuICAgICAgICAgICAgICAgICAgICB3YXJuKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIi5jb25jYXQobmFtZV8xLCBcIj5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICAgICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBwcmV2Q2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgYy5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgbm90IHR5cGVkIGluIE5vZGVcbiAgICAgICAgICAgICAgICBjLmRhdGEucG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcFtjLmtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAga2VwdC5wdXNoKGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbik7XG4gICAgfSxcbiAgICB1cGRhdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgICAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJztcbiAgICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAgICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcbiAgICAgICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICAgICAgICAgIHZhciBlbF8xID0gYy5lbG07XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBlbF8xLnN0eWxlO1xuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbF8xLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICAgICAgICAgIGVsXzEuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIChlbF8xLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbF8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxfMS5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxfMS5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbF8xLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgaGFzTW92ZTogZnVuY3Rpb24gKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAgICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgICAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgICAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgICAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICAgICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgICAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgICAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyhjKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICAgICAgYy5lbG0uX21vdmVDYigpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICAgICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbihjKSB7XG4gICAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbihjKSB7XG4gICAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gICAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gICAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgICBpZiAoZHggfHwgZHkpIHtcbiAgICAgICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdChkeCwgXCJweCxcIikuY29uY2F0KGR5LCBcInB4KVwiKTtcbiAgICAgICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICAgIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICAgIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChlbCwgaHlkcmF0aW5nKSB7XG4gICAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpO1xufTtcbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGluQnJvd3Nlcikge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICAgICAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXSgnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgICAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICAgICAgICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIik7XG4gICAgICAgIH1cbiAgICB9LCAwKTtcbn1cblxuZXhwb3J0IHsgRWZmZWN0U2NvcGUsIGNvbXB1dGVkLCBjdXN0b21SZWYsIFZ1ZSBhcyBkZWZhdWx0LCBkZWZpbmVBc3luY0NvbXBvbmVudCwgZGVmaW5lQ29tcG9uZW50LCBkZWwsIGVmZmVjdFNjb3BlLCBnZXRDdXJyZW50SW5zdGFuY2UsIGdldEN1cnJlbnRTY29wZSwgaCwgaW5qZWN0LCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgaXNTaGFsbG93LCBtYXJrUmF3LCBtZXJnZURlZmF1bHRzLCBuZXh0VGljaywgb25BY3RpdmF0ZWQsIG9uQmVmb3JlTW91bnQsIG9uQmVmb3JlVW5tb3VudCwgb25CZWZvcmVVcGRhdGUsIG9uRGVhY3RpdmF0ZWQsIG9uRXJyb3JDYXB0dXJlZCwgb25Nb3VudGVkLCBvblJlbmRlclRyYWNrZWQsIG9uUmVuZGVyVHJpZ2dlcmVkLCBvblNjb3BlRGlzcG9zZSwgb25TZXJ2ZXJQcmVmZXRjaCwgb25Vbm1vdW50ZWQsIG9uVXBkYXRlZCwgcHJvdmlkZSwgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiQxIGFzIHJlZiwgc2V0LCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRyaWdnZXJSZWYsIHVucmVmLCB1c2VBdHRycywgdXNlQ3NzTW9kdWxlLCB1c2VDc3NWYXJzLCB1c2VMaXN0ZW5lcnMsIHVzZVNsb3RzLCB2ZXJzaW9uLCB3YXRjaCwgd2F0Y2hFZmZlY3QsIHdhdGNoUG9zdEVmZmVjdCwgd2F0Y2hTeW5jRWZmZWN0IH07XG4iLCIvKiFcbiAqIHZ1ZXggdjMuNi4yXG4gKiAoYykgMjAyMSBFdmFuIFlvdVxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIGFwcGx5TWl4aW4gKFZ1ZSkge1xuICB2YXIgdmVyc2lvbiA9IE51bWJlcihWdWUudmVyc2lvbi5zcGxpdCgnLicpWzBdKTtcblxuICBpZiAodmVyc2lvbiA+PSAyKSB7XG4gICAgVnVlLm1peGluKHsgYmVmb3JlQ3JlYXRlOiB2dWV4SW5pdCB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdmVycmlkZSBpbml0IGFuZCBpbmplY3QgdnVleCBpbml0IHByb2NlZHVyZVxuICAgIC8vIGZvciAxLnggYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgdmFyIF9pbml0ID0gVnVlLnByb3RvdHlwZS5faW5pdDtcbiAgICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gICAgICBvcHRpb25zLmluaXQgPSBvcHRpb25zLmluaXRcbiAgICAgICAgPyBbdnVleEluaXRdLmNvbmNhdChvcHRpb25zLmluaXQpXG4gICAgICAgIDogdnVleEluaXQ7XG4gICAgICBfaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVnVleCBpbml0IGhvb2ssIGluamVjdGVkIGludG8gZWFjaCBpbnN0YW5jZXMgaW5pdCBob29rcyBsaXN0LlxuICAgKi9cblxuICBmdW5jdGlvbiB2dWV4SW5pdCAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgIC8vIHN0b3JlIGluamVjdGlvblxuICAgIGlmIChvcHRpb25zLnN0b3JlKSB7XG4gICAgICB0aGlzLiRzdG9yZSA9IHR5cGVvZiBvcHRpb25zLnN0b3JlID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gb3B0aW9ucy5zdG9yZSgpXG4gICAgICAgIDogb3B0aW9ucy5zdG9yZTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMucGFyZW50ICYmIG9wdGlvbnMucGFyZW50LiRzdG9yZSkge1xuICAgICAgdGhpcy4kc3RvcmUgPSBvcHRpb25zLnBhcmVudC4kc3RvcmU7XG4gICAgfVxuICB9XG59XG5cbnZhciB0YXJnZXQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICA/IHdpbmRvd1xuICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXG4gICAgPyBnbG9iYWxcbiAgICA6IHt9O1xudmFyIGRldnRvb2xIb29rID0gdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbmZ1bmN0aW9uIGRldnRvb2xQbHVnaW4gKHN0b3JlKSB7XG4gIGlmICghZGV2dG9vbEhvb2spIHsgcmV0dXJuIH1cblxuICBzdG9yZS5fZGV2dG9vbEhvb2sgPSBkZXZ0b29sSG9vaztcblxuICBkZXZ0b29sSG9vay5lbWl0KCd2dWV4OmluaXQnLCBzdG9yZSk7XG5cbiAgZGV2dG9vbEhvb2sub24oJ3Z1ZXg6dHJhdmVsLXRvLXN0YXRlJywgZnVuY3Rpb24gKHRhcmdldFN0YXRlKSB7XG4gICAgc3RvcmUucmVwbGFjZVN0YXRlKHRhcmdldFN0YXRlKTtcbiAgfSk7XG5cbiAgc3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uIChtdXRhdGlvbiwgc3RhdGUpIHtcbiAgICBkZXZ0b29sSG9vay5lbWl0KCd2dWV4Om11dGF0aW9uJywgbXV0YXRpb24sIHN0YXRlKTtcbiAgfSwgeyBwcmVwZW5kOiB0cnVlIH0pO1xuXG4gIHN0b3JlLnN1YnNjcmliZUFjdGlvbihmdW5jdGlvbiAoYWN0aW9uLCBzdGF0ZSkge1xuICAgIGRldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6YWN0aW9uJywgYWN0aW9uLCBzdGF0ZSk7XG4gIH0sIHsgcHJlcGVuZDogdHJ1ZSB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IGl0ZW0gdGhhdCBwYXNzIHRoZSB0ZXN0XG4gKiBieSBzZWNvbmQgYXJndW1lbnQgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gKiBAcmV0dXJuIHsqfVxuICovXG5mdW5jdGlvbiBmaW5kIChsaXN0LCBmKSB7XG4gIHJldHVybiBsaXN0LmZpbHRlcihmKVswXVxufVxuXG4vKipcbiAqIERlZXAgY29weSB0aGUgZ2l2ZW4gb2JqZWN0IGNvbnNpZGVyaW5nIGNpcmN1bGFyIHN0cnVjdHVyZS5cbiAqIFRoaXMgZnVuY3Rpb24gY2FjaGVzIGFsbCBuZXN0ZWQgb2JqZWN0cyBhbmQgaXRzIGNvcGllcy5cbiAqIElmIGl0IGRldGVjdHMgY2lyY3VsYXIgc3RydWN0dXJlLCB1c2UgY2FjaGVkIGNvcHkgdG8gYXZvaWQgaW5maW5pdGUgbG9vcC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBjYWNoZVxuICogQHJldHVybiB7Kn1cbiAqL1xuZnVuY3Rpb24gZGVlcENvcHkgKG9iaiwgY2FjaGUpIHtcbiAgaWYgKCBjYWNoZSA9PT0gdm9pZCAwICkgY2FjaGUgPSBbXTtcblxuICAvLyBqdXN0IHJldHVybiBpZiBvYmogaXMgaW1tdXRhYmxlIHZhbHVlXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICAvLyBpZiBvYmogaXMgaGl0LCBpdCBpcyBpbiBjaXJjdWxhciBzdHJ1Y3R1cmVcbiAgdmFyIGhpdCA9IGZpbmQoY2FjaGUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLm9yaWdpbmFsID09PSBvYmo7IH0pO1xuICBpZiAoaGl0KSB7XG4gICAgcmV0dXJuIGhpdC5jb3B5XG4gIH1cblxuICB2YXIgY29weSA9IEFycmF5LmlzQXJyYXkob2JqKSA/IFtdIDoge307XG4gIC8vIHB1dCB0aGUgY29weSBpbnRvIGNhY2hlIGF0IGZpcnN0XG4gIC8vIGJlY2F1c2Ugd2Ugd2FudCB0byByZWZlciBpdCBpbiByZWN1cnNpdmUgZGVlcENvcHlcbiAgY2FjaGUucHVzaCh7XG4gICAgb3JpZ2luYWw6IG9iaixcbiAgICBjb3B5OiBjb3B5XG4gIH0pO1xuXG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgY29weVtrZXldID0gZGVlcENvcHkob2JqW2tleV0sIGNhY2hlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvcHlcbn1cblxuLyoqXG4gKiBmb3JFYWNoIGZvciBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaFZhbHVlIChvYmosIGZuKSB7XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmbihvYmpba2V5XSwga2V5KTsgfSk7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG5mdW5jdGlvbiBpc1Byb21pc2UgKHZhbCkge1xuICByZXR1cm4gdmFsICYmIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG5mdW5jdGlvbiBhc3NlcnQgKGNvbmRpdGlvbiwgbXNnKSB7XG4gIGlmICghY29uZGl0aW9uKSB7IHRocm93IG5ldyBFcnJvcigoXCJbdnVleF0gXCIgKyBtc2cpKSB9XG59XG5cbmZ1bmN0aW9uIHBhcnRpYWwgKGZuLCBhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4oYXJnKVxuICB9XG59XG5cbi8vIEJhc2UgZGF0YSBzdHJ1Y3QgZm9yIHN0b3JlJ3MgbW9kdWxlLCBwYWNrYWdlIHdpdGggc29tZSBhdHRyaWJ1dGUgYW5kIG1ldGhvZFxudmFyIE1vZHVsZSA9IGZ1bmN0aW9uIE1vZHVsZSAocmF3TW9kdWxlLCBydW50aW1lKSB7XG4gIHRoaXMucnVudGltZSA9IHJ1bnRpbWU7XG4gIC8vIFN0b3JlIHNvbWUgY2hpbGRyZW4gaXRlbVxuICB0aGlzLl9jaGlsZHJlbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIFN0b3JlIHRoZSBvcmlnaW4gbW9kdWxlIG9iamVjdCB3aGljaCBwYXNzZWQgYnkgcHJvZ3JhbW1lclxuICB0aGlzLl9yYXdNb2R1bGUgPSByYXdNb2R1bGU7XG4gIHZhciByYXdTdGF0ZSA9IHJhd01vZHVsZS5zdGF0ZTtcblxuICAvLyBTdG9yZSB0aGUgb3JpZ2luIG1vZHVsZSdzIHN0YXRlXG4gIHRoaXMuc3RhdGUgPSAodHlwZW9mIHJhd1N0YXRlID09PSAnZnVuY3Rpb24nID8gcmF3U3RhdGUoKSA6IHJhd1N0YXRlKSB8fCB7fTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IG5hbWVzcGFjZWQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzLm5hbWVzcGFjZWQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISF0aGlzLl9yYXdNb2R1bGUubmFtZXNwYWNlZFxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIGFkZENoaWxkIChrZXksIG1vZHVsZSkge1xuICB0aGlzLl9jaGlsZHJlbltrZXldID0gbW9kdWxlO1xufTtcblxuTW9kdWxlLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkIChrZXkpIHtcbiAgZGVsZXRlIHRoaXMuX2NoaWxkcmVuW2tleV07XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24gZ2V0Q2hpbGQgKGtleSkge1xuICByZXR1cm4gdGhpcy5fY2hpbGRyZW5ba2V5XVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5oYXNDaGlsZCA9IGZ1bmN0aW9uIGhhc0NoaWxkIChrZXkpIHtcbiAgcmV0dXJuIGtleSBpbiB0aGlzLl9jaGlsZHJlblxufTtcblxuTW9kdWxlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKHJhd01vZHVsZSkge1xuICB0aGlzLl9yYXdNb2R1bGUubmFtZXNwYWNlZCA9IHJhd01vZHVsZS5uYW1lc3BhY2VkO1xuICBpZiAocmF3TW9kdWxlLmFjdGlvbnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUuYWN0aW9ucyA9IHJhd01vZHVsZS5hY3Rpb25zO1xuICB9XG4gIGlmIChyYXdNb2R1bGUubXV0YXRpb25zKSB7XG4gICAgdGhpcy5fcmF3TW9kdWxlLm11dGF0aW9ucyA9IHJhd01vZHVsZS5tdXRhdGlvbnM7XG4gIH1cbiAgaWYgKHJhd01vZHVsZS5nZXR0ZXJzKSB7XG4gICAgdGhpcy5fcmF3TW9kdWxlLmdldHRlcnMgPSByYXdNb2R1bGUuZ2V0dGVycztcbiAgfVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoQ2hpbGQgPSBmdW5jdGlvbiBmb3JFYWNoQ2hpbGQgKGZuKSB7XG4gIGZvckVhY2hWYWx1ZSh0aGlzLl9jaGlsZHJlbiwgZm4pO1xufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoR2V0dGVyID0gZnVuY3Rpb24gZm9yRWFjaEdldHRlciAoZm4pIHtcbiAgaWYgKHRoaXMuX3Jhd01vZHVsZS5nZXR0ZXJzKSB7XG4gICAgZm9yRWFjaFZhbHVlKHRoaXMuX3Jhd01vZHVsZS5nZXR0ZXJzLCBmbik7XG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaEFjdGlvbiA9IGZ1bmN0aW9uIGZvckVhY2hBY3Rpb24gKGZuKSB7XG4gIGlmICh0aGlzLl9yYXdNb2R1bGUuYWN0aW9ucykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUuYWN0aW9ucywgZm4pO1xuICB9XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hNdXRhdGlvbiA9IGZ1bmN0aW9uIGZvckVhY2hNdXRhdGlvbiAoZm4pIHtcbiAgaWYgKHRoaXMuX3Jhd01vZHVsZS5tdXRhdGlvbnMpIHtcbiAgICBmb3JFYWNoVmFsdWUodGhpcy5fcmF3TW9kdWxlLm11dGF0aW9ucywgZm4pO1xuICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggTW9kdWxlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBNb2R1bGVDb2xsZWN0aW9uID0gZnVuY3Rpb24gTW9kdWxlQ29sbGVjdGlvbiAocmF3Um9vdE1vZHVsZSkge1xuICAvLyByZWdpc3RlciByb290IG1vZHVsZSAoVnVleC5TdG9yZSBvcHRpb25zKVxuICB0aGlzLnJlZ2lzdGVyKFtdLCByYXdSb290TW9kdWxlLCBmYWxzZSk7XG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChtb2R1bGUsIGtleSkge1xuICAgIHJldHVybiBtb2R1bGUuZ2V0Q2hpbGQoa2V5KVxuICB9LCB0aGlzLnJvb3QpXG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXROYW1lc3BhY2UgPSBmdW5jdGlvbiBnZXROYW1lc3BhY2UgKHBhdGgpIHtcbiAgdmFyIG1vZHVsZSA9IHRoaXMucm9vdDtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIGtleSkge1xuICAgIG1vZHVsZSA9IG1vZHVsZS5nZXRDaGlsZChrZXkpO1xuICAgIHJldHVybiBuYW1lc3BhY2UgKyAobW9kdWxlLm5hbWVzcGFjZWQgPyBrZXkgKyAnLycgOiAnJylcbiAgfSwgJycpXG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUkMSAocmF3Um9vdE1vZHVsZSkge1xuICB1cGRhdGUoW10sIHRoaXMucm9vdCwgcmF3Um9vdE1vZHVsZSk7XG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyIChwYXRoLCByYXdNb2R1bGUsIHJ1bnRpbWUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICBpZiAoIHJ1bnRpbWUgPT09IHZvaWQgMCApIHJ1bnRpbWUgPSB0cnVlO1xuXG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICBhc3NlcnRSYXdNb2R1bGUocGF0aCwgcmF3TW9kdWxlKTtcbiAgfVxuXG4gIHZhciBuZXdNb2R1bGUgPSBuZXcgTW9kdWxlKHJhd01vZHVsZSwgcnVudGltZSk7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMucm9vdCA9IG5ld01vZHVsZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXQocGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIHBhcmVudC5hZGRDaGlsZChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIG5ld01vZHVsZSk7XG4gIH1cblxuICAvLyByZWdpc3RlciBuZXN0ZWQgbW9kdWxlc1xuICBpZiAocmF3TW9kdWxlLm1vZHVsZXMpIHtcbiAgICBmb3JFYWNoVmFsdWUocmF3TW9kdWxlLm1vZHVsZXMsIGZ1bmN0aW9uIChyYXdDaGlsZE1vZHVsZSwga2V5KSB7XG4gICAgICB0aGlzJDEucmVnaXN0ZXIocGF0aC5jb25jYXQoa2V5KSwgcmF3Q2hpbGRNb2R1bGUsIHJ1bnRpbWUpO1xuICAgIH0pO1xuICB9XG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24gdW5yZWdpc3RlciAocGF0aCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5nZXQocGF0aC5zbGljZSgwLCAtMSkpO1xuICB2YXIga2V5ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICB2YXIgY2hpbGQgPSBwYXJlbnQuZ2V0Q2hpbGQoa2V5KTtcblxuICBpZiAoIWNoaWxkKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIlt2dWV4XSB0cnlpbmcgdG8gdW5yZWdpc3RlciBtb2R1bGUgJ1wiICsga2V5ICsgXCInLCB3aGljaCBpcyBcIiArXG4gICAgICAgIFwibm90IHJlZ2lzdGVyZWRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoIWNoaWxkLnJ1bnRpbWUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHBhcmVudC5yZW1vdmVDaGlsZChrZXkpO1xufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUuaXNSZWdpc3RlcmVkID0gZnVuY3Rpb24gaXNSZWdpc3RlcmVkIChwYXRoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSk7XG4gIHZhciBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHJldHVybiBwYXJlbnQuaGFzQ2hpbGQoa2V5KVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG5mdW5jdGlvbiB1cGRhdGUgKHBhdGgsIHRhcmdldE1vZHVsZSwgbmV3TW9kdWxlKSB7XG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICBhc3NlcnRSYXdNb2R1bGUocGF0aCwgbmV3TW9kdWxlKTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSB0YXJnZXQgbW9kdWxlXG4gIHRhcmdldE1vZHVsZS51cGRhdGUobmV3TW9kdWxlKTtcblxuICAvLyB1cGRhdGUgbmVzdGVkIG1vZHVsZXNcbiAgaWYgKG5ld01vZHVsZS5tb2R1bGVzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG5ld01vZHVsZS5tb2R1bGVzKSB7XG4gICAgICBpZiAoIXRhcmdldE1vZHVsZS5nZXRDaGlsZChrZXkpKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIlt2dWV4XSB0cnlpbmcgdG8gYWRkIGEgbmV3IG1vZHVsZSAnXCIgKyBrZXkgKyBcIicgb24gaG90IHJlbG9hZGluZywgXCIgK1xuICAgICAgICAgICAgJ21hbnVhbCByZWxvYWQgaXMgbmVlZGVkJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUoXG4gICAgICAgIHBhdGguY29uY2F0KGtleSksXG4gICAgICAgIHRhcmdldE1vZHVsZS5nZXRDaGlsZChrZXkpLFxuICAgICAgICBuZXdNb2R1bGUubW9kdWxlc1trZXldXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZnVuY3Rpb25Bc3NlcnQgPSB7XG4gIGFzc2VydDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7IH0sXG4gIGV4cGVjdGVkOiAnZnVuY3Rpb24nXG59O1xuXG52YXIgb2JqZWN0QXNzZXJ0ID0ge1xuICBhc3NlcnQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmhhbmRsZXIgPT09ICdmdW5jdGlvbicpOyB9LFxuICBleHBlY3RlZDogJ2Z1bmN0aW9uIG9yIG9iamVjdCB3aXRoIFwiaGFuZGxlclwiIGZ1bmN0aW9uJ1xufTtcblxudmFyIGFzc2VydFR5cGVzID0ge1xuICBnZXR0ZXJzOiBmdW5jdGlvbkFzc2VydCxcbiAgbXV0YXRpb25zOiBmdW5jdGlvbkFzc2VydCxcbiAgYWN0aW9uczogb2JqZWN0QXNzZXJ0XG59O1xuXG5mdW5jdGlvbiBhc3NlcnRSYXdNb2R1bGUgKHBhdGgsIHJhd01vZHVsZSkge1xuICBPYmplY3Qua2V5cyhhc3NlcnRUeXBlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFyYXdNb2R1bGVba2V5XSkgeyByZXR1cm4gfVxuXG4gICAgdmFyIGFzc2VydE9wdGlvbnMgPSBhc3NlcnRUeXBlc1trZXldO1xuXG4gICAgZm9yRWFjaFZhbHVlKHJhd01vZHVsZVtrZXldLCBmdW5jdGlvbiAodmFsdWUsIHR5cGUpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgYXNzZXJ0T3B0aW9ucy5hc3NlcnQodmFsdWUpLFxuICAgICAgICBtYWtlQXNzZXJ0aW9uTWVzc2FnZShwYXRoLCBrZXksIHR5cGUsIHZhbHVlLCBhc3NlcnRPcHRpb25zLmV4cGVjdGVkKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VBc3NlcnRpb25NZXNzYWdlIChwYXRoLCBrZXksIHR5cGUsIHZhbHVlLCBleHBlY3RlZCkge1xuICB2YXIgYnVmID0ga2V5ICsgXCIgc2hvdWxkIGJlIFwiICsgZXhwZWN0ZWQgKyBcIiBidXQgXFxcIlwiICsga2V5ICsgXCIuXCIgKyB0eXBlICsgXCJcXFwiXCI7XG4gIGlmIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICBidWYgKz0gXCIgaW4gbW9kdWxlIFxcXCJcIiArIChwYXRoLmpvaW4oJy4nKSkgKyBcIlxcXCJcIjtcbiAgfVxuICBidWYgKz0gXCIgaXMgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsdWUpKSArIFwiLlwiO1xuICByZXR1cm4gYnVmXG59XG5cbnZhciBWdWU7IC8vIGJpbmQgb24gaW5zdGFsbFxuXG52YXIgU3RvcmUgPSBmdW5jdGlvbiBTdG9yZSAob3B0aW9ucykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgLy8gQXV0byBpbnN0YWxsIGlmIGl0IGlzIG5vdCBkb25lIHlldCBhbmQgYHdpbmRvd2AgaGFzIGBWdWVgLlxuICAvLyBUbyBhbGxvdyB1c2VycyB0byBhdm9pZCBhdXRvLWluc3RhbGxhdGlvbiBpbiBzb21lIGNhc2VzLFxuICAvLyB0aGlzIGNvZGUgc2hvdWxkIGJlIHBsYWNlZCBoZXJlLiBTZWUgIzczMVxuICBpZiAoIVZ1ZSAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XG4gICAgaW5zdGFsbCh3aW5kb3cuVnVlKTtcbiAgfVxuXG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICBhc3NlcnQoVnVlLCBcIm11c3QgY2FsbCBWdWUudXNlKFZ1ZXgpIGJlZm9yZSBjcmVhdGluZyBhIHN0b3JlIGluc3RhbmNlLlwiKTtcbiAgICBhc3NlcnQodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnLCBcInZ1ZXggcmVxdWlyZXMgYSBQcm9taXNlIHBvbHlmaWxsIGluIHRoaXMgYnJvd3Nlci5cIik7XG4gICAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBTdG9yZSwgXCJzdG9yZSBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3IuXCIpO1xuICB9XG5cbiAgdmFyIHBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnM7IGlmICggcGx1Z2lucyA9PT0gdm9pZCAwICkgcGx1Z2lucyA9IFtdO1xuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7IGlmICggc3RyaWN0ID09PSB2b2lkIDAgKSBzdHJpY3QgPSBmYWxzZTtcblxuICAvLyBzdG9yZSBpbnRlcm5hbCBzdGF0ZVxuICB0aGlzLl9jb21taXR0aW5nID0gZmFsc2U7XG4gIHRoaXMuX2FjdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9hY3Rpb25TdWJzY3JpYmVycyA9IFtdO1xuICB0aGlzLl9tdXRhdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl93cmFwcGVkR2V0dGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX21vZHVsZXMgPSBuZXcgTW9kdWxlQ29sbGVjdGlvbihvcHRpb25zKTtcbiAgdGhpcy5fbW9kdWxlc05hbWVzcGFjZU1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG4gIHRoaXMuX3dhdGNoZXJWTSA9IG5ldyBWdWUoKTtcbiAgdGhpcy5fbWFrZUxvY2FsR2V0dGVyc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvLyBiaW5kIGNvbW1pdCBhbmQgZGlzcGF0Y2ggdG8gc2VsZlxuICB2YXIgc3RvcmUgPSB0aGlzO1xuICB2YXIgcmVmID0gdGhpcztcbiAgdmFyIGRpc3BhdGNoID0gcmVmLmRpc3BhdGNoO1xuICB2YXIgY29tbWl0ID0gcmVmLmNvbW1pdDtcbiAgdGhpcy5kaXNwYXRjaCA9IGZ1bmN0aW9uIGJvdW5kRGlzcGF0Y2ggKHR5cGUsIHBheWxvYWQpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2guY2FsbChzdG9yZSwgdHlwZSwgcGF5bG9hZClcbiAgfTtcbiAgdGhpcy5jb21taXQgPSBmdW5jdGlvbiBib3VuZENvbW1pdCAodHlwZSwgcGF5bG9hZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBjb21taXQuY2FsbChzdG9yZSwgdHlwZSwgcGF5bG9hZCwgb3B0aW9ucylcbiAgfTtcblxuICAvLyBzdHJpY3QgbW9kZVxuICB0aGlzLnN0cmljdCA9IHN0cmljdDtcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9tb2R1bGVzLnJvb3Quc3RhdGU7XG5cbiAgLy8gaW5pdCByb290IG1vZHVsZS5cbiAgLy8gdGhpcyBhbHNvIHJlY3Vyc2l2ZWx5IHJlZ2lzdGVycyBhbGwgc3ViLW1vZHVsZXNcbiAgLy8gYW5kIGNvbGxlY3RzIGFsbCBtb2R1bGUgZ2V0dGVycyBpbnNpZGUgdGhpcy5fd3JhcHBlZEdldHRlcnNcbiAgaW5zdGFsbE1vZHVsZSh0aGlzLCBzdGF0ZSwgW10sIHRoaXMuX21vZHVsZXMucm9vdCk7XG5cbiAgLy8gaW5pdGlhbGl6ZSB0aGUgc3RvcmUgdm0sIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgcmVhY3Rpdml0eVxuICAvLyAoYWxzbyByZWdpc3RlcnMgX3dyYXBwZWRHZXR0ZXJzIGFzIGNvbXB1dGVkIHByb3BlcnRpZXMpXG4gIHJlc2V0U3RvcmVWTSh0aGlzLCBzdGF0ZSk7XG5cbiAgLy8gYXBwbHkgcGx1Z2luc1xuICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikgeyByZXR1cm4gcGx1Z2luKHRoaXMkMSk7IH0pO1xuXG4gIHZhciB1c2VEZXZ0b29scyA9IG9wdGlvbnMuZGV2dG9vbHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGV2dG9vbHMgOiBWdWUuY29uZmlnLmRldnRvb2xzO1xuICBpZiAodXNlRGV2dG9vbHMpIHtcbiAgICBkZXZ0b29sUGx1Z2luKHRoaXMpO1xuICB9XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDEgPSB7IHN0YXRlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycyQxLnN0YXRlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ZtLl9kYXRhLiQkc3RhdGVcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycyQxLnN0YXRlLnNldCA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICBhc3NlcnQoZmFsc2UsIFwidXNlIHN0b3JlLnJlcGxhY2VTdGF0ZSgpIHRvIGV4cGxpY2l0IHJlcGxhY2Ugc3RvcmUgc3RhdGUuXCIpO1xuICB9XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gY29tbWl0IChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gY2hlY2sgb2JqZWN0LXN0eWxlIGNvbW1pdFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKTtcbiAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICAgIHZhciBwYXlsb2FkID0gcmVmLnBheWxvYWQ7XG4gICAgdmFyIG9wdGlvbnMgPSByZWYub3B0aW9ucztcblxuICB2YXIgbXV0YXRpb24gPSB7IHR5cGU6IHR5cGUsIHBheWxvYWQ6IHBheWxvYWQgfTtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fbXV0YXRpb25zW3R5cGVdO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBtdXRhdGlvbiB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgZW50cnkuZm9yRWFjaChmdW5jdGlvbiBjb21taXRJdGVyYXRvciAoaGFuZGxlcikge1xuICAgICAgaGFuZGxlcihwYXlsb2FkKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgdGhpcy5fc3Vic2NyaWJlcnNcbiAgICAuc2xpY2UoKSAvLyBzaGFsbG93IGNvcHkgdG8gcHJldmVudCBpdGVyYXRvciBpbnZhbGlkYXRpb24gaWYgc3Vic2NyaWJlciBzeW5jaHJvbm91c2x5IGNhbGxzIHVuc3Vic2NyaWJlXG4gICAgLmZvckVhY2goZnVuY3Rpb24gKHN1YikgeyByZXR1cm4gc3ViKG11dGF0aW9uLCB0aGlzJDEuc3RhdGUpOyB9KTtcblxuICBpZiAoXG4gICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgb3B0aW9ucyAmJiBvcHRpb25zLnNpbGVudFxuICApIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIlt2dWV4XSBtdXRhdGlvbiB0eXBlOiBcIiArIHR5cGUgKyBcIi4gU2lsZW50IG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLiBcIiArXG4gICAgICAnVXNlIHRoZSBmaWx0ZXIgZnVuY3Rpb25hbGl0eSBpbiB0aGUgdnVlLWRldnRvb2xzJ1xuICAgICk7XG4gIH1cbn07XG5cblN0b3JlLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoIChfdHlwZSwgX3BheWxvYWQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAvLyBjaGVjayBvYmplY3Qtc3R5bGUgZGlzcGF0Y2hcbiAgdmFyIHJlZiA9IHVuaWZ5T2JqZWN0U3R5bGUoX3R5cGUsIF9wYXlsb2FkKTtcbiAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICAgIHZhciBwYXlsb2FkID0gcmVmLnBheWxvYWQ7XG5cbiAgdmFyIGFjdGlvbiA9IHsgdHlwZTogdHlwZSwgcGF5bG9hZDogcGF5bG9hZCB9O1xuICB2YXIgZW50cnkgPSB0aGlzLl9hY3Rpb25zW3R5cGVdO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBhY3Rpb24gdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLl9hY3Rpb25TdWJzY3JpYmVyc1xuICAgICAgLnNsaWNlKCkgLy8gc2hhbGxvdyBjb3B5IHRvIHByZXZlbnQgaXRlcmF0b3IgaW52YWxpZGF0aW9uIGlmIHN1YnNjcmliZXIgc3luY2hyb25vdXNseSBjYWxscyB1bnN1YnNjcmliZVxuICAgICAgLmZpbHRlcihmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIuYmVmb3JlOyB9KVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHN1YikgeyByZXR1cm4gc3ViLmJlZm9yZShhY3Rpb24sIHRoaXMkMS5zdGF0ZSk7IH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW3Z1ZXhdIGVycm9yIGluIGJlZm9yZSBhY3Rpb24gc3Vic2NyaWJlcnM6IFwiKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9IGVudHJ5Lmxlbmd0aCA+IDFcbiAgICA/IFByb21pc2UuYWxsKGVudHJ5Lm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gaGFuZGxlcihwYXlsb2FkKTsgfSkpXG4gICAgOiBlbnRyeVswXShwYXlsb2FkKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMkMS5fYWN0aW9uU3Vic2NyaWJlcnNcbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1Yi5hZnRlcjsgfSlcbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIuYWZ0ZXIoYWN0aW9uLCB0aGlzJDEuc3RhdGUpOyB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlt2dWV4XSBlcnJvciBpbiBhZnRlciBhY3Rpb24gc3Vic2NyaWJlcnM6IFwiKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlcyk7XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzJDEuX2FjdGlvblN1YnNjcmliZXJzXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIuZXJyb3I7IH0pXG4gICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHN1YikgeyByZXR1cm4gc3ViLmVycm9yKGFjdGlvbiwgdGhpcyQxLnN0YXRlLCBlcnJvcik7IH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiW3Z1ZXhdIGVycm9yIGluIGVycm9yIGFjdGlvbiBzdWJzY3JpYmVyczogXCIpO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfSk7XG4gIH0pXG59O1xuXG5TdG9yZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlIChmbiwgb3B0aW9ucykge1xuICByZXR1cm4gZ2VuZXJpY1N1YnNjcmliZShmbiwgdGhpcy5fc3Vic2NyaWJlcnMsIG9wdGlvbnMpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUuc3Vic2NyaWJlQWN0aW9uID0gZnVuY3Rpb24gc3Vic2NyaWJlQWN0aW9uIChmbiwgb3B0aW9ucykge1xuICB2YXIgc3VicyA9IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IHsgYmVmb3JlOiBmbiB9IDogZm47XG4gIHJldHVybiBnZW5lcmljU3Vic2NyaWJlKHN1YnMsIHRoaXMuX2FjdGlvblN1YnNjcmliZXJzLCBvcHRpb25zKVxufTtcblxuU3RvcmUucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gd2F0Y2ggKGdldHRlciwgY2IsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBnZXR0ZXIgPT09ICdmdW5jdGlvbicsIFwic3RvcmUud2F0Y2ggb25seSBhY2NlcHRzIGEgZnVuY3Rpb24uXCIpO1xuICB9XG4gIHJldHVybiB0aGlzLl93YXRjaGVyVk0uJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldHRlcih0aGlzJDEuc3RhdGUsIHRoaXMkMS5nZXR0ZXJzKTsgfSwgY2IsIG9wdGlvbnMpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gcmVwbGFjZVN0YXRlIChzdGF0ZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMkMS5fdm0uX2RhdGEuJCRzdGF0ZSA9IHN0YXRlO1xuICB9KTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5yZWdpc3Rlck1vZHVsZSA9IGZ1bmN0aW9uIHJlZ2lzdGVyTW9kdWxlIChwYXRoLCByYXdNb2R1bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7IHBhdGggPSBbcGF0aF07IH1cblxuICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGF0aCksIFwibW9kdWxlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBhbiBBcnJheS5cIik7XG4gICAgYXNzZXJ0KHBhdGgubGVuZ3RoID4gMCwgJ2Nhbm5vdCByZWdpc3RlciB0aGUgcm9vdCBtb2R1bGUgYnkgdXNpbmcgcmVnaXN0ZXJNb2R1bGUuJyk7XG4gIH1cblxuICB0aGlzLl9tb2R1bGVzLnJlZ2lzdGVyKHBhdGgsIHJhd01vZHVsZSk7XG4gIGluc3RhbGxNb2R1bGUodGhpcywgdGhpcy5zdGF0ZSwgcGF0aCwgdGhpcy5fbW9kdWxlcy5nZXQocGF0aCksIG9wdGlvbnMucHJlc2VydmVTdGF0ZSk7XG4gIC8vIHJlc2V0IHN0b3JlIHRvIHVwZGF0ZSBnZXR0ZXJzLi4uXG4gIHJlc2V0U3RvcmVWTSh0aGlzLCB0aGlzLnN0YXRlKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS51bnJlZ2lzdGVyTW9kdWxlID0gZnVuY3Rpb24gdW5yZWdpc3Rlck1vZHVsZSAocGF0aCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHsgcGF0aCA9IFtwYXRoXTsgfVxuXG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShwYXRoKSwgXCJtb2R1bGUgcGF0aCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIEFycmF5LlwiKTtcbiAgfVxuXG4gIHRoaXMuX21vZHVsZXMudW5yZWdpc3RlcihwYXRoKTtcbiAgdGhpcy5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudFN0YXRlID0gZ2V0TmVzdGVkU3RhdGUodGhpcyQxLnN0YXRlLCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgVnVlLmRlbGV0ZShwYXJlbnRTdGF0ZSwgcGF0aFtwYXRoLmxlbmd0aCAtIDFdKTtcbiAgfSk7XG4gIHJlc2V0U3RvcmUodGhpcyk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuaGFzTW9kdWxlID0gZnVuY3Rpb24gaGFzTW9kdWxlIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHsgcGF0aCA9IFtwYXRoXTsgfVxuXG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShwYXRoKSwgXCJtb2R1bGUgcGF0aCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIEFycmF5LlwiKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9tb2R1bGVzLmlzUmVnaXN0ZXJlZChwYXRoKVxufTtcblxuU3RvcmUucHJvdG90eXBlLmhvdFVwZGF0ZSA9IGZ1bmN0aW9uIGhvdFVwZGF0ZSAobmV3T3B0aW9ucykge1xuICB0aGlzLl9tb2R1bGVzLnVwZGF0ZShuZXdPcHRpb25zKTtcbiAgcmVzZXRTdG9yZSh0aGlzLCB0cnVlKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5fd2l0aENvbW1pdCA9IGZ1bmN0aW9uIF93aXRoQ29tbWl0IChmbikge1xuICB2YXIgY29tbWl0dGluZyA9IHRoaXMuX2NvbW1pdHRpbmc7XG4gIHRoaXMuX2NvbW1pdHRpbmcgPSB0cnVlO1xuICBmbigpO1xuICB0aGlzLl9jb21taXR0aW5nID0gY29tbWl0dGluZztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBTdG9yZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxICk7XG5cbmZ1bmN0aW9uIGdlbmVyaWNTdWJzY3JpYmUgKGZuLCBzdWJzLCBvcHRpb25zKSB7XG4gIGlmIChzdWJzLmluZGV4T2YoZm4pIDwgMCkge1xuICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5wcmVwZW5kXG4gICAgICA/IHN1YnMudW5zaGlmdChmbilcbiAgICAgIDogc3Vicy5wdXNoKGZuKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gc3Vicy5pbmRleE9mKGZuKTtcbiAgICBpZiAoaSA+IC0xKSB7XG4gICAgICBzdWJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRTdG9yZSAoc3RvcmUsIGhvdCkge1xuICBzdG9yZS5fYWN0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl9tdXRhdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzdG9yZS5fd3JhcHBlZEdldHRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzdG9yZS5fbW9kdWxlc05hbWVzcGFjZU1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBzdGF0ZSA9IHN0b3JlLnN0YXRlO1xuICAvLyBpbml0IGFsbCBtb2R1bGVzXG4gIGluc3RhbGxNb2R1bGUoc3RvcmUsIHN0YXRlLCBbXSwgc3RvcmUuX21vZHVsZXMucm9vdCwgdHJ1ZSk7XG4gIC8vIHJlc2V0IHZtXG4gIHJlc2V0U3RvcmVWTShzdG9yZSwgc3RhdGUsIGhvdCk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0U3RvcmVWTSAoc3RvcmUsIHN0YXRlLCBob3QpIHtcbiAgdmFyIG9sZFZtID0gc3RvcmUuX3ZtO1xuXG4gIC8vIGJpbmQgc3RvcmUgcHVibGljIGdldHRlcnNcbiAgc3RvcmUuZ2V0dGVycyA9IHt9O1xuICAvLyByZXNldCBsb2NhbCBnZXR0ZXJzIGNhY2hlXG4gIHN0b3JlLl9tYWtlTG9jYWxHZXR0ZXJzQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgd3JhcHBlZEdldHRlcnMgPSBzdG9yZS5fd3JhcHBlZEdldHRlcnM7XG4gIHZhciBjb21wdXRlZCA9IHt9O1xuICBmb3JFYWNoVmFsdWUod3JhcHBlZEdldHRlcnMsIGZ1bmN0aW9uIChmbiwga2V5KSB7XG4gICAgLy8gdXNlIGNvbXB1dGVkIHRvIGxldmVyYWdlIGl0cyBsYXp5LWNhY2hpbmcgbWVjaGFuaXNtXG4gICAgLy8gZGlyZWN0IGlubGluZSBmdW5jdGlvbiB1c2Ugd2lsbCBsZWFkIHRvIGNsb3N1cmUgcHJlc2VydmluZyBvbGRWbS5cbiAgICAvLyB1c2luZyBwYXJ0aWFsIHRvIHJldHVybiBmdW5jdGlvbiB3aXRoIG9ubHkgYXJndW1lbnRzIHByZXNlcnZlZCBpbiBjbG9zdXJlIGVudmlyb25tZW50LlxuICAgIGNvbXB1dGVkW2tleV0gPSBwYXJ0aWFsKGZuLCBzdG9yZSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN0b3JlLmdldHRlcnMsIGtleSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdG9yZS5fdm1ba2V5XTsgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUgLy8gZm9yIGxvY2FsIGdldHRlcnNcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gdXNlIGEgVnVlIGluc3RhbmNlIHRvIHN0b3JlIHRoZSBzdGF0ZSB0cmVlXG4gIC8vIHN1cHByZXNzIHdhcm5pbmdzIGp1c3QgaW4gY2FzZSB0aGUgdXNlciBoYXMgYWRkZWRcbiAgLy8gc29tZSBmdW5reSBnbG9iYWwgbWl4aW5zXG4gIHZhciBzaWxlbnQgPSBWdWUuY29uZmlnLnNpbGVudDtcbiAgVnVlLmNvbmZpZy5zaWxlbnQgPSB0cnVlO1xuICBzdG9yZS5fdm0gPSBuZXcgVnVlKHtcbiAgICBkYXRhOiB7XG4gICAgICAkJHN0YXRlOiBzdGF0ZVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IGNvbXB1dGVkXG4gIH0pO1xuICBWdWUuY29uZmlnLnNpbGVudCA9IHNpbGVudDtcblxuICAvLyBlbmFibGUgc3RyaWN0IG1vZGUgZm9yIG5ldyB2bVxuICBpZiAoc3RvcmUuc3RyaWN0KSB7XG4gICAgZW5hYmxlU3RyaWN0TW9kZShzdG9yZSk7XG4gIH1cblxuICBpZiAob2xkVm0pIHtcbiAgICBpZiAoaG90KSB7XG4gICAgICAvLyBkaXNwYXRjaCBjaGFuZ2VzIGluIGFsbCBzdWJzY3JpYmVkIHdhdGNoZXJzXG4gICAgICAvLyB0byBmb3JjZSBnZXR0ZXIgcmUtZXZhbHVhdGlvbiBmb3IgaG90IHJlbG9hZGluZy5cbiAgICAgIHN0b3JlLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2xkVm0uX2RhdGEuJCRzdGF0ZSA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gICAgVnVlLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9sZFZtLiRkZXN0cm95KCk7IH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxNb2R1bGUgKHN0b3JlLCByb290U3RhdGUsIHBhdGgsIG1vZHVsZSwgaG90KSB7XG4gIHZhciBpc1Jvb3QgPSAhcGF0aC5sZW5ndGg7XG4gIHZhciBuYW1lc3BhY2UgPSBzdG9yZS5fbW9kdWxlcy5nZXROYW1lc3BhY2UocGF0aCk7XG5cbiAgLy8gcmVnaXN0ZXIgaW4gbmFtZXNwYWNlIG1hcFxuICBpZiAobW9kdWxlLm5hbWVzcGFjZWQpIHtcbiAgICBpZiAoc3RvcmUuX21vZHVsZXNOYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSAmJiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIGR1cGxpY2F0ZSBuYW1lc3BhY2UgXCIgKyBuYW1lc3BhY2UgKyBcIiBmb3IgdGhlIG5hbWVzcGFjZWQgbW9kdWxlIFwiICsgKHBhdGguam9pbignLycpKSkpO1xuICAgIH1cbiAgICBzdG9yZS5fbW9kdWxlc05hbWVzcGFjZU1hcFtuYW1lc3BhY2VdID0gbW9kdWxlO1xuICB9XG5cbiAgLy8gc2V0IHN0YXRlXG4gIGlmICghaXNSb290ICYmICFob3QpIHtcbiAgICB2YXIgcGFyZW50U3RhdGUgPSBnZXROZXN0ZWRTdGF0ZShyb290U3RhdGUsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICB2YXIgbW9kdWxlTmFtZSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICBzdG9yZS5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGlmIChtb2R1bGVOYW1lIGluIHBhcmVudFN0YXRlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgKFwiW3Z1ZXhdIHN0YXRlIGZpZWxkIFxcXCJcIiArIG1vZHVsZU5hbWUgKyBcIlxcXCIgd2FzIG92ZXJyaWRkZW4gYnkgYSBtb2R1bGUgd2l0aCB0aGUgc2FtZSBuYW1lIGF0IFxcXCJcIiArIChwYXRoLmpvaW4oJy4nKSkgKyBcIlxcXCJcIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBWdWUuc2V0KHBhcmVudFN0YXRlLCBtb2R1bGVOYW1lLCBtb2R1bGUuc3RhdGUpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGxvY2FsID0gbW9kdWxlLmNvbnRleHQgPSBtYWtlTG9jYWxDb250ZXh0KHN0b3JlLCBuYW1lc3BhY2UsIHBhdGgpO1xuXG4gIG1vZHVsZS5mb3JFYWNoTXV0YXRpb24oZnVuY3Rpb24gKG11dGF0aW9uLCBrZXkpIHtcbiAgICB2YXIgbmFtZXNwYWNlZFR5cGUgPSBuYW1lc3BhY2UgKyBrZXk7XG4gICAgcmVnaXN0ZXJNdXRhdGlvbihzdG9yZSwgbmFtZXNwYWNlZFR5cGUsIG11dGF0aW9uLCBsb2NhbCk7XG4gIH0pO1xuXG4gIG1vZHVsZS5mb3JFYWNoQWN0aW9uKGZ1bmN0aW9uIChhY3Rpb24sIGtleSkge1xuICAgIHZhciB0eXBlID0gYWN0aW9uLnJvb3QgPyBrZXkgOiBuYW1lc3BhY2UgKyBrZXk7XG4gICAgdmFyIGhhbmRsZXIgPSBhY3Rpb24uaGFuZGxlciB8fCBhY3Rpb247XG4gICAgcmVnaXN0ZXJBY3Rpb24oc3RvcmUsIHR5cGUsIGhhbmRsZXIsIGxvY2FsKTtcbiAgfSk7XG5cbiAgbW9kdWxlLmZvckVhY2hHZXR0ZXIoZnVuY3Rpb24gKGdldHRlciwga2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZWRUeXBlID0gbmFtZXNwYWNlICsga2V5O1xuICAgIHJlZ2lzdGVyR2V0dGVyKHN0b3JlLCBuYW1lc3BhY2VkVHlwZSwgZ2V0dGVyLCBsb2NhbCk7XG4gIH0pO1xuXG4gIG1vZHVsZS5mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkLCBrZXkpIHtcbiAgICBpbnN0YWxsTW9kdWxlKHN0b3JlLCByb290U3RhdGUsIHBhdGguY29uY2F0KGtleSksIGNoaWxkLCBob3QpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBtYWtlIGxvY2FsaXplZCBkaXNwYXRjaCwgY29tbWl0LCBnZXR0ZXJzIGFuZCBzdGF0ZVxuICogaWYgdGhlcmUgaXMgbm8gbmFtZXNwYWNlLCBqdXN0IHVzZSByb290IG9uZXNcbiAqL1xuZnVuY3Rpb24gbWFrZUxvY2FsQ29udGV4dCAoc3RvcmUsIG5hbWVzcGFjZSwgcGF0aCkge1xuICB2YXIgbm9OYW1lc3BhY2UgPSBuYW1lc3BhY2UgPT09ICcnO1xuXG4gIHZhciBsb2NhbCA9IHtcbiAgICBkaXNwYXRjaDogbm9OYW1lc3BhY2UgPyBzdG9yZS5kaXNwYXRjaCA6IGZ1bmN0aW9uIChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyA9IHVuaWZ5T2JqZWN0U3R5bGUoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucyk7XG4gICAgICB2YXIgcGF5bG9hZCA9IGFyZ3MucGF5bG9hZDtcbiAgICAgIHZhciBvcHRpb25zID0gYXJncy5vcHRpb25zO1xuICAgICAgdmFyIHR5cGUgPSBhcmdzLnR5cGU7XG5cbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5yb290KSB7XG4gICAgICAgIHR5cGUgPSBuYW1lc3BhY2UgKyB0eXBlO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFzdG9yZS5fYWN0aW9uc1t0eXBlXSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIHVua25vd24gbG9jYWwgYWN0aW9uIHR5cGU6IFwiICsgKGFyZ3MudHlwZSkgKyBcIiwgZ2xvYmFsIHR5cGU6IFwiICsgdHlwZSkpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaCh0eXBlLCBwYXlsb2FkKVxuICAgIH0sXG5cbiAgICBjb21taXQ6IG5vTmFtZXNwYWNlID8gc3RvcmUuY29tbWl0IDogZnVuY3Rpb24gKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKTtcbiAgICAgIHZhciBwYXlsb2FkID0gYXJncy5wYXlsb2FkO1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmdzLm9wdGlvbnM7XG4gICAgICB2YXIgdHlwZSA9IGFyZ3MudHlwZTtcblxuICAgICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnJvb3QpIHtcbiAgICAgICAgdHlwZSA9IG5hbWVzcGFjZSArIHR5cGU7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXN0b3JlLl9tdXRhdGlvbnNbdHlwZV0pIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGxvY2FsIG11dGF0aW9uIHR5cGU6IFwiICsgKGFyZ3MudHlwZSkgKyBcIiwgZ2xvYmFsIHR5cGU6IFwiICsgdHlwZSkpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0b3JlLmNvbW1pdCh0eXBlLCBwYXlsb2FkLCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gZ2V0dGVycyBhbmQgc3RhdGUgb2JqZWN0IG11c3QgYmUgZ290dGVuIGxhemlseVxuICAvLyBiZWNhdXNlIHRoZXkgd2lsbCBiZSBjaGFuZ2VkIGJ5IHZtIHVwZGF0ZVxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsb2NhbCwge1xuICAgIGdldHRlcnM6IHtcbiAgICAgIGdldDogbm9OYW1lc3BhY2VcbiAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBzdG9yZS5nZXR0ZXJzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZUxvY2FsR2V0dGVycyhzdG9yZSwgbmFtZXNwYWNlKTsgfVxuICAgIH0sXG4gICAgc3RhdGU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0TmVzdGVkU3RhdGUoc3RvcmUuc3RhdGUsIHBhdGgpOyB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbG9jYWxcbn1cblxuZnVuY3Rpb24gbWFrZUxvY2FsR2V0dGVycyAoc3RvcmUsIG5hbWVzcGFjZSkge1xuICBpZiAoIXN0b3JlLl9tYWtlTG9jYWxHZXR0ZXJzQ2FjaGVbbmFtZXNwYWNlXSkge1xuICAgIHZhciBnZXR0ZXJzUHJveHkgPSB7fTtcbiAgICB2YXIgc3BsaXRQb3MgPSBuYW1lc3BhY2UubGVuZ3RoO1xuICAgIE9iamVjdC5rZXlzKHN0b3JlLmdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIC8vIHNraXAgaWYgdGhlIHRhcmdldCBnZXR0ZXIgaXMgbm90IG1hdGNoIHRoaXMgbmFtZXNwYWNlXG4gICAgICBpZiAodHlwZS5zbGljZSgwLCBzcGxpdFBvcykgIT09IG5hbWVzcGFjZSkgeyByZXR1cm4gfVxuXG4gICAgICAvLyBleHRyYWN0IGxvY2FsIGdldHRlciB0eXBlXG4gICAgICB2YXIgbG9jYWxUeXBlID0gdHlwZS5zbGljZShzcGxpdFBvcyk7XG5cbiAgICAgIC8vIEFkZCBhIHBvcnQgdG8gdGhlIGdldHRlcnMgcHJveHkuXG4gICAgICAvLyBEZWZpbmUgYXMgZ2V0dGVyIHByb3BlcnR5IGJlY2F1c2VcbiAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV2YWx1YXRlIHRoZSBnZXR0ZXJzIGluIHRoaXMgdGltZS5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnZXR0ZXJzUHJveHksIGxvY2FsVHlwZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0b3JlLmdldHRlcnNbdHlwZV07IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHN0b3JlLl9tYWtlTG9jYWxHZXR0ZXJzQ2FjaGVbbmFtZXNwYWNlXSA9IGdldHRlcnNQcm94eTtcbiAgfVxuXG4gIHJldHVybiBzdG9yZS5fbWFrZUxvY2FsR2V0dGVyc0NhY2hlW25hbWVzcGFjZV1cbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJNdXRhdGlvbiAoc3RvcmUsIHR5cGUsIGhhbmRsZXIsIGxvY2FsKSB7XG4gIHZhciBlbnRyeSA9IHN0b3JlLl9tdXRhdGlvbnNbdHlwZV0gfHwgKHN0b3JlLl9tdXRhdGlvbnNbdHlwZV0gPSBbXSk7XG4gIGVudHJ5LnB1c2goZnVuY3Rpb24gd3JhcHBlZE11dGF0aW9uSGFuZGxlciAocGF5bG9hZCkge1xuICAgIGhhbmRsZXIuY2FsbChzdG9yZSwgbG9jYWwuc3RhdGUsIHBheWxvYWQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJBY3Rpb24gKHN0b3JlLCB0eXBlLCBoYW5kbGVyLCBsb2NhbCkge1xuICB2YXIgZW50cnkgPSBzdG9yZS5fYWN0aW9uc1t0eXBlXSB8fCAoc3RvcmUuX2FjdGlvbnNbdHlwZV0gPSBbXSk7XG4gIGVudHJ5LnB1c2goZnVuY3Rpb24gd3JhcHBlZEFjdGlvbkhhbmRsZXIgKHBheWxvYWQpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5jYWxsKHN0b3JlLCB7XG4gICAgICBkaXNwYXRjaDogbG9jYWwuZGlzcGF0Y2gsXG4gICAgICBjb21taXQ6IGxvY2FsLmNvbW1pdCxcbiAgICAgIGdldHRlcnM6IGxvY2FsLmdldHRlcnMsXG4gICAgICBzdGF0ZTogbG9jYWwuc3RhdGUsXG4gICAgICByb290R2V0dGVyczogc3RvcmUuZ2V0dGVycyxcbiAgICAgIHJvb3RTdGF0ZTogc3RvcmUuc3RhdGVcbiAgICB9LCBwYXlsb2FkKTtcbiAgICBpZiAoIWlzUHJvbWlzZShyZXMpKSB7XG4gICAgICByZXMgPSBQcm9taXNlLnJlc29sdmUocmVzKTtcbiAgICB9XG4gICAgaWYgKHN0b3JlLl9kZXZ0b29sSG9vaykge1xuICAgICAgcmV0dXJuIHJlcy5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHN0b3JlLl9kZXZ0b29sSG9vay5lbWl0KCd2dWV4OmVycm9yJywgZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzXG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJHZXR0ZXIgKHN0b3JlLCB0eXBlLCByYXdHZXR0ZXIsIGxvY2FsKSB7XG4gIGlmIChzdG9yZS5fd3JhcHBlZEdldHRlcnNbdHlwZV0pIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSBkdXBsaWNhdGUgZ2V0dGVyIGtleTogXCIgKyB0eXBlKSk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIHN0b3JlLl93cmFwcGVkR2V0dGVyc1t0eXBlXSA9IGZ1bmN0aW9uIHdyYXBwZWRHZXR0ZXIgKHN0b3JlKSB7XG4gICAgcmV0dXJuIHJhd0dldHRlcihcbiAgICAgIGxvY2FsLnN0YXRlLCAvLyBsb2NhbCBzdGF0ZVxuICAgICAgbG9jYWwuZ2V0dGVycywgLy8gbG9jYWwgZ2V0dGVyc1xuICAgICAgc3RvcmUuc3RhdGUsIC8vIHJvb3Qgc3RhdGVcbiAgICAgIHN0b3JlLmdldHRlcnMgLy8gcm9vdCBnZXR0ZXJzXG4gICAgKVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbmFibGVTdHJpY3RNb2RlIChzdG9yZSkge1xuICBzdG9yZS5fdm0uJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEuJCRzdGF0ZSB9LCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgYXNzZXJ0KHN0b3JlLl9jb21taXR0aW5nLCBcImRvIG5vdCBtdXRhdGUgdnVleCBzdG9yZSBzdGF0ZSBvdXRzaWRlIG11dGF0aW9uIGhhbmRsZXJzLlwiKTtcbiAgICB9XG4gIH0sIHsgZGVlcDogdHJ1ZSwgc3luYzogdHJ1ZSB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TmVzdGVkU3RhdGUgKHN0YXRlLCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbiAoc3RhdGUsIGtleSkgeyByZXR1cm4gc3RhdGVba2V5XTsgfSwgc3RhdGUpXG59XG5cbmZ1bmN0aW9uIHVuaWZ5T2JqZWN0U3R5bGUgKHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgaWYgKGlzT2JqZWN0KHR5cGUpICYmIHR5cGUudHlwZSkge1xuICAgIG9wdGlvbnMgPSBwYXlsb2FkO1xuICAgIHBheWxvYWQgPSB0eXBlO1xuICAgIHR5cGUgPSB0eXBlLnR5cGU7XG4gIH1cblxuICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJywgKFwiZXhwZWN0cyBzdHJpbmcgYXMgdGhlIHR5cGUsIGJ1dCBmb3VuZCBcIiArICh0eXBlb2YgdHlwZSkgKyBcIi5cIikpO1xuICB9XG5cbiAgcmV0dXJuIHsgdHlwZTogdHlwZSwgcGF5bG9hZDogcGF5bG9hZCwgb3B0aW9uczogb3B0aW9ucyB9XG59XG5cbmZ1bmN0aW9uIGluc3RhbGwgKF9WdWUpIHtcbiAgaWYgKFZ1ZSAmJiBfVnVlID09PSBWdWUpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnW3Z1ZXhdIGFscmVhZHkgaW5zdGFsbGVkLiBWdWUudXNlKFZ1ZXgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIFZ1ZSA9IF9WdWU7XG4gIGFwcGx5TWl4aW4oVnVlKTtcbn1cblxuLyoqXG4gKiBSZWR1Y2UgdGhlIGNvZGUgd2hpY2ggd3JpdHRlbiBpbiBWdWUuanMgZm9yIGdldHRpbmcgdGhlIHN0YXRlLlxuICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lc3BhY2VdIC0gTW9kdWxlJ3MgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gc3RhdGVzICMgT2JqZWN0J3MgaXRlbSBjYW4gYmUgYSBmdW5jdGlvbiB3aGljaCBhY2NlcHQgc3RhdGUgYW5kIGdldHRlcnMgZm9yIHBhcmFtLCB5b3UgY2FuIGRvIHNvbWV0aGluZyBmb3Igc3RhdGUgYW5kIGdldHRlcnMgaW4gaXQuXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqL1xudmFyIG1hcFN0YXRlID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIHN0YXRlcykge1xuICB2YXIgcmVzID0ge307XG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzVmFsaWRNYXAoc3RhdGVzKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1t2dWV4XSBtYXBTdGF0ZTogbWFwcGVyIHBhcmFtZXRlciBtdXN0IGJlIGVpdGhlciBhbiBBcnJheSBvciBhbiBPYmplY3QnKTtcbiAgfVxuICBub3JtYWxpemVNYXAoc3RhdGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkU3RhdGUgKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy4kc3RvcmUuc3RhdGU7XG4gICAgICB2YXIgZ2V0dGVycyA9IHRoaXMuJHN0b3JlLmdldHRlcnM7XG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBtb2R1bGUgPSBnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcFN0YXRlJywgbmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZSA9IG1vZHVsZS5jb250ZXh0LnN0YXRlO1xuICAgICAgICBnZXR0ZXJzID0gbW9kdWxlLmNvbnRleHQuZ2V0dGVycztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdmFsLmNhbGwodGhpcywgc3RhdGUsIGdldHRlcnMpXG4gICAgICAgIDogc3RhdGVbdmFsXVxuICAgIH07XG4gICAgLy8gbWFyayB2dWV4IGdldHRlciBmb3IgZGV2dG9vbHNcbiAgICByZXNba2V5XS52dWV4ID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vKipcbiAqIFJlZHVjZSB0aGUgY29kZSB3aGljaCB3cml0dGVuIGluIFZ1ZS5qcyBmb3IgY29tbWl0dGluZyB0aGUgbXV0YXRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZXNwYWNlXSAtIE1vZHVsZSdzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG11dGF0aW9ucyAjIE9iamVjdCdzIGl0ZW0gY2FuIGJlIGEgZnVuY3Rpb24gd2hpY2ggYWNjZXB0IGBjb21taXRgIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBwYXJhbSwgaXQgY2FuIGFjY2VwdCBhbm90aGVyIHBhcmFtcy4gWW91IGNhbiBjb21taXQgbXV0YXRpb24gYW5kIGRvIGFueSBvdGhlciB0aGluZ3MgaW4gdGhpcyBmdW5jdGlvbi4gc3BlY2lhbGx5LCBZb3UgbmVlZCB0byBwYXNzIGFudGhvciBwYXJhbXMgZnJvbSB0aGUgbWFwcGVkIGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgbWFwTXV0YXRpb25zID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIG11dGF0aW9ucykge1xuICB2YXIgcmVzID0ge307XG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzVmFsaWRNYXAobXV0YXRpb25zKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1t2dWV4XSBtYXBNdXRhdGlvbnM6IG1hcHBlciBwYXJhbWV0ZXIgbXVzdCBiZSBlaXRoZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0Jyk7XG4gIH1cbiAgbm9ybWFsaXplTWFwKG11dGF0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZE11dGF0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAvLyBHZXQgdGhlIGNvbW1pdCBtZXRob2QgZnJvbSBzdG9yZVxuICAgICAgdmFyIGNvbW1pdCA9IHRoaXMuJHN0b3JlLmNvbW1pdDtcbiAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgdmFyIG1vZHVsZSA9IGdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwTXV0YXRpb25zJywgbmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjb21taXQgPSBtb2R1bGUuY29udGV4dC5jb21taXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHZhbC5hcHBseSh0aGlzLCBbY29tbWl0XS5jb25jYXQoYXJncykpXG4gICAgICAgIDogY29tbWl0LmFwcGx5KHRoaXMuJHN0b3JlLCBbdmFsXS5jb25jYXQoYXJncykpXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vKipcbiAqIFJlZHVjZSB0aGUgY29kZSB3aGljaCB3cml0dGVuIGluIFZ1ZS5qcyBmb3IgZ2V0dGluZyB0aGUgZ2V0dGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lc3BhY2VdIC0gTW9kdWxlJ3MgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gZ2V0dGVyc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgbWFwR2V0dGVycyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBnZXR0ZXJzKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNWYWxpZE1hcChnZXR0ZXJzKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1t2dWV4XSBtYXBHZXR0ZXJzOiBtYXBwZXIgcGFyYW1ldGVyIG11c3QgYmUgZWl0aGVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCcpO1xuICB9XG4gIG5vcm1hbGl6ZU1hcChnZXR0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIC8vIFRoZSBuYW1lc3BhY2UgaGFzIGJlZW4gbXV0YXRlZCBieSBub3JtYWxpemVOYW1lc3BhY2VcbiAgICB2YWwgPSBuYW1lc3BhY2UgKyB2YWw7XG4gICAgcmVzW2tleV0gPSBmdW5jdGlvbiBtYXBwZWRHZXR0ZXIgKCkge1xuICAgICAgaWYgKG5hbWVzcGFjZSAmJiAhZ2V0TW9kdWxlQnlOYW1lc3BhY2UodGhpcy4kc3RvcmUsICdtYXBHZXR0ZXJzJywgbmFtZXNwYWNlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgISh2YWwgaW4gdGhpcy4kc3RvcmUuZ2V0dGVycykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBnZXR0ZXI6IFwiICsgdmFsKSk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnNbdmFsXVxuICAgIH07XG4gICAgLy8gbWFyayB2dWV4IGdldHRlciBmb3IgZGV2dG9vbHNcbiAgICByZXNba2V5XS52dWV4ID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vKipcbiAqIFJlZHVjZSB0aGUgY29kZSB3aGljaCB3cml0dGVuIGluIFZ1ZS5qcyBmb3IgZGlzcGF0Y2ggdGhlIGFjdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lc3BhY2VdIC0gTW9kdWxlJ3MgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gYWN0aW9ucyAjIE9iamVjdCdzIGl0ZW0gY2FuIGJlIGEgZnVuY3Rpb24gd2hpY2ggYWNjZXB0IGBkaXNwYXRjaGAgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IHBhcmFtLCBpdCBjYW4gYWNjZXB0IGFudGhvciBwYXJhbXMuIFlvdSBjYW4gZGlzcGF0Y2ggYWN0aW9uIGFuZCBkbyBhbnkgb3RoZXIgdGhpbmdzIGluIHRoaXMgZnVuY3Rpb24uIHNwZWNpYWxseSwgWW91IG5lZWQgdG8gcGFzcyBhbnRob3IgcGFyYW1zIGZyb20gdGhlIG1hcHBlZCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIG1hcEFjdGlvbnMgPSBub3JtYWxpemVOYW1lc3BhY2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwgYWN0aW9ucykge1xuICB2YXIgcmVzID0ge307XG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzVmFsaWRNYXAoYWN0aW9ucykpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbdnVleF0gbWFwQWN0aW9uczogbWFwcGVyIHBhcmFtZXRlciBtdXN0IGJlIGVpdGhlciBhbiBBcnJheSBvciBhbiBPYmplY3QnKTtcbiAgfVxuICBub3JtYWxpemVNYXAoYWN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZEFjdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgLy8gZ2V0IGRpc3BhdGNoIGZ1bmN0aW9uIGZyb20gc3RvcmVcbiAgICAgIHZhciBkaXNwYXRjaCA9IHRoaXMuJHN0b3JlLmRpc3BhdGNoO1xuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgbW9kdWxlID0gZ2V0TW9kdWxlQnlOYW1lc3BhY2UodGhpcy4kc3RvcmUsICdtYXBBY3Rpb25zJywgbmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaCA9IG1vZHVsZS5jb250ZXh0LmRpc3BhdGNoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB2YWwuYXBwbHkodGhpcywgW2Rpc3BhdGNoXS5jb25jYXQoYXJncykpXG4gICAgICAgIDogZGlzcGF0Y2guYXBwbHkodGhpcy4kc3RvcmUsIFt2YWxdLmNvbmNhdChhcmdzKSlcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8qKlxuICogUmViaW5kaW5nIG5hbWVzcGFjZSBwYXJhbSBmb3IgbWFwWFhYIGZ1bmN0aW9uIGluIHNwZWNpYWwgc2NvcGVkLCBhbmQgcmV0dXJuIHRoZW0gYnkgc2ltcGxlIG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgY3JlYXRlTmFtZXNwYWNlZEhlbHBlcnMgPSBmdW5jdGlvbiAobmFtZXNwYWNlKSB7IHJldHVybiAoe1xuICBtYXBTdGF0ZTogbWFwU3RhdGUuYmluZChudWxsLCBuYW1lc3BhY2UpLFxuICBtYXBHZXR0ZXJzOiBtYXBHZXR0ZXJzLmJpbmQobnVsbCwgbmFtZXNwYWNlKSxcbiAgbWFwTXV0YXRpb25zOiBtYXBNdXRhdGlvbnMuYmluZChudWxsLCBuYW1lc3BhY2UpLFxuICBtYXBBY3Rpb25zOiBtYXBBY3Rpb25zLmJpbmQobnVsbCwgbmFtZXNwYWNlKVxufSk7IH07XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBtYXBcbiAqIG5vcm1hbGl6ZU1hcChbMSwgMiwgM10pID0+IFsgeyBrZXk6IDEsIHZhbDogMSB9LCB7IGtleTogMiwgdmFsOiAyIH0sIHsga2V5OiAzLCB2YWw6IDMgfSBdXG4gKiBub3JtYWxpemVNYXAoe2E6IDEsIGI6IDIsIGM6IDN9KSA9PiBbIHsga2V5OiAnYScsIHZhbDogMSB9LCB7IGtleTogJ2InLCB2YWw6IDIgfSwgeyBrZXk6ICdjJywgdmFsOiAzIH0gXVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IG1hcFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVNYXAgKG1hcCkge1xuICBpZiAoIWlzVmFsaWRNYXAobWFwKSkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG1hcClcbiAgICA/IG1hcC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKHsga2V5OiBrZXksIHZhbDoga2V5IH0pOyB9KVxuICAgIDogT2JqZWN0LmtleXMobWFwKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKHsga2V5OiBrZXksIHZhbDogbWFwW2tleV0gfSk7IH0pXG59XG5cbi8qKlxuICogVmFsaWRhdGUgd2hldGhlciBnaXZlbiBtYXAgaXMgdmFsaWQgb3Igbm90XG4gKiBAcGFyYW0geyp9IG1hcFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZE1hcCAobWFwKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG1hcCkgfHwgaXNPYmplY3QobWFwKVxufVxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIGV4cGVjdCB0d28gcGFyYW0gY29udGFpbnMgbmFtZXNwYWNlIGFuZCBtYXAuIGl0IHdpbGwgbm9ybWFsaXplIHRoZSBuYW1lc3BhY2UgYW5kIHRoZW4gdGhlIHBhcmFtJ3MgZnVuY3Rpb24gd2lsbCBoYW5kbGUgdGhlIG5ldyBuYW1lc3BhY2UgYW5kIHRoZSBtYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWVzcGFjZSAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1hcCkge1xuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlICE9PSAnc3RyaW5nJykge1xuICAgICAgbWFwID0gbmFtZXNwYWNlO1xuICAgICAgbmFtZXNwYWNlID0gJyc7XG4gICAgfSBlbHNlIGlmIChuYW1lc3BhY2UuY2hhckF0KG5hbWVzcGFjZS5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgICBuYW1lc3BhY2UgKz0gJy8nO1xuICAgIH1cbiAgICByZXR1cm4gZm4obmFtZXNwYWNlLCBtYXApXG4gIH1cbn1cblxuLyoqXG4gKiBTZWFyY2ggYSBzcGVjaWFsIG1vZHVsZSBmcm9tIHN0b3JlIGJ5IG5hbWVzcGFjZS4gaWYgbW9kdWxlIG5vdCBleGlzdCwgcHJpbnQgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdG9yZVxuICogQHBhcmFtIHtTdHJpbmd9IGhlbHBlclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRNb2R1bGVCeU5hbWVzcGFjZSAoc3RvcmUsIGhlbHBlciwgbmFtZXNwYWNlKSB7XG4gIHZhciBtb2R1bGUgPSBzdG9yZS5fbW9kdWxlc05hbWVzcGFjZU1hcFtuYW1lc3BhY2VdO1xuICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFtb2R1bGUpIHtcbiAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSBtb2R1bGUgbmFtZXNwYWNlIG5vdCBmb3VuZCBpbiBcIiArIGhlbHBlciArIFwiKCk6IFwiICsgbmFtZXNwYWNlKSk7XG4gIH1cbiAgcmV0dXJuIG1vZHVsZVxufVxuXG4vLyBDcmVkaXRzOiBib3Jyb3dlZCBjb2RlIGZyb20gZmNvbWIvcmVkdXgtbG9nZ2VyXG5cbmZ1bmN0aW9uIGNyZWF0ZUxvZ2dlciAocmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgdmFyIGNvbGxhcHNlZCA9IHJlZi5jb2xsYXBzZWQ7IGlmICggY29sbGFwc2VkID09PSB2b2lkIDAgKSBjb2xsYXBzZWQgPSB0cnVlO1xuICB2YXIgZmlsdGVyID0gcmVmLmZpbHRlcjsgaWYgKCBmaWx0ZXIgPT09IHZvaWQgMCApIGZpbHRlciA9IGZ1bmN0aW9uIChtdXRhdGlvbiwgc3RhdGVCZWZvcmUsIHN0YXRlQWZ0ZXIpIHsgcmV0dXJuIHRydWU7IH07XG4gIHZhciB0cmFuc2Zvcm1lciA9IHJlZi50cmFuc2Zvcm1lcjsgaWYgKCB0cmFuc2Zvcm1lciA9PT0gdm9pZCAwICkgdHJhbnNmb3JtZXIgPSBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHN0YXRlOyB9O1xuICB2YXIgbXV0YXRpb25UcmFuc2Zvcm1lciA9IHJlZi5tdXRhdGlvblRyYW5zZm9ybWVyOyBpZiAoIG11dGF0aW9uVHJhbnNmb3JtZXIgPT09IHZvaWQgMCApIG11dGF0aW9uVHJhbnNmb3JtZXIgPSBmdW5jdGlvbiAobXV0KSB7IHJldHVybiBtdXQ7IH07XG4gIHZhciBhY3Rpb25GaWx0ZXIgPSByZWYuYWN0aW9uRmlsdGVyOyBpZiAoIGFjdGlvbkZpbHRlciA9PT0gdm9pZCAwICkgYWN0aW9uRmlsdGVyID0gZnVuY3Rpb24gKGFjdGlvbiwgc3RhdGUpIHsgcmV0dXJuIHRydWU7IH07XG4gIHZhciBhY3Rpb25UcmFuc2Zvcm1lciA9IHJlZi5hY3Rpb25UcmFuc2Zvcm1lcjsgaWYgKCBhY3Rpb25UcmFuc2Zvcm1lciA9PT0gdm9pZCAwICkgYWN0aW9uVHJhbnNmb3JtZXIgPSBmdW5jdGlvbiAoYWN0KSB7IHJldHVybiBhY3Q7IH07XG4gIHZhciBsb2dNdXRhdGlvbnMgPSByZWYubG9nTXV0YXRpb25zOyBpZiAoIGxvZ011dGF0aW9ucyA9PT0gdm9pZCAwICkgbG9nTXV0YXRpb25zID0gdHJ1ZTtcbiAgdmFyIGxvZ0FjdGlvbnMgPSByZWYubG9nQWN0aW9uczsgaWYgKCBsb2dBY3Rpb25zID09PSB2b2lkIDAgKSBsb2dBY3Rpb25zID0gdHJ1ZTtcbiAgdmFyIGxvZ2dlciA9IHJlZi5sb2dnZXI7IGlmICggbG9nZ2VyID09PSB2b2lkIDAgKSBsb2dnZXIgPSBjb25zb2xlO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICB2YXIgcHJldlN0YXRlID0gZGVlcENvcHkoc3RvcmUuc3RhdGUpO1xuXG4gICAgaWYgKHR5cGVvZiBsb2dnZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAobG9nTXV0YXRpb25zKSB7XG4gICAgICBzdG9yZS5zdWJzY3JpYmUoZnVuY3Rpb24gKG11dGF0aW9uLCBzdGF0ZSkge1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gZGVlcENvcHkoc3RhdGUpO1xuXG4gICAgICAgIGlmIChmaWx0ZXIobXV0YXRpb24sIHByZXZTdGF0ZSwgbmV4dFN0YXRlKSkge1xuICAgICAgICAgIHZhciBmb3JtYXR0ZWRUaW1lID0gZ2V0Rm9ybWF0dGVkVGltZSgpO1xuICAgICAgICAgIHZhciBmb3JtYXR0ZWRNdXRhdGlvbiA9IG11dGF0aW9uVHJhbnNmb3JtZXIobXV0YXRpb24pO1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJtdXRhdGlvbiBcIiArIChtdXRhdGlvbi50eXBlKSArIGZvcm1hdHRlZFRpbWU7XG5cbiAgICAgICAgICBzdGFydE1lc3NhZ2UobG9nZ2VyLCBtZXNzYWdlLCBjb2xsYXBzZWQpO1xuICAgICAgICAgIGxvZ2dlci5sb2coJyVjIHByZXYgc3RhdGUnLCAnY29sb3I6ICM5RTlFOUU7IGZvbnQtd2VpZ2h0OiBib2xkJywgdHJhbnNmb3JtZXIocHJldlN0YXRlKSk7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnJWMgbXV0YXRpb24nLCAnY29sb3I6ICMwM0E5RjQ7IGZvbnQtd2VpZ2h0OiBib2xkJywgZm9ybWF0dGVkTXV0YXRpb24pO1xuICAgICAgICAgIGxvZ2dlci5sb2coJyVjIG5leHQgc3RhdGUnLCAnY29sb3I6ICM0Q0FGNTA7IGZvbnQtd2VpZ2h0OiBib2xkJywgdHJhbnNmb3JtZXIobmV4dFN0YXRlKSk7XG4gICAgICAgICAgZW5kTWVzc2FnZShsb2dnZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldlN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGxvZ0FjdGlvbnMpIHtcbiAgICAgIHN0b3JlLnN1YnNjcmliZUFjdGlvbihmdW5jdGlvbiAoYWN0aW9uLCBzdGF0ZSkge1xuICAgICAgICBpZiAoYWN0aW9uRmlsdGVyKGFjdGlvbiwgc3RhdGUpKSB7XG4gICAgICAgICAgdmFyIGZvcm1hdHRlZFRpbWUgPSBnZXRGb3JtYXR0ZWRUaW1lKCk7XG4gICAgICAgICAgdmFyIGZvcm1hdHRlZEFjdGlvbiA9IGFjdGlvblRyYW5zZm9ybWVyKGFjdGlvbik7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcImFjdGlvbiBcIiArIChhY3Rpb24udHlwZSkgKyBmb3JtYXR0ZWRUaW1lO1xuXG4gICAgICAgICAgc3RhcnRNZXNzYWdlKGxvZ2dlciwgbWVzc2FnZSwgY29sbGFwc2VkKTtcbiAgICAgICAgICBsb2dnZXIubG9nKCclYyBhY3Rpb24nLCAnY29sb3I6ICMwM0E5RjQ7IGZvbnQtd2VpZ2h0OiBib2xkJywgZm9ybWF0dGVkQWN0aW9uKTtcbiAgICAgICAgICBlbmRNZXNzYWdlKGxvZ2dlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydE1lc3NhZ2UgKGxvZ2dlciwgbWVzc2FnZSwgY29sbGFwc2VkKSB7XG4gIHZhciBzdGFydE1lc3NhZ2UgPSBjb2xsYXBzZWRcbiAgICA/IGxvZ2dlci5ncm91cENvbGxhcHNlZFxuICAgIDogbG9nZ2VyLmdyb3VwO1xuXG4gIC8vIHJlbmRlclxuICB0cnkge1xuICAgIHN0YXJ0TWVzc2FnZS5jYWxsKGxvZ2dlciwgbWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dnZXIubG9nKG1lc3NhZ2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZE1lc3NhZ2UgKGxvZ2dlcikge1xuICB0cnkge1xuICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyLmxvZygn4oCU4oCUIGxvZyBlbmQg4oCU4oCUJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Rm9ybWF0dGVkVGltZSAoKSB7XG4gIHZhciB0aW1lID0gbmV3IERhdGUoKTtcbiAgcmV0dXJuIChcIiBAIFwiICsgKHBhZCh0aW1lLmdldEhvdXJzKCksIDIpKSArIFwiOlwiICsgKHBhZCh0aW1lLmdldE1pbnV0ZXMoKSwgMikpICsgXCI6XCIgKyAocGFkKHRpbWUuZ2V0U2Vjb25kcygpLCAyKSkgKyBcIi5cIiArIChwYWQodGltZS5nZXRNaWxsaXNlY29uZHMoKSwgMykpKVxufVxuXG5mdW5jdGlvbiByZXBlYXQgKHN0ciwgdGltZXMpIHtcbiAgcmV0dXJuIChuZXcgQXJyYXkodGltZXMgKyAxKSkuam9pbihzdHIpXG59XG5cbmZ1bmN0aW9uIHBhZCAobnVtLCBtYXhMZW5ndGgpIHtcbiAgcmV0dXJuIHJlcGVhdCgnMCcsIG1heExlbmd0aCAtIG51bS50b1N0cmluZygpLmxlbmd0aCkgKyBudW1cbn1cblxudmFyIGluZGV4ID0ge1xuICBTdG9yZTogU3RvcmUsXG4gIGluc3RhbGw6IGluc3RhbGwsXG4gIHZlcnNpb246ICczLjYuMicsXG4gIG1hcFN0YXRlOiBtYXBTdGF0ZSxcbiAgbWFwTXV0YXRpb25zOiBtYXBNdXRhdGlvbnMsXG4gIG1hcEdldHRlcnM6IG1hcEdldHRlcnMsXG4gIG1hcEFjdGlvbnM6IG1hcEFjdGlvbnMsXG4gIGNyZWF0ZU5hbWVzcGFjZWRIZWxwZXJzOiBjcmVhdGVOYW1lc3BhY2VkSGVscGVycyxcbiAgY3JlYXRlTG9nZ2VyOiBjcmVhdGVMb2dnZXJcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuZXhwb3J0IHsgU3RvcmUsIGNyZWF0ZUxvZ2dlciwgY3JlYXRlTmFtZXNwYWNlZEhlbHBlcnMsIGluc3RhbGwsIG1hcEFjdGlvbnMsIG1hcEdldHRlcnMsIG1hcE11dGF0aW9ucywgbWFwU3RhdGUgfTtcbiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vQXBwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD03YmE1YmQ5MFwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0FwcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL0FwcC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD03YmE1YmQ5MCZsYW5nPXNjc3NcIlxuaW1wb3J0IHN0eWxlMSBmcm9tIFwiLi9BcHAudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTEmaWQ9N2JhNWJkOTAmbGFuZz1jc3NcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiUzpcXFxcQ29kZVByb2plY3RzXFxcXHBlcnNvbmFsU2l0ZVxcXFxub2RlX21vZHVsZXNcXFxcdnVlLWhvdC1yZWxvYWQtYXBpXFxcXGRpc3RcXFxcaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCc3YmE1YmQ5MCcpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCc3YmE1YmQ5MCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCc3YmE1YmQ5MCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vQXBwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD03YmE1YmQ5MFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzdiYTViZDkwJywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvQXBwLnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2UhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2UhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanMhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMi51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0FwcC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD03YmE1YmQ5MCZsYW5nPXNjc3NcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcyEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0yLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQXBwLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0xJmlkPTdiYTViZDkwJmxhbmc9Y3NzXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/cnVsZVNldFsxXS5ydWxlc1syXSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0FwcC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9N2JhNWJkOTBcIiIsIi8qIVxuICogQ1NTUGx1Z2luIDMuNy4wXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOC0yMDIxLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuLyogZXNsaW50LWRpc2FibGUgKi9cblxuaW1wb3J0IHtnc2FwLCBfZ2V0UHJvcGVydHksIF9udW1FeHAsIF9udW1XaXRoVW5pdEV4cCwgZ2V0VW5pdCwgX2lzU3RyaW5nLCBfaXNVbmRlZmluZWQsIF9yZW5kZXJDb21wbGV4U3RyaW5nLCBfcmVsRXhwLCBfZm9yRWFjaE5hbWUsIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHksIF9jb2xvclN0cmluZ0ZpbHRlciwgX2NoZWNrUGx1Z2luLCBfcmVwbGFjZVJhbmRvbSwgX3BsdWdpbnMsIEdTQ2FjaGUsIFByb3BUd2VlbiwgX2NvbmZpZywgX3RpY2tlciwgX3JvdW5kLCBfbWlzc2luZ1BsdWdpbiwgX2dldFNldHRlciwgX2dldENhY2hlLCBfY29sb3JFeHAsXG5cdF9zZXREZWZhdWx0cywgX3JlbW92ZUxpbmtlZExpc3RJdGVtIC8vZm9yIHRoZSBjb21tZW50ZWQtb3V0IGNsYXNzTmFtZSBmZWF0dXJlLlxufSBmcm9tIFwiLi9nc2FwLWNvcmUuanNcIjtcblxubGV0IF93aW4sIF9kb2MsIF9kb2NFbGVtZW50LCBfcGx1Z2luSW5pdHRlZCwgX3RlbXBEaXYsIF90ZW1wRGl2U3R5bGVyLCBfcmVjZW50U2V0dGVyUGx1Z2luLFxuXHRfd2luZG93RXhpc3RzID0gKCkgPT4gdHlwZW9mKHdpbmRvdykgIT09IFwidW5kZWZpbmVkXCIsXG5cdF90cmFuc2Zvcm1Qcm9wcyA9IHt9LFxuXHRfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG5cdF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcblx0X2F0YW4yID0gTWF0aC5hdGFuMixcblx0X2JpZ051bSA9IDFlOCxcblx0X2NhcHNFeHAgPSAvKFtBLVpdKS9nLFxuXHRfaG9yaXpvbnRhbEV4cCA9IC8oPzpsZWZ0fHJpZ2h0fHdpZHRofG1hcmdpbnxwYWRkaW5nfHgpL2ksXG5cdF9jb21wbGV4RXhwID0gL1tcXHMsXFwoXVxcUy8sXG5cdF9wcm9wZXJ0eUFsaWFzZXMgPSB7YXV0b0FscGhhOlwib3BhY2l0eSx2aXNpYmlsaXR5XCIsIHNjYWxlOlwic2NhbGVYLHNjYWxlWVwiLCBhbHBoYTpcIm9wYWNpdHlcIn0sXG5cdF9yZW5kZXJDU1NQcm9wID0gKHJhdGlvLCBkYXRhKSA9PiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgKE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwKSArIGRhdGEudSwgZGF0YSksXG5cdF9yZW5kZXJQcm9wV2l0aEVuZCA9IChyYXRpbywgZGF0YSkgPT4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID09PSAxID8gZGF0YS5lIDogKE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwKSArIGRhdGEudSwgZGF0YSksXG5cdF9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZyA9IChyYXRpbywgZGF0YSkgPT4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID8gKE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwKSArIGRhdGEudSA6IGRhdGEuYiwgZGF0YSksIC8vaWYgdW5pdHMgY2hhbmdlLCB3ZSBuZWVkIGEgd2F5IHRvIHJlbmRlciB0aGUgb3JpZ2luYWwgdW5pdC92YWx1ZSB3aGVuIHRoZSB0d2VlbiBnb2VzIGFsbCB0aGUgd2F5IGJhY2sgdG8gdGhlIGJlZ2lubmluZyAocmF0aW86MClcblx0X3JlbmRlclJvdW5kZWRDU1NQcm9wID0gKHJhdGlvLCBkYXRhKSA9PiB7XG5cdFx0bGV0IHZhbHVlID0gZGF0YS5zICsgZGF0YS5jICogcmF0aW87XG5cdFx0ZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIH5+KHZhbHVlICsgKHZhbHVlIDwgMCA/IC0uNSA6IC41KSkgKyBkYXRhLnUsIGRhdGEpO1xuXHR9LFxuXHRfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZSA9IChyYXRpbywgZGF0YSkgPT4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID8gZGF0YS5lIDogZGF0YS5iLCBkYXRhKSxcblx0X3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgPSAocmF0aW8sIGRhdGEpID0+IGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyAhPT0gMSA/IGRhdGEuYiA6IGRhdGEuZSwgZGF0YSksXG5cdF9zZXR0ZXJDU1NTdHlsZSA9ICh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkgPT4gdGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlLFxuXHRfc2V0dGVyQ1NTUHJvcCA9ICh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkgPT4gdGFyZ2V0LnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSksXG5cdF9zZXR0ZXJUcmFuc2Zvcm0gPSAodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpID0+IHRhcmdldC5fZ3NhcFtwcm9wZXJ0eV0gPSB2YWx1ZSxcblx0X3NldHRlclNjYWxlID0gKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSA9PiB0YXJnZXQuX2dzYXAuc2NhbGVYID0gdGFyZ2V0Ll9nc2FwLnNjYWxlWSA9IHZhbHVlLFxuXHRfc2V0dGVyU2NhbGVXaXRoUmVuZGVyID0gKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhLCByYXRpbykgPT4ge1xuXHRcdGxldCBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcblx0XHRjYWNoZS5zY2FsZVggPSBjYWNoZS5zY2FsZVkgPSB2YWx1ZTtcblx0XHRjYWNoZS5yZW5kZXJUcmFuc2Zvcm0ocmF0aW8sIGNhY2hlKTtcblx0fSxcblx0X3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIgPSAodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEsIHJhdGlvKSA9PiB7XG5cdFx0bGV0IGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuXHRcdGNhY2hlW3Byb3BlcnR5XSA9IHZhbHVlO1xuXHRcdGNhY2hlLnJlbmRlclRyYW5zZm9ybShyYXRpbywgY2FjaGUpO1xuXHR9LFxuXHRfdHJhbnNmb3JtUHJvcCA9IFwidHJhbnNmb3JtXCIsXG5cdF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiLFxuXHRfc3VwcG9ydHMzRCxcblx0X2NyZWF0ZUVsZW1lbnQgPSAodHlwZSwgbnMpID0+IHtcblx0XHRsZXQgZSA9IF9kb2MuY3JlYXRlRWxlbWVudE5TID8gX2RvYy5jcmVhdGVFbGVtZW50TlMoKG5zIHx8IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiKS5yZXBsYWNlKC9eaHR0cHMvLCBcImh0dHBcIiksIHR5cGUpIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpOyAvL3NvbWUgc2VydmVycyBzd2FwIGluIGh0dHBzIGZvciBodHRwIGluIHRoZSBuYW1lc3BhY2Ugd2hpY2ggY2FuIGJyZWFrIHRoaW5ncywgbWFraW5nIFwic3R5bGVcIiBpbmFjY2Vzc2libGUuXG5cdFx0cmV0dXJuIGUuc3R5bGUgPyBlIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpOyAvL3NvbWUgZW52aXJvbm1lbnRzIHdvbid0IGFsbG93IGFjY2VzcyB0byB0aGUgZWxlbWVudCdzIHN0eWxlIHdoZW4gY3JlYXRlZCB3aXRoIGEgbmFtZXNwYWNlIGluIHdoaWNoIGNhc2Ugd2UgZGVmYXVsdCB0byB0aGUgc3RhbmRhcmQgY3JlYXRlRWxlbWVudCgpIHRvIHdvcmsgYXJvdW5kIHRoZSBpc3N1ZS4gQWxzbyBub3RlIHRoYXQgd2hlbiBHU0FQIGlzIGVtYmVkZGVkIGRpcmVjdGx5IGluc2lkZSBhbiBTVkcgZmlsZSwgY3JlYXRlRWxlbWVudCgpIHdvbid0IGFsbG93IGFjY2VzcyB0byB0aGUgc3R5bGUgb2JqZWN0IGluIEZpcmVmb3ggKHNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIwMjE1LXByb2JsZW0tdXNpbmctdHdlZW5tYXgtaW4tc3RhbmRhbG9uZS1zZWxmLWNvbnRhaW5pbmctc3ZnLWZpbGUtZXJyLWNhbm5vdC1zZXQtcHJvcGVydHktY3NzdGV4dC1vZi11bmRlZmluZWQvKS5cblx0fSxcblx0X2dldENvbXB1dGVkUHJvcGVydHkgPSAodGFyZ2V0LCBwcm9wZXJ0eSwgc2tpcFByZWZpeEZhbGxiYWNrKSA9PiB7XG5cdFx0bGV0IGNzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuXHRcdHJldHVybiBjc1twcm9wZXJ0eV0gfHwgY3MuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eS5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KSB8fCAoIXNraXBQcmVmaXhGYWxsYmFjayAmJiBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF9jaGVja1Byb3BQcmVmaXgocHJvcGVydHkpIHx8IHByb3BlcnR5LCAxKSkgfHwgXCJcIjsgLy9jc3MgdmFyaWFibGVzIG1heSBub3QgbmVlZCBjYXBzIHN3YXBwZWQgb3V0IGZvciBkYXNoZXMgYW5kIGxvd2VyY2FzZS5cblx0fSxcblx0X3ByZWZpeGVzID0gXCJPLE1veixtcyxNcyxXZWJraXRcIi5zcGxpdChcIixcIiksXG5cdF9jaGVja1Byb3BQcmVmaXggPSAocHJvcGVydHksIGVsZW1lbnQsIHByZWZlclByZWZpeCkgPT4ge1xuXHRcdGxldCBlID0gZWxlbWVudCB8fCBfdGVtcERpdixcblx0XHRcdHMgPSBlLnN0eWxlLFxuXHRcdFx0aSA9IDU7XG5cdFx0aWYgKHByb3BlcnR5IGluIHMgJiYgIXByZWZlclByZWZpeCkge1xuXHRcdFx0cmV0dXJuIHByb3BlcnR5O1xuXHRcdH1cblx0XHRwcm9wZXJ0eSA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc3Vic3RyKDEpO1xuXHRcdHdoaWxlIChpLS0gJiYgISgoX3ByZWZpeGVzW2ldK3Byb3BlcnR5KSBpbiBzKSkgeyB9XG5cdFx0cmV0dXJuIChpIDwgMCkgPyBudWxsIDogKChpID09PSAzKSA/IFwibXNcIiA6IChpID49IDApID8gX3ByZWZpeGVzW2ldIDogXCJcIikgKyBwcm9wZXJ0eTtcblx0fSxcblx0X2luaXRDb3JlID0gKCkgPT4ge1xuXHRcdGlmIChfd2luZG93RXhpc3RzKCkgJiYgd2luZG93LmRvY3VtZW50KSB7XG5cdFx0XHRfd2luID0gd2luZG93O1xuXHRcdFx0X2RvYyA9IF93aW4uZG9jdW1lbnQ7XG5cdFx0XHRfZG9jRWxlbWVudCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0X3RlbXBEaXYgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKSB8fCB7c3R5bGU6e319O1xuXHRcdFx0X3RlbXBEaXZTdHlsZXIgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdF90cmFuc2Zvcm1Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChfdHJhbnNmb3JtUHJvcCk7XG5cdFx0XHRfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF90cmFuc2Zvcm1Qcm9wICsgXCJPcmlnaW5cIjtcblx0XHRcdF90ZW1wRGl2LnN0eWxlLmNzc1RleHQgPSBcImJvcmRlci13aWR0aDowO2xpbmUtaGVpZ2h0OjA7cG9zaXRpb246YWJzb2x1dGU7cGFkZGluZzowXCI7IC8vbWFrZSBzdXJlIHRvIG92ZXJyaWRlIGNlcnRhaW4gcHJvcGVydGllcyB0aGF0IG1heSBjb250YW1pbmF0ZSBtZWFzdXJlbWVudHMsIGluIGNhc2UgdGhlIHVzZXIgaGFzIG92ZXJyZWFjaGluZyBzdHlsZSBzaGVldHMuXG5cdFx0XHRfc3VwcG9ydHMzRCA9ICEhX2NoZWNrUHJvcFByZWZpeChcInBlcnNwZWN0aXZlXCIpO1xuXHRcdFx0X3BsdWdpbkluaXR0ZWQgPSAxO1xuXHRcdH1cblx0fSxcblx0X2dldEJCb3hIYWNrID0gZnVuY3Rpb24oc3dhcElmUG9zc2libGUpIHsgLy93b3JrcyBhcm91bmQgaXNzdWVzIGluIHNvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgdGhhdCBkb24ndCBjb3JyZWN0bHkgcmVwb3J0IGdldEJCb3goKSBvbiBTVkcgZWxlbWVudHMgaW5zaWRlIGEgPGRlZnM+IGVsZW1lbnQgYW5kL29yIDxtYXNrPi4gV2UgdHJ5IGNyZWF0aW5nIGFuIFNWRywgYWRkaW5nIGl0IHRvIHRoZSBkb2N1bWVudEVsZW1lbnQgYW5kIHRvc3MgdGhlIGVsZW1lbnQgaW4gdGhlcmUgc28gdGhhdCBpdCdzIGRlZmluaXRlbHkgcGFydCBvZiB0aGUgcmVuZGVyaW5nIHRyZWUsIHRoZW4gZ3JhYiB0aGUgYmJveCBhbmQgaWYgaXQgd29ya3MsIHdlIGFjdHVhbGx5IHN3YXAgb3V0IHRoZSBvcmlnaW5hbCBnZXRCQm94KCkgbWV0aG9kIGZvciBvdXIgb3duIHRoYXQgZG9lcyB0aGVzZSBleHRyYSBzdGVwcyB3aGVuZXZlciBnZXRCQm94IGlzIG5lZWRlZC4gVGhpcyBoZWxwcyBlbnN1cmUgdGhhdCBwZXJmb3JtYW5jZSBpcyBvcHRpbWFsIChvbmx5IGRvIGFsbCB0aGVzZSBleHRyYSBzdGVwcyB3aGVuIGFic29sdXRlbHkgbmVjZXNzYXJ5Li4ubW9zdCBlbGVtZW50cyBkb24ndCBuZWVkIGl0KS5cblx0XHRsZXQgc3ZnID0gX2NyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgKHRoaXMub3duZXJTVkdFbGVtZW50ICYmIHRoaXMub3duZXJTVkdFbGVtZW50LmdldEF0dHJpYnV0ZShcInhtbG5zXCIpKSB8fCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIpLFxuXHRcdFx0b2xkUGFyZW50ID0gdGhpcy5wYXJlbnROb2RlLFxuXHRcdFx0b2xkU2libGluZyA9IHRoaXMubmV4dFNpYmxpbmcsXG5cdFx0XHRvbGRDU1MgPSB0aGlzLnN0eWxlLmNzc1RleHQsXG5cdFx0XHRiYm94O1xuXHRcdF9kb2NFbGVtZW50LmFwcGVuZENoaWxkKHN2Zyk7XG5cdFx0c3ZnLmFwcGVuZENoaWxkKHRoaXMpO1xuXHRcdHRoaXMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0XHRpZiAoc3dhcElmUG9zc2libGUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGJib3ggPSB0aGlzLmdldEJCb3goKTtcblx0XHRcdFx0dGhpcy5fZ3NhcEJCb3ggPSB0aGlzLmdldEJCb3g7IC8vc3RvcmUgdGhlIG9yaWdpbmFsXG5cdFx0XHRcdHRoaXMuZ2V0QkJveCA9IF9nZXRCQm94SGFjaztcblx0XHRcdH0gY2F0Y2ggKGUpIHsgfVxuXHRcdH0gZWxzZSBpZiAodGhpcy5fZ3NhcEJCb3gpIHtcblx0XHRcdGJib3ggPSB0aGlzLl9nc2FwQkJveCgpO1xuXHRcdH1cblx0XHRpZiAob2xkUGFyZW50KSB7XG5cdFx0XHRpZiAob2xkU2libGluZykge1xuXHRcdFx0XHRvbGRQYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIG9sZFNpYmxpbmcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkUGFyZW50LmFwcGVuZENoaWxkKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRfZG9jRWxlbWVudC5yZW1vdmVDaGlsZChzdmcpO1xuXHRcdHRoaXMuc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcblx0XHRyZXR1cm4gYmJveDtcblx0fSxcblx0X2dldEF0dHJpYnV0ZUZhbGxiYWNrcyA9ICh0YXJnZXQsIGF0dHJpYnV0ZXNBcnJheSkgPT4ge1xuXHRcdGxldCBpID0gYXR0cmlidXRlc0FycmF5Lmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pKSB7XG5cdFx0XHRcdHJldHVybiB0YXJnZXQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZXNBcnJheVtpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRfZ2V0QkJveCA9IHRhcmdldCA9PiB7XG5cdFx0bGV0IGJvdW5kcztcblx0XHR0cnkge1xuXHRcdFx0Ym91bmRzID0gdGFyZ2V0LmdldEJCb3goKTsgLy9GaXJlZm94IHRocm93cyBlcnJvcnMgaWYgeW91IHRyeSBjYWxsaW5nIGdldEJCb3goKSBvbiBhbiBTVkcgZWxlbWVudCB0aGF0J3Mgbm90IHJlbmRlcmVkIChsaWtlIGluIGEgPHN5bWJvbD4gb3IgPGRlZnM+KS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjEyMTE4XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGJvdW5kcyA9IF9nZXRCQm94SGFjay5jYWxsKHRhcmdldCwgdHJ1ZSk7XG5cdFx0fVxuXHRcdChib3VuZHMgJiYgKGJvdW5kcy53aWR0aCB8fCBib3VuZHMuaGVpZ2h0KSkgfHwgdGFyZ2V0LmdldEJCb3ggPT09IF9nZXRCQm94SGFjayB8fCAoYm91bmRzID0gX2dldEJCb3hIYWNrLmNhbGwodGFyZ2V0LCB0cnVlKSk7XG5cdFx0Ly9zb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIG1pc3JlcG9ydCB0aGUgYm91bmRzIGlmIHRoZSBlbGVtZW50IGhhcyB6ZXJvIHdpZHRoIGFuZCBoZWlnaHQgKGl0IGp1c3QgYXNzdW1lcyBpdCdzIGF0IHg6MCwgeTowKSwgdGh1cyB3ZSBuZWVkIHRvIG1hbnVhbGx5IGdyYWIgdGhlIHBvc2l0aW9uIGluIHRoYXQgY2FzZS5cblx0XHRyZXR1cm4gKGJvdW5kcyAmJiAhYm91bmRzLndpZHRoICYmICFib3VuZHMueCAmJiAhYm91bmRzLnkpID8ge3g6ICtfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgW1wieFwiLFwiY3hcIixcIngxXCJdKSB8fCAwLCB5OitfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgW1wieVwiLFwiY3lcIixcInkxXCJdKSB8fCAwLCB3aWR0aDowLCBoZWlnaHQ6MH0gOiBib3VuZHM7XG5cdH0sXG5cdF9pc1NWRyA9IGUgPT4gISEoZS5nZXRDVE0gJiYgKCFlLnBhcmVudE5vZGUgfHwgZS5vd25lclNWR0VsZW1lbnQpICYmIF9nZXRCQm94KGUpKSwgLy9yZXBvcnRzIGlmIHRoZSBlbGVtZW50IGlzIGFuIFNWRyBvbiB3aGljaCBnZXRCQm94KCkgYWN0dWFsbHkgd29ya3Ncblx0X3JlbW92ZVByb3BlcnR5ID0gKHRhcmdldCwgcHJvcGVydHkpID0+IHtcblx0XHRpZiAocHJvcGVydHkpIHtcblx0XHRcdGxldCBzdHlsZSA9IHRhcmdldC5zdHlsZTtcblx0XHRcdGlmIChwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgcHJvcGVydHkgIT09IF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSB7XG5cdFx0XHRcdHByb3BlcnR5ID0gX3RyYW5zZm9ybVByb3A7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc3R5bGUucmVtb3ZlUHJvcGVydHkpIHtcblx0XHRcdFx0aWYgKHByb3BlcnR5LnN1YnN0cigwLDIpID09PSBcIm1zXCIgfHwgcHJvcGVydHkuc3Vic3RyKDAsNikgPT09IFwid2Via2l0XCIpIHsgLy9NaWNyb3NvZnQgYW5kIHNvbWUgV2Via2l0IGJyb3dzZXJzIGRvbid0IGNvbmZvcm0gdG8gdGhlIHN0YW5kYXJkIG9mIGNhcGl0YWxpemluZyB0aGUgZmlyc3QgcHJlZml4IGNoYXJhY3Rlciwgc28gd2UgYWRqdXN0IHNvIHRoYXQgd2hlbiB3ZSBwcmVmaXggdGhlIGNhcHMgd2l0aCBhIGRhc2gsIGl0J3MgY29ycmVjdCAob3RoZXJ3aXNlIGl0J2QgYmUgXCJtcy10cmFuc2Zvcm1cIiBpbnN0ZWFkIG9mIFwiLW1zLXRyYW5zZm9ybVwiIGZvciBJRTksIGZvciBleGFtcGxlKVxuXHRcdFx0XHRcdHByb3BlcnR5ID0gXCItXCIgKyBwcm9wZXJ0eTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eS5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcblx0XHRcdH0gZWxzZSB7IC8vbm90ZTogb2xkIHZlcnNpb25zIG9mIElFIHVzZSBcInJlbW92ZUF0dHJpYnV0ZSgpXCIgaW5zdGVhZCBvZiBcInJlbW92ZVByb3BlcnR5KClcIlxuXHRcdFx0XHRzdHlsZS5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0X2FkZE5vblR3ZWVuaW5nUFQgPSAocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBiZWdpbm5pbmcsIGVuZCwgb25seVNldEF0RW5kKSA9PiB7XG5cdFx0bGV0IHB0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAxLCBvbmx5U2V0QXRFbmQgPyBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA6IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlKTtcblx0XHRwbHVnaW4uX3B0ID0gcHQ7XG5cdFx0cHQuYiA9IGJlZ2lubmluZztcblx0XHRwdC5lID0gZW5kO1xuXHRcdHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cdFx0cmV0dXJuIHB0O1xuXHR9LFxuXHRfbm9uQ29udmVydGlibGVVbml0cyA9IHtkZWc6MSwgcmFkOjEsIHR1cm46MX0sXG5cdC8vdGFrZXMgYSBzaW5nbGUgdmFsdWUgbGlrZSAyMHB4IGFuZCBjb252ZXJ0cyBpdCB0byB0aGUgdW5pdCBzcGVjaWZpZWQsIGxpa2UgXCIlXCIsIHJldHVybmluZyBvbmx5IHRoZSBudW1lcmljIGFtb3VudC5cblx0X2NvbnZlcnRUb1VuaXQgPSAodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHVuaXQpID0+IHtcblx0XHRsZXQgY3VyVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwLFxuXHRcdFx0Y3VyVW5pdCA9ICh2YWx1ZSArIFwiXCIpLnRyaW0oKS5zdWJzdHIoKGN1clZhbHVlICsgXCJcIikubGVuZ3RoKSB8fCBcInB4XCIsIC8vIHNvbWUgYnJvd3NlcnMgbGVhdmUgZXh0cmEgd2hpdGVzcGFjZSBhdCB0aGUgYmVnaW5uaW5nIG9mIENTUyB2YXJpYWJsZXMsIGhlbmNlIHRoZSBuZWVkIHRvIHRyaW0oKVxuXHRcdFx0c3R5bGUgPSBfdGVtcERpdi5zdHlsZSxcblx0XHRcdGhvcml6b250YWwgPSBfaG9yaXpvbnRhbEV4cC50ZXN0KHByb3BlcnR5KSxcblx0XHRcdGlzUm9vdFNWRyA9IHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCIsXG5cdFx0XHRtZWFzdXJlUHJvcGVydHkgPSAoaXNSb290U1ZHID8gXCJjbGllbnRcIiA6IFwib2Zmc2V0XCIpICsgKGhvcml6b250YWwgPyBcIldpZHRoXCIgOiBcIkhlaWdodFwiKSxcblx0XHRcdGFtb3VudCA9IDEwMCxcblx0XHRcdHRvUGl4ZWxzID0gdW5pdCA9PT0gXCJweFwiLFxuXHRcdFx0dG9QZXJjZW50ID0gdW5pdCA9PT0gXCIlXCIsXG5cdFx0XHRweCwgcGFyZW50LCBjYWNoZSwgaXNTVkc7XG5cdFx0aWYgKHVuaXQgPT09IGN1clVuaXQgfHwgIWN1clZhbHVlIHx8IF9ub25Db252ZXJ0aWJsZVVuaXRzW3VuaXRdIHx8IF9ub25Db252ZXJ0aWJsZVVuaXRzW2N1clVuaXRdKSB7XG5cdFx0XHRyZXR1cm4gY3VyVmFsdWU7XG5cdFx0fVxuXHRcdChjdXJVbml0ICE9PSBcInB4XCIgJiYgIXRvUGl4ZWxzKSAmJiAoY3VyVmFsdWUgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgXCJweFwiKSk7XG5cdFx0aXNTVkcgPSB0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpO1xuXHRcdGlmICgodG9QZXJjZW50IHx8IGN1clVuaXQgPT09IFwiJVwiKSAmJiAoX3RyYW5zZm9ybVByb3BzW3Byb3BlcnR5XSB8fCB+cHJvcGVydHkuaW5kZXhPZihcImFkaXVzXCIpKSkge1xuXHRcdFx0cHggPSBpc1NWRyA/IHRhcmdldC5nZXRCQm94KClbaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdIDogdGFyZ2V0W21lYXN1cmVQcm9wZXJ0eV07XG5cdFx0XHRyZXR1cm4gX3JvdW5kKHRvUGVyY2VudCA/IGN1clZhbHVlIC8gcHggKiBhbW91bnQgOiBjdXJWYWx1ZSAvIDEwMCAqIHB4KTtcblx0XHR9XG5cdFx0c3R5bGVbaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdID0gYW1vdW50ICsgKHRvUGl4ZWxzID8gY3VyVW5pdCA6IHVuaXQpO1xuXHRcdHBhcmVudCA9ICh+cHJvcGVydHkuaW5kZXhPZihcImFkaXVzXCIpIHx8ICh1bml0ID09PSBcImVtXCIgJiYgdGFyZ2V0LmFwcGVuZENoaWxkICYmICFpc1Jvb3RTVkcpKSA/IHRhcmdldCA6IHRhcmdldC5wYXJlbnROb2RlO1xuXHRcdGlmIChpc1NWRykge1xuXHRcdFx0cGFyZW50ID0gKHRhcmdldC5vd25lclNWR0VsZW1lbnQgfHwge30pLnBhcmVudE5vZGU7XG5cdFx0fVxuXHRcdGlmICghcGFyZW50IHx8IHBhcmVudCA9PT0gX2RvYyB8fCAhcGFyZW50LmFwcGVuZENoaWxkKSB7XG5cdFx0XHRwYXJlbnQgPSBfZG9jLmJvZHk7XG5cdFx0fVxuXHRcdGNhY2hlID0gcGFyZW50Ll9nc2FwO1xuXHRcdGlmIChjYWNoZSAmJiB0b1BlcmNlbnQgJiYgY2FjaGUud2lkdGggJiYgaG9yaXpvbnRhbCAmJiBjYWNoZS50aW1lID09PSBfdGlja2VyLnRpbWUpIHtcblx0XHRcdHJldHVybiBfcm91bmQoY3VyVmFsdWUgLyBjYWNoZS53aWR0aCAqIGFtb3VudCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChzdHlsZS5wb3NpdGlvbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJwb3NpdGlvblwiKSk7XG5cdFx0XHQocGFyZW50ID09PSB0YXJnZXQpICYmIChzdHlsZS5wb3NpdGlvbiA9IFwic3RhdGljXCIpOyAvLyBsaWtlIGZvciBib3JkZXJSYWRpdXMsIGlmIGl0J3MgYSAlIHdlIG11c3QgaGF2ZSBpdCByZWxhdGl2ZSB0byB0aGUgdGFyZ2V0IGl0c2VsZiBidXQgdGhhdCBtYXkgbm90IGhhdmUgcG9zaXRpb246IHJlbGF0aXZlIG9yIHBvc2l0aW9uOiBhYnNvbHV0ZSBpbiB3aGljaCBjYXNlIGl0J2QgZ28gdXAgdGhlIGNoYWluIHVudGlsIGl0IGZpbmRzIGl0cyBvZmZzZXRQYXJlbnQgKGJhZCkuIHBvc2l0aW9uOiBzdGF0aWMgcHJvdGVjdHMgYWdhaW5zdCB0aGF0LlxuXHRcdFx0cGFyZW50LmFwcGVuZENoaWxkKF90ZW1wRGl2KTtcblx0XHRcdHB4ID0gX3RlbXBEaXZbbWVhc3VyZVByb3BlcnR5XTtcblx0XHRcdHBhcmVudC5yZW1vdmVDaGlsZChfdGVtcERpdik7XG5cdFx0XHRzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRcdGlmIChob3Jpem9udGFsICYmIHRvUGVyY2VudCkge1xuXHRcdFx0XHRjYWNoZSA9IF9nZXRDYWNoZShwYXJlbnQpO1xuXHRcdFx0XHRjYWNoZS50aW1lID0gX3RpY2tlci50aW1lO1xuXHRcdFx0XHRjYWNoZS53aWR0aCA9IHBhcmVudFttZWFzdXJlUHJvcGVydHldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX3JvdW5kKHRvUGl4ZWxzID8gcHggKiBjdXJWYWx1ZSAvIGFtb3VudCA6IHB4ICYmIGN1clZhbHVlID8gYW1vdW50IC8gcHggKiBjdXJWYWx1ZSA6IDApO1xuXHR9LFxuXHRfZ2V0ID0gKHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpID0+IHtcblx0XHRsZXQgdmFsdWU7XG5cdFx0X3BsdWdpbkluaXR0ZWQgfHwgX2luaXRDb3JlKCk7XG5cdFx0aWYgKChwcm9wZXJ0eSBpbiBfcHJvcGVydHlBbGlhc2VzKSAmJiBwcm9wZXJ0eSAhPT0gXCJ0cmFuc2Zvcm1cIikge1xuXHRcdFx0cHJvcGVydHkgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcblx0XHRcdGlmICh+cHJvcGVydHkuaW5kZXhPZihcIixcIikpIHtcblx0XHRcdFx0cHJvcGVydHkgPSBwcm9wZXJ0eS5zcGxpdChcIixcIilbMF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG5cdFx0XHR2YWx1ZSA9IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHVuY2FjaGUpO1xuXHRcdFx0dmFsdWUgPSAocHJvcGVydHkgIT09IFwidHJhbnNmb3JtT3JpZ2luXCIpID8gdmFsdWVbcHJvcGVydHldIDogdmFsdWUuc3ZnID8gdmFsdWUub3JpZ2luIDogX2ZpcnN0VHdvT25seShfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSkgKyBcIiBcIiArIHZhbHVlLnpPcmlnaW4gKyBcInB4XCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbHVlID0gdGFyZ2V0LnN0eWxlW3Byb3BlcnR5XTtcblx0XHRcdGlmICghdmFsdWUgfHwgdmFsdWUgPT09IFwiYXV0b1wiIHx8IHVuY2FjaGUgfHwgfih2YWx1ZSArIFwiXCIpLmluZGV4T2YoXCJjYWxjKFwiKSkge1xuXHRcdFx0XHR2YWx1ZSA9IChfc3BlY2lhbFByb3BzW3Byb3BlcnR5XSAmJiBfc3BlY2lhbFByb3BzW3Byb3BlcnR5XSh0YXJnZXQsIHByb3BlcnR5LCB1bml0KSkgfHwgX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSkgfHwgX2dldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHx8IChwcm9wZXJ0eSA9PT0gXCJvcGFjaXR5XCIgPyAxIDogMCk7IC8vIG5vdGU6IHNvbWUgYnJvd3NlcnMsIGxpa2UgRmlyZWZveCwgZG9uJ3QgcmVwb3J0IGJvcmRlclJhZGl1cyBjb3JyZWN0bHkhIEluc3RlYWQsIGl0IG9ubHkgcmVwb3J0cyBldmVyeSBjb3JuZXIgbGlrZSAgYm9yZGVyVG9wTGVmdFJhZGl1c1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdW5pdCAmJiAhfih2YWx1ZSArIFwiXCIpLnRyaW0oKS5pbmRleE9mKFwiIFwiKSA/IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCB1bml0KSArIHVuaXQgOiB2YWx1ZTtcblxuXHR9LFxuXHRfdHdlZW5Db21wbGV4Q1NTU3RyaW5nID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kKSB7IC8vbm90ZTogd2UgY2FsbCBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwocGx1Z2luSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblx0XHRpZiAoIXN0YXJ0IHx8IHN0YXJ0ID09PSBcIm5vbmVcIikgeyAvLyBzb21lIGJyb3dzZXJzIGxpa2UgU2FmYXJpIGFjdHVhbGx5IFBSRUZFUiB0aGUgcHJlZml4ZWQgcHJvcGVydHkgYW5kIG1pcy1yZXBvcnQgdGhlIHVucHJlZml4ZWQgdmFsdWUgbGlrZSBjbGlwUGF0aCAoQlVHKS4gSW4gb3RoZXIgd29yZHMsIGV2ZW4gdGhvdWdoIGNsaXBQYXRoIGV4aXN0cyBpbiB0aGUgc3R5bGUgKFwiY2xpcFBhdGhcIiBpbiB0YXJnZXQuc3R5bGUpIGFuZCBpdCdzIHNldCBpbiB0aGUgQ1NTIHByb3Blcmx5IChhbG9uZyB3aXRoIC13ZWJraXQtY2xpcC1wYXRoKSwgU2FmYXJpIHJlcG9ydHMgY2xpcFBhdGggYXMgXCJub25lXCIgd2hlcmVhcyBXZWJraXRDbGlwUGF0aCByZXBvcnRzIGFjY3VyYXRlbHkgbGlrZSBcImVsbGlwc2UoMTAwJSAwJSBhdCA1MCUgMCUpXCIsIHNvIGluIHRoaXMgY2FzZSB3ZSBtdXN0IFNXSVRDSCB0byB1c2luZyB0aGUgcHJlZml4ZWQgcHJvcGVydHkgaW5zdGVhZC4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMTgzMTAtY2xpcHBhdGgtZG9lc250LXdvcmstb24taW9zL1xuXHRcdFx0bGV0IHAgPSBfY2hlY2tQcm9wUHJlZml4KHByb3AsIHRhcmdldCwgMSksXG5cdFx0XHRcdHMgPSBwICYmIF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcCwgMSk7XG5cdFx0XHRpZiAocyAmJiBzICE9PSBzdGFydCkge1xuXHRcdFx0XHRwcm9wID0gcDtcblx0XHRcdFx0c3RhcnQgPSBzO1xuXHRcdFx0fSBlbHNlIGlmIChwcm9wID09PSBcImJvcmRlckNvbG9yXCIpIHtcblx0XHRcdFx0c3RhcnQgPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIFwiYm9yZGVyVG9wQ29sb3JcIik7IC8vIEZpcmVmb3ggYnVnOiBhbHdheXMgcmVwb3J0cyBcImJvcmRlckNvbG9yXCIgYXMgXCJcIiwgc28gd2UgbXVzdCBmYWxsIGJhY2sgdG8gYm9yZGVyVG9wQ29sb3IuIFNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzI0NTgzLWhvdy10by1yZXR1cm4tY29sb3JzLXRoYXQtaS1oYWQtYWZ0ZXItcmV2ZXJzZS9cblx0XHRcdH1cblx0XHR9XG5cdFx0bGV0IHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LnN0eWxlLCBwcm9wLCAwLCAxLCBfcmVuZGVyQ29tcGxleFN0cmluZyksXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRtYXRjaEluZGV4ID0gMCxcblx0XHRcdGEsIHJlc3VsdCxcdHN0YXJ0VmFsdWVzLCBzdGFydE51bSwgY29sb3IsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBlbmROdW0sIGNodW5rLCBlbmRVbml0LCBzdGFydFVuaXQsIHJlbGF0aXZlLCBlbmRWYWx1ZXM7XG5cdFx0cHQuYiA9IHN0YXJ0O1xuXHRcdHB0LmUgPSBlbmQ7XG5cdFx0c3RhcnQgKz0gXCJcIjsgLy9lbnN1cmUgdmFsdWVzIGFyZSBzdHJpbmdzXG5cdFx0ZW5kICs9IFwiXCI7XG5cdFx0aWYgKGVuZCA9PT0gXCJhdXRvXCIpIHtcblx0XHRcdHRhcmdldC5zdHlsZVtwcm9wXSA9IGVuZDtcblx0XHRcdGVuZCA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcCkgfHwgZW5kO1xuXHRcdFx0dGFyZ2V0LnN0eWxlW3Byb3BdID0gc3RhcnQ7XG5cdFx0fVxuXHRcdGEgPSBbc3RhcnQsIGVuZF07XG5cdFx0X2NvbG9yU3RyaW5nRmlsdGVyKGEpOyAvL3Bhc3MgYW4gYXJyYXkgd2l0aCB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyB2YWx1ZXMgYW5kIGxldCB0aGUgZmlsdGVyIGRvIHdoYXRldmVyIGl0IG5lZWRzIHRvIHRoZSB2YWx1ZXMuIElmIGNvbG9ycyBhcmUgZm91bmQsIGl0IHJldHVybnMgdHJ1ZSBhbmQgdGhlbiB3ZSBtdXN0IG1hdGNoIHdoZXJlIHRoZSBjb2xvciBzaG93cyB1cCBvcmRlci13aXNlIGJlY2F1c2UgZm9yIHRoaW5ncyBsaWtlIGJveFNoYWRvdywgc29tZXRpbWVzIHRoZSBicm93c2VyIHByb3ZpZGVzIHRoZSBjb21wdXRlZCB2YWx1ZXMgd2l0aCB0aGUgY29sb3IgRklSU1QsIGJ1dCB0aGUgdXNlciBwcm92aWRlcyBpdCB3aXRoIHRoZSBjb2xvciBMQVNULCBzbyBmbGlwIHRoZW0gaWYgbmVjZXNzYXJ5LiBTYW1lIGZvciBkcm9wLXNoYWRvdygpLlxuXHRcdHN0YXJ0ID0gYVswXTtcblx0XHRlbmQgPSBhWzFdO1xuXHRcdHN0YXJ0VmFsdWVzID0gc3RhcnQubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcblx0XHRlbmRWYWx1ZXMgPSBlbmQubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcblx0XHRpZiAoZW5kVmFsdWVzLmxlbmd0aCkge1xuXHRcdFx0d2hpbGUgKChyZXN1bHQgPSBfbnVtV2l0aFVuaXRFeHAuZXhlYyhlbmQpKSkge1xuXHRcdFx0XHRlbmRWYWx1ZSA9IHJlc3VsdFswXTtcblx0XHRcdFx0Y2h1bmsgPSBlbmQuc3Vic3RyaW5nKGluZGV4LCByZXN1bHQuaW5kZXgpO1xuXHRcdFx0XHRpZiAoY29sb3IpIHtcblx0XHRcdFx0XHRjb2xvciA9IChjb2xvciArIDEpICUgNTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaHVuay5zdWJzdHIoLTUpID09PSBcInJnYmEoXCIgfHwgY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJoc2xhKFwiKSB7XG5cdFx0XHRcdFx0Y29sb3IgPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlbmRWYWx1ZSAhPT0gKHN0YXJ0VmFsdWUgPSBzdGFydFZhbHVlc1ttYXRjaEluZGV4KytdIHx8IFwiXCIpKSB7XG5cdFx0XHRcdFx0c3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpIHx8IDA7XG5cdFx0XHRcdFx0c3RhcnRVbml0ID0gc3RhcnRWYWx1ZS5zdWJzdHIoKHN0YXJ0TnVtICsgXCJcIikubGVuZ3RoKTtcblx0XHRcdFx0XHRyZWxhdGl2ZSA9IChlbmRWYWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiKSA/ICsoZW5kVmFsdWUuY2hhckF0KDApICsgXCIxXCIpIDogMDtcblx0XHRcdFx0XHRpZiAocmVsYXRpdmUpIHtcblx0XHRcdFx0XHRcdGVuZFZhbHVlID0gZW5kVmFsdWUuc3Vic3RyKDIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKTtcblx0XHRcdFx0XHRlbmRVbml0ID0gZW5kVmFsdWUuc3Vic3RyKChlbmROdW0gKyBcIlwiKS5sZW5ndGgpO1xuXHRcdFx0XHRcdGluZGV4ID0gX251bVdpdGhVbml0RXhwLmxhc3RJbmRleCAtIGVuZFVuaXQubGVuZ3RoO1xuXHRcdFx0XHRcdGlmICghZW5kVW5pdCkgeyAvL2lmIHNvbWV0aGluZyBsaWtlIFwicGVyc3BlY3RpdmU6MzAwXCIgaXMgcGFzc2VkIGluIGFuZCB3ZSBtdXN0IGFkZCBhIHVuaXQgdG8gdGhlIGVuZFxuXHRcdFx0XHRcdFx0ZW5kVW5pdCA9IGVuZFVuaXQgfHwgX2NvbmZpZy51bml0c1twcm9wXSB8fCBzdGFydFVuaXQ7XG5cdFx0XHRcdFx0XHRpZiAoaW5kZXggPT09IGVuZC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0ZW5kICs9IGVuZFVuaXQ7XG5cdFx0XHRcdFx0XHRcdHB0LmUgKz0gZW5kVW5pdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCkge1xuXHRcdFx0XHRcdFx0c3RhcnROdW0gPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3AsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIHx8IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vdGhlc2UgbmVzdGVkIFByb3BUd2VlbnMgYXJlIGhhbmRsZWQgaW4gYSBzcGVjaWFsIHdheSAtIHdlJ2xsIG5ldmVyIGFjdHVhbGx5IGNhbGwgYSByZW5kZXIgb3Igc2V0dGVyIG1ldGhvZCBvbiB0aGVtLiBXZSdsbCBqdXN0IGxvb3AgdGhyb3VnaCB0aGVtIGluIHRoZSBwYXJlbnQgY29tcGxleCBzdHJpbmcgUHJvcFR3ZWVuJ3MgcmVuZGVyIG1ldGhvZC5cblx0XHRcdFx0XHRwdC5fcHQgPSB7XG5cdFx0XHRcdFx0XHRfbmV4dDpwdC5fcHQsXG5cdFx0XHRcdFx0XHRwOihjaHVuayB8fCAobWF0Y2hJbmRleCA9PT0gMSkpID8gY2h1bmsgOiBcIixcIiwgLy9ub3RlOiBTVkcgc3BlYyBhbGxvd3Mgb21pc3Npb24gb2YgY29tbWEvc3BhY2Ugd2hlbiBhIG5lZ2F0aXZlIHNpZ24gaXMgd2VkZ2VkIGJldHdlZW4gdHdvIG51bWJlcnMsIGxpa2UgMi41LTUuMyBpbnN0ZWFkIG9mIDIuNSwtNS4zIGJ1dCB3aGVuIHR3ZWVuaW5nLCB0aGUgbmVnYXRpdmUgdmFsdWUgbWF5IHN3aXRjaCB0byBwb3NpdGl2ZSwgc28gd2UgaW5zZXJ0IHRoZSBjb21tYSBqdXN0IGluIGNhc2UuXG5cdFx0XHRcdFx0XHRzOnN0YXJ0TnVtLFxuXHRcdFx0XHRcdFx0YzpyZWxhdGl2ZSA/IHJlbGF0aXZlICogZW5kTnVtIDogZW5kTnVtIC0gc3RhcnROdW0sXG5cdFx0XHRcdFx0XHRtOihjb2xvciAmJiBjb2xvciA8IDQpIHx8IHByb3AgPT09IFwiekluZGV4XCIgPyBNYXRoLnJvdW5kIDogMFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHB0LmMgPSAoaW5kZXggPCBlbmQubGVuZ3RoKSA/IGVuZC5zdWJzdHJpbmcoaW5kZXgsIGVuZC5sZW5ndGgpIDogXCJcIjsgLy93ZSB1c2UgdGhlIFwiY1wiIG9mIHRoZSBQcm9wVHdlZW4gdG8gc3RvcmUgdGhlIGZpbmFsIHBhcnQgb2YgdGhlIHN0cmluZyAoYWZ0ZXIgdGhlIGxhc3QgbnVtYmVyKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwdC5yID0gcHJvcCA9PT0gXCJkaXNwbGF5XCIgJiYgZW5kID09PSBcIm5vbmVcIiA/IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kIDogX3JlbmRlck5vblR3ZWVuaW5nVmFsdWU7XG5cdFx0fVxuXHRcdF9yZWxFeHAudGVzdChlbmQpICYmIChwdC5lID0gMCk7IC8vaWYgdGhlIGVuZCBzdHJpbmcgY29udGFpbnMgcmVsYXRpdmUgdmFsdWVzIG9yIGR5bmFtaWMgcmFuZG9tKC4uLikgdmFsdWVzLCBkZWxldGUgdGhlIGVuZCBpdCBzbyB0aGF0IG9uIHRoZSBmaW5hbCByZW5kZXIgd2UgZG9uJ3QgYWN0dWFsbHkgc2V0IGl0IHRvIHRoZSBzdHJpbmcgd2l0aCArPSBvciAtPSBjaGFyYWN0ZXJzIChmb3JjZXMgaXQgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHZhbHVlKS5cblx0XHR0aGlzLl9wdCA9IHB0OyAvL3N0YXJ0IHRoZSBsaW5rZWQgbGlzdCB3aXRoIHRoaXMgbmV3IFByb3BUd2Vlbi4gUmVtZW1iZXIsIHdlIGNhbGwgX3R3ZWVuQ29tcGxleENTU1N0cmluZy5jYWxsKHBsdWdpbkluc3RhbmNlLi4uKSB0byBlbnN1cmUgdGhhdCBpdCdzIHNjb3BlZCBwcm9wZXJseS4gV2UgbWF5IGNhbGwgaXQgZnJvbSB3aXRoaW4gYW5vdGhlciBwbHVnaW4gdG9vLCB0aHVzIFwidGhpc1wiIHdvdWxkIHJlZmVyIHRvIHRoZSBwbHVnaW4uXG5cdFx0cmV0dXJuIHB0O1xuXHR9LFxuXHRfa2V5d29yZFRvUGVyY2VudCA9IHt0b3A6XCIwJVwiLCBib3R0b206XCIxMDAlXCIsIGxlZnQ6XCIwJVwiLCByaWdodDpcIjEwMCVcIiwgY2VudGVyOlwiNTAlXCJ9LFxuXHRfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyA9IHZhbHVlID0+IHtcblx0XHRsZXQgc3BsaXQgPSB2YWx1ZS5zcGxpdChcIiBcIiksXG5cdFx0XHR4ID0gc3BsaXRbMF0sXG5cdFx0XHR5ID0gc3BsaXRbMV0gfHwgXCI1MCVcIjtcblx0XHRpZiAoeCA9PT0gXCJ0b3BcIiB8fCB4ID09PSBcImJvdHRvbVwiIHx8IHkgPT09IFwibGVmdFwiIHx8IHkgPT09IFwicmlnaHRcIikgeyAvL3RoZSB1c2VyIHByb3ZpZGVkIHRoZW0gaW4gdGhlIHdyb25nIG9yZGVyLCBzbyBmbGlwIHRoZW1cblx0XHRcdHZhbHVlID0geDtcblx0XHRcdHggPSB5O1xuXHRcdFx0eSA9IHZhbHVlO1xuXHRcdH1cblx0XHRzcGxpdFswXSA9IF9rZXl3b3JkVG9QZXJjZW50W3hdIHx8IHg7XG5cdFx0c3BsaXRbMV0gPSBfa2V5d29yZFRvUGVyY2VudFt5XSB8fCB5O1xuXHRcdHJldHVybiBzcGxpdC5qb2luKFwiIFwiKTtcblx0fSxcblx0X3JlbmRlckNsZWFyUHJvcHMgPSAocmF0aW8sIGRhdGEpID0+IHtcblx0XHRpZiAoZGF0YS50d2VlbiAmJiBkYXRhLnR3ZWVuLl90aW1lID09PSBkYXRhLnR3ZWVuLl9kdXIpIHtcblx0XHRcdGxldCB0YXJnZXQgPSBkYXRhLnQsXG5cdFx0XHRcdHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuXHRcdFx0XHRwcm9wcyA9IGRhdGEudSxcblx0XHRcdFx0Y2FjaGUgPSB0YXJnZXQuX2dzYXAsXG5cdFx0XHRcdHByb3AsIGNsZWFyVHJhbnNmb3JtcywgaTtcblx0XHRcdGlmIChwcm9wcyA9PT0gXCJhbGxcIiB8fCBwcm9wcyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRzdHlsZS5jc3NUZXh0ID0gXCJcIjtcblx0XHRcdFx0Y2xlYXJUcmFuc2Zvcm1zID0gMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHByb3BzID0gcHJvcHMuc3BsaXQoXCIsXCIpO1xuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRwcm9wID0gcHJvcHNbaV07XG5cdFx0XHRcdFx0aWYgKF90cmFuc2Zvcm1Qcm9wc1twcm9wXSkge1xuXHRcdFx0XHRcdFx0Y2xlYXJUcmFuc2Zvcm1zID0gMTtcblx0XHRcdFx0XHRcdHByb3AgPSAocHJvcCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIikgPyBfdHJhbnNmb3JtT3JpZ2luUHJvcCA6IF90cmFuc2Zvcm1Qcm9wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGNsZWFyVHJhbnNmb3Jtcykge1xuXHRcdFx0XHRfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cdFx0XHRcdGlmIChjYWNoZSkge1xuXHRcdFx0XHRcdGNhY2hlLnN2ZyAmJiB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuXHRcdFx0XHRcdF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpOyAvLyBmb3JjZSBhbGwgdGhlIGNhY2hlZCB2YWx1ZXMgYmFjayB0byBcIm5vcm1hbFwiL2lkZW50aXR5LCBvdGhlcndpc2UgaWYgdGhlcmUncyBhbm90aGVyIHR3ZWVuIHRoYXQncyBhbHJlYWR5IHNldCB0byByZW5kZXIgdHJhbnNmb3JtcyBvbiB0aGlzIGVsZW1lbnQsIGl0IGNvdWxkIGRpc3BsYXkgdGhlIHdyb25nIHZhbHVlcy5cblx0XHRcdFx0XHRjYWNoZS51bmNhY2hlID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0Ly8gbm90ZTogc3BlY2lhbFByb3BzIHNob3VsZCByZXR1cm4gMSBpZiAoYW5kIG9ubHkgaWYpIHRoZXkgaGF2ZSBhIG5vbi16ZXJvIHByaW9yaXR5LiBJdCBpbmRpY2F0ZXMgd2UgbmVlZCB0byBzb3J0IHRoZSBsaW5rZWQgbGlzdC5cblx0X3NwZWNpYWxQcm9wcyA9IHtcblx0XHRjbGVhclByb3BzKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG5cdFx0XHRpZiAodHdlZW4uZGF0YSAhPT0gXCJpc0Zyb21TdGFydFwiKSB7XG5cdFx0XHRcdGxldCBwdCA9IHBsdWdpbi5fcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIDAsIDAsIF9yZW5kZXJDbGVhclByb3BzKTtcblx0XHRcdFx0cHQudSA9IGVuZFZhbHVlO1xuXHRcdFx0XHRwdC5wciA9IC0xMDtcblx0XHRcdFx0cHQudHdlZW4gPSB0d2Vlbjtcblx0XHRcdFx0cGx1Z2luLl9wcm9wcy5wdXNoKHByb3BlcnR5KTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8qIGNsYXNzTmFtZSBmZWF0dXJlIChhYm91dCAwLjRrYiBnemlwcGVkKS5cblx0XHQsIGNsYXNzTmFtZShwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xuXHRcdFx0bGV0IF9yZW5kZXJDbGFzc05hbWUgPSAocmF0aW8sIGRhdGEpID0+IHtcblx0XHRcdFx0XHRkYXRhLmNzcy5yZW5kZXIocmF0aW8sIGRhdGEuY3NzKTtcblx0XHRcdFx0XHRpZiAoIXJhdGlvIHx8IHJhdGlvID09PSAxKSB7XG5cdFx0XHRcdFx0XHRsZXQgaW5saW5lID0gZGF0YS5ybXYsXG5cdFx0XHRcdFx0XHRcdHRhcmdldCA9IGRhdGEudCxcblx0XHRcdFx0XHRcdFx0cDtcblx0XHRcdFx0XHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCByYXRpbyA/IGRhdGEuZSA6IGRhdGEuYik7XG5cdFx0XHRcdFx0XHRmb3IgKHAgaW4gaW5saW5lKSB7XG5cdFx0XHRcdFx0XHRcdF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIHApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0X2dldEFsbFN0eWxlcyA9ICh0YXJnZXQpID0+IHtcblx0XHRcdFx0XHRsZXQgc3R5bGVzID0ge30sXG5cdFx0XHRcdFx0XHRjb21wdXRlZCA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KSxcblx0XHRcdFx0XHRcdHA7XG5cdFx0XHRcdFx0Zm9yIChwIGluIGNvbXB1dGVkKSB7XG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4ocCkgJiYgcCAhPT0gXCJjc3NUZXh0XCIgJiYgcCAhPT0gXCJsZW5ndGhcIikge1xuXHRcdFx0XHRcdFx0XHRzdHlsZXNbcF0gPSBjb21wdXRlZFtwXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X3NldERlZmF1bHRzKHN0eWxlcywgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSkpO1xuXHRcdFx0XHRcdHJldHVybiBzdHlsZXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHN0YXJ0Q2xhc3NMaXN0ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLFxuXHRcdFx0XHRzdHlsZSA9IHRhcmdldC5zdHlsZSxcblx0XHRcdFx0Y3NzVGV4dCA9IHN0eWxlLmNzc1RleHQsXG5cdFx0XHRcdGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuXHRcdFx0XHRjbGFzc1BUID0gY2FjaGUuY2xhc3NQVCxcblx0XHRcdFx0aW5saW5lVG9SZW1vdmVBdEVuZCA9IHt9LFxuXHRcdFx0XHRkYXRhID0ge3Q6dGFyZ2V0LCBwbHVnaW46cGx1Z2luLCBybXY6aW5saW5lVG9SZW1vdmVBdEVuZCwgYjpzdGFydENsYXNzTGlzdCwgZTooZW5kVmFsdWUuY2hhckF0KDEpICE9PSBcIj1cIikgPyBlbmRWYWx1ZSA6IHN0YXJ0Q2xhc3NMaXN0LnJlcGxhY2UobmV3IFJlZ0V4cChcIig/OlxcXFxzfF4pXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgKyBcIig/IVtcXFxcdy1dKVwiKSwgXCJcIikgKyAoKGVuZFZhbHVlLmNoYXJBdCgwKSA9PT0gXCIrXCIpID8gXCIgXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgOiBcIlwiKX0sXG5cdFx0XHRcdGNoYW5naW5nVmFycyA9IHt9LFxuXHRcdFx0XHRzdGFydFZhcnMgPSBfZ2V0QWxsU3R5bGVzKHRhcmdldCksXG5cdFx0XHRcdHRyYW5zZm9ybVJlbGF0ZWQgPSAvKHRyYW5zZm9ybXxwZXJzcGVjdGl2ZSkvaSxcblx0XHRcdFx0ZW5kVmFycywgcDtcblx0XHRcdGlmIChjbGFzc1BUKSB7XG5cdFx0XHRcdGNsYXNzUFQucigxLCBjbGFzc1BULmQpO1xuXHRcdFx0XHRfcmVtb3ZlTGlua2VkTGlzdEl0ZW0oY2xhc3NQVC5kLnBsdWdpbiwgY2xhc3NQVCwgXCJfcHRcIik7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZGF0YS5lKTtcblx0XHRcdGVuZFZhcnMgPSBfZ2V0QWxsU3R5bGVzKHRhcmdldCwgdHJ1ZSk7XG5cdFx0XHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgc3RhcnRDbGFzc0xpc3QpO1xuXHRcdFx0Zm9yIChwIGluIGVuZFZhcnMpIHtcblx0XHRcdFx0aWYgKGVuZFZhcnNbcF0gIT09IHN0YXJ0VmFyc1twXSAmJiAhdHJhbnNmb3JtUmVsYXRlZC50ZXN0KHApKSB7XG5cdFx0XHRcdFx0Y2hhbmdpbmdWYXJzW3BdID0gZW5kVmFyc1twXTtcblx0XHRcdFx0XHRpZiAoIXN0eWxlW3BdICYmIHN0eWxlW3BdICE9PSBcIjBcIikge1xuXHRcdFx0XHRcdFx0aW5saW5lVG9SZW1vdmVBdEVuZFtwXSA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjYWNoZS5jbGFzc1BUID0gcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBcImNsYXNzTmFtZVwiLCAwLCAwLCBfcmVuZGVyQ2xhc3NOYW1lLCBkYXRhLCAwLCAtMTEpO1xuXHRcdFx0aWYgKHN0eWxlLmNzc1RleHQgIT09IGNzc1RleHQpIHsgLy9vbmx5IGFwcGx5IGlmIHRoaW5ncyBjaGFuZ2UuIE90aGVyd2lzZSwgaW4gY2FzZXMgbGlrZSBhIGJhY2tncm91bmQtaW1hZ2UgdGhhdCdzIHB1bGxlZCBkeW5hbWljYWxseSwgaXQgY291bGQgY2F1c2UgYSByZWZyZXNoLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMDM2OC1wb3NzaWJsZS1nc2FwLWJ1Zy1zd2l0Y2hpbmctY2xhc3NuYW1lcy1pbi1jaHJvbWUvLlxuXHRcdFx0XHRzdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDsgLy93ZSByZWNvcmRlZCBjc3NUZXh0IGJlZm9yZSB3ZSBzd2FwcGVkIGNsYXNzZXMgYW5kIHJhbiBfZ2V0QWxsU3R5bGVzKCkgYmVjYXVzZSBpbiBjYXNlcyB3aGVuIGEgY2xhc3NOYW1lIHR3ZWVuIGlzIG92ZXJ3cml0dGVuLCB3ZSByZW1vdmUgYWxsIHRoZSByZWxhdGVkIHR3ZWVuaW5nIHByb3BlcnRpZXMgZnJvbSB0aGF0IGNsYXNzIGNoYW5nZSAob3RoZXJ3aXNlIGNsYXNzLXNwZWNpZmljIHN0dWZmIGNhbid0IG92ZXJyaWRlIHByb3BlcnRpZXMgd2UndmUgZGlyZWN0bHkgc2V0IG9uIHRoZSB0YXJnZXQncyBzdHlsZSBvYmplY3QgZHVlIHRvIHNwZWNpZmljaXR5KS5cblx0XHRcdH1cblx0XHRcdF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHRydWUpOyAvL3RvIGNsZWFyIHRoZSBjYWNoaW5nIG9mIHRyYW5zZm9ybXNcblx0XHRcdGRhdGEuY3NzID0gbmV3IGdzYXAucGx1Z2lucy5jc3MoKTtcblx0XHRcdGRhdGEuY3NzLmluaXQodGFyZ2V0LCBjaGFuZ2luZ1ZhcnMsIHR3ZWVuKTtcblx0XHRcdHBsdWdpbi5fcHJvcHMucHVzaCguLi5kYXRhLmNzcy5fcHJvcHMpO1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXHRcdCovXG5cdH0sXG5cblxuXG5cblxuXHQvKlxuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQgKiBUUkFOU0ZPUk1TXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqL1xuXHRfaWRlbnRpdHkyRE1hdHJpeCA9IFsxLDAsMCwxLDAsMF0sXG5cdF9yb3RhdGlvbmFsUHJvcGVydGllcyA9IHt9LFxuXHRfaXNOdWxsVHJhbnNmb3JtID0gdmFsdWUgPT4gKHZhbHVlID09PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiIHx8IHZhbHVlID09PSBcIm5vbmVcIiB8fCAhdmFsdWUpLFxuXHRfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5ID0gdGFyZ2V0ID0+IHtcblx0XHRsZXQgbWF0cml4U3RyaW5nID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cdFx0cmV0dXJuIF9pc051bGxUcmFuc2Zvcm0obWF0cml4U3RyaW5nKSA/IF9pZGVudGl0eTJETWF0cml4IDogbWF0cml4U3RyaW5nLnN1YnN0cig3KS5tYXRjaChfbnVtRXhwKS5tYXAoX3JvdW5kKTtcblx0fSxcblx0X2dldE1hdHJpeCA9ICh0YXJnZXQsIGZvcmNlMkQpID0+IHtcblx0XHRsZXQgY2FjaGUgPSB0YXJnZXQuX2dzYXAgfHwgX2dldENhY2hlKHRhcmdldCksXG5cdFx0XHRzdHlsZSA9IHRhcmdldC5zdHlsZSxcblx0XHRcdG1hdHJpeCA9IF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkodGFyZ2V0KSxcblx0XHRcdHBhcmVudCwgbmV4dFNpYmxpbmcsIHRlbXAsIGFkZGVkVG9ET007XG5cdFx0aWYgKGNhY2hlLnN2ZyAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpKSB7XG5cdFx0XHR0ZW1wID0gdGFyZ2V0LnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkubWF0cml4OyAvL2Vuc3VyZXMgdGhhdCBldmVuIGNvbXBsZXggdmFsdWVzIGxpa2UgXCJ0cmFuc2xhdGUoNTAsNjApIHJvdGF0ZSgxMzUsMCwwKVwiIGFyZSBwYXJzZWQgYmVjYXVzZSBpdCBtYXNoZXMgaXQgaW50byBhIG1hdHJpeC5cblx0XHRcdG1hdHJpeCA9IFt0ZW1wLmEsIHRlbXAuYiwgdGVtcC5jLCB0ZW1wLmQsIHRlbXAuZSwgdGVtcC5mXTtcblx0XHRcdHJldHVybiAobWF0cml4LmpvaW4oXCIsXCIpID09PSBcIjEsMCwwLDEsMCwwXCIpID8gX2lkZW50aXR5MkRNYXRyaXggOiBtYXRyaXg7XG5cdFx0fSBlbHNlIGlmIChtYXRyaXggPT09IF9pZGVudGl0eTJETWF0cml4ICYmICF0YXJnZXQub2Zmc2V0UGFyZW50ICYmIHRhcmdldCAhPT0gX2RvY0VsZW1lbnQgJiYgIWNhY2hlLnN2ZykgeyAvL25vdGU6IGlmIG9mZnNldFBhcmVudCBpcyBudWxsLCB0aGF0IG1lYW5zIHRoZSBlbGVtZW50IGlzbid0IGluIHRoZSBub3JtYWwgZG9jdW1lbnQgZmxvdywgbGlrZSBpZiBpdCBoYXMgZGlzcGxheTpub25lIG9yIG9uZSBvZiBpdHMgYW5jZXN0b3JzIGhhcyBkaXNwbGF5Om5vbmUpLiBGaXJlZm94IHJldHVybnMgbnVsbCBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSgpIGlmIHRoZSBlbGVtZW50IGlzIGluIGFuIGlmcmFtZSB0aGF0IGhhcyBkaXNwbGF5Om5vbmUuIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuXHRcdFx0Ly9icm93c2VycyBkb24ndCByZXBvcnQgdHJhbnNmb3JtcyBhY2N1cmF0ZWx5IHVubGVzcyB0aGUgZWxlbWVudCBpcyBpbiB0aGUgRE9NIGFuZCBoYXMgYSBkaXNwbGF5IHZhbHVlIHRoYXQncyBub3QgXCJub25lXCIuIEZpcmVmb3ggYW5kIE1pY3Jvc29mdCBicm93c2VycyBoYXZlIGEgcGFydGlhbCBidWcgd2hlcmUgdGhleSdsbCByZXBvcnQgdHJhbnNmb3JtcyBldmVuIGlmIGRpc3BsYXk6bm9uZSBCVVQgbm90IGFueSBwZXJjZW50YWdlLWJhc2VkIHZhbHVlcyBsaWtlIHRyYW5zbGF0ZSgtNTAlLCA4cHgpIHdpbGwgYmUgcmVwb3J0ZWQgYXMgaWYgaXQncyB0cmFuc2xhdGUoMCwgOHB4KS5cblx0XHRcdHRlbXAgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0XHRcdHBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCFwYXJlbnQgfHwgIXRhcmdldC5vZmZzZXRQYXJlbnQpIHsgLy8gbm90ZTogaW4gMy4zLjAgd2Ugc3dpdGNoZWQgdGFyZ2V0Lm9mZnNldFBhcmVudCB0byBfZG9jLmJvZHkuY29udGFpbnModGFyZ2V0KSB0byBhdm9pZCBbc29tZXRpbWVzIHVubmVjZXNzYXJ5XSBNdXRhdGlvbk9ic2VydmVyIGNhbGxzIGJ1dCB0aGF0IHdhc24ndCBhZGVxdWF0ZSBiZWNhdXNlIHRoZXJlIGFyZSBlZGdlIGNhc2VzIHdoZXJlIG5lc3RlZCBwb3NpdGlvbjogZml4ZWQgZWxlbWVudHMgbmVlZCB0byBnZXQgcmVwYXJlbnRlZCB0byBhY2N1cmF0ZWx5IHNlbnNlIHRyYW5zZm9ybXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JlZW5zb2NrL0dTQVAvaXNzdWVzLzM4OCBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HU0FQL2lzc3Vlcy8zNzVcblx0XHRcdFx0YWRkZWRUb0RPTSA9IDE7IC8vZmxhZ1xuXHRcdFx0XHRuZXh0U2libGluZyA9IHRhcmdldC5uZXh0U2libGluZztcblx0XHRcdFx0X2RvY0VsZW1lbnQuYXBwZW5kQ2hpbGQodGFyZ2V0KTsgLy93ZSBtdXN0IGFkZCBpdCB0byB0aGUgRE9NIGluIG9yZGVyIHRvIGdldCB2YWx1ZXMgcHJvcGVybHlcblx0XHRcdH1cblx0XHRcdG1hdHJpeCA9IF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkodGFyZ2V0KTtcblx0XHRcdHRlbXAgPyAoc3R5bGUuZGlzcGxheSA9IHRlbXApIDogX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgXCJkaXNwbGF5XCIpO1xuXHRcdFx0aWYgKGFkZGVkVG9ET00pIHtcblx0XHRcdFx0bmV4dFNpYmxpbmcgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRhcmdldCwgbmV4dFNpYmxpbmcpIDogcGFyZW50ID8gcGFyZW50LmFwcGVuZENoaWxkKHRhcmdldCkgOiBfZG9jRWxlbWVudC5yZW1vdmVDaGlsZCh0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gKGZvcmNlMkQgJiYgbWF0cml4Lmxlbmd0aCA+IDYpID8gW21hdHJpeFswXSwgbWF0cml4WzFdLCBtYXRyaXhbNF0sIG1hdHJpeFs1XSwgbWF0cml4WzEyXSwgbWF0cml4WzEzXV0gOiBtYXRyaXg7XG5cdH0sXG5cdF9hcHBseVNWR09yaWdpbiA9ICh0YXJnZXQsIG9yaWdpbiwgb3JpZ2luSXNBYnNvbHV0ZSwgc21vb3RoLCBtYXRyaXhBcnJheSwgcGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8pID0+IHtcblx0XHRsZXQgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG5cdFx0XHRtYXRyaXggPSBtYXRyaXhBcnJheSB8fCBfZ2V0TWF0cml4KHRhcmdldCwgdHJ1ZSksXG5cdFx0XHR4T3JpZ2luT2xkID0gY2FjaGUueE9yaWdpbiB8fCAwLFxuXHRcdFx0eU9yaWdpbk9sZCA9IGNhY2hlLnlPcmlnaW4gfHwgMCxcblx0XHRcdHhPZmZzZXRPbGQgPSBjYWNoZS54T2Zmc2V0IHx8IDAsXG5cdFx0XHR5T2Zmc2V0T2xkID0gY2FjaGUueU9mZnNldCB8fCAwLFxuXHRcdFx0YSA9IG1hdHJpeFswXSxcblx0XHRcdGIgPSBtYXRyaXhbMV0sXG5cdFx0XHRjID0gbWF0cml4WzJdLFxuXHRcdFx0ZCA9IG1hdHJpeFszXSxcblx0XHRcdHR4ID0gbWF0cml4WzRdLFxuXHRcdFx0dHkgPSBtYXRyaXhbNV0sXG5cdFx0XHRvcmlnaW5TcGxpdCA9IG9yaWdpbi5zcGxpdChcIiBcIiksXG5cdFx0XHR4T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW5TcGxpdFswXSkgfHwgMCxcblx0XHRcdHlPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpblNwbGl0WzFdKSB8fCAwLFxuXHRcdFx0Ym91bmRzLCBkZXRlcm1pbmFudCwgeCwgeTtcblx0XHRpZiAoIW9yaWdpbklzQWJzb2x1dGUpIHtcblx0XHRcdGJvdW5kcyA9IF9nZXRCQm94KHRhcmdldCk7XG5cdFx0XHR4T3JpZ2luID0gYm91bmRzLnggKyAofm9yaWdpblNwbGl0WzBdLmluZGV4T2YoXCIlXCIpID8geE9yaWdpbiAvIDEwMCAqIGJvdW5kcy53aWR0aCA6IHhPcmlnaW4pO1xuXHRcdFx0eU9yaWdpbiA9IGJvdW5kcy55ICsgKH4oKG9yaWdpblNwbGl0WzFdIHx8IG9yaWdpblNwbGl0WzBdKS5pbmRleE9mKFwiJVwiKSkgPyB5T3JpZ2luIC8gMTAwICogYm91bmRzLmhlaWdodCA6IHlPcmlnaW4pO1xuXHRcdH0gZWxzZSBpZiAobWF0cml4ICE9PSBfaWRlbnRpdHkyRE1hdHJpeCAmJiAoZGV0ZXJtaW5hbnQgPSAoYSAqIGQgLSBiICogYykpKSB7IC8vaWYgaXQncyB6ZXJvIChsaWtlIGlmIHNjYWxlWCBhbmQgc2NhbGVZIGFyZSB6ZXJvKSwgc2tpcCBpdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBkaXZpZGluZyBieSB6ZXJvLlxuXHRcdFx0eCA9IHhPcmlnaW4gKiAoZCAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoLWMgLyBkZXRlcm1pbmFudCkgKyAoKGMgKiB0eSAtIGQgKiB0eCkgLyBkZXRlcm1pbmFudCk7XG5cdFx0XHR5ID0geE9yaWdpbiAqICgtYiAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoYSAvIGRldGVybWluYW50KSAtICgoYSAqIHR5IC0gYiAqIHR4KSAvIGRldGVybWluYW50KTtcblx0XHRcdHhPcmlnaW4gPSB4O1xuXHRcdFx0eU9yaWdpbiA9IHk7XG5cdFx0fVxuXHRcdGlmIChzbW9vdGggfHwgKHNtb290aCAhPT0gZmFsc2UgJiYgY2FjaGUuc21vb3RoKSkge1xuXHRcdFx0dHggPSB4T3JpZ2luIC0geE9yaWdpbk9sZDtcblx0XHRcdHR5ID0geU9yaWdpbiAtIHlPcmlnaW5PbGQ7XG5cdFx0XHRjYWNoZS54T2Zmc2V0ID0geE9mZnNldE9sZCArICh0eCAqIGEgKyB0eSAqIGMpIC0gdHg7XG5cdFx0XHRjYWNoZS55T2Zmc2V0ID0geU9mZnNldE9sZCArICh0eCAqIGIgKyB0eSAqIGQpIC0gdHk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhY2hlLnhPZmZzZXQgPSBjYWNoZS55T2Zmc2V0ID0gMDtcblx0XHR9XG5cdFx0Y2FjaGUueE9yaWdpbiA9IHhPcmlnaW47XG5cdFx0Y2FjaGUueU9yaWdpbiA9IHlPcmlnaW47XG5cdFx0Y2FjaGUuc21vb3RoID0gISFzbW9vdGg7XG5cdFx0Y2FjaGUub3JpZ2luID0gb3JpZ2luO1xuXHRcdGNhY2hlLm9yaWdpbklzQWJzb2x1dGUgPSAhIW9yaWdpbklzQWJzb2x1dGU7XG5cdFx0dGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSA9IFwiMHB4IDBweFwiOyAvL290aGVyd2lzZSwgaWYgc29tZW9uZSBzZXRzICBhbiBvcmlnaW4gdmlhIENTUywgaXQgd2lsbCBsaWtlbHkgaW50ZXJmZXJlIHdpdGggdGhlIFNWRyB0cmFuc2Zvcm0gYXR0cmlidXRlIG9uZXMgKGJlY2F1c2UgcmVtZW1iZXIsIHdlJ3JlIGJha2luZyB0aGUgb3JpZ2luIGludG8gdGhlIG1hdHJpeCgpIHZhbHVlKS5cblx0XHRpZiAocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8pIHtcblx0XHRcdF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ4T3JpZ2luXCIsIHhPcmlnaW5PbGQsIHhPcmlnaW4pO1xuXHRcdFx0X2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInlPcmlnaW5cIiwgeU9yaWdpbk9sZCwgeU9yaWdpbik7XG5cdFx0XHRfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieE9mZnNldFwiLCB4T2Zmc2V0T2xkLCBjYWNoZS54T2Zmc2V0KTtcblx0XHRcdF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ5T2Zmc2V0XCIsIHlPZmZzZXRPbGQsIGNhY2hlLnlPZmZzZXQpO1xuXHRcdH1cblx0XHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIsIHhPcmlnaW4gKyBcIiBcIiArIHlPcmlnaW4pO1xuXHR9LFxuXHRfcGFyc2VUcmFuc2Zvcm0gPSAodGFyZ2V0LCB1bmNhY2hlKSA9PiB7XG5cdFx0bGV0IGNhY2hlID0gdGFyZ2V0Ll9nc2FwIHx8IG5ldyBHU0NhY2hlKHRhcmdldCk7XG5cdFx0aWYgKFwieFwiIGluIGNhY2hlICYmICF1bmNhY2hlICYmICFjYWNoZS51bmNhY2hlKSB7XG5cdFx0XHRyZXR1cm4gY2FjaGU7XG5cdFx0fVxuXHRcdGxldCBzdHlsZSA9IHRhcmdldC5zdHlsZSxcblx0XHRcdGludmVydGVkU2NhbGVYID0gY2FjaGUuc2NhbGVYIDwgMCxcblx0XHRcdHB4ID0gXCJweFwiLFxuXHRcdFx0ZGVnID0gXCJkZWdcIixcblx0XHRcdG9yaWdpbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybU9yaWdpblByb3ApIHx8IFwiMFwiLFxuXHRcdFx0eCwgeSwgeiwgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCByb3RhdGlvblgsIHJvdGF0aW9uWSwgc2tld1gsIHNrZXdZLCBwZXJzcGVjdGl2ZSwgeE9yaWdpbiwgeU9yaWdpbixcblx0XHRcdG1hdHJpeCwgYW5nbGUsIGNvcywgc2luLCBhLCBiLCBjLCBkLCBhMTIsIGEyMiwgdDEsIHQyLCB0MywgYTEzLCBhMjMsIGEzMywgYTQyLCBhNDMsIGEzMjtcblx0XHR4ID0geSA9IHogPSByb3RhdGlvbiA9IHJvdGF0aW9uWCA9IHJvdGF0aW9uWSA9IHNrZXdYID0gc2tld1kgPSBwZXJzcGVjdGl2ZSA9IDA7XG5cdFx0c2NhbGVYID0gc2NhbGVZID0gMTtcblx0XHRjYWNoZS5zdmcgPSAhISh0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpKTtcblx0XHRtYXRyaXggPSBfZ2V0TWF0cml4KHRhcmdldCwgY2FjaGUuc3ZnKTtcblx0XHRpZiAoY2FjaGUuc3ZnKSB7XG5cdFx0XHR0MSA9ICghY2FjaGUudW5jYWNoZSB8fCBvcmlnaW4gPT09IFwiMHB4IDBweFwiKSAmJiAhdW5jYWNoZSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIpOyAvLyBpZiBvcmlnaW4gaXMgMCwwIGFuZCBjYWNoZS51bmNhY2hlIGlzIHRydWUsIGxldCB0aGUgcmVjb3JkZWQgZGF0YS1zdmctb3JpZ2luIHN0YXkuIE90aGVyd2lzZSwgd2hlbmV2ZXIgd2Ugc2V0IGNhY2hlLnVuY2FjaGUgdG8gdHJ1ZSwgd2UnZCBuZWVkIHRvIHNldCBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IChjYWNoZS54T3JpZ2luIC0gYmJveC54KSArIFwicHggXCIgKyAoY2FjaGUueU9yaWdpbiAtIGJib3gueSkgKyBcInB4XCIuIFJlbWVtYmVyLCB0byB3b3JrIGFyb3VuZCBicm93c2VyIGluY29uc2lzdGVuY2llcyB3ZSBhbHdheXMgZm9yY2UgU1ZHIGVsZW1lbnRzJyB0cmFuc2Zvcm1PcmlnaW4gdG8gMCwwIGFuZCBvZmZzZXQgdGhlIHRyYW5zbGF0aW9uIGFjY29yZGluZ2x5LlxuXHRcdFx0X2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgdDEgfHwgb3JpZ2luLCAhIXQxIHx8IGNhY2hlLm9yaWdpbklzQWJzb2x1dGUsIGNhY2hlLnNtb290aCAhPT0gZmFsc2UsIG1hdHJpeCk7XG5cdFx0fVxuXHRcdHhPcmlnaW4gPSBjYWNoZS54T3JpZ2luIHx8IDA7XG5cdFx0eU9yaWdpbiA9IGNhY2hlLnlPcmlnaW4gfHwgMDtcblx0XHRpZiAobWF0cml4ICE9PSBfaWRlbnRpdHkyRE1hdHJpeCkge1xuXHRcdFx0YSA9IG1hdHJpeFswXTsgLy9hMTFcblx0XHRcdGIgPSBtYXRyaXhbMV07IC8vYTIxXG5cdFx0XHRjID0gbWF0cml4WzJdOyAvL2EzMVxuXHRcdFx0ZCA9IG1hdHJpeFszXTsgLy9hNDFcblx0XHRcdHggPSBhMTIgPSBtYXRyaXhbNF07XG5cdFx0XHR5ID0gYTIyID0gbWF0cml4WzVdO1xuXG5cdFx0XHQvLzJEIG1hdHJpeFxuXHRcdFx0aWYgKG1hdHJpeC5sZW5ndGggPT09IDYpIHtcblx0XHRcdFx0c2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuXHRcdFx0XHRzY2FsZVkgPSBNYXRoLnNxcnQoZCAqIGQgKyBjICogYyk7XG5cdFx0XHRcdHJvdGF0aW9uID0gKGEgfHwgYikgPyBfYXRhbjIoYiwgYSkgKiBfUkFEMkRFRyA6IDA7IC8vbm90ZTogaWYgc2NhbGVYIGlzIDAsIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IG1lYXN1cmUgcm90YXRpb24uIFNhbWUgZm9yIHNrZXdYIHdpdGggYSBzY2FsZVkgb2YgMC4gVGhlcmVmb3JlLCB3ZSBkZWZhdWx0IHRvIHRoZSBwcmV2aW91c2x5IHJlY29yZGVkIHZhbHVlIChvciB6ZXJvIGlmIHRoYXQgZG9lc24ndCBleGlzdCkuXG5cdFx0XHRcdHNrZXdYID0gKGMgfHwgZCkgPyBfYXRhbjIoYywgZCkgKiBfUkFEMkRFRyArIHJvdGF0aW9uIDogMDtcblx0XHRcdFx0c2tld1ggJiYgKHNjYWxlWSAqPSBNYXRoLmFicyhNYXRoLmNvcyhza2V3WCAqIF9ERUcyUkFEKSkpO1xuXHRcdFx0XHRpZiAoY2FjaGUuc3ZnKSB7XG5cdFx0XHRcdFx0eCAtPSB4T3JpZ2luIC0gKHhPcmlnaW4gKiBhICsgeU9yaWdpbiAqIGMpO1xuXHRcdFx0XHRcdHkgLT0geU9yaWdpbiAtICh4T3JpZ2luICogYiArIHlPcmlnaW4gKiBkKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLzNEIG1hdHJpeFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YTMyID0gbWF0cml4WzZdO1xuXHRcdFx0XHRhNDIgPSBtYXRyaXhbN107XG5cdFx0XHRcdGExMyA9IG1hdHJpeFs4XTtcblx0XHRcdFx0YTIzID0gbWF0cml4WzldO1xuXHRcdFx0XHRhMzMgPSBtYXRyaXhbMTBdO1xuXHRcdFx0XHRhNDMgPSBtYXRyaXhbMTFdO1xuXHRcdFx0XHR4ID0gbWF0cml4WzEyXTtcblx0XHRcdFx0eSA9IG1hdHJpeFsxM107XG5cdFx0XHRcdHogPSBtYXRyaXhbMTRdO1xuXG5cdFx0XHRcdGFuZ2xlID0gX2F0YW4yKGEzMiwgYTMzKTtcblx0XHRcdFx0cm90YXRpb25YID0gYW5nbGUgKiBfUkFEMkRFRztcblx0XHRcdFx0Ly9yb3RhdGlvblhcblx0XHRcdFx0aWYgKGFuZ2xlKSB7XG5cdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcblx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuXHRcdFx0XHRcdHQxID0gYTEyKmNvcythMTMqc2luO1xuXHRcdFx0XHRcdHQyID0gYTIyKmNvcythMjMqc2luO1xuXHRcdFx0XHRcdHQzID0gYTMyKmNvcythMzMqc2luO1xuXHRcdFx0XHRcdGExMyA9IGExMiotc2luK2ExMypjb3M7XG5cdFx0XHRcdFx0YTIzID0gYTIyKi1zaW4rYTIzKmNvcztcblx0XHRcdFx0XHRhMzMgPSBhMzIqLXNpbithMzMqY29zO1xuXHRcdFx0XHRcdGE0MyA9IGE0Miotc2luK2E0Mypjb3M7XG5cdFx0XHRcdFx0YTEyID0gdDE7XG5cdFx0XHRcdFx0YTIyID0gdDI7XG5cdFx0XHRcdFx0YTMyID0gdDM7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9yb3RhdGlvbllcblx0XHRcdFx0YW5nbGUgPSBfYXRhbjIoLWMsIGEzMyk7XG5cdFx0XHRcdHJvdGF0aW9uWSA9IGFuZ2xlICogX1JBRDJERUc7XG5cdFx0XHRcdGlmIChhbmdsZSkge1xuXHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG5cdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcblx0XHRcdFx0XHR0MSA9IGEqY29zLWExMypzaW47XG5cdFx0XHRcdFx0dDIgPSBiKmNvcy1hMjMqc2luO1xuXHRcdFx0XHRcdHQzID0gYypjb3MtYTMzKnNpbjtcblx0XHRcdFx0XHRhNDMgPSBkKnNpbithNDMqY29zO1xuXHRcdFx0XHRcdGEgPSB0MTtcblx0XHRcdFx0XHRiID0gdDI7XG5cdFx0XHRcdFx0YyA9IHQzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vcm90YXRpb25aXG5cdFx0XHRcdGFuZ2xlID0gX2F0YW4yKGIsIGEpO1xuXHRcdFx0XHRyb3RhdGlvbiA9IGFuZ2xlICogX1JBRDJERUc7XG5cdFx0XHRcdGlmIChhbmdsZSkge1xuXHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0XHRcdFx0dDEgPSBhKmNvcytiKnNpbjtcblx0XHRcdFx0XHR0MiA9IGExMipjb3MrYTIyKnNpbjtcblx0XHRcdFx0XHRiID0gYipjb3MtYSpzaW47XG5cdFx0XHRcdFx0YTIyID0gYTIyKmNvcy1hMTIqc2luO1xuXHRcdFx0XHRcdGEgPSB0MTtcblx0XHRcdFx0XHRhMTIgPSB0Mjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyb3RhdGlvblggJiYgTWF0aC5hYnMocm90YXRpb25YKSArIE1hdGguYWJzKHJvdGF0aW9uKSA+IDM1OS45KSB7IC8vd2hlbiByb3RhdGlvblkgaXMgc2V0LCBpdCB3aWxsIG9mdGVuIGJlIHBhcnNlZCBhcyAxODAgZGVncmVlcyBkaWZmZXJlbnQgdGhhbiBpdCBzaG91bGQgYmUsIGFuZCByb3RhdGlvblggYW5kIHJvdGF0aW9uIGJvdGggYmVpbmcgMTgwIChpdCBsb29rcyB0aGUgc2FtZSksIHNvIHdlIGFkanVzdCBmb3IgdGhhdCBoZXJlLlxuXHRcdFx0XHRcdHJvdGF0aW9uWCA9IHJvdGF0aW9uID0gMDtcblx0XHRcdFx0XHRyb3RhdGlvblkgPSAxODAgLSByb3RhdGlvblk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2NhbGVYID0gX3JvdW5kKE1hdGguc3FydChhICogYSArIGIgKiBiICsgYyAqIGMpKTtcblx0XHRcdFx0c2NhbGVZID0gX3JvdW5kKE1hdGguc3FydChhMjIgKiBhMjIgKyBhMzIgKiBhMzIpKTtcblx0XHRcdFx0YW5nbGUgPSBfYXRhbjIoYTEyLCBhMjIpO1xuXHRcdFx0XHRza2V3WCA9IChNYXRoLmFicyhhbmdsZSkgPiAwLjAwMDIpID8gYW5nbGUgKiBfUkFEMkRFRyA6IDA7XG5cdFx0XHRcdHBlcnNwZWN0aXZlID0gYTQzID8gMSAvICgoYTQzIDwgMCkgPyAtYTQzIDogYTQzKSA6IDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjYWNoZS5zdmcpIHsgLy9zZW5zZSBpZiB0aGVyZSBhcmUgQ1NTIHRyYW5zZm9ybXMgYXBwbGllZCBvbiBhbiBTVkcgZWxlbWVudCBpbiB3aGljaCBjYXNlIHdlIG11c3Qgb3ZlcndyaXRlIHRoZW0gd2hlbiByZW5kZXJpbmcuIFRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIGlzIG1vcmUgcmVsaWFibGUgY3Jvc3MtYnJvd3NlciwgYnV0IHdlIGNhbid0IGp1c3QgcmVtb3ZlIHRoZSBDU1Mgb25lcyBiZWNhdXNlIHRoZXkgbWF5IGJlIGFwcGxpZWQgaW4gYSBDU1MgcnVsZSBzb21ld2hlcmUgKG5vdCBqdXN0IGlubGluZSkuXG5cdFx0XHRcdHQxID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblx0XHRcdFx0Y2FjaGUuZm9yY2VDU1MgPSB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwiXCIpIHx8ICghX2lzTnVsbFRyYW5zZm9ybShfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKSkpO1xuXHRcdFx0XHR0MSAmJiB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHQxKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoTWF0aC5hYnMoc2tld1gpID4gOTAgJiYgTWF0aC5hYnMoc2tld1gpIDwgMjcwKSB7XG5cdFx0XHRpZiAoaW52ZXJ0ZWRTY2FsZVgpIHtcblx0XHRcdFx0c2NhbGVYICo9IC0xO1xuXHRcdFx0XHRza2V3WCArPSAocm90YXRpb24gPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRyb3RhdGlvbiArPSAocm90YXRpb24gPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2NhbGVZICo9IC0xO1xuXHRcdFx0XHRza2V3WCArPSAoc2tld1ggPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjYWNoZS54ID0geCAtICgoY2FjaGUueFBlcmNlbnQgPSB4ICYmIChjYWNoZS54UGVyY2VudCB8fCAoTWF0aC5yb3VuZCh0YXJnZXQub2Zmc2V0V2lkdGggLyAyKSA9PT0gTWF0aC5yb3VuZCgteCkgPyAtNTAgOiAwKSkpID8gdGFyZ2V0Lm9mZnNldFdpZHRoICogY2FjaGUueFBlcmNlbnQgLyAxMDAgOiAwKSArIHB4O1xuXHRcdGNhY2hlLnkgPSB5IC0gKChjYWNoZS55UGVyY2VudCA9IHkgJiYgKGNhY2hlLnlQZXJjZW50IHx8IChNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRIZWlnaHQgLyAyKSA9PT0gTWF0aC5yb3VuZCgteSkgPyAtNTAgOiAwKSkpID8gdGFyZ2V0Lm9mZnNldEhlaWdodCAqIGNhY2hlLnlQZXJjZW50IC8gMTAwIDogMCkgKyBweDtcblx0XHRjYWNoZS56ID0geiArIHB4O1xuXHRcdGNhY2hlLnNjYWxlWCA9IF9yb3VuZChzY2FsZVgpO1xuXHRcdGNhY2hlLnNjYWxlWSA9IF9yb3VuZChzY2FsZVkpO1xuXHRcdGNhY2hlLnJvdGF0aW9uID0gX3JvdW5kKHJvdGF0aW9uKSArIGRlZztcblx0XHRjYWNoZS5yb3RhdGlvblggPSBfcm91bmQocm90YXRpb25YKSArIGRlZztcblx0XHRjYWNoZS5yb3RhdGlvblkgPSBfcm91bmQocm90YXRpb25ZKSArIGRlZztcblx0XHRjYWNoZS5za2V3WCA9IHNrZXdYICsgZGVnO1xuXHRcdGNhY2hlLnNrZXdZID0gc2tld1kgKyBkZWc7XG5cdFx0Y2FjaGUudHJhbnNmb3JtUGVyc3BlY3RpdmUgPSBwZXJzcGVjdGl2ZSArIHB4O1xuXHRcdGlmICgoY2FjaGUuek9yaWdpbiA9IHBhcnNlRmxvYXQob3JpZ2luLnNwbGl0KFwiIFwiKVsyXSkgfHwgMCkpIHtcblx0XHRcdHN0eWxlW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSA9IF9maXJzdFR3b09ubHkob3JpZ2luKTtcblx0XHR9XG5cdFx0Y2FjaGUueE9mZnNldCA9IGNhY2hlLnlPZmZzZXQgPSAwO1xuXHRcdGNhY2hlLmZvcmNlM0QgPSBfY29uZmlnLmZvcmNlM0Q7XG5cdFx0Y2FjaGUucmVuZGVyVHJhbnNmb3JtID0gY2FjaGUuc3ZnID8gX3JlbmRlclNWR1RyYW5zZm9ybXMgOiBfc3VwcG9ydHMzRCA/IF9yZW5kZXJDU1NUcmFuc2Zvcm1zIDogX3JlbmRlck5vbjNEVHJhbnNmb3Jtcztcblx0XHRjYWNoZS51bmNhY2hlID0gMDtcblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdF9maXJzdFR3b09ubHkgPSB2YWx1ZSA9PiAodmFsdWUgPSB2YWx1ZS5zcGxpdChcIiBcIikpWzBdICsgXCIgXCIgKyB2YWx1ZVsxXSwgLy9mb3IgaGFuZGxpbmcgdHJhbnNmb3JtT3JpZ2luIHZhbHVlcywgc3RyaXBwaW5nIG91dCB0aGUgM3JkIGRpbWVuc2lvblxuXHRfYWRkUHhUcmFuc2xhdGUgPSAodGFyZ2V0LCBzdGFydCwgdmFsdWUpID0+IHtcblx0XHRsZXQgdW5pdCA9IGdldFVuaXQoc3RhcnQpO1xuXHRcdHJldHVybiBfcm91bmQocGFyc2VGbG9hdChzdGFydCkgKyBwYXJzZUZsb2F0KF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ4XCIsIHZhbHVlICsgXCJweFwiLCB1bml0KSkpICsgdW5pdDtcblx0fSxcblx0X3JlbmRlck5vbjNEVHJhbnNmb3JtcyA9IChyYXRpbywgY2FjaGUpID0+IHtcblx0XHRjYWNoZS56ID0gXCIwcHhcIjtcblx0XHRjYWNoZS5yb3RhdGlvblkgPSBjYWNoZS5yb3RhdGlvblggPSBcIjBkZWdcIjtcblx0XHRjYWNoZS5mb3JjZTNEID0gMDtcblx0XHRfcmVuZGVyQ1NTVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpO1xuXHR9LFxuXHRfemVyb0RlZyA9IFwiMGRlZ1wiLFxuXHRfemVyb1B4ID0gXCIwcHhcIixcblx0X2VuZFBhcmVudGhlc2lzID0gXCIpIFwiLFxuXHRfcmVuZGVyQ1NTVHJhbnNmb3JtcyA9IGZ1bmN0aW9uKHJhdGlvLCBjYWNoZSkge1xuXHRcdGxldCB7eFBlcmNlbnQsIHlQZXJjZW50LCB4LCB5LCB6LCByb3RhdGlvbiwgcm90YXRpb25ZLCByb3RhdGlvblgsIHNrZXdYLCBza2V3WSwgc2NhbGVYLCBzY2FsZVksIHRyYW5zZm9ybVBlcnNwZWN0aXZlLCBmb3JjZTNELCB0YXJnZXQsIHpPcmlnaW59ID0gY2FjaGUgfHwgdGhpcyxcblx0XHRcdHRyYW5zZm9ybXMgPSBcIlwiLFxuXHRcdFx0dXNlM0QgPSAoZm9yY2UzRCA9PT0gXCJhdXRvXCIgJiYgcmF0aW8gJiYgcmF0aW8gIT09IDEpIHx8IGZvcmNlM0QgPT09IHRydWU7XG5cblx0XHQvLyBTYWZhcmkgaGFzIGEgYnVnIHRoYXQgY2F1c2VzIGl0IG5vdCB0byByZW5kZXIgM0QgdHJhbnNmb3JtLW9yaWdpbiB2YWx1ZXMgcHJvcGVybHksIHNvIHdlIGZvcmNlIHRoZSB6IG9yaWdpbiB0byAwLCByZWNvcmQgaXQgaW4gdGhlIGNhY2hlLCBhbmQgdGhlbiBkbyB0aGUgbWF0aCBoZXJlIHRvIG9mZnNldCB0aGUgdHJhbnNsYXRlIHZhbHVlcyBhY2NvcmRpbmdseSAoYmFzaWNhbGx5IGRvIHRoZSAzRCB0cmFuc2Zvcm0tb3JpZ2luIHBhcnQgbWFudWFsbHkpXG5cdFx0aWYgKHpPcmlnaW4gJiYgKHJvdGF0aW9uWCAhPT0gX3plcm9EZWcgfHwgcm90YXRpb25ZICE9PSBfemVyb0RlZykpIHtcblx0XHRcdGxldCBhbmdsZSA9IHBhcnNlRmxvYXQocm90YXRpb25ZKSAqIF9ERUcyUkFELFxuXHRcdFx0XHRhMTMgPSBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHRcdGEzMyA9IE1hdGguY29zKGFuZ2xlKSxcblx0XHRcdFx0Y29zO1xuXHRcdFx0YW5nbGUgPSBwYXJzZUZsb2F0KHJvdGF0aW9uWCkgKiBfREVHMlJBRDtcblx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRcdHggPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB4LCBhMTMgKiBjb3MgKiAtek9yaWdpbik7XG5cdFx0XHR5ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeSwgLU1hdGguc2luKGFuZ2xlKSAqIC16T3JpZ2luKTtcblx0XHRcdHogPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB6LCBhMzMgKiBjb3MgKiAtek9yaWdpbiArIHpPcmlnaW4pO1xuXHRcdH1cblxuXHRcdGlmICh0cmFuc2Zvcm1QZXJzcGVjdGl2ZSAhPT0gX3plcm9QeCkge1xuXHRcdFx0dHJhbnNmb3JtcyArPSBcInBlcnNwZWN0aXZlKFwiICsgdHJhbnNmb3JtUGVyc3BlY3RpdmUgKyBfZW5kUGFyZW50aGVzaXM7XG5cdFx0fVxuXHRcdGlmICh4UGVyY2VudCB8fCB5UGVyY2VudCkge1xuXHRcdFx0dHJhbnNmb3JtcyArPSBcInRyYW5zbGF0ZShcIiArIHhQZXJjZW50ICsgXCIlLCBcIiArIHlQZXJjZW50ICsgXCIlKSBcIjtcblx0XHR9XG5cdFx0aWYgKHVzZTNEIHx8IHggIT09IF96ZXJvUHggfHwgeSAhPT0gX3plcm9QeCB8fCB6ICE9PSBfemVyb1B4KSB7XG5cdFx0XHR0cmFuc2Zvcm1zICs9ICh6ICE9PSBfemVyb1B4IHx8IHVzZTNEKSA/IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCIsIFwiICsgeSArIFwiLCBcIiArIHogKyBcIikgXCIgOiBcInRyYW5zbGF0ZShcIiArIHggKyBcIiwgXCIgKyB5ICsgX2VuZFBhcmVudGhlc2lzO1xuXHRcdH1cblx0XHRpZiAocm90YXRpb24gIT09IF96ZXJvRGVnKSB7XG5cdFx0XHR0cmFuc2Zvcm1zICs9IFwicm90YXRlKFwiICsgcm90YXRpb24gKyBfZW5kUGFyZW50aGVzaXM7XG5cdFx0fVxuXHRcdGlmIChyb3RhdGlvblkgIT09IF96ZXJvRGVnKSB7XG5cdFx0XHR0cmFuc2Zvcm1zICs9IFwicm90YXRlWShcIiArIHJvdGF0aW9uWSArIF9lbmRQYXJlbnRoZXNpcztcblx0XHR9XG5cdFx0aWYgKHJvdGF0aW9uWCAhPT0gX3plcm9EZWcpIHtcblx0XHRcdHRyYW5zZm9ybXMgKz0gXCJyb3RhdGVYKFwiICsgcm90YXRpb25YICsgX2VuZFBhcmVudGhlc2lzO1xuXHRcdH1cblx0XHRpZiAoc2tld1ggIT09IF96ZXJvRGVnIHx8IHNrZXdZICE9PSBfemVyb0RlZykge1xuXHRcdFx0dHJhbnNmb3JtcyArPSBcInNrZXcoXCIgKyBza2V3WCArIFwiLCBcIiArIHNrZXdZICsgX2VuZFBhcmVudGhlc2lzO1xuXHRcdH1cblx0XHRpZiAoc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMSkge1xuXHRcdFx0dHJhbnNmb3JtcyArPSBcInNjYWxlKFwiICsgc2NhbGVYICsgXCIsIFwiICsgc2NhbGVZICsgX2VuZFBhcmVudGhlc2lzO1xuXHRcdH1cblx0XHR0YXJnZXQuc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtcyB8fCBcInRyYW5zbGF0ZSgwLCAwKVwiO1xuXHR9LFxuXHRfcmVuZGVyU1ZHVHJhbnNmb3JtcyA9IGZ1bmN0aW9uKHJhdGlvLCBjYWNoZSkge1xuXHRcdGxldCB7eFBlcmNlbnQsIHlQZXJjZW50LCB4LCB5LCByb3RhdGlvbiwgc2tld1gsIHNrZXdZLCBzY2FsZVgsIHNjYWxlWSwgdGFyZ2V0LCB4T3JpZ2luLCB5T3JpZ2luLCB4T2Zmc2V0LCB5T2Zmc2V0LCBmb3JjZUNTU30gPSBjYWNoZSB8fCB0aGlzLFxuXHRcdFx0dHggPSBwYXJzZUZsb2F0KHgpLFxuXHRcdFx0dHkgPSBwYXJzZUZsb2F0KHkpLFxuXHRcdFx0YTExLCBhMjEsIGExMiwgYTIyLCB0ZW1wO1xuXHRcdHJvdGF0aW9uID0gcGFyc2VGbG9hdChyb3RhdGlvbik7XG5cdFx0c2tld1ggPSBwYXJzZUZsb2F0KHNrZXdYKTtcblx0XHRza2V3WSA9IHBhcnNlRmxvYXQoc2tld1kpO1xuXHRcdGlmIChza2V3WSkgeyAvL2ZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBjb21iaW5lIGFsbCBza2V3aW5nIGludG8gdGhlIHNrZXdYIGFuZCByb3RhdGlvbiB2YWx1ZXMuIFJlbWVtYmVyLCBhIHNrZXdZIG9mIDEwIGRlZ3JlZXMgbG9va3MgdGhlIHNhbWUgYXMgYSByb3RhdGlvbiBvZiAxMCBkZWdyZWVzIHBsdXMgYSBza2V3WCBvZiAxMCBkZWdyZWVzLlxuXHRcdFx0c2tld1kgPSBwYXJzZUZsb2F0KHNrZXdZKTtcblx0XHRcdHNrZXdYICs9IHNrZXdZO1xuXHRcdFx0cm90YXRpb24gKz0gc2tld1k7XG5cdFx0fVxuXHRcdGlmIChyb3RhdGlvbiB8fCBza2V3WCkge1xuXHRcdFx0cm90YXRpb24gKj0gX0RFRzJSQUQ7XG5cdFx0XHRza2V3WCAqPSBfREVHMlJBRDtcblx0XHRcdGExMSA9IE1hdGguY29zKHJvdGF0aW9uKSAqIHNjYWxlWDtcblx0XHRcdGEyMSA9IE1hdGguc2luKHJvdGF0aW9uKSAqIHNjYWxlWDtcblx0XHRcdGExMiA9IE1hdGguc2luKHJvdGF0aW9uIC0gc2tld1gpICogLXNjYWxlWTtcblx0XHRcdGEyMiA9IE1hdGguY29zKHJvdGF0aW9uIC0gc2tld1gpICogc2NhbGVZO1xuXHRcdFx0aWYgKHNrZXdYKSB7XG5cdFx0XHRcdHNrZXdZICo9IF9ERUcyUkFEO1xuXHRcdFx0XHR0ZW1wID0gTWF0aC50YW4oc2tld1ggLSBza2V3WSk7XG5cdFx0XHRcdHRlbXAgPSBNYXRoLnNxcnQoMSArIHRlbXAgKiB0ZW1wKTtcblx0XHRcdFx0YTEyICo9IHRlbXA7XG5cdFx0XHRcdGEyMiAqPSB0ZW1wO1xuXHRcdFx0XHRpZiAoc2tld1kpIHtcblx0XHRcdFx0XHR0ZW1wID0gTWF0aC50YW4oc2tld1kpO1xuXHRcdFx0XHRcdHRlbXAgPSBNYXRoLnNxcnQoMSArIHRlbXAgKiB0ZW1wKTtcblx0XHRcdFx0XHRhMTEgKj0gdGVtcDtcblx0XHRcdFx0XHRhMjEgKj0gdGVtcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YTExID0gX3JvdW5kKGExMSk7XG5cdFx0XHRhMjEgPSBfcm91bmQoYTIxKTtcblx0XHRcdGExMiA9IF9yb3VuZChhMTIpO1xuXHRcdFx0YTIyID0gX3JvdW5kKGEyMik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGExMSA9IHNjYWxlWDtcblx0XHRcdGEyMiA9IHNjYWxlWTtcblx0XHRcdGEyMSA9IGExMiA9IDA7XG5cdFx0fVxuXHRcdGlmICgodHggJiYgIX4oeCArIFwiXCIpLmluZGV4T2YoXCJweFwiKSkgfHwgKHR5ICYmICF+KHkgKyBcIlwiKS5pbmRleE9mKFwicHhcIikpKSB7XG5cdFx0XHR0eCA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ4XCIsIHgsIFwicHhcIik7XG5cdFx0XHR0eSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ5XCIsIHksIFwicHhcIik7XG5cdFx0fVxuXHRcdGlmICh4T3JpZ2luIHx8IHlPcmlnaW4gfHwgeE9mZnNldCB8fCB5T2Zmc2V0KSB7XG5cdFx0XHR0eCA9IF9yb3VuZCh0eCArIHhPcmlnaW4gLSAoeE9yaWdpbiAqIGExMSArIHlPcmlnaW4gKiBhMTIpICsgeE9mZnNldCk7XG5cdFx0XHR0eSA9IF9yb3VuZCh0eSArIHlPcmlnaW4gLSAoeE9yaWdpbiAqIGEyMSArIHlPcmlnaW4gKiBhMjIpICsgeU9mZnNldCk7XG5cdFx0fVxuXHRcdGlmICh4UGVyY2VudCB8fCB5UGVyY2VudCkge1xuXHRcdFx0Ly9UaGUgU1ZHIHNwZWMgZG9lc24ndCBzdXBwb3J0IHBlcmNlbnRhZ2UtYmFzZWQgdHJhbnNsYXRpb24gaW4gdGhlIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlLCBzbyB3ZSBtZXJnZSBpdCBpbnRvIHRoZSB0cmFuc2xhdGlvbiB0byBzaW11bGF0ZSBpdC5cblx0XHRcdHRlbXAgPSB0YXJnZXQuZ2V0QkJveCgpO1xuXHRcdFx0dHggPSBfcm91bmQodHggKyB4UGVyY2VudCAvIDEwMCAqIHRlbXAud2lkdGgpO1xuXHRcdFx0dHkgPSBfcm91bmQodHkgKyB5UGVyY2VudCAvIDEwMCAqIHRlbXAuaGVpZ2h0KTtcblx0XHR9XG5cdFx0dGVtcCA9IFwibWF0cml4KFwiICsgYTExICsgXCIsXCIgKyBhMjEgKyBcIixcIiArIGExMiArIFwiLFwiICsgYTIyICsgXCIsXCIgKyB0eCArIFwiLFwiICsgdHkgKyBcIilcIjtcblx0XHR0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHRlbXApO1xuXHRcdGZvcmNlQ1NTICYmICh0YXJnZXQuc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdGVtcCk7IC8vc29tZSBicm93c2VycyBwcmlvcml0aXplIENTUyB0cmFuc2Zvcm1zIG92ZXIgdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUuIFdoZW4gd2Ugc2Vuc2UgdGhhdCB0aGUgdXNlciBoYXMgQ1NTIHRyYW5zZm9ybXMgYXBwbGllZCwgd2UgbXVzdCBvdmVyd3JpdGUgdGhlbSB0aGlzIHdheSAob3RoZXJ3aXNlIHNvbWUgYnJvd3NlciBzaW1wbHkgd29uJ3QgcmVuZGVyIHRoZSAgdHJhbnNmb3JtIGF0dHJpYnV0ZSBjaGFuZ2VzISlcblx0fSxcblx0X2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4gPSBmdW5jdGlvbihwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIHN0YXJ0TnVtLCBlbmRWYWx1ZSwgcmVsYXRpdmUpIHtcblx0XHRsZXQgY2FwID0gMzYwLFxuXHRcdFx0aXNTdHJpbmcgPSBfaXNTdHJpbmcoZW5kVmFsdWUpLFxuXHRcdFx0ZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSkgKiAoKGlzU3RyaW5nICYmIH5lbmRWYWx1ZS5pbmRleE9mKFwicmFkXCIpKSA/IF9SQUQyREVHIDogMSksXG5cdFx0XHRjaGFuZ2UgPSByZWxhdGl2ZSA/IGVuZE51bSAqIHJlbGF0aXZlIDogZW5kTnVtIC0gc3RhcnROdW0sXG5cdFx0XHRmaW5hbFZhbHVlID0gKHN0YXJ0TnVtICsgY2hhbmdlKSArIFwiZGVnXCIsXG5cdFx0XHRkaXJlY3Rpb24sIHB0O1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0ZGlyZWN0aW9uID0gZW5kVmFsdWUuc3BsaXQoXCJfXCIpWzFdO1xuXHRcdFx0aWYgKGRpcmVjdGlvbiA9PT0gXCJzaG9ydFwiKSB7XG5cdFx0XHRcdGNoYW5nZSAlPSBjYXA7XG5cdFx0XHRcdGlmIChjaGFuZ2UgIT09IGNoYW5nZSAlIChjYXAgLyAyKSkge1xuXHRcdFx0XHRcdGNoYW5nZSArPSAoY2hhbmdlIDwgMCkgPyBjYXAgOiAtY2FwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGlyZWN0aW9uID09PSBcImN3XCIgJiYgY2hhbmdlIDwgMCkge1xuXHRcdFx0XHRjaGFuZ2UgPSAoKGNoYW5nZSArIGNhcCAqIF9iaWdOdW0pICUgY2FwKSAtIH5+KGNoYW5nZSAvIGNhcCkgKiBjYXA7XG5cdFx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gXCJjY3dcIiAmJiBjaGFuZ2UgPiAwKSB7XG5cdFx0XHRcdGNoYW5nZSA9ICgoY2hhbmdlIC0gY2FwICogX2JpZ051bSkgJSBjYXApIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cGx1Z2luLl9wdCA9IHB0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCBzdGFydE51bSwgY2hhbmdlLCBfcmVuZGVyUHJvcFdpdGhFbmQpO1xuXHRcdHB0LmUgPSBmaW5hbFZhbHVlO1xuXHRcdHB0LnUgPSBcImRlZ1wiO1xuXHRcdHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cdFx0cmV0dXJuIHB0O1xuXHR9LFxuXHRfYXNzaWduID0gKHRhcmdldCwgc291cmNlKSA9PiB7IC8vIEludGVybmV0IEV4cGxvcmVyIGRvZXNuJ3QgaGF2ZSBPYmplY3QuYXNzaWduKCksIHNvIHdlIHJlY3JlYXRlIGl0IGhlcmUuXG5cdFx0Zm9yIChsZXQgcCBpbiBzb3VyY2UpIHtcblx0XHRcdHRhcmdldFtwXSA9IHNvdXJjZVtwXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fSxcblx0X2FkZFJhd1RyYW5zZm9ybVBUcyA9IChwbHVnaW4sIHRyYW5zZm9ybXMsIHRhcmdldCkgPT4geyAvL2ZvciBoYW5kbGluZyBjYXNlcyB3aGVyZSBzb21lb25lIHBhc3NlcyBpbiBhIHdob2xlIHRyYW5zZm9ybSBzdHJpbmcsIGxpa2UgdHJhbnNmb3JtOiBcInNjYWxlKDIsIDMpIHJvdGF0ZSgyMGRlZykgdHJhbnNsYXRlWSgzMGVtKVwiXG5cdFx0bGV0IHN0YXJ0Q2FjaGUgPSBfYXNzaWduKHt9LCB0YXJnZXQuX2dzYXApLFxuXHRcdFx0ZXhjbHVkZSA9IFwicGVyc3BlY3RpdmUsZm9yY2UzRCx0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luXCIsXG5cdFx0XHRzdHlsZSA9IHRhcmdldC5zdHlsZSxcblx0XHRcdGVuZENhY2hlLCBwLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgc3RhcnROdW0sIGVuZE51bSwgc3RhcnRVbml0LCBlbmRVbml0O1xuXHRcdGlmIChzdGFydENhY2hlLnN2Zykge1xuXHRcdFx0c3RhcnRWYWx1ZSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG5cdFx0XHR0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwiXCIpO1xuXHRcdFx0c3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3Jtcztcblx0XHRcdGVuZENhY2hlID0gX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSk7XG5cdFx0XHRfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cdFx0XHR0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHN0YXJ0VmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdGFydFZhbHVlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpW190cmFuc2Zvcm1Qcm9wXTtcblx0XHRcdHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXM7XG5cdFx0XHRlbmRDYWNoZSA9IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpO1xuXHRcdFx0c3R5bGVbX3RyYW5zZm9ybVByb3BdID0gc3RhcnRWYWx1ZTtcblx0XHR9XG5cdFx0Zm9yIChwIGluIF90cmFuc2Zvcm1Qcm9wcykge1xuXHRcdFx0c3RhcnRWYWx1ZSA9IHN0YXJ0Q2FjaGVbcF07XG5cdFx0XHRlbmRWYWx1ZSA9IGVuZENhY2hlW3BdO1xuXHRcdFx0aWYgKHN0YXJ0VmFsdWUgIT09IGVuZFZhbHVlICYmIGV4Y2x1ZGUuaW5kZXhPZihwKSA8IDApIHsgLy90d2VlbmluZyB0byBubyBwZXJzcGVjdGl2ZSBnaXZlcyB2ZXJ5IHVuaW50dWl0aXZlIHJlc3VsdHMgLSBqdXN0IGtlZXAgdGhlIHNhbWUgcGVyc3BlY3RpdmUgaW4gdGhhdCBjYXNlLlxuXHRcdFx0XHRzdGFydFVuaXQgPSBnZXRVbml0KHN0YXJ0VmFsdWUpO1xuXHRcdFx0XHRlbmRVbml0ID0gZ2V0VW5pdChlbmRWYWx1ZSk7XG5cdFx0XHRcdHN0YXJ0TnVtID0gKHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCkgPyBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIDogcGFyc2VGbG9hdChzdGFydFZhbHVlKTtcblx0XHRcdFx0ZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG5cdFx0XHRcdHBsdWdpbi5fcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIGVuZENhY2hlLCBwLCBzdGFydE51bSwgZW5kTnVtIC0gc3RhcnROdW0sIF9yZW5kZXJDU1NQcm9wKTtcblx0XHRcdFx0cGx1Z2luLl9wdC51ID0gZW5kVW5pdCB8fCAwO1xuXHRcdFx0XHRwbHVnaW4uX3Byb3BzLnB1c2gocCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdF9hc3NpZ24oZW5kQ2FjaGUsIHN0YXJ0Q2FjaGUpO1xuXHR9O1xuXG4vLyBoYW5kbGUgc3BsaXR0aW5nIGFwYXJ0IHBhZGRpbmcsIG1hcmdpbiwgYm9yZGVyV2lkdGgsIGFuZCBib3JkZXJSYWRpdXMgaW50byB0aGVpciA0IGNvbXBvbmVudHMuIEZpcmVmb3gsIGZvciBleGFtcGxlLCB3b24ndCByZXBvcnQgYm9yZGVyUmFkaXVzIGNvcnJlY3RseSAtIGl0IHdpbGwgb25seSBkbyBib3JkZXJUb3BMZWZ0UmFkaXVzIGFuZCB0aGUgb3RoZXIgY29ybmVycy4gV2UgYWxzbyB3YW50IHRvIGhhbmRsZSBwYWRkaW5nVG9wLCBtYXJnaW5MZWZ0LCBib3JkZXJSaWdodFdpZHRoLCBldGMuXG5fZm9yRWFjaE5hbWUoXCJwYWRkaW5nLG1hcmdpbixXaWR0aCxSYWRpdXNcIiwgKG5hbWUsIGluZGV4KSA9PiB7XG5cdGxldCB0ID0gXCJUb3BcIixcblx0XHRyID0gXCJSaWdodFwiLFxuXHRcdGIgPSBcIkJvdHRvbVwiLFxuXHRcdGwgPSBcIkxlZnRcIixcblx0XHRwcm9wcyA9IChpbmRleCA8IDMgPyBbdCxyLGIsbF0gOiBbdCtsLCB0K3IsIGIrciwgYitsXSkubWFwKHNpZGUgPT4gaW5kZXggPCAyID8gbmFtZSArIHNpZGUgOiBcImJvcmRlclwiICsgc2lkZSArIG5hbWUpO1xuXHRfc3BlY2lhbFByb3BzWyhpbmRleCA+IDEgPyBcImJvcmRlclwiICsgbmFtZSA6IG5hbWUpXSA9IGZ1bmN0aW9uKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG5cdFx0bGV0IGEsIHZhcnM7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSB7IC8vIGdldHRlciwgcGFzc2VkIHRhcmdldCwgcHJvcGVydHksIGFuZCB1bml0IChmcm9tIF9nZXQoKSlcblx0XHRcdGEgPSBwcm9wcy5tYXAocHJvcCA9PiBfZ2V0KHBsdWdpbiwgcHJvcCwgcHJvcGVydHkpKTtcblx0XHRcdHZhcnMgPSBhLmpvaW4oXCIgXCIpO1xuXHRcdFx0cmV0dXJuIHZhcnMuc3BsaXQoYVswXSkubGVuZ3RoID09PSA1ID8gYVswXSA6IHZhcnM7XG5cdFx0fVxuXHRcdGEgPSAoZW5kVmFsdWUgKyBcIlwiKS5zcGxpdChcIiBcIik7XG5cdFx0dmFycyA9IHt9O1xuXHRcdHByb3BzLmZvckVhY2goKHByb3AsIGkpID0+IHZhcnNbcHJvcF0gPSBhW2ldID0gYVtpXSB8fCBhWygoKGkgLSAxKSAvIDIpIHwgMCldKTtcblx0XHRwbHVnaW4uaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuKTtcblx0fVxufSk7XG5cblxuZXhwb3J0IGNvbnN0IENTU1BsdWdpbiA9IHtcblx0bmFtZTogXCJjc3NcIixcblx0cmVnaXN0ZXI6IF9pbml0Q29yZSxcblx0dGFyZ2V0VGVzdCh0YXJnZXQpIHtcblx0XHRyZXR1cm4gdGFyZ2V0LnN0eWxlICYmIHRhcmdldC5ub2RlVHlwZTtcblx0fSxcblx0aW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuXHRcdGxldCBwcm9wcyA9IHRoaXMuX3Byb3BzLFxuXHRcdFx0c3R5bGUgPSB0YXJnZXQuc3R5bGUsXG5cdFx0XHRzdGFydEF0ID0gdHdlZW4udmFycy5zdGFydEF0LFxuXHRcdFx0c3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGVuZE51bSwgc3RhcnROdW0sIHR5cGUsIHNwZWNpYWxQcm9wLCBwLCBzdGFydFVuaXQsIGVuZFVuaXQsIHJlbGF0aXZlLCBpc1RyYW5zZm9ybVJlbGF0ZWQsIHRyYW5zZm9ybVByb3BUd2VlbiwgY2FjaGUsIHNtb290aCwgaGFzUHJpb3JpdHk7XG5cdFx0X3BsdWdpbkluaXR0ZWQgfHwgX2luaXRDb3JlKCk7XG5cdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdGlmIChwID09PSBcImF1dG9Sb3VuZFwiKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0ZW5kVmFsdWUgPSB2YXJzW3BdO1xuXHRcdFx0aWYgKF9wbHVnaW5zW3BdICYmIF9jaGVja1BsdWdpbihwLCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykpIHsgLy8gcGx1Z2luc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHR5cGUgPSB0eXBlb2YoZW5kVmFsdWUpO1xuXHRcdFx0c3BlY2lhbFByb3AgPSBfc3BlY2lhbFByb3BzW3BdO1xuXHRcdFx0aWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRlbmRWYWx1ZSA9IGVuZFZhbHVlLmNhbGwodHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpO1xuXHRcdFx0XHR0eXBlID0gdHlwZW9mKGVuZFZhbHVlKTtcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlID09PSBcInN0cmluZ1wiICYmIH5lbmRWYWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiKSkge1xuXHRcdFx0XHRlbmRWYWx1ZSA9IF9yZXBsYWNlUmFuZG9tKGVuZFZhbHVlKTtcblx0XHRcdH1cblx0XHRcdGlmIChzcGVjaWFsUHJvcCkge1xuXHRcdFx0XHRzcGVjaWFsUHJvcCh0aGlzLCB0YXJnZXQsIHAsIGVuZFZhbHVlLCB0d2VlbikgJiYgKGhhc1ByaW9yaXR5ID0gMSk7XG5cdFx0XHR9IGVsc2UgaWYgKHAuc3Vic3RyKDAsMikgPT09IFwiLS1cIikgeyAvL0NTUyB2YXJpYWJsZVxuXHRcdFx0XHRzdGFydFZhbHVlID0gKGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS5nZXRQcm9wZXJ0eVZhbHVlKHApICsgXCJcIikudHJpbSgpO1xuXHRcdFx0XHRlbmRWYWx1ZSArPSBcIlwiO1xuXHRcdFx0XHRfY29sb3JFeHAubGFzdEluZGV4ID0gMDtcblx0XHRcdFx0aWYgKCFfY29sb3JFeHAudGVzdChzdGFydFZhbHVlKSkgeyAvLyBjb2xvcnMgZG9uJ3QgaGF2ZSB1bml0c1xuXHRcdFx0XHRcdHN0YXJ0VW5pdCA9IGdldFVuaXQoc3RhcnRWYWx1ZSk7XG5cdFx0XHRcdFx0ZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVuZFVuaXQgPyBzdGFydFVuaXQgIT09IGVuZFVuaXQgJiYgKHN0YXJ0VmFsdWUgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpICsgZW5kVW5pdCkgOiBzdGFydFVuaXQgJiYgKGVuZFZhbHVlICs9IHN0YXJ0VW5pdCk7XG5cdFx0XHRcdHRoaXMuYWRkKHN0eWxlLCBcInNldFByb3BlcnR5XCIsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBpbmRleCwgdGFyZ2V0cywgMCwgMCwgcCk7XG5cdFx0XHRcdHByb3BzLnB1c2gocCk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdFx0aWYgKHN0YXJ0QXQgJiYgcCBpbiBzdGFydEF0KSB7IC8vIGluIGNhc2Ugc29tZW9uZSBoYXJkLWNvZGVzIGEgY29tcGxleCB2YWx1ZSBhcyB0aGUgc3RhcnQsIGxpa2UgdG9wOiBcImNhbGMoMnZoIC8gMilcIi4gV2l0aG91dCB0aGlzLCBpdCdkIHVzZSB0aGUgY29tcHV0ZWQgdmFsdWUgKGFsd2F5cyBpbiBweClcblx0XHRcdFx0XHRzdGFydFZhbHVlID0gdHlwZW9mKHN0YXJ0QXRbcF0pID09PSBcImZ1bmN0aW9uXCIgPyBzdGFydEF0W3BdLmNhbGwodHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIDogc3RhcnRBdFtwXTtcblx0XHRcdFx0XHQocCBpbiBfY29uZmlnLnVuaXRzKSAmJiAhZ2V0VW5pdChzdGFydFZhbHVlKSAmJiAoc3RhcnRWYWx1ZSArPSBfY29uZmlnLnVuaXRzW3BdKTsgLy8gZm9yIGNhc2VzIHdoZW4gc29tZW9uZSBwYXNzZXMgaW4gYSB1bml0bGVzcyB2YWx1ZSBsaWtlIHt4OiAxMDB9OyBpZiB3ZSB0cnkgc2V0dGluZyB0cmFuc2xhdGUoMTAwLCAwcHgpIGl0IHdvbid0IHdvcmsuXG5cdFx0XHRcdFx0KHN0YXJ0VmFsdWUgKyBcIlwiKS5jaGFyQXQoMSkgPT09IFwiPVwiICYmIChzdGFydFZhbHVlID0gX2dldCh0YXJnZXQsIHApKTsgLy8gY2FuJ3Qgd29yayB3aXRoIHJlbGF0aXZlIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXJ0VmFsdWUgPSBfZ2V0KHRhcmdldCwgcCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpO1xuXHRcdFx0XHRyZWxhdGl2ZSA9ICh0eXBlID09PSBcInN0cmluZ1wiICYmIGVuZFZhbHVlLmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gKyhlbmRWYWx1ZS5jaGFyQXQoMCkgKyBcIjFcIikgOiAwO1xuXHRcdFx0XHRyZWxhdGl2ZSAmJiAoZW5kVmFsdWUgPSBlbmRWYWx1ZS5zdWJzdHIoMikpO1xuXHRcdFx0XHRlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKTtcblx0XHRcdFx0aWYgKHAgaW4gX3Byb3BlcnR5QWxpYXNlcykge1xuXHRcdFx0XHRcdGlmIChwID09PSBcImF1dG9BbHBoYVwiKSB7IC8vc3BlY2lhbCBjYXNlIHdoZXJlIHdlIGNvbnRyb2wgdGhlIHZpc2liaWxpdHkgYWxvbmcgd2l0aCBvcGFjaXR5LiBXZSBzdGlsbCBhbGxvdyB0aGUgb3BhY2l0eSB2YWx1ZSB0byBwYXNzIHRocm91Z2ggYW5kIGdldCB0d2VlbmVkLlxuXHRcdFx0XHRcdFx0aWYgKHN0YXJ0TnVtID09PSAxICYmIF9nZXQodGFyZ2V0LCBcInZpc2liaWxpdHlcIikgPT09IFwiaGlkZGVuXCIgJiYgZW5kTnVtKSB7IC8vaWYgdmlzaWJpbGl0eSBpcyBpbml0aWFsbHkgc2V0IHRvIFwiaGlkZGVuXCIsIHdlIHNob3VsZCBpbnRlcnByZXQgdGhhdCBhcyBpbnRlbnQgdG8gbWFrZSBvcGFjaXR5IDAgKGEgY29udmVuaWVuY2UpXG5cdFx0XHRcdFx0XHRcdHN0YXJ0TnVtID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIHN0eWxlLCBcInZpc2liaWxpdHlcIiwgc3RhcnROdW0gPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCIsIGVuZE51bSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiwgIWVuZE51bSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwICE9PSBcInNjYWxlXCIgJiYgcCAhPT0gXCJ0cmFuc2Zvcm1cIikge1xuXHRcdFx0XHRcdFx0cCA9IF9wcm9wZXJ0eUFsaWFzZXNbcF07XG5cdFx0XHRcdFx0XHR+cC5pbmRleE9mKFwiLFwiKSAmJiAocCA9IHAuc3BsaXQoXCIsXCIpWzBdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpc1RyYW5zZm9ybVJlbGF0ZWQgPSAocCBpbiBfdHJhbnNmb3JtUHJvcHMpO1xuXG5cdFx0XHRcdC8vLS0tIFRSQU5TRk9STS1SRUxBVEVEIC0tLVxuXHRcdFx0XHRpZiAoaXNUcmFuc2Zvcm1SZWxhdGVkKSB7XG5cdFx0XHRcdFx0aWYgKCF0cmFuc2Zvcm1Qcm9wVHdlZW4pIHtcblx0XHRcdFx0XHRcdGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuXHRcdFx0XHRcdFx0KGNhY2hlLnJlbmRlclRyYW5zZm9ybSAmJiAhdmFycy5wYXJzZVRyYW5zZm9ybSkgfHwgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgdmFycy5wYXJzZVRyYW5zZm9ybSk7IC8vIGlmLCBmb3IgZXhhbXBsZSwgZ3NhcC5zZXQoLi4uIHt0cmFuc2Zvcm06XCJ0cmFuc2xhdGVYKDUwdncpXCJ9KSwgdGhlIF9nZXQoKSBjYWxsIGRvZXNuJ3QgcGFyc2UgdGhlIHRyYW5zZm9ybSwgdGh1cyBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0gd29uJ3QgYmUgc2V0IHlldCBzbyBmb3JjZSB0aGUgcGFyc2luZyBvZiB0aGUgdHJhbnNmb3JtIGhlcmUuXG5cdFx0XHRcdFx0XHRzbW9vdGggPSAodmFycy5zbW9vdGhPcmlnaW4gIT09IGZhbHNlICYmIGNhY2hlLnNtb290aCk7XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm1Qcm9wVHdlZW4gPSB0aGlzLl9wdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHN0eWxlLCBfdHJhbnNmb3JtUHJvcCwgMCwgMSwgY2FjaGUucmVuZGVyVHJhbnNmb3JtLCBjYWNoZSwgMCwgLTEpOyAvL3RoZSBmaXJzdCB0aW1lIHRocm91Z2gsIGNyZWF0ZSB0aGUgcmVuZGVyaW5nIFByb3BUd2VlbiBzbyB0aGF0IGl0IHJ1bnMgTEFTVCAoaW4gdGhlIGxpbmtlZCBsaXN0LCB3ZSBrZWVwIGFkZGluZyB0byB0aGUgYmVnaW5uaW5nKVxuXHRcdFx0XHRcdFx0dHJhbnNmb3JtUHJvcFR3ZWVuLmRlcCA9IDE7IC8vZmxhZyBpdCBhcyBkZXBlbmRlbnQgc28gdGhhdCBpZiB0aGluZ3MgZ2V0IGtpbGxlZC9vdmVyd3JpdHRlbiBhbmQgdGhpcyBpcyB0aGUgb25seSBQcm9wVHdlZW4gbGVmdCwgd2UgY2FuIHNhZmVseSBraWxsIHRoZSB3aG9sZSB0d2Vlbi5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHAgPT09IFwic2NhbGVcIikge1xuXHRcdFx0XHRcdFx0dGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBjYWNoZSwgXCJzY2FsZVlcIiwgY2FjaGUuc2NhbGVZLCAocmVsYXRpdmUgPyByZWxhdGl2ZSAqIGVuZE51bSA6IGVuZE51bSAtIGNhY2hlLnNjYWxlWSkgfHwgMCk7XG5cdFx0XHRcdFx0XHRwcm9wcy5wdXNoKFwic2NhbGVZXCIsIHApO1xuXHRcdFx0XHRcdFx0cCArPSBcIlhcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHAgPT09IFwidHJhbnNmb3JtT3JpZ2luXCIpIHtcblx0XHRcdFx0XHRcdGVuZFZhbHVlID0gX2NvbnZlcnRLZXl3b3Jkc1RvUGVyY2VudGFnZXMoZW5kVmFsdWUpOyAvL2luIGNhc2Ugc29tZXRoaW5nIGxpa2UgXCJsZWZ0IHRvcFwiIG9yIFwiYm90dG9tIHJpZ2h0XCIgaXMgcGFzc2VkIGluLiBDb252ZXJ0IHRvIHBlcmNlbnRhZ2VzLlxuXHRcdFx0XHRcdFx0aWYgKGNhY2hlLnN2Zykge1xuXHRcdFx0XHRcdFx0XHRfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCBlbmRWYWx1ZSwgMCwgc21vb3RoLCAwLCB0aGlzKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGVuZFVuaXQgPSBwYXJzZUZsb2F0KGVuZFZhbHVlLnNwbGl0KFwiIFwiKVsyXSkgfHwgMDsgLy9oYW5kbGUgdGhlIHpPcmlnaW4gc2VwYXJhdGVseSFcblx0XHRcdFx0XHRcdFx0ZW5kVW5pdCAhPT0gY2FjaGUuek9yaWdpbiAmJiBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBjYWNoZSwgXCJ6T3JpZ2luXCIsIGNhY2hlLnpPcmlnaW4sIGVuZFVuaXQpO1xuXHRcdFx0XHRcdFx0XHRfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBzdHlsZSwgcCwgX2ZpcnN0VHdvT25seShzdGFydFZhbHVlKSwgX2ZpcnN0VHdvT25seShlbmRWYWx1ZSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwID09PSBcInN2Z09yaWdpblwiKSB7XG5cdFx0XHRcdFx0XHRfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCBlbmRWYWx1ZSwgMSwgc21vb3RoLCAwLCB0aGlzKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocCBpbiBfcm90YXRpb25hbFByb3BlcnRpZXMpIHtcblx0XHRcdFx0XHRcdF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuKHRoaXMsIGNhY2hlLCBwLCBzdGFydE51bSwgZW5kVmFsdWUsIHJlbGF0aXZlKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwID09PSBcInNtb290aE9yaWdpblwiKSB7XG5cdFx0XHRcdFx0XHRfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBjYWNoZSwgXCJzbW9vdGhcIiwgY2FjaGUuc21vb3RoLCBlbmRWYWx1ZSk7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHAgPT09IFwiZm9yY2UzRFwiKSB7XG5cdFx0XHRcdFx0XHRjYWNoZVtwXSA9IGVuZFZhbHVlO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwID09PSBcInRyYW5zZm9ybVwiKSB7XG5cdFx0XHRcdFx0XHRfYWRkUmF3VHJhbnNmb3JtUFRzKHRoaXMsIGVuZFZhbHVlLCB0YXJnZXQpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCEocCBpbiBzdHlsZSkpIHtcblx0XHRcdFx0XHRwID0gX2NoZWNrUHJvcFByZWZpeChwKSB8fCBwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlzVHJhbnNmb3JtUmVsYXRlZCB8fCAoKGVuZE51bSB8fCBlbmROdW0gPT09IDApICYmIChzdGFydE51bSB8fCBzdGFydE51bSA9PT0gMCkgJiYgIV9jb21wbGV4RXhwLnRlc3QoZW5kVmFsdWUpICYmIChwIGluIHN0eWxlKSkpIHtcblx0XHRcdFx0XHRzdGFydFVuaXQgPSAoc3RhcnRWYWx1ZSArIFwiXCIpLnN1YnN0cigoc3RhcnROdW0gKyBcIlwiKS5sZW5ndGgpO1xuXHRcdFx0XHRcdGVuZE51bSB8fCAoZW5kTnVtID0gMCk7IC8vIHByb3RlY3QgYWdhaW5zdCBOYU5cblx0XHRcdFx0XHRlbmRVbml0ID0gZ2V0VW5pdChlbmRWYWx1ZSkgfHwgKChwIGluIF9jb25maWcudW5pdHMpID8gX2NvbmZpZy51bml0c1twXSA6IHN0YXJ0VW5pdCk7XG5cdFx0XHRcdFx0c3RhcnRVbml0ICE9PSBlbmRVbml0ICYmIChzdGFydE51bSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkpO1xuXHRcdFx0XHRcdHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgaXNUcmFuc2Zvcm1SZWxhdGVkID8gY2FjaGUgOiBzdHlsZSwgcCwgc3RhcnROdW0sIHJlbGF0aXZlID8gcmVsYXRpdmUgKiBlbmROdW0gOiBlbmROdW0gLSBzdGFydE51bSwgKCFpc1RyYW5zZm9ybVJlbGF0ZWQgJiYgKGVuZFVuaXQgPT09IFwicHhcIiB8fCBwID09PSBcInpJbmRleFwiKSAmJiB2YXJzLmF1dG9Sb3VuZCAhPT0gZmFsc2UpID8gX3JlbmRlclJvdW5kZWRDU1NQcm9wIDogX3JlbmRlckNTU1Byb3ApO1xuXHRcdFx0XHRcdHRoaXMuX3B0LnUgPSBlbmRVbml0IHx8IDA7XG5cdFx0XHRcdFx0aWYgKHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCkgeyAvL3doZW4gdGhlIHR3ZWVuIGdvZXMgYWxsIHRoZSB3YXkgYmFjayB0byB0aGUgYmVnaW5uaW5nLCB3ZSBuZWVkIHRvIHJldmVydCBpdCB0byB0aGUgT0xEL09SSUdJTkFMIHZhbHVlICh3aXRoIHRob3NlIHVuaXRzKS4gV2UgcmVjb3JkIHRoYXQgYXMgYSBcImJcIiAoYmVnaW5uaW5nKSBwcm9wZXJ0eSBhbmQgcG9pbnQgdG8gYSByZW5kZXIgbWV0aG9kIHRoYXQgaGFuZGxlcyB0aGF0LiAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKVxuXHRcdFx0XHRcdFx0dGhpcy5fcHQuYiA9IHN0YXJ0VmFsdWU7XG5cdFx0XHRcdFx0XHR0aGlzLl9wdC5yID0gX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICghKHAgaW4gc3R5bGUpKSB7XG5cdFx0XHRcdFx0aWYgKHAgaW4gdGFyZ2V0KSB7IC8vbWF5YmUgaXQncyBub3QgYSBzdHlsZSAtIGl0IGNvdWxkIGJlIGEgcHJvcGVydHkgYWRkZWQgZGlyZWN0bHkgdG8gYW4gZWxlbWVudCBpbiB3aGljaCBjYXNlIHdlJ2xsIHRyeSB0byBhbmltYXRlIHRoYXQuXG5cdFx0XHRcdFx0XHR0aGlzLmFkZCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUgfHwgdGFyZ2V0W3BdLCBlbmRWYWx1ZSwgaW5kZXgsIHRhcmdldHMpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRfbWlzc2luZ1BsdWdpbihwLCBlbmRWYWx1ZSk7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X3R3ZWVuQ29tcGxleENTU1N0cmluZy5jYWxsKHRoaXMsIHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHByb3BzLnB1c2gocCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGhhc1ByaW9yaXR5ICYmIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkodGhpcyk7XG5cblx0fSxcblx0Z2V0OiBfZ2V0LFxuXHRhbGlhc2VzOiBfcHJvcGVydHlBbGlhc2VzLFxuXHRnZXRTZXR0ZXIodGFyZ2V0LCBwcm9wZXJ0eSwgcGx1Z2luKSB7IC8vcmV0dXJucyBhIHNldHRlciBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUgYW5kIGFwcGxpZXMgaXQgYWNjb3JkaW5nbHkuIFJlbWVtYmVyLCBwcm9wZXJ0aWVzIGxpa2UgXCJ4XCIgYXJlbid0IGFzIHNpbXBsZSBhcyB0YXJnZXQuc3R5bGUucHJvcGVydHkgPSB2YWx1ZSBiZWNhdXNlIHRoZXkndmUgZ290IHRvIGJlIGFwcGxpZWQgdG8gYSBwcm94eSBvYmplY3QgYW5kIHRoZW4gbWVyZ2VkIGludG8gYSB0cmFuc2Zvcm0gc3RyaW5nIGluIGEgcmVuZGVyZXIuXG5cdFx0bGV0IHAgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcblx0XHQocCAmJiBwLmluZGV4T2YoXCIsXCIpIDwgMCkgJiYgKHByb3BlcnR5ID0gcCk7XG5cdFx0cmV0dXJuIChwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgcHJvcGVydHkgIT09IF90cmFuc2Zvcm1PcmlnaW5Qcm9wICYmICh0YXJnZXQuX2dzYXAueCB8fCBfZ2V0KHRhcmdldCwgXCJ4XCIpKSkgPyAocGx1Z2luICYmIF9yZWNlbnRTZXR0ZXJQbHVnaW4gPT09IHBsdWdpbiA/IChwcm9wZXJ0eSA9PT0gXCJzY2FsZVwiID8gX3NldHRlclNjYWxlIDogX3NldHRlclRyYW5zZm9ybSkgOiAoX3JlY2VudFNldHRlclBsdWdpbiA9IHBsdWdpbiB8fCB7fSkgJiYgKHByb3BlcnR5ID09PSBcInNjYWxlXCIgPyBfc2V0dGVyU2NhbGVXaXRoUmVuZGVyIDogX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIpKSA6IHRhcmdldC5zdHlsZSAmJiAhX2lzVW5kZWZpbmVkKHRhcmdldC5zdHlsZVtwcm9wZXJ0eV0pID8gX3NldHRlckNTU1N0eWxlIDogfnByb3BlcnR5LmluZGV4T2YoXCItXCIpID8gX3NldHRlckNTU1Byb3AgOiBfZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHkpO1xuXHR9LFxuXHRjb3JlOiB7IF9yZW1vdmVQcm9wZXJ0eSwgX2dldE1hdHJpeCB9XG5cbn07XG5cbmdzYXAudXRpbHMuY2hlY2tQcmVmaXggPSBfY2hlY2tQcm9wUHJlZml4O1xuKGZ1bmN0aW9uKHBvc2l0aW9uQW5kU2NhbGUsIHJvdGF0aW9uLCBvdGhlcnMsIGFsaWFzZXMpIHtcblx0bGV0IGFsbCA9IF9mb3JFYWNoTmFtZShwb3NpdGlvbkFuZFNjYWxlICsgXCIsXCIgKyByb3RhdGlvbiArIFwiLFwiICsgb3RoZXJzLCBuYW1lID0+IHtfdHJhbnNmb3JtUHJvcHNbbmFtZV0gPSAxfSk7XG5cdF9mb3JFYWNoTmFtZShyb3RhdGlvbiwgbmFtZSA9PiB7X2NvbmZpZy51bml0c1tuYW1lXSA9IFwiZGVnXCI7IF9yb3RhdGlvbmFsUHJvcGVydGllc1tuYW1lXSA9IDF9KTtcblx0X3Byb3BlcnR5QWxpYXNlc1thbGxbMTNdXSA9IHBvc2l0aW9uQW5kU2NhbGUgKyBcIixcIiArIHJvdGF0aW9uO1xuXHRfZm9yRWFjaE5hbWUoYWxpYXNlcywgbmFtZSA9PiB7XG5cdFx0bGV0IHNwbGl0ID0gbmFtZS5zcGxpdChcIjpcIik7XG5cdFx0X3Byb3BlcnR5QWxpYXNlc1tzcGxpdFsxXV0gPSBhbGxbc3BsaXRbMF1dO1xuXHR9KTtcbn0pKFwieCx5LHosc2NhbGUsc2NhbGVYLHNjYWxlWSx4UGVyY2VudCx5UGVyY2VudFwiLCBcInJvdGF0aW9uLHJvdGF0aW9uWCxyb3RhdGlvblksc2tld1gsc2tld1lcIiwgXCJ0cmFuc2Zvcm0sdHJhbnNmb3JtT3JpZ2luLHN2Z09yaWdpbixmb3JjZTNELHNtb290aE9yaWdpbix0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiLCBcIjA6dHJhbnNsYXRlWCwxOnRyYW5zbGF0ZVksMjp0cmFuc2xhdGVaLDg6cm90YXRlLDg6cm90YXRpb25aLDg6cm90YXRlWiw5OnJvdGF0ZVgsMTA6cm90YXRlWVwiKTtcbl9mb3JFYWNoTmFtZShcIngseSx6LHRvcCxyaWdodCxib3R0b20sbGVmdCx3aWR0aCxoZWlnaHQsZm9udFNpemUscGFkZGluZyxtYXJnaW4scGVyc3BlY3RpdmVcIiwgbmFtZSA9PiB7X2NvbmZpZy51bml0c1tuYW1lXSA9IFwicHhcIn0pO1xuXG5nc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbik7XG5cbmV4cG9ydCB7IENTU1BsdWdpbiBhcyBkZWZhdWx0LCBfZ2V0QkJveCwgX2NyZWF0ZUVsZW1lbnQsIF9jaGVja1Byb3BQcmVmaXggYXMgY2hlY2tQcmVmaXggfTsiLCIvKiFcbiAqIENTU1J1bGVQbHVnaW4gMy43LjBcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5sZXQgZ3NhcCwgX2NvcmVJbml0dGVkLCBfd2luLCBfZG9jLCBDU1NQbHVnaW4sXG5cdF93aW5kb3dFeGlzdHMgPSAoKSA9PiB0eXBlb2Yod2luZG93KSAhPT0gXCJ1bmRlZmluZWRcIixcblx0X2dldEdTQVAgPSAoKSA9PiBnc2FwIHx8IChfd2luZG93RXhpc3RzKCkgJiYgKGdzYXAgPSB3aW5kb3cuZ3NhcCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbiAmJiBnc2FwKSxcblx0X2NoZWNrUmVnaXN0ZXIgPSAoKSA9PiB7XG5cdFx0aWYgKCFfY29yZUluaXR0ZWQpIHtcblx0XHRcdF9pbml0Q29yZSgpO1xuXHRcdFx0aWYgKCFDU1NQbHVnaW4pIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUGx1Z2luLCBDU1NSdWxlUGx1Z2luKVwiKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9jb3JlSW5pdHRlZDtcblx0fSxcblx0X2luaXRDb3JlID0gY29yZSA9PiB7XG5cdFx0Z3NhcCA9IGNvcmUgfHwgX2dldEdTQVAoKTtcblx0XHRpZiAoX3dpbmRvd0V4aXN0cygpKSB7XG5cdFx0XHRfd2luID0gd2luZG93O1xuXHRcdFx0X2RvYyA9IGRvY3VtZW50O1xuXHRcdH1cblx0XHRpZiAoZ3NhcCkge1xuXHRcdFx0Q1NTUGx1Z2luID0gZ3NhcC5wbHVnaW5zLmNzcztcblx0XHRcdGlmIChDU1NQbHVnaW4pIHtcblx0XHRcdFx0X2NvcmVJbml0dGVkID0gMTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblxuZXhwb3J0IGNvbnN0IENTU1J1bGVQbHVnaW4gPSB7XG5cdHZlcnNpb246IFwiMy43LjBcIixcblx0bmFtZTogXCJjc3NSdWxlXCIsXG5cdGluaXQodGFyZ2V0LCB2YWx1ZSwgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG5cdFx0aWYgKCFfY2hlY2tSZWdpc3RlcigpIHx8IHR5cGVvZih0YXJnZXQuY3NzVGV4dCkgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0bGV0IGRpdiA9IHRhcmdldC5fZ3NQcm94eSA9IHRhcmdldC5fZ3NQcm94eSB8fCBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0dGhpcy5zcyA9IHRhcmdldDtcblx0XHR0aGlzLnN0eWxlID0gZGl2LnN0eWxlO1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID0gdGFyZ2V0LmNzc1RleHQ7XG5cdFx0Q1NTUGx1Z2luLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZGl2LCB2YWx1ZSwgdHdlZW4sIGluZGV4LCB0YXJnZXRzKTsgLy93ZSBqdXN0IG9mZmxvYWQgYWxsIHRoZSB3b3JrIHRvIHRoZSByZWd1bGFyIENTU1BsdWdpbiBhbmQgdGhlbiBjb3B5IHRoZSBjc3NUZXh0IGJhY2sgb3ZlciB0byB0aGUgcnVsZSBpbiB0aGUgcmVuZGVyKCkgbWV0aG9kLiBUaGlzIGFsbG93cyB1cyB0byBoYXZlIGFsbCBvZiB0aGUgdXBkYXRlcyB0byBDU1NQbHVnaW4gYXV0b21hdGljYWxseSBmbG93IHRocm91Z2ggdG8gQ1NTUnVsZVBsdWdpbiBpbnN0ZWFkIG9mIGhhdmluZyB0byBtYWludGFpbiBib3RoXG5cdH0sXG5cdHJlbmRlcihyYXRpbywgZGF0YSkge1xuXHRcdGxldCBwdCA9IGRhdGEuX3B0LFxuXHRcdFx0c3R5bGUgPSBkYXRhLnN0eWxlLFxuXHRcdFx0c3MgPSBkYXRhLnNzLFxuXHRcdFx0aTtcblx0XHR3aGlsZSAocHQpIHtcblx0XHRcdHB0LnIocmF0aW8sIHB0LmQpO1xuXHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHR9XG5cdFx0aSA9IHN0eWxlLmxlbmd0aDtcblx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdHNzW3N0eWxlW2ldXSA9IHN0eWxlW3N0eWxlW2ldXTtcblx0XHR9XG5cdH0sXG5cdGdldFJ1bGUoc2VsZWN0b3IpIHtcblx0XHRfY2hlY2tSZWdpc3RlcigpO1xuXHRcdGxldCBydWxlUHJvcCA9IF9kb2MuYWxsID8gXCJydWxlc1wiIDogXCJjc3NSdWxlc1wiLFxuXHRcdFx0c3R5bGVTaGVldHMgPSBfZG9jLnN0eWxlU2hlZXRzLFxuXHRcdFx0aSA9IHN0eWxlU2hlZXRzLmxlbmd0aCxcblx0XHRcdHBzZXVkbyA9IChzZWxlY3Rvci5jaGFyQXQoMCkgPT09IFwiOlwiKSxcblx0XHRcdGosIGN1clNTLCBjcywgYTtcblx0XHRzZWxlY3RvciA9IChwc2V1ZG8gPyBcIlwiIDogXCIsXCIpICsgc2VsZWN0b3Iuc3BsaXQoXCI6OlwiKS5qb2luKFwiOlwiKS50b0xvd2VyQ2FzZSgpICsgXCIsXCI7IC8vbm90ZTogb2xkIHZlcnNpb25zIG9mIElFIHJlcG9ydCB0YWcgbmFtZSBzZWxlY3RvcnMgYXMgdXBwZXIgY2FzZSwgc28gd2UganVzdCBjaGFuZ2UgZXZlcnl0aGluZyB0byBsb3dlcmNhc2UuXG5cdFx0aWYgKHBzZXVkbykge1xuXHRcdFx0YSA9IFtdO1xuXHRcdH1cblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHQvL0ZpcmVmb3ggbWF5IHRocm93IGluc2VjdXJlIG9wZXJhdGlvbiBlcnJvcnMgd2hlbiBjc3MgaXMgbG9hZGVkIGZyb20gb3RoZXIgZG9tYWlucywgc28gdHJ5L2NhdGNoLlxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y3VyU1MgPSBzdHlsZVNoZWV0c1tpXVtydWxlUHJvcF07XG5cdFx0XHRcdGlmICghY3VyU1MpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRqID0gY3VyU1MubGVuZ3RoO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oZSk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKC0taiA+IC0xKSB7XG5cdFx0XHRcdGNzID0gY3VyU1Nbal07XG5cdFx0XHRcdGlmIChjcy5zZWxlY3RvclRleHQgJiYgKFwiLFwiICsgY3Muc2VsZWN0b3JUZXh0LnNwbGl0KFwiOjpcIikuam9pbihcIjpcIikudG9Mb3dlckNhc2UoKSArIFwiLFwiKS5pbmRleE9mKHNlbGVjdG9yKSAhPT0gLTEpIHsgLy9ub3RlOiBJRSBhZGRzIGFuIGV4dHJhIFwiOlwiIHRvIHBzZXVkbyBzZWxlY3RvcnMsIHNvIC5teUNsYXNzOmFmdGVyIGJlY29tZXMgLm15Q2xhc3M6OmFmdGVyLCBzbyB3ZSBuZWVkIHRvIHN0cmlwIHRoZSBleHRyYSBvbmUgb3V0LlxuXHRcdFx0XHRcdGlmIChwc2V1ZG8pIHtcblx0XHRcdFx0XHRcdGEucHVzaChjcy5zdHlsZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBjcy5zdHlsZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGE7XG5cdH0sXG5cdHJlZ2lzdGVyOiBfaW5pdENvcmVcbn07XG5cbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihDU1NSdWxlUGx1Z2luKTtcblxuZXhwb3J0IHsgQ1NTUnVsZVBsdWdpbiBhcyBkZWZhdWx0IH07IiwiLyohXG4gKiBDdXN0b21FYXNlIDMuNy4wXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDIxLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuLyogZXNsaW50LWRpc2FibGUgKi9cblxuaW1wb3J0IHsgc3RyaW5nVG9SYXdQYXRoLCByYXdQYXRoVG9TdHJpbmcsIHRyYW5zZm9ybVJhd1BhdGggfSBmcm9tIFwiLi91dGlscy9wYXRocy5qc1wiO1xuXG5sZXQgZ3NhcCwgX2NvcmVJbml0dGVkLFxuXHRfZ2V0R1NBUCA9ICgpID0+IGdzYXAgfHwgKHR5cGVvZih3aW5kb3cpICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcCksXG5cdF9pbml0Q29yZSA9ICgpID0+IHtcblx0XHRnc2FwID0gX2dldEdTQVAoKTtcblx0XHRpZiAoZ3NhcCkge1xuXHRcdFx0Z3NhcC5yZWdpc3RlckVhc2UoXCJfQ0VcIiwgQ3VzdG9tRWFzZS5jcmVhdGUpO1xuXHRcdFx0X2NvcmVJbml0dGVkID0gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS53YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oQ3VzdG9tRWFzZSlcIik7XG5cdFx0fVxuXHR9LFxuXHRfYmlnTnVtID0gMWUyMCxcblx0X3JvdW5kID0gdmFsdWUgPT4gfn4odmFsdWUgKiAxMDAwICsgKHZhbHVlIDwgMCA/IC0uNSA6IC41KSkgLyAxMDAwLFxuXHRfYm9udXNWYWxpZGF0ZWQgPSAxLCAvLzxuYW1lPkN1c3RvbUVhc2U8L25hbWU+XG5cdF9udW1FeHAgPSAvWy0rPVxcLl0qXFxkK1tcXC5lXFwtXFwrXSpcXGQqW2VcXC1cXCtdKlxcZCovZ2ksIC8vZmluZHMgYW55IG51bWJlcnMsIGluY2x1ZGluZyBvbmVzIHRoYXQgc3RhcnQgd2l0aCArPSBvciAtPSwgbmVnYXRpdmUgbnVtYmVycywgYW5kIG9uZXMgaW4gc2NpZW50aWZpYyBub3RhdGlvbiBsaWtlIDFlLTguXG5cdF9uZWVkc1BhcnNpbmdFeHAgPSAvW2NMbHNTYUFoSHZWdFRxUV0vZyxcblx0X2ZpbmRNaW5pbXVtID0gdmFsdWVzID0+IHtcblx0XHRsZXQgbCA9IHZhbHVlcy5sZW5ndGgsXG5cdFx0XHRtaW4gPSBfYmlnTnVtLFxuXHRcdFx0aTtcblx0XHRmb3IgKGkgPSAxOyBpIDwgbDsgaSArPSA2KSB7XG5cdFx0XHQrdmFsdWVzW2ldIDwgbWluICYmIChtaW4gPSArdmFsdWVzW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1pbjtcblx0fSxcblx0Ly90YWtlcyBhbGwgdGhlIHBvaW50cyBhbmQgdHJhbnNsYXRlcy9zY2FsZXMgdGhlbSBzbyB0aGF0IHRoZSB4IHN0YXJ0cyBhdCAwIGFuZCBlbmRzIGF0IDEuXG5cdF9ub3JtYWxpemUgPSAodmFsdWVzLCBoZWlnaHQsIG9yaWdpblkpID0+IHtcblx0XHRpZiAoIW9yaWdpblkgJiYgb3JpZ2luWSAhPT0gMCkge1xuXHRcdFx0b3JpZ2luWSA9IE1hdGgubWF4KCt2YWx1ZXNbdmFsdWVzLmxlbmd0aC0xXSwgK3ZhbHVlc1sxXSk7XG5cdFx0fVxuXHRcdGxldCB0eCA9ICt2YWx1ZXNbMF0gKiAtMSxcblx0XHRcdHR5ID0gLW9yaWdpblksXG5cdFx0XHRsID0gdmFsdWVzLmxlbmd0aCxcblx0XHRcdHN4ID0gMSAvICgrdmFsdWVzW2wgLSAyXSArIHR4KSxcblx0XHRcdHN5ID0gLWhlaWdodCB8fCAoKE1hdGguYWJzKCt2YWx1ZXNbbCAtIDFdIC0gK3ZhbHVlc1sxXSkgPCAwLjAxICogKCt2YWx1ZXNbbCAtIDJdIC0gK3ZhbHVlc1swXSkpID8gX2ZpbmRNaW5pbXVtKHZhbHVlcykgKyB0eSA6ICt2YWx1ZXNbbCAtIDFdICsgdHkpLFxuXHRcdFx0aTtcblx0XHRpZiAoc3kpIHsgLy90eXBpY2FsbHkgeSBlbmRzIGF0IDEgKHNvIHRoYXQgdGhlIGVuZCB2YWx1ZXMgYXJlIHJlYWNoZWQpXG5cdFx0XHRzeSA9IDEgLyBzeTtcblx0XHR9IGVsc2UgeyAvL2luIGNhc2UgdGhlIGVhc2UgcmV0dXJucyB0byBpdHMgYmVnaW5uaW5nIHZhbHVlLCBzY2FsZSBldmVyeXRoaW5nIHByb3BvcnRpb25hbGx5XG5cdFx0XHRzeSA9IC1zeDtcblx0XHR9XG5cdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkgKz0gMikge1xuXHRcdFx0dmFsdWVzW2ldID0gKCt2YWx1ZXNbaV0gKyB0eCkgKiBzeDtcblx0XHRcdHZhbHVlc1tpICsgMV0gPSAoK3ZhbHVlc1tpICsgMV0gKyB0eSkgKiBzeTtcblx0XHR9XG5cdH0sXG5cdC8vbm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBwb2ludCBvYmplY3RzIGxpa2Uge3gsIHl9IHJhdGhlciB0aGFuIHdvcmtpbmcgd2l0aCBzZWdtZW50cyB3aGljaCBhcmUgYXJyYXlzIHdpdGggYWx0ZXJuYXRpbmcgeCwgeSB2YWx1ZXMgYXMgaW4gdGhlIHNpbWlsYXIgZnVuY3Rpb24gaW4gcGF0aHMuanNcblx0X2JlemllclRvUG9pbnRzID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgdGhyZXNob2xkLCBwb2ludHMsIGluZGV4KSB7XG5cdFx0bGV0IHgxMiA9ICh4MSArIHgyKSAvIDIsXG5cdFx0XHR5MTIgPSAoeTEgKyB5MikgLyAyLFxuXHRcdFx0eDIzID0gKHgyICsgeDMpIC8gMixcblx0XHRcdHkyMyA9ICh5MiArIHkzKSAvIDIsXG5cdFx0XHR4MzQgPSAoeDMgKyB4NCkgLyAyLFxuXHRcdFx0eTM0ID0gKHkzICsgeTQpIC8gMixcblx0XHRcdHgxMjMgPSAoeDEyICsgeDIzKSAvIDIsXG5cdFx0XHR5MTIzID0gKHkxMiArIHkyMykgLyAyLFxuXHRcdFx0eDIzNCA9ICh4MjMgKyB4MzQpIC8gMixcblx0XHRcdHkyMzQgPSAoeTIzICsgeTM0KSAvIDIsXG5cdFx0XHR4MTIzNCA9ICh4MTIzICsgeDIzNCkgLyAyLFxuXHRcdFx0eTEyMzQgPSAoeTEyMyArIHkyMzQpIC8gMixcblx0XHRcdGR4ID0geDQgLSB4MSxcblx0XHRcdGR5ID0geTQgLSB5MSxcblx0XHRcdGQyID0gTWF0aC5hYnMoKHgyIC0geDQpICogZHkgLSAoeTIgLSB5NCkgKiBkeCksXG5cdFx0XHRkMyA9IE1hdGguYWJzKCh4MyAtIHg0KSAqIGR5IC0gKHkzIC0geTQpICogZHgpLFxuXHRcdFx0bGVuZ3RoO1xuXHRcdGlmICghcG9pbnRzKSB7XG5cdFx0XHRwb2ludHMgPSBbe3g6IHgxLCB5OiB5MX0sIHt4OiB4NCwgeTogeTR9XTtcblx0XHRcdGluZGV4ID0gMTtcblx0XHR9XG5cdFx0cG9pbnRzLnNwbGljZShpbmRleCB8fCBwb2ludHMubGVuZ3RoIC0gMSwgMCwge3g6IHgxMjM0LCB5OiB5MTIzNH0pO1xuXHRcdGlmICgoZDIgKyBkMykgKiAoZDIgKyBkMykgPiB0aHJlc2hvbGQgKiAoZHggKiBkeCArIGR5ICogZHkpKSB7XG5cdFx0XHRsZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuXHRcdFx0X2JlemllclRvUG9pbnRzKHgxLCB5MSwgeDEyLCB5MTIsIHgxMjMsIHkxMjMsIHgxMjM0LCB5MTIzNCwgdGhyZXNob2xkLCBwb2ludHMsIGluZGV4KTtcblx0XHRcdF9iZXppZXJUb1BvaW50cyh4MTIzNCwgeTEyMzQsIHgyMzQsIHkyMzQsIHgzNCwgeTM0LCB4NCwgeTQsIHRocmVzaG9sZCwgcG9pbnRzLCBpbmRleCArIDEgKyAocG9pbnRzLmxlbmd0aCAtIGxlbmd0aCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcG9pbnRzO1xuXHR9O1xuXG5leHBvcnQgY2xhc3MgQ3VzdG9tRWFzZSB7XG5cblx0Y29uc3RydWN0b3IoaWQsIGRhdGEsIGNvbmZpZykge1xuXHRcdF9jb3JlSW5pdHRlZCB8fCBfaW5pdENvcmUoKTtcblx0XHR0aGlzLmlkID0gaWQ7XG5cdFx0X2JvbnVzVmFsaWRhdGVkICYmIHRoaXMuc2V0RGF0YShkYXRhLCBjb25maWcpO1xuXHR9XG5cblx0c2V0RGF0YShkYXRhLCBjb25maWcpIHtcblx0XHRjb25maWcgPSBjb25maWcgfHwge307XG5cdFx0ZGF0YSA9IGRhdGEgfHwgXCIwLDAsMSwxXCI7XG5cdFx0bGV0IHZhbHVlcyA9IGRhdGEubWF0Y2goX251bUV4cCksXG5cdFx0XHRjbG9zZXN0ID0gMSxcblx0XHRcdHBvaW50cyA9IFtdLFxuXHRcdFx0bG9va3VwID0gW10sXG5cdFx0XHRwcmVjaXNpb24gPSBjb25maWcucHJlY2lzaW9uIHx8IDEsXG5cdFx0XHRmYXN0ID0gKHByZWNpc2lvbiA8PSAxKSxcblx0XHRcdGwsIGExLCBhMiwgaSwgaW5jLCBqLCBwb2ludCwgcHJldlBvaW50LCBwO1xuXHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdFx0aWYgKF9uZWVkc1BhcnNpbmdFeHAudGVzdChkYXRhKSB8fCAofmRhdGEuaW5kZXhPZihcIk1cIikgJiYgZGF0YS5pbmRleE9mKFwiQ1wiKSA8IDApKSB7XG5cdFx0XHR2YWx1ZXMgPSBzdHJpbmdUb1Jhd1BhdGgoZGF0YSlbMF07XG5cdFx0fVxuXHRcdGwgPSB2YWx1ZXMubGVuZ3RoO1xuXHRcdGlmIChsID09PSA0KSB7XG5cdFx0XHR2YWx1ZXMudW5zaGlmdCgwLCAwKTtcblx0XHRcdHZhbHVlcy5wdXNoKDEsIDEpO1xuXHRcdFx0bCA9IDg7XG5cdFx0fSBlbHNlIGlmICgobCAtIDIpICUgNikge1xuXHRcdFx0dGhyb3cgXCJJbnZhbGlkIEN1c3RvbUVhc2VcIjtcblx0XHR9XG5cdFx0aWYgKCt2YWx1ZXNbMF0gIT09IDAgfHwgK3ZhbHVlc1tsIC0gMl0gIT09IDEpIHtcblx0XHRcdF9ub3JtYWxpemUodmFsdWVzLCBjb25maWcuaGVpZ2h0LCBjb25maWcub3JpZ2luWSk7XG5cdFx0fVxuXHRcdHRoaXMuc2VnbWVudCA9IHZhbHVlcztcblx0XHRmb3IgKGkgPSAyOyBpIDwgbDsgaSArPSA2KSB7XG5cdFx0XHRhMSA9IHt4OiArdmFsdWVzW2kgLSAyXSwgeTogK3ZhbHVlc1tpIC0gMV19O1xuXHRcdFx0YTIgPSB7eDogK3ZhbHVlc1tpICsgNF0sIHk6ICt2YWx1ZXNbaSArIDVdfTtcblx0XHRcdHBvaW50cy5wdXNoKGExLCBhMik7XG5cdFx0XHRfYmV6aWVyVG9Qb2ludHMoYTEueCwgYTEueSwgK3ZhbHVlc1tpXSwgK3ZhbHVlc1tpICsgMV0sICt2YWx1ZXNbaSArIDJdLCArdmFsdWVzW2kgKyAzXSwgYTIueCwgYTIueSwgMSAvIChwcmVjaXNpb24gKiAyMDAwMDApLCBwb2ludHMsIHBvaW50cy5sZW5ndGggLSAxKTtcblx0XHR9XG5cdFx0bCA9IHBvaW50cy5sZW5ndGg7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0cG9pbnQgPSBwb2ludHNbaV07XG5cdFx0XHRwcmV2UG9pbnQgPSBwb2ludHNbaSAtIDFdIHx8IHBvaW50O1xuXHRcdFx0aWYgKChwb2ludC54ID4gcHJldlBvaW50LnggfHwgKHByZXZQb2ludC55ICE9PSBwb2ludC55ICYmIHByZXZQb2ludC54ID09PSBwb2ludC54KSB8fCBwb2ludCA9PT0gcHJldlBvaW50KSAmJiBwb2ludC54IDw9IDEpIHsgLy9pZiBhIHBvaW50IGdvZXMgQkFDS1dBUkQgaW4gdGltZSBvciBpcyBhIGR1cGxpY2F0ZSwganVzdCBkcm9wIGl0LiBBbHNvIGl0IHNob3VsZG4ndCBnbyBwYXN0IDEgb24gdGhlIHggYXhpcywgYXMgY291bGQgaGFwcGVuIGluIGEgc3RyaW5nIGxpa2UgXCJNMCwwIEMwLDAgMC4xMiwwLjY4IDAuMTgsMC43ODggMC4xOTUsMC44NDUgMC4zMDgsMSAwLjMyLDEgMC40MDMsMS4wMDUgMC4zOTgsMSAwLjUsMSAwLjYwMiwxIDAuODE2LDEuMDA1IDAuOSwxIDAuOTEsMSAwLjk0OCwwLjY5IDAuOTYyLDAuNjE1IDEuMDAzLDAuMzc2IDEsMCAxLDBcIi5cblx0XHRcdFx0cHJldlBvaW50LmN4ID0gcG9pbnQueCAtIHByZXZQb2ludC54OyAvL2NoYW5nZSBpbiB4IGJldHdlZW4gdGhpcyBwb2ludCBhbmQgdGhlIG5leHQgcG9pbnQgKHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbilcblx0XHRcdFx0cHJldlBvaW50LmN5ID0gcG9pbnQueSAtIHByZXZQb2ludC55O1xuXHRcdFx0XHRwcmV2UG9pbnQubiA9IHBvaW50O1xuXHRcdFx0XHRwcmV2UG9pbnQubnggPSBwb2ludC54OyAvL25leHQgcG9pbnQncyB4IHZhbHVlIChwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24sIG1ha2luZyBsb29rdXBzIGZhc3RlciBpbiBnZXRSYXRpbygpKS4gUmVtZW1iZXIsIHRoZSBsb29rdXAgd2lsbCBhbHdheXMgbGFuZCBvbiBhIHNwb3Qgd2hlcmUgaXQncyBlaXRoZXIgdGhpcyBwb2ludCBvciB0aGUgdmVyeSBuZXh0IG9uZSAobmV2ZXIgYmV5b25kIHRoYXQpXG5cdFx0XHRcdGlmIChmYXN0ICYmIGkgPiAxICYmIE1hdGguYWJzKHByZXZQb2ludC5jeSAvIHByZXZQb2ludC5jeCAtIHBvaW50c1tpIC0gMl0uY3kgLyBwb2ludHNbaSAtIDJdLmN4KSA+IDIpIHsgLy9pZiB0aGVyZSdzIGEgc3VkZGVuIGNoYW5nZSBpbiBkaXJlY3Rpb24sIHByaW9yaXRpemUgYWNjdXJhY3kgb3ZlciBzcGVlZC4gTGlrZSBhIGJvdW5jZSBlYXNlIC0geW91IGRvbid0IHdhbnQgdG8gcmlzayB0aGUgc2FtcGxpbmcgY2h1bmtzIGxhbmRpbmcgb24gZWFjaCBzaWRlIG9mIHRoZSBib3VuY2UgYW5jaG9yIGFuZCBoYXZpbmcgaXQgY2xpcHBlZCBvZmYuXG5cdFx0XHRcdFx0ZmFzdCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByZXZQb2ludC5jeCA8IGNsb3Nlc3QpIHtcblx0XHRcdFx0XHRpZiAoIXByZXZQb2ludC5jeCkge1xuXHRcdFx0XHRcdFx0cHJldlBvaW50LmN4ID0gMC4wMDE7IC8vYXZvaWRzIG1hdGggcHJvYmxlbXMgaW4gZ2V0UmF0aW8oKSAoZGl2aWRpbmcgYnkgemVybylcblx0XHRcdFx0XHRcdGlmIChpID09PSBsIC0gMSkgeyAvL2luIGNhc2UgdGhlIGZpbmFsIHNlZ21lbnQgZ29lcyB2ZXJ0aWNhbCBSSUdIVCBhdCB0aGUgZW5kLCBtYWtlIHN1cmUgd2UgZW5kIGF0IHRoZSBlbmQuXG5cdFx0XHRcdFx0XHRcdHByZXZQb2ludC54IC09IDAuMDAxO1xuXHRcdFx0XHRcdFx0XHRjbG9zZXN0ID0gTWF0aC5taW4oY2xvc2VzdCwgMC4wMDEpO1xuXHRcdFx0XHRcdFx0XHRmYXN0ID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvc2VzdCA9IHByZXZQb2ludC5jeDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvaW50cy5zcGxpY2UoaS0tLCAxKTtcblx0XHRcdFx0bC0tO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRsID0gKDEgLyBjbG9zZXN0ICsgMSkgfCAwO1xuXHRcdGluYyA9IDEgLyBsO1xuXHRcdGogPSAwO1xuXHRcdHBvaW50ID0gcG9pbnRzWzBdO1xuXHRcdGlmIChmYXN0KSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7IC8vZm9yIGZhc3Rlc3QgbG9va3Vwcywgd2UganVzdCBzYW1wbGUgYWxvbmcgdGhlIHBhdGggYXQgZXF1YWwgeCAodGltZSkgZGlzdGFuY2UuIFVzZXMgbW9yZSBtZW1vcnkgYW5kIGlzIHNsaWdodGx5IGxlc3MgYWNjdXJhdGUgZm9yIGFuY2hvcnMgdGhhdCBkb24ndCBsYW5kIG9uIHRoZSBzYW1wbGluZyBwb2ludHMsIGJ1dCBmb3IgdGhlIHZhc3QgbWFqb3JpdHkgb2YgZWFzZXMgaXQncyBleGNlbGxlbnQgKGFuZCBmYXN0KS5cblx0XHRcdFx0cCA9IGkgKiBpbmM7XG5cdFx0XHRcdGlmIChwb2ludC5ueCA8IHApIHtcblx0XHRcdFx0XHRwb2ludCA9IHBvaW50c1srK2pdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGExID0gcG9pbnQueSArICgocCAtIHBvaW50LngpIC8gcG9pbnQuY3gpICogcG9pbnQuY3k7XG5cdFx0XHRcdGxvb2t1cFtpXSA9IHt4OiBwLCBjeDogaW5jLCB5OiBhMSwgY3k6IDAsIG54OiA5fTtcblx0XHRcdFx0aWYgKGkpIHtcblx0XHRcdFx0XHRsb29rdXBbaSAtIDFdLmN5ID0gYTEgLSBsb29rdXBbaSAtIDFdLnk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxvb2t1cFtsIC0gMV0uY3kgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLnkgLSBhMTtcblx0XHR9IGVsc2UgeyAvL3RoaXMgb3B0aW9uIGlzIG1vcmUgYWNjdXJhdGUsIGVuc3VyaW5nIHRoYXQgRVZFUlkgYW5jaG9yIGlzIGhpdCBwZXJmZWN0bHkuIENsaXBwaW5nIGFjcm9zcyBhIGJvdW5jZSwgZm9yIGV4YW1wbGUsIHdvdWxkIG5ldmVyIGhhcHBlbi5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHsgLy9idWlsZCBhIGxvb2t1cCB0YWJsZSBiYXNlZCBvbiB0aGUgc21hbGxlc3QgZGlzdGFuY2Ugc28gdGhhdCB3ZSBjYW4gaW5zdGFudGx5IGZpbmQgdGhlIGFwcHJvcHJpYXRlIHBvaW50ICh3ZWxsLCBpdCdsbCBlaXRoZXIgYmUgdGhhdCBwb2ludCBvciB0aGUgdmVyeSBuZXh0IG9uZSkuIFdlJ2xsIGxvb2sgdXAgYmFzZWQgb24gdGhlIGxpbmVhciBwcm9ncmVzcy4gU28gaXQncyBpdCdzIDAuNSBhbmQgdGhlIGxvb2t1cCB0YWJsZSBoYXMgMTAwIGVsZW1lbnRzLCBpdCdkIGJlIGxpa2UgbG9va3VwW01hdGguZmxvb3IoMC41ICogMTAwKV1cblx0XHRcdFx0aWYgKHBvaW50Lm54IDwgaSAqIGluYykge1xuXHRcdFx0XHRcdHBvaW50ID0gcG9pbnRzWysral07XG5cdFx0XHRcdH1cblx0XHRcdFx0bG9va3VwW2ldID0gcG9pbnQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChqIDwgcG9pbnRzLmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0bG9va3VwW2ktMV0gPSBwb2ludHNbcG9pbnRzLmxlbmd0aC0yXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly90aGlzLl9jYWxjRW5kID0gKHBvaW50c1twb2ludHMubGVuZ3RoLTFdLnkgIT09IDEgfHwgcG9pbnRzWzBdLnkgIT09IDApOyAvL2Vuc3VyZXMgdGhhdCB3ZSBkb24ndCBydW4gaW50byBmbG9hdGluZyBwb2ludCBlcnJvcnMuIEFzIGxvbmcgYXMgd2UncmUgc3RhcnRpbmcgYXQgMCBhbmQgZW5kaW5nIGF0IDEsIHRlbGwgR1NBUCB0byBza2lwIHRoZSBmaW5hbCBjYWxjdWxhdGlvbiBhbmQgdXNlIDAvMSBhcyB0aGUgZmFjdG9yLlxuXG5cdFx0dGhpcy5lYXNlID0gcCA9PiB7XG5cdFx0XHRsZXQgcG9pbnQgPSBsb29rdXBbKHAgKiBsKSB8IDBdIHx8IGxvb2t1cFtsIC0gMV07XG5cdFx0XHRpZiAocG9pbnQubnggPCBwKSB7XG5cdFx0XHRcdHBvaW50ID0gcG9pbnQubjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwb2ludC55ICsgKChwIC0gcG9pbnQueCkgLyBwb2ludC5jeCkgKiBwb2ludC5jeTtcblx0XHR9O1xuXG5cdFx0dGhpcy5lYXNlLmN1c3RvbSA9IHRoaXM7XG5cblx0XHR0aGlzLmlkICYmIGdzYXAucmVnaXN0ZXJFYXNlKHRoaXMuaWQsIHRoaXMuZWFzZSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGdldFNWR0RhdGEoY29uZmlnKSB7XG5cdFx0cmV0dXJuIEN1c3RvbUVhc2UuZ2V0U1ZHRGF0YSh0aGlzLCBjb25maWcpO1xuXHR9XG5cblx0c3RhdGljIGNyZWF0ZShpZCwgZGF0YSwgY29uZmlnKSB7XG5cdFx0cmV0dXJuIChuZXcgQ3VzdG9tRWFzZShpZCwgZGF0YSwgY29uZmlnKSkuZWFzZTtcblx0fVxuXG5cdHN0YXRpYyByZWdpc3Rlcihjb3JlKSB7XG5cdFx0Z3NhcCA9IGNvcmU7XG5cdFx0X2luaXRDb3JlKCk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0KGlkKSB7XG5cdFx0cmV0dXJuIGdzYXAucGFyc2VFYXNlKGlkKTtcblx0fVxuXG5cdHN0YXRpYyBnZXRTVkdEYXRhKGVhc2UsIGNvbmZpZykge1xuXHRcdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblx0XHRsZXQgd2lkdGggPSBjb25maWcud2lkdGggfHwgMTAwLFxuXHRcdFx0aGVpZ2h0ID0gY29uZmlnLmhlaWdodCB8fCAxMDAsXG5cdFx0XHR4ID0gY29uZmlnLnggfHwgMCxcblx0XHRcdHkgPSAoY29uZmlnLnkgfHwgMCkgKyBoZWlnaHQsXG5cdFx0XHRlID0gZ3NhcC51dGlscy50b0FycmF5KGNvbmZpZy5wYXRoKVswXSxcblx0XHRcdGEsIHNsb3BlLCBpLCBpbmMsIHR4LCB0eSwgcHJlY2lzaW9uLCB0aHJlc2hvbGQsIHByZXZYLCBwcmV2WTtcblx0XHRpZiAoY29uZmlnLmludmVydCkge1xuXHRcdFx0aGVpZ2h0ID0gLWhlaWdodDtcblx0XHRcdHkgPSAwO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mKGVhc2UpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRlYXNlID0gZ3NhcC5wYXJzZUVhc2UoZWFzZSk7XG5cdFx0fVxuXHRcdGlmIChlYXNlLmN1c3RvbSkge1xuXHRcdFx0ZWFzZSA9IGVhc2UuY3VzdG9tO1xuXHRcdH1cblx0XHRpZiAoZWFzZSBpbnN0YW5jZW9mIEN1c3RvbUVhc2UpIHtcblx0XHRcdGEgPSByYXdQYXRoVG9TdHJpbmcodHJhbnNmb3JtUmF3UGF0aChbZWFzZS5zZWdtZW50XSwgd2lkdGgsIDAsIDAsIC1oZWlnaHQsIHgsIHkpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YSA9IFt4LCB5XTtcblx0XHRcdHByZWNpc2lvbiA9IE1hdGgubWF4KDUsIChjb25maWcucHJlY2lzaW9uIHx8IDEpICogMjAwKTtcblx0XHRcdGluYyA9IDEgLyBwcmVjaXNpb247XG5cdFx0XHRwcmVjaXNpb24gKz0gMjtcblx0XHRcdHRocmVzaG9sZCA9IDUgLyBwcmVjaXNpb247XG5cdFx0XHRwcmV2WCA9IF9yb3VuZCh4ICsgaW5jICogd2lkdGgpO1xuXHRcdFx0cHJldlkgPSBfcm91bmQoeSArIGVhc2UoaW5jKSAqIC1oZWlnaHQpO1xuXHRcdFx0c2xvcGUgPSAocHJldlkgLSB5KSAvIChwcmV2WCAtIHgpO1xuXHRcdFx0Zm9yIChpID0gMjsgaSA8IHByZWNpc2lvbjsgaSsrKSB7XG5cdFx0XHRcdHR4ID0gX3JvdW5kKHggKyBpICogaW5jICogd2lkdGgpO1xuXHRcdFx0XHR0eSA9IF9yb3VuZCh5ICsgZWFzZShpICogaW5jKSAqIC1oZWlnaHQpO1xuXHRcdFx0XHRpZiAoTWF0aC5hYnMoKHR5IC0gcHJldlkpIC8gKHR4IC0gcHJldlgpIC0gc2xvcGUpID4gdGhyZXNob2xkIHx8IGkgPT09IHByZWNpc2lvbiAtIDEpIHsgLy9vbmx5IGFkZCBwb2ludHMgd2hlbiB0aGUgc2xvcGUgY2hhbmdlcyBiZXlvbmQgdGhlIHRocmVzaG9sZFxuXHRcdFx0XHRcdGEucHVzaChwcmV2WCwgcHJldlkpO1xuXHRcdFx0XHRcdHNsb3BlID0gKHR5IC0gcHJldlkpIC8gKHR4IC0gcHJldlgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHByZXZYID0gdHg7XG5cdFx0XHRcdHByZXZZID0gdHk7XG5cdFx0XHR9XG5cdFx0XHRhID0gXCJNXCIgKyBhLmpvaW4oXCIsXCIpO1xuXHRcdH1cblx0XHRlICYmIGUuc2V0QXR0cmlidXRlKFwiZFwiLCBhKTtcblx0XHRyZXR1cm4gYTtcblx0fVxuXG59XG5cbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihDdXN0b21FYXNlKTtcblxuQ3VzdG9tRWFzZS52ZXJzaW9uID0gXCIzLjcuMFwiO1xuXG5leHBvcnQgeyBDdXN0b21FYXNlIGFzIGRlZmF1bHQgfTsiLCIvKiFcbiAqIFNjcm9sbFRyaWdnZXIgMy43LjBcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5sZXQgZ3NhcCwgX2NvcmVJbml0dGVkLCBfd2luLCBfZG9jLCBfZG9jRWwsIF9ib2R5LCBfcm9vdCwgX3Jlc2l6ZURlbGF5LCBfcmFmLCBfcmVxdWVzdCwgX3RvQXJyYXksIF9jbGFtcCwgX3RpbWUyLCBfc3luY0ludGVydmFsLCBfcmVmcmVzaGluZywgX3BvaW50ZXJJc0Rvd24sIF90cmFuc2Zvcm1Qcm9wLCBfaSwgX3ByZXZXaWR0aCwgX3ByZXZIZWlnaHQsIF9hdXRvUmVmcmVzaCwgX3NvcnQsIF9zdXBwcmVzc092ZXJ3cml0ZXMsIF9pZ25vcmVSZXNpemUsXG5cdF9saW1pdENhbGxiYWNrcywgLy8gaWYgdHJ1ZSwgd2UnbGwgb25seSB0cmlnZ2VyIGNhbGxiYWNrcyBpZiB0aGUgYWN0aXZlIHN0YXRlIHRvZ2dsZXMsIHNvIGlmIHlvdSBzY3JvbGwgaW1tZWRpYXRlbHkgcGFzdCBib3RoIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBvZiBhIFNjcm9sbFRyaWdnZXIgKHRodXMgaW5hY3RpdmUgdG8gaW5hY3RpdmUpLCBuZWl0aGVyIGl0cyBvbkVudGVyIG5vciBvbkxlYXZlIHdpbGwgYmUgY2FsbGVkLiBUaGlzIGlzIHVzZWZ1bCBkdXJpbmcgc3RhcnR1cC5cblx0X3N0YXJ0dXAgPSAxLFxuXHRfcHJveGllcyA9IFtdLFxuXHRfc2Nyb2xsZXJzID0gW10sXG5cdF9nZXRUaW1lID0gRGF0ZS5ub3csXG5cdF90aW1lMSA9IF9nZXRUaW1lKCksXG5cdF9sYXN0U2Nyb2xsVGltZSA9IDAsXG5cdF9lbmFibGVkID0gMSxcblx0X3Bhc3NUaHJvdWdoID0gdiA9PiB2LFxuXHRfcm91bmQgPSB2YWx1ZSA9PiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwKSAvIDEwMDAwMCB8fCAwLFxuXHRfd2luZG93RXhpc3RzID0gKCkgPT4gdHlwZW9mKHdpbmRvdykgIT09IFwidW5kZWZpbmVkXCIsXG5cdF9nZXRHU0FQID0gKCkgPT4gZ3NhcCB8fCAoX3dpbmRvd0V4aXN0cygpICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcCksXG5cdF9pc1ZpZXdwb3J0ID0gZSA9PiAhIX5fcm9vdC5pbmRleE9mKGUpLFxuXHRfZ2V0UHJveHlQcm9wID0gKGVsZW1lbnQsIHByb3BlcnR5KSA9PiB+X3Byb3hpZXMuaW5kZXhPZihlbGVtZW50KSAmJiBfcHJveGllc1tfcHJveGllcy5pbmRleE9mKGVsZW1lbnQpICsgMV1bcHJvcGVydHldLFxuXHRfZ2V0U2Nyb2xsRnVuYyA9IChlbGVtZW50LCB7cywgc2N9KSA9PiB7IC8vIHdlIHN0b3JlIHRoZSBzY3JvbGxlciBmdW5jdGlvbnMgaW4gYSBhbHRlcm5hdGluZyBzZXF1ZW5jZWQgQXJyYXkgbGlrZSBbZWxlbWVudCwgdmVydGljYWxTY3JvbGxGdW5jLCBob3Jpem9udGFsU2Nyb2xsRnVuYywgLi4uXSBzbyB0aGF0IHdlIGNhbiBtaW5pbWl6ZSBtZW1vcnksIG1heGltaXplIHBlcmZvcm1hbmNlLCBhbmQgd2UgYWxzbyByZWNvcmQgdGhlIGxhc3QgcG9zaXRpb24gYXMgYSBcIi5yZWNcIiBwcm9wZXJ0eSBpbiBvcmRlciB0byByZXZlcnQgdG8gdGhhdCBhZnRlciByZWZyZXNoaW5nIHRvIGVuc3VyZSB0aGluZ3MgZG9uJ3Qgc2hpZnQgYXJvdW5kLlxuXHRcdGxldCBpID0gX3Njcm9sbGVycy5pbmRleE9mKGVsZW1lbnQpLFxuXHRcdFx0b2Zmc2V0ID0gc2MgPT09IF92ZXJ0aWNhbC5zYyA/IDEgOiAyO1xuXHRcdCF+aSAmJiAoaSA9IF9zY3JvbGxlcnMucHVzaChlbGVtZW50KSAtIDEpO1xuXHRcdHJldHVybiBfc2Nyb2xsZXJzW2kgKyBvZmZzZXRdIHx8IChfc2Nyb2xsZXJzW2kgKyBvZmZzZXRdID0gX2dldFByb3h5UHJvcChlbGVtZW50LCBzKSB8fCAoX2lzVmlld3BvcnQoZWxlbWVudCkgPyBzYyA6IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVsZW1lbnRbc10gPSB2YWx1ZSkgOiBlbGVtZW50W3NdOyB9KSk7XG5cdH0sXG5cdF9nZXRCb3VuZHNGdW5jID0gZWxlbWVudCA9PiBfZ2V0UHJveHlQcm9wKGVsZW1lbnQsIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIpIHx8IChfaXNWaWV3cG9ydChlbGVtZW50KSA/ICgpID0+IHtfd2luT2Zmc2V0cy53aWR0aCA9IF93aW4uaW5uZXJXaWR0aDsgX3dpbk9mZnNldHMuaGVpZ2h0ID0gX3dpbi5pbm5lckhlaWdodDsgcmV0dXJuIF93aW5PZmZzZXRzO30gOiAoKSA9PiBfZ2V0Qm91bmRzKGVsZW1lbnQpKSxcblx0X2dldFNpemVGdW5jID0gKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCB7ZCwgZDIsIGF9KSA9PiAoYSA9IF9nZXRQcm94eVByb3Aoc2Nyb2xsZXIsIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIpKSA/ICgpID0+IGEoKVtkXSA6ICgpID0+IChpc1ZpZXdwb3J0ID8gX3dpbltcImlubmVyXCIgKyBkMl0gOiBzY3JvbGxlcltcImNsaWVudFwiICsgZDJdKSB8fCAwLFxuXHRfZ2V0T2Zmc2V0c0Z1bmMgPSAoZWxlbWVudCwgaXNWaWV3cG9ydCkgPT4gIWlzVmlld3BvcnQgfHwgfl9wcm94aWVzLmluZGV4T2YoZWxlbWVudCkgPyBfZ2V0Qm91bmRzRnVuYyhlbGVtZW50KSA6ICgpID0+IF93aW5PZmZzZXRzLFxuXHRfbWF4U2Nyb2xsID0gKGVsZW1lbnQsIHtzLCBkMiwgZCwgYX0pID0+IChzID0gXCJzY3JvbGxcIiArIGQyKSAmJiAoYSA9IF9nZXRQcm94eVByb3AoZWxlbWVudCwgcykpID8gYSgpIC0gX2dldEJvdW5kc0Z1bmMoZWxlbWVudCkoKVtkXSA6IF9pc1ZpZXdwb3J0KGVsZW1lbnQpID8gTWF0aC5tYXgoX2RvY0VsW3NdLCBfYm9keVtzXSkgLSAoX3dpbltcImlubmVyXCIgKyBkMl0gfHwgX2RvY0VsW1wiY2xpZW50XCIgKyBkMl0gfHwgX2JvZHlbXCJjbGllbnRcIiArIGQyXSkgOiBlbGVtZW50W3NdIC0gZWxlbWVudFtcIm9mZnNldFwiICsgZDJdLFxuXHRfaXRlcmF0ZUF1dG9SZWZyZXNoID0gKGZ1bmMsIGV2ZW50cykgPT4ge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgX2F1dG9SZWZyZXNoLmxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHQoIWV2ZW50cyB8fCB+ZXZlbnRzLmluZGV4T2YoX2F1dG9SZWZyZXNoW2krMV0pKSAmJiBmdW5jKF9hdXRvUmVmcmVzaFtpXSwgX2F1dG9SZWZyZXNoW2krMV0sIF9hdXRvUmVmcmVzaFtpKzJdKTtcblx0XHR9XG5cdH0sXG5cdF9pc1N0cmluZyA9IHZhbHVlID0+IHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIsXG5cdF9pc0Z1bmN0aW9uID0gdmFsdWUgPT4gdHlwZW9mKHZhbHVlKSA9PT0gXCJmdW5jdGlvblwiLFxuXHRfaXNOdW1iZXIgPSB2YWx1ZSA9PiB0eXBlb2YodmFsdWUpID09PSBcIm51bWJlclwiLFxuXHRfaXNPYmplY3QgPSB2YWx1ZSA9PiB0eXBlb2YodmFsdWUpID09PSBcIm9iamVjdFwiLFxuXHRfY2FsbElmRnVuYyA9IHZhbHVlID0+IF9pc0Z1bmN0aW9uKHZhbHVlKSAmJiB2YWx1ZSgpLFxuXHRfY29tYmluZUZ1bmMgPSAoZjEsIGYyKSA9PiAoKSA9PiB7XG5cdFx0bGV0IHJlc3VsdDEgPSBfY2FsbElmRnVuYyhmMSksXG5cdFx0XHRyZXN1bHQyID0gX2NhbGxJZkZ1bmMoZjIpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRfY2FsbElmRnVuYyhyZXN1bHQxKTtcblx0XHRcdF9jYWxsSWZGdW5jKHJlc3VsdDIpO1xuXHRcdH1cblx0fSxcblx0X2FicyA9IE1hdGguYWJzLFxuXHRfc2Nyb2xsTGVmdCA9IFwic2Nyb2xsTGVmdFwiLFxuXHRfc2Nyb2xsVG9wID0gXCJzY3JvbGxUb3BcIixcblx0X2xlZnQgPSBcImxlZnRcIixcblx0X3RvcCA9IFwidG9wXCIsXG5cdF9yaWdodCA9IFwicmlnaHRcIixcblx0X2JvdHRvbSA9IFwiYm90dG9tXCIsXG5cdF93aWR0aCA9IFwid2lkdGhcIixcblx0X2hlaWdodCA9IFwiaGVpZ2h0XCIsXG5cdF9SaWdodCA9IFwiUmlnaHRcIixcblx0X0xlZnQgPSBcIkxlZnRcIixcblx0X1RvcCA9IFwiVG9wXCIsXG5cdF9Cb3R0b20gPSBcIkJvdHRvbVwiLFxuXHRfcGFkZGluZyA9IFwicGFkZGluZ1wiLFxuXHRfbWFyZ2luID0gXCJtYXJnaW5cIixcblx0X1dpZHRoID0gXCJXaWR0aFwiLFxuXHRfSGVpZ2h0ID0gXCJIZWlnaHRcIixcblx0X3B4ID0gXCJweFwiLFxuXHRfaG9yaXpvbnRhbCA9IHtzOiBfc2Nyb2xsTGVmdCwgcDogX2xlZnQsIHAyOiBfTGVmdCwgb3M6IF9yaWdodCwgb3MyOiBfUmlnaHQsIGQ6IF93aWR0aCwgZDI6IF9XaWR0aCwgYTogXCJ4XCIsIHNjOiBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IF93aW4uc2Nyb2xsVG8odmFsdWUsIF92ZXJ0aWNhbC5zYygpKSA6IF93aW4ucGFnZVhPZmZzZXQgfHwgX2RvY1tfc2Nyb2xsTGVmdF0gfHwgX2RvY0VsW19zY3JvbGxMZWZ0XSB8fCBfYm9keVtfc2Nyb2xsTGVmdF0gfHwgMH19LFxuXHRfdmVydGljYWwgPSB7czogX3Njcm9sbFRvcCwgcDogX3RvcCwgcDI6IF9Ub3AsIG9zOiBfYm90dG9tLCBvczI6IF9Cb3R0b20sIGQ6IF9oZWlnaHQsIGQyOiBfSGVpZ2h0LCBhOiBcInlcIiwgb3A6IF9ob3Jpem9udGFsLCBzYzogZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBfd2luLnNjcm9sbFRvKF9ob3Jpem9udGFsLnNjKCksIHZhbHVlKSA6IF93aW4ucGFnZVlPZmZzZXQgfHwgX2RvY1tfc2Nyb2xsVG9wXSB8fCBfZG9jRWxbX3Njcm9sbFRvcF0gfHwgX2JvZHlbX3Njcm9sbFRvcF0gfHwgMH19LFxuXHRfZ2V0Q29tcHV0ZWRTdHlsZSA9IGVsZW1lbnQgPT4gX3dpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLFxuXHRfbWFrZVBvc2l0aW9uYWJsZSA9IGVsZW1lbnQgPT4geyAvLyBpZiB0aGUgZWxlbWVudCBhbHJlYWR5IGhhcyBwb3NpdGlvbjogYWJzb2x1dGUgb3IgZml4ZWQsIGxlYXZlIHRoYXQsIG90aGVyd2lzZSBtYWtlIGl0IHBvc2l0aW9uOiByZWxhdGl2ZVxuXHRcdGxldCBwb3NpdGlvbiA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uO1xuXHRcdGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAocG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSA/IHBvc2l0aW9uIDogXCJyZWxhdGl2ZVwiO1xuXHR9LFxuXHRfc2V0RGVmYXVsdHMgPSAob2JqLCBkZWZhdWx0cykgPT4ge1xuXHRcdGZvciAobGV0IHAgaW4gZGVmYXVsdHMpIHtcblx0XHRcdChwIGluIG9iaikgfHwgKG9ialtwXSA9IGRlZmF1bHRzW3BdKTtcblx0XHR9XG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblx0Ly9faXNJblZpZXdwb3J0ID0gZWxlbWVudCA9PiAoZWxlbWVudCA9IF9nZXRCb3VuZHMoZWxlbWVudCkpICYmICEoZWxlbWVudC50b3AgPiAoX3dpbi5pbm5lckhlaWdodCB8fCBfZG9jRWwuY2xpZW50SGVpZ2h0KSB8fCBlbGVtZW50LmJvdHRvbSA8IDAgfHwgZWxlbWVudC5sZWZ0ID4gKF93aW4uaW5uZXJXaWR0aCB8fCBfZG9jRWwuY2xpZW50V2lkdGgpIHx8IGVsZW1lbnQucmlnaHQgPCAwKSAmJiBlbGVtZW50LFxuXHRfZ2V0Qm91bmRzID0gKGVsZW1lbnQsIHdpdGhvdXRUcmFuc2Zvcm1zKSA9PiB7XG5cdFx0bGV0IHR3ZWVuID0gd2l0aG91dFRyYW5zZm9ybXMgJiYgX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudClbX3RyYW5zZm9ybVByb3BdICE9PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiICYmIGdzYXAudG8oZWxlbWVudCwge3g6IDAsIHk6IDAsIHhQZXJjZW50OiAwLCB5UGVyY2VudDogMCwgcm90YXRpb246IDAsIHJvdGF0aW9uWDogMCwgcm90YXRpb25ZOiAwLCBzY2FsZTogMSwgc2tld1g6IDAsIHNrZXdZOiAwfSkucHJvZ3Jlc3MoMSksXG5cdFx0XHRib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHR3ZWVuICYmIHR3ZWVuLnByb2dyZXNzKDApLmtpbGwoKTtcblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXHRfZ2V0U2l6ZSA9IChlbGVtZW50LCB7ZDJ9KSA9PiBlbGVtZW50W1wib2Zmc2V0XCIgKyBkMl0gfHwgZWxlbWVudFtcImNsaWVudFwiICsgZDJdIHx8IDAsXG5cdF9nZXRMYWJlbFJhdGlvQXJyYXkgPSB0aW1lbGluZSA9PiB7XG5cdFx0bGV0IGEgPSBbXSxcblx0XHRcdGxhYmVscyA9IHRpbWVsaW5lLmxhYmVscyxcblx0XHRcdGR1cmF0aW9uID0gdGltZWxpbmUuZHVyYXRpb24oKSxcblx0XHRcdHA7XG5cdFx0Zm9yIChwIGluIGxhYmVscykge1xuXHRcdFx0YS5wdXNoKGxhYmVsc1twXSAvIGR1cmF0aW9uKTtcblx0XHR9XG5cdFx0cmV0dXJuIGE7XG5cdH0sXG5cdF9nZXRDbG9zZXN0TGFiZWwgPSBhbmltYXRpb24gPT4gdmFsdWUgPT4gZ3NhcC51dGlscy5zbmFwKF9nZXRMYWJlbFJhdGlvQXJyYXkoYW5pbWF0aW9uKSwgdmFsdWUpLFxuXHRfZ2V0TGFiZWxBdERpcmVjdGlvbiA9IHRpbWVsaW5lID0+IHtcblx0XHRyZXR1cm4gKHZhbHVlLCBzdCkgPT4ge1xuXHRcdFx0bGV0IGEgPSBfZ2V0TGFiZWxSYXRpb0FycmF5KHRpbWVsaW5lKSxcblx0XHRcdFx0aTtcblx0XHRcdGEuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuXHRcdFx0aWYgKHN0LmRpcmVjdGlvbiA+IDApIHtcblx0XHRcdFx0dmFsdWUgLT0gMWUtNDsgLy8gdG8gYXZvaWQgcm91bmRpbmcgZXJyb3JzLiBJZiB3ZSdyZSB0b28gc3RyaWN0LCBpdCBtaWdodCBzbmFwIGZvcndhcmQsIHRoZW4gaW1tZWRpYXRlbHkgYWdhaW4sIGFuZCBhZ2Fpbi5cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoYVtpXSA+PSB2YWx1ZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGFbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBhLnBvcCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHR2YWx1ZSArPSAxZS00O1xuXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0aWYgKGFbaV0gPD0gdmFsdWUpIHtcblx0XHRcdFx0XHRcdHJldHVybiBhW2ldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFbMF07XG5cdFx0fTtcblx0fSxcblx0X211bHRpTGlzdGVuZXIgPSAoZnVuYywgZWxlbWVudCwgdHlwZXMsIGNhbGxiYWNrKSA9PiB0eXBlcy5zcGxpdChcIixcIikuZm9yRWFjaCh0eXBlID0+IGZ1bmMoZWxlbWVudCwgdHlwZSwgY2FsbGJhY2spKSxcblx0X2FkZExpc3RlbmVyID0gKGVsZW1lbnQsIHR5cGUsIGZ1bmMpID0+IGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jLCB7cGFzc2l2ZTogdHJ1ZX0pLFxuXHRfcmVtb3ZlTGlzdGVuZXIgPSAoZWxlbWVudCwgdHlwZSwgZnVuYykgPT4gZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmMpLFxuXHRfbWFya2VyRGVmYXVsdHMgPSB7c3RhcnRDb2xvcjogXCJncmVlblwiLCBlbmRDb2xvcjogXCJyZWRcIiwgaW5kZW50OiAwLCBmb250U2l6ZTogXCIxNnB4XCIsIGZvbnRXZWlnaHQ6XCJub3JtYWxcIn0sXG5cdF9kZWZhdWx0cyA9IHt0b2dnbGVBY3Rpb25zOiBcInBsYXlcIiwgYW50aWNpcGF0ZVBpbjogMH0sXG5cdF9rZXl3b3JkcyA9IHt0b3A6IDAsIGxlZnQ6IDAsIGNlbnRlcjogMC41LCBib3R0b206IDEsIHJpZ2h0OiAxfSxcblx0X29mZnNldFRvUHggPSAodmFsdWUsIHNpemUpID0+IHtcblx0XHRpZiAoX2lzU3RyaW5nKHZhbHVlKSkge1xuXHRcdFx0bGV0IGVxSW5kZXggPSB2YWx1ZS5pbmRleE9mKFwiPVwiKSxcblx0XHRcdFx0cmVsYXRpdmUgPSB+ZXFJbmRleCA/ICsodmFsdWUuY2hhckF0KGVxSW5kZXgtMSkgKyAxKSAqIHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyKGVxSW5kZXggKyAxKSkgOiAwO1xuXHRcdFx0aWYgKH5lcUluZGV4KSB7XG5cdFx0XHRcdCh2YWx1ZS5pbmRleE9mKFwiJVwiKSA+IGVxSW5kZXgpICYmIChyZWxhdGl2ZSAqPSBzaXplIC8gMTAwKTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgZXFJbmRleC0xKTtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gcmVsYXRpdmUgKyAoKHZhbHVlIGluIF9rZXl3b3JkcykgPyBfa2V5d29yZHNbdmFsdWVdICogc2l6ZSA6IH52YWx1ZS5pbmRleE9mKFwiJVwiKSA/IHBhcnNlRmxvYXQodmFsdWUpICogc2l6ZSAvIDEwMCA6IHBhcnNlRmxvYXQodmFsdWUpIHx8IDApO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdF9jcmVhdGVNYXJrZXIgPSAodHlwZSwgbmFtZSwgY29udGFpbmVyLCBkaXJlY3Rpb24sIHtzdGFydENvbG9yLCBlbmRDb2xvciwgZm9udFNpemUsIGluZGVudCwgZm9udFdlaWdodH0sIG9mZnNldCwgbWF0Y2hXaWR0aEVsKSA9PiB7XG5cdFx0bGV0IGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cdFx0XHR1c2VGaXhlZFBvc2l0aW9uID0gX2lzVmlld3BvcnQoY29udGFpbmVyKSB8fCBfZ2V0UHJveHlQcm9wKGNvbnRhaW5lciwgXCJwaW5UeXBlXCIpID09PSBcImZpeGVkXCIsXG5cdFx0XHRpc1Njcm9sbGVyID0gdHlwZS5pbmRleE9mKFwic2Nyb2xsZXJcIikgIT09IC0xLFxuXHRcdFx0cGFyZW50ID0gdXNlRml4ZWRQb3NpdGlvbiA/IF9ib2R5IDogY29udGFpbmVyLFxuXHRcdFx0aXNTdGFydCA9IHR5cGUuaW5kZXhPZihcInN0YXJ0XCIpICE9PSAtMSxcblx0XHRcdGNvbG9yID0gaXNTdGFydCA/IHN0YXJ0Q29sb3IgOiBlbmRDb2xvcixcblx0XHRcdGNzcyA9IFwiYm9yZGVyLWNvbG9yOlwiICsgY29sb3IgKyBcIjtmb250LXNpemU6XCIgKyBmb250U2l6ZSArIFwiO2NvbG9yOlwiICsgY29sb3IgKyBcIjtmb250LXdlaWdodDpcIiArIGZvbnRXZWlnaHQgKyBcIjtwb2ludGVyLWV2ZW50czpub25lO3doaXRlLXNwYWNlOm5vd3JhcDtmb250LWZhbWlseTpzYW5zLXNlcmlmLEFyaWFsO3otaW5kZXg6MTAwMDtwYWRkaW5nOjRweCA4cHg7Ym9yZGVyLXdpZHRoOjA7Ym9yZGVyLXN0eWxlOnNvbGlkO1wiO1xuXHRcdGNzcyArPSBcInBvc2l0aW9uOlwiICsgKGlzU2Nyb2xsZXIgJiYgdXNlRml4ZWRQb3NpdGlvbiA/IFwiZml4ZWQ7XCIgOiBcImFic29sdXRlO1wiKTtcblx0XHQoaXNTY3JvbGxlciB8fCAhdXNlRml4ZWRQb3NpdGlvbikgJiYgKGNzcyArPSAoZGlyZWN0aW9uID09PSBfdmVydGljYWwgPyBfcmlnaHQgOiBfYm90dG9tKSArIFwiOlwiICsgKG9mZnNldCArIHBhcnNlRmxvYXQoaW5kZW50KSkgKyBcInB4O1wiKTtcblx0XHRtYXRjaFdpZHRoRWwgJiYgKGNzcyArPSBcImJveC1zaXppbmc6Ym9yZGVyLWJveDt0ZXh0LWFsaWduOmxlZnQ7d2lkdGg6XCIgKyBtYXRjaFdpZHRoRWwub2Zmc2V0V2lkdGggKyBcInB4O1wiKTtcblx0XHRlLl9pc1N0YXJ0ID0gaXNTdGFydDtcblx0XHRlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiZ3NhcC1tYXJrZXItXCIgKyB0eXBlKTtcblx0XHRlLnN0eWxlLmNzc1RleHQgPSBjc3M7XG5cdFx0ZS5pbm5lclRleHQgPSBuYW1lIHx8IG5hbWUgPT09IDAgPyB0eXBlICsgXCItXCIgKyBuYW1lIDogdHlwZTtcblx0XHRwYXJlbnQuY2hpbGRyZW5bMF0gPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKGUsIHBhcmVudC5jaGlsZHJlblswXSkgOiBwYXJlbnQuYXBwZW5kQ2hpbGQoZSk7XG5cdFx0ZS5fb2Zmc2V0ID0gZVtcIm9mZnNldFwiICsgZGlyZWN0aW9uLm9wLmQyXTtcblx0XHRfcG9zaXRpb25NYXJrZXIoZSwgMCwgZGlyZWN0aW9uLCBpc1N0YXJ0KTtcblx0XHRyZXR1cm4gZTtcblx0fSxcblx0X3Bvc2l0aW9uTWFya2VyID0gKG1hcmtlciwgc3RhcnQsIGRpcmVjdGlvbiwgZmxpcHBlZCkgPT4ge1xuXHRcdGxldCB2YXJzID0ge2Rpc3BsYXk6IFwiYmxvY2tcIn0sXG5cdFx0XHRzaWRlID0gZGlyZWN0aW9uW2ZsaXBwZWQgPyBcIm9zMlwiIDogXCJwMlwiXSxcblx0XHRcdG9wcG9zaXRlU2lkZSA9IGRpcmVjdGlvbltmbGlwcGVkID8gXCJwMlwiIDogXCJvczJcIl07XG5cdFx0bWFya2VyLl9pc0ZsaXBwZWQgPSBmbGlwcGVkO1xuXHRcdHZhcnNbZGlyZWN0aW9uLmEgKyBcIlBlcmNlbnRcIl0gPSBmbGlwcGVkID8gLTEwMCA6IDA7XG5cdFx0dmFyc1tkaXJlY3Rpb24uYV0gPSBmbGlwcGVkID8gXCIxcHhcIiA6IDA7XG5cdFx0dmFyc1tcImJvcmRlclwiICsgc2lkZSArIF9XaWR0aF0gPSAxO1xuXHRcdHZhcnNbXCJib3JkZXJcIiArIG9wcG9zaXRlU2lkZSArIF9XaWR0aF0gPSAwO1xuXHRcdHZhcnNbZGlyZWN0aW9uLnBdID0gc3RhcnQgKyBcInB4XCI7XG5cdFx0Z3NhcC5zZXQobWFya2VyLCB2YXJzKTtcblx0fSxcblx0X3RyaWdnZXJzID0gW10sXG5cdF9pZHMgPSB7fSxcblx0X3N5bmMgPSAoKSA9PiBfcmVxdWVzdCB8fCAoX3JlcXVlc3QgPSBfcmFmKF91cGRhdGVBbGwpKSxcblx0X29uU2Nyb2xsID0gKCkgPT4ge1xuXHRcdGlmICghX3JlcXVlc3QpIHtcblx0XHRcdF9yZXF1ZXN0ID0gX3JhZihfdXBkYXRlQWxsKTtcblx0XHRcdF9sYXN0U2Nyb2xsVGltZSB8fCBfZGlzcGF0Y2goXCJzY3JvbGxTdGFydFwiKTtcblx0XHRcdF9sYXN0U2Nyb2xsVGltZSA9IF9nZXRUaW1lKCk7XG5cdFx0fVxuXHR9LFxuXHRfb25SZXNpemUgPSAoKSA9PiAhX3JlZnJlc2hpbmcgJiYgIV9pZ25vcmVSZXNpemUgJiYgIV9kb2MuZnVsbHNjcmVlbkVsZW1lbnQgJiYgX3Jlc2l6ZURlbGF5LnJlc3RhcnQodHJ1ZSksIC8vIGlnbm9yZSByZXNpemVzIHRyaWdnZXJlZCBieSByZWZyZXNoKClcblx0X2xpc3RlbmVycyA9IHt9LFxuXHRfZW1wdHlBcnJheSA9IFtdLFxuXHRfbWVkaWEgPSBbXSxcblx0X2NyZWF0aW5nTWVkaWEsIC8vIHdoZW4gU2Nyb2xsVHJpZ2dlci5tYXRjaE1lZGlhKCkgaXMgY2FsbGVkLCB3ZSByZWNvcmQgdGhlIGN1cnJlbnQgbWVkaWEga2V5IGhlcmUgKGxpa2UgXCIobWluLXdpZHRoOiA4MDBweClcIikgc28gdGhhdCB3ZSBjYW4gYXNzaWduIGl0IHRvIGV2ZXJ5dGhpbmcgdGhhdCdzIGNyZWF0ZWQgZHVyaW5nIHRoYXQgY2FsbC4gVGhlbiB3ZSBjYW4gcmV2ZXJ0IGp1c3QgdGhvc2Ugd2hlbiBuZWNlc3NhcnkuIEluIHRoZSBTY3JvbGxUcmlnZ2VyJ3MgaW5pdCgpIGNhbGwsIHRoZSBfY3JlYXRpbmdNZWRpYSBpcyByZWNvcmRlZCBhcyBhIFwibWVkaWFcIiBwcm9wZXJ0eSBvbiB0aGUgaW5zdGFuY2UuXG5cdF9sYXN0TWVkaWFUaWNrLFxuXHRfb25NZWRpYUNoYW5nZSA9IGUgPT4ge1xuXHRcdGxldCB0aWNrID0gZ3NhcC50aWNrZXIuZnJhbWUsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGluZGV4O1xuXHRcdGlmIChfbGFzdE1lZGlhVGljayAhPT0gdGljayB8fCBfc3RhcnR1cCkge1xuXHRcdFx0X3JldmVydEFsbCgpO1xuXHRcdFx0Zm9yICg7IGkgPCBfbWVkaWEubGVuZ3RoOyBpKz00KSB7XG5cdFx0XHRcdGluZGV4ID0gX3dpbi5tYXRjaE1lZGlhKF9tZWRpYVtpXSkubWF0Y2hlcztcblx0XHRcdFx0aWYgKGluZGV4ICE9PSBfbWVkaWFbaSszXSkgeyAvLyBub3RlOiBzb21lIGJyb3dzZXJzIGZpcmUgdGhlIG1hdGNoTWVkaWEgZXZlbnQgbXVsdGlwbGUgdGltZXMsIGxpa2Ugd2hlbiBnb2luZyBmdWxsIHNjcmVlbiwgc28gd2Ugc2hvdWxkbid0IGNhbGwgdGhlIGZ1bmN0aW9uIG11bHRpcGxlIHRpbWVzLiBDaGVjayB0byBzZWUgaWYgaXQncyBhbHJlYWR5IG1hdGNoZWQuXG5cdFx0XHRcdFx0X21lZGlhW2krM10gPSBpbmRleDtcblx0XHRcdFx0XHRpbmRleCA/IG1hdGNoZXMucHVzaChpKSA6IF9yZXZlcnRBbGwoMSwgX21lZGlhW2ldKSB8fCAoX2lzRnVuY3Rpb24oX21lZGlhW2krMl0pICYmIF9tZWRpYVtpKzJdKCkpOyAvLyBGaXJlZm94IGRvZXNuJ3QgdXBkYXRlIHRoZSBcIm1hdGNoZXNcIiBwcm9wZXJ0eSBvZiB0aGUgTWVkaWFRdWVyeUxpc3Qgb2JqZWN0IGNvcnJlY3RseSAtIGl0IG9ubHkgZG9lcyBzbyBhcyBpdCBjYWxscyBpdHMgY2hhbmdlIGhhbmRsZXIgLSBzbyB3ZSBtdXN0IHJlLWNyZWF0ZSBhIG1lZGlhIHF1ZXJ5IGhlcmUgdG8gZW5zdXJlIGl0J3MgYWNjdXJhdGUuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdF9yZXZlcnRSZWNvcmRlZCgpOyAvLyBpbiBjYXNlIGtpbGxpbmcvcmV2ZXJ0aW5nIGFueSBvZiB0aGUgYW5pbWF0aW9ucyBhY3R1YWxseSBhZGRlZCBpbmxpbmUgc3R5bGVzIGJhY2suXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpbmRleCA9IG1hdGNoZXNbaV07XG5cdFx0XHRcdF9jcmVhdGluZ01lZGlhID0gX21lZGlhW2luZGV4XTtcblx0XHRcdFx0X21lZGlhW2luZGV4KzJdID0gX21lZGlhW2luZGV4KzFdKGUpO1xuXHRcdFx0fVxuXHRcdFx0X2NyZWF0aW5nTWVkaWEgPSAwO1xuXHRcdFx0X2NvcmVJbml0dGVkICYmIF9yZWZyZXNoQWxsKDAsIDEpO1xuXHRcdFx0X2xhc3RNZWRpYVRpY2sgPSB0aWNrO1xuXHRcdFx0X2Rpc3BhdGNoKFwibWF0Y2hNZWRpYVwiKTtcblx0XHR9XG5cdH0sXG5cdF9zb2Z0UmVmcmVzaCA9ICgpID0+IF9yZW1vdmVMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInNjcm9sbEVuZFwiLCBfc29mdFJlZnJlc2gpIHx8IF9yZWZyZXNoQWxsKHRydWUpLFxuXHRfZGlzcGF0Y2ggPSB0eXBlID0+IChfbGlzdGVuZXJzW3R5cGVdICYmIF9saXN0ZW5lcnNbdHlwZV0ubWFwKGYgPT4gZigpKSkgfHwgX2VtcHR5QXJyYXksXG5cdF9zYXZlZFN0eWxlcyA9IFtdLCAvLyB3aGVuIFNjcm9sbFRyaWdnZXIuc2F2ZVN0eWxlcygpIGlzIGNhbGxlZCwgdGhlIGlubGluZSBzdHlsZXMgYXJlIHJlY29yZGVkIGluIHRoaXMgQXJyYXkgaW4gYSBzZXF1ZW50aWFsIGZvcm1hdCBsaWtlIFtlbGVtZW50LCBjc3NUZXh0LCBnc0NhY2hlLCBtZWRpYV0uIFRoaXMga2VlcHMgaXQgdmVyeSBtZW1vcnktZWZmaWNpZW50IGFuZCBmYXN0IHRvIGl0ZXJhdGUgdGhyb3VnaC5cblx0X3JldmVydFJlY29yZGVkID0gbWVkaWEgPT4ge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgX3NhdmVkU3R5bGVzLmxlbmd0aDsgaSs9NSkge1xuXHRcdFx0aWYgKCFtZWRpYSB8fCBfc2F2ZWRTdHlsZXNbaSs0XSA9PT0gbWVkaWEpIHtcblx0XHRcdFx0X3NhdmVkU3R5bGVzW2ldLnN0eWxlLmNzc1RleHQgPSBfc2F2ZWRTdHlsZXNbaSsxXTtcblx0XHRcdFx0X3NhdmVkU3R5bGVzW2ldLmdldEJCb3ggJiYgX3NhdmVkU3R5bGVzW2ldLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBfc2F2ZWRTdHlsZXNbaSsyXSB8fCBcIlwiKTtcblx0XHRcdFx0X3NhdmVkU3R5bGVzW2krM10udW5jYWNoZSA9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRfcmV2ZXJ0QWxsID0gKGtpbGwsIG1lZGlhKSA9PiB7XG5cdFx0bGV0IHRyaWdnZXI7XG5cdFx0Zm9yIChfaSA9IDA7IF9pIDwgX3RyaWdnZXJzLmxlbmd0aDsgX2krKykge1xuXHRcdFx0dHJpZ2dlciA9IF90cmlnZ2Vyc1tfaV07XG5cdFx0XHRpZiAoIW1lZGlhIHx8IHRyaWdnZXIubWVkaWEgPT09IG1lZGlhKSB7XG5cdFx0XHRcdGlmIChraWxsKSB7XG5cdFx0XHRcdFx0dHJpZ2dlci5raWxsKDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRyaWdnZXIucmV2ZXJ0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0bWVkaWEgJiYgX3JldmVydFJlY29yZGVkKG1lZGlhKTtcblx0XHRtZWRpYSB8fCBfZGlzcGF0Y2goXCJyZXZlcnRcIik7XG5cdH0sXG5cdF9yZWZyZXNoQWxsID0gKGZvcmNlLCBza2lwUmV2ZXJ0KSA9PiB7XG5cdFx0aWYgKF9sYXN0U2Nyb2xsVGltZSAmJiAhZm9yY2UpIHtcblx0XHRcdF9hZGRMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInNjcm9sbEVuZFwiLCBfc29mdFJlZnJlc2gpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRsZXQgcmVmcmVzaEluaXRzID0gX2Rpc3BhdGNoKFwicmVmcmVzaEluaXRcIik7XG5cdFx0X3NvcnQgJiYgU2Nyb2xsVHJpZ2dlci5zb3J0KCk7XG5cdFx0c2tpcFJldmVydCB8fCBfcmV2ZXJ0QWxsKCk7XG5cdFx0X3RyaWdnZXJzLmZvckVhY2godCA9PiB0LnJlZnJlc2goKSkgLy8gZG9uJ3QgbG9vcCB3aXRoIF9pIGJlY2F1c2UgZHVyaW5nIGEgcmVmcmVzaCgpIHNvbWVvbmUgY291bGQgY2FsbCBTY3JvbGxUcmlnZ2VyLnVwZGF0ZSgpIHdoaWNoIHdvdWxkIGl0ZXJhdGUgdGhyb3VnaCBfaSByZXN1bHRpbmcgaW4gYSBza2lwLlxuXHRcdHJlZnJlc2hJbml0cy5mb3JFYWNoKHJlc3VsdCA9PiByZXN1bHQgJiYgcmVzdWx0LnJlbmRlciAmJiByZXN1bHQucmVuZGVyKC0xKSk7IC8vIGlmIHRoZSBvblJlZnJlc2hJbml0KCkgcmV0dXJucyBhbiBhbmltYXRpb24gKHR5cGljYWxseSBhIGdzYXAuc2V0KCkpLCByZXZlcnQgaXQuIFRoaXMgbWFrZXMgaXQgZWFzeSB0byBwdXQgdGhpbmdzIGluIGEgY2VydGFpbiBzcG90IGJlZm9yZSByZWZyZXNoaW5nIGZvciBtZWFzdXJlbWVudCBwdXJwb3NlcywgYW5kIHRoZW4gcHV0IHRoaW5ncyBiYWNrLlxuXHRcdF9zY3JvbGxlcnMuZm9yRWFjaChvYmogPT4gdHlwZW9mKG9iaikgPT09IFwiZnVuY3Rpb25cIiAmJiAob2JqLnJlYyA9IDApKTsgLy8gemVyby1vdXQgYWxsIHRoZSByZWNvcmRlZCBzY3JvbGwgcG9zaXRpb25zLiBEb24ndCB1c2UgX3RyaWdnZXJzIGJlY2F1c2UgaWYsIGZvciBleGFtcGxlLCAubWF0Y2hNZWRpYSgpIGlzIHVzZWQgdG8gY3JlYXRlIHNvbWUgU2Nyb2xsVHJpZ2dlcnMgYW5kIHRoZW4gdGhlIHVzZXIgcmVzaXplcyBhbmQgaXQgcmVtb3ZlcyBBTEwgU2Nyb2xsVHJpZ2dlcnMsIGFuZCB0aGVuIGdvIGJhY2sgdG8gYSBzaXplIHdoZXJlIHRoZXJlIGFyZSBTY3JvbGxUcmlnZ2VycywgaXQgd291bGQgaGF2ZSBrZXB0IHRoZSBwb3NpdGlvbihzKSBzYXZlZCBmcm9tIHRoZSBpbml0aWFsIHN0YXRlLlxuXHRcdF9yZXNpemVEZWxheS5wYXVzZSgpO1xuXHRcdF9kaXNwYXRjaChcInJlZnJlc2hcIik7XG5cdH0sXG5cdF9sYXN0U2Nyb2xsID0gMCxcblx0X2RpcmVjdGlvbiA9IDEsXG5cdF91cGRhdGVBbGwgPSAoKSA9PiB7XG5cdFx0bGV0IGwgPSBfdHJpZ2dlcnMubGVuZ3RoLFxuXHRcdFx0dGltZSA9IF9nZXRUaW1lKCksXG5cdFx0XHRyZWNvcmRWZWxvY2l0eSA9IHRpbWUgLSBfdGltZTEgPj0gNTAsXG5cdFx0XHRzY3JvbGwgPSBsICYmIF90cmlnZ2Vyc1swXS5zY3JvbGwoKTtcblx0XHRfZGlyZWN0aW9uID0gX2xhc3RTY3JvbGwgPiBzY3JvbGwgPyAtMSA6IDE7XG5cdFx0X2xhc3RTY3JvbGwgPSBzY3JvbGw7XG5cdFx0aWYgKHJlY29yZFZlbG9jaXR5KSB7XG5cdFx0XHRpZiAoX2xhc3RTY3JvbGxUaW1lICYmICFfcG9pbnRlcklzRG93biAmJiB0aW1lIC0gX2xhc3RTY3JvbGxUaW1lID4gMjAwKSB7XG5cdFx0XHRcdF9sYXN0U2Nyb2xsVGltZSA9IDA7XG5cdFx0XHRcdF9kaXNwYXRjaChcInNjcm9sbEVuZFwiKTtcblx0XHRcdH1cblx0XHRcdF90aW1lMiA9IF90aW1lMTtcblx0XHRcdF90aW1lMSA9IHRpbWU7XG5cdFx0fVxuXHRcdGlmIChfZGlyZWN0aW9uIDwgMCkge1xuXHRcdFx0X2kgPSBsO1xuXHRcdFx0d2hpbGUgKF9pLS0gPiAwKSB7XG5cdFx0XHRcdF90cmlnZ2Vyc1tfaV0gJiYgX3RyaWdnZXJzW19pXS51cGRhdGUoMCwgcmVjb3JkVmVsb2NpdHkpO1xuXHRcdFx0fVxuXHRcdFx0X2RpcmVjdGlvbiA9IDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoX2kgPSAwOyBfaSA8IGw7IF9pKyspIHtcblx0XHRcdFx0X3RyaWdnZXJzW19pXSAmJiBfdHJpZ2dlcnNbX2ldLnVwZGF0ZSgwLCByZWNvcmRWZWxvY2l0eSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdF9yZXF1ZXN0ID0gMDtcblx0fSxcblx0X3Byb3BOYW1lc1RvQ29weSA9IFtfbGVmdCwgX3RvcCwgX2JvdHRvbSwgX3JpZ2h0LCBfbWFyZ2luICsgX0JvdHRvbSwgX21hcmdpbiArIF9SaWdodCwgX21hcmdpbiArIF9Ub3AsIF9tYXJnaW4gKyBfTGVmdCwgXCJkaXNwbGF5XCIsIFwiZmxleFNocmlua1wiLCBcImZsb2F0XCIsIFwiekluZGV4XCIsIFwiZ3JpZC1jb2x1bW4tc3RhcnRcIiwgXCJncmlkLWNvbHVtbi1lbmRcIiwgXCJncmlkLXJvdy1zdGFydFwiLCBcImdyaWQtcm93LWVuZFwiLCBcImdyaWQtYXJlYVwiLCBcImp1c3RpZnktc2VsZlwiLCBcImFsaWduLXNlbGZcIiwgXCJwbGFjZS1zZWxmXCJdLFxuXHRfc3RhdGVQcm9wcyA9IF9wcm9wTmFtZXNUb0NvcHkuY29uY2F0KFtfd2lkdGgsIF9oZWlnaHQsIFwiYm94U2l6aW5nXCIsIFwibWF4XCIgKyBfV2lkdGgsIFwibWF4XCIgKyBfSGVpZ2h0LCBcInBvc2l0aW9uXCIsIF9tYXJnaW4sIF9wYWRkaW5nLCBfcGFkZGluZyArIF9Ub3AsIF9wYWRkaW5nICsgX1JpZ2h0LCBfcGFkZGluZyArIF9Cb3R0b20sIF9wYWRkaW5nICsgX0xlZnRdKSxcblx0X3N3YXBQaW5PdXQgPSAocGluLCBzcGFjZXIsIHN0YXRlKSA9PiB7XG5cdFx0X3NldFN0YXRlKHN0YXRlKTtcblx0XHRpZiAocGluLnBhcmVudE5vZGUgPT09IHNwYWNlcikge1xuXHRcdFx0bGV0IHBhcmVudCA9IHNwYWNlci5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKHBpbiwgc3BhY2VyKTtcblx0XHRcdFx0cGFyZW50LnJlbW92ZUNoaWxkKHNwYWNlcik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRfc3dhcFBpbkluID0gKHBpbiwgc3BhY2VyLCBjcywgc3BhY2VyU3RhdGUpID0+IHtcblx0XHRpZiAocGluLnBhcmVudE5vZGUgIT09IHNwYWNlcikge1xuXHRcdFx0bGV0IGkgPSBfcHJvcE5hbWVzVG9Db3B5Lmxlbmd0aCxcblx0XHRcdFx0c3BhY2VyU3R5bGUgPSBzcGFjZXIuc3R5bGUsXG5cdFx0XHRcdHBpblN0eWxlID0gcGluLnN0eWxlLFxuXHRcdFx0XHRwO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRwID0gX3Byb3BOYW1lc1RvQ29weVtpXTtcblx0XHRcdFx0c3BhY2VyU3R5bGVbcF0gPSBjc1twXTtcblx0XHRcdH1cblx0XHRcdHNwYWNlclN0eWxlLnBvc2l0aW9uID0gY3MucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiA/IFwiYWJzb2x1dGVcIiA6IFwicmVsYXRpdmVcIjtcblx0XHRcdChjcy5kaXNwbGF5ID09PSBcImlubGluZVwiKSAmJiAoc3BhY2VyU3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCIpO1xuXHRcdFx0cGluU3R5bGVbX2JvdHRvbV0gPSBwaW5TdHlsZVtfcmlnaHRdID0gXCJhdXRvXCI7XG5cdFx0XHRzcGFjZXJTdHlsZS5vdmVyZmxvdyA9IFwidmlzaWJsZVwiO1xuXHRcdFx0c3BhY2VyU3R5bGUuYm94U2l6aW5nID0gXCJib3JkZXItYm94XCI7XG5cdFx0XHRzcGFjZXJTdHlsZVtfd2lkdGhdID0gX2dldFNpemUocGluLCBfaG9yaXpvbnRhbCkgKyBfcHg7XG5cdFx0XHRzcGFjZXJTdHlsZVtfaGVpZ2h0XSA9IF9nZXRTaXplKHBpbiwgX3ZlcnRpY2FsKSArIF9weDtcblx0XHRcdHNwYWNlclN0eWxlW19wYWRkaW5nXSA9IHBpblN0eWxlW19tYXJnaW5dID0gcGluU3R5bGVbX3RvcF0gPSBwaW5TdHlsZVtfbGVmdF0gPSBcIjBcIjtcblx0XHRcdF9zZXRTdGF0ZShzcGFjZXJTdGF0ZSk7XG5cdFx0XHRwaW5TdHlsZVtfd2lkdGhdID0gcGluU3R5bGVbXCJtYXhcIiArIF9XaWR0aF0gPSBjc1tfd2lkdGhdO1xuXHRcdFx0cGluU3R5bGVbX2hlaWdodF0gPSBwaW5TdHlsZVtcIm1heFwiICsgX0hlaWdodF0gPSBjc1tfaGVpZ2h0XTtcblx0XHRcdHBpblN0eWxlW19wYWRkaW5nXSA9IGNzW19wYWRkaW5nXTtcblx0XHRcdHBpbi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzcGFjZXIsIHBpbik7XG5cdFx0XHRzcGFjZXIuYXBwZW5kQ2hpbGQocGluKTtcblx0XHR9XG5cdH0sXG5cdF9jYXBzRXhwID0gLyhbQS1aXSkvZyxcblx0X3NldFN0YXRlID0gc3RhdGUgPT4ge1xuXHRcdGlmIChzdGF0ZSkge1xuXHRcdFx0bGV0IHN0eWxlID0gc3RhdGUudC5zdHlsZSxcblx0XHRcdFx0bCA9IHN0YXRlLmxlbmd0aCxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdHAsIHZhbHVlO1xuXHRcdFx0KHN0YXRlLnQuX2dzYXAgfHwgZ3NhcC5jb3JlLmdldENhY2hlKHN0YXRlLnQpKS51bmNhY2hlID0gMTsgLy8gb3RoZXJ3aXNlIHRyYW5zZm9ybXMgbWF5IGJlIG9mZlxuXHRcdFx0Zm9yICg7IGkgPCBsOyBpICs9Mikge1xuXHRcdFx0XHR2YWx1ZSA9IHN0YXRlW2krMV07XG5cdFx0XHRcdHAgPSBzdGF0ZVtpXTtcblx0XHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdFx0c3R5bGVbcF0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChzdHlsZVtwXSkge1xuXHRcdFx0XHRcdHN0eWxlLnJlbW92ZVByb3BlcnR5KHAucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdF9nZXRTdGF0ZSA9IGVsZW1lbnQgPT4geyAvLyByZXR1cm5zIGFuIEFycmF5IHdpdGggYWx0ZXJuYXRpbmcgdmFsdWVzIGxpa2UgW3Byb3BlcnR5LCB2YWx1ZSwgcHJvcGVydHksIHZhbHVlXSBhbmQgYSBcInRcIiBwcm9wZXJ0eSBwb2ludGluZyB0byB0aGUgdGFyZ2V0IChlbGVtZW50KS4gTWFrZXMgaXQgZmFzdCBhbmQgY2hlYXAuXG5cdFx0bGV0IGwgPSBfc3RhdGVQcm9wcy5sZW5ndGgsXG5cdFx0XHRzdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG5cdFx0XHRzdGF0ZSA9IFtdLFxuXHRcdFx0aSA9IDA7XG5cdFx0Zm9yICg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHN0YXRlLnB1c2goX3N0YXRlUHJvcHNbaV0sIHN0eWxlW19zdGF0ZVByb3BzW2ldXSk7XG5cdFx0fVxuXHRcdHN0YXRlLnQgPSBlbGVtZW50O1xuXHRcdHJldHVybiBzdGF0ZTtcblx0fSxcblx0X2NvcHlTdGF0ZSA9IChzdGF0ZSwgb3ZlcnJpZGUsIG9taXRPZmZzZXRzKSA9PiB7XG5cdFx0bGV0IHJlc3VsdCA9IFtdLFxuXHRcdFx0bCA9IHN0YXRlLmxlbmd0aCxcblx0XHRcdGkgPSBvbWl0T2Zmc2V0cyA/IDggOiAwLCAvLyBza2lwIHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSBpZiBvbWl0T2Zmc2V0cyBpcyB0cnVlXG5cdFx0XHRwO1xuXHRcdGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XG5cdFx0XHRwID0gc3RhdGVbaV07XG5cdFx0XHRyZXN1bHQucHVzaChwLCAocCBpbiBvdmVycmlkZSkgPyBvdmVycmlkZVtwXSA6IHN0YXRlW2krMV0pO1xuXHRcdH1cblx0XHRyZXN1bHQudCA9IHN0YXRlLnQ7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblx0X3dpbk9mZnNldHMgPSB7bGVmdDowLCB0b3A6MH0sXG5cdF9wYXJzZVBvc2l0aW9uID0gKHZhbHVlLCB0cmlnZ2VyLCBzY3JvbGxlclNpemUsIGRpcmVjdGlvbiwgc2Nyb2xsLCBtYXJrZXIsIG1hcmtlclNjcm9sbGVyLCBzZWxmLCBzY3JvbGxlckJvdW5kcywgYm9yZGVyV2lkdGgsIHVzZUZpeGVkUG9zaXRpb24sIHNjcm9sbGVyTWF4KSA9PiB7XG5cdFx0X2lzRnVuY3Rpb24odmFsdWUpICYmICh2YWx1ZSA9IHZhbHVlKHNlbGYpKTtcblx0XHRpZiAoX2lzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5zdWJzdHIoMCwzKSA9PT0gXCJtYXhcIikge1xuXHRcdFx0dmFsdWUgPSBzY3JvbGxlck1heCArICh2YWx1ZS5jaGFyQXQoNCkgPT09IFwiPVwiID8gX29mZnNldFRvUHgoXCIwXCIgKyB2YWx1ZS5zdWJzdHIoMyksIHNjcm9sbGVyU2l6ZSkgOiAwKTtcblx0XHR9XG5cdFx0aWYgKCFfaXNOdW1iZXIodmFsdWUpKSB7XG5cdFx0XHRfaXNGdW5jdGlvbih0cmlnZ2VyKSAmJiAodHJpZ2dlciA9IHRyaWdnZXIoc2VsZikpO1xuXHRcdFx0bGV0IGVsZW1lbnQgPSBfdG9BcnJheSh0cmlnZ2VyKVswXSB8fCBfYm9keSxcblx0XHRcdFx0Ym91bmRzID0gX2dldEJvdW5kcyhlbGVtZW50KSB8fCB7fSxcblx0XHRcdFx0b2Zmc2V0cyA9IHZhbHVlLnNwbGl0KFwiIFwiKSxcblx0XHRcdFx0bG9jYWxPZmZzZXQsIGdsb2JhbE9mZnNldCwgZGlzcGxheTtcblx0XHRcdGlmICgoIWJvdW5kcyB8fCAoIWJvdW5kcy5sZWZ0ICYmICFib3VuZHMudG9wKSkgJiYgX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZGlzcGxheSA9PT0gXCJub25lXCIpIHsgLy8gaWYgZGlzcGxheSBpcyBcIm5vbmVcIiwgaXQgd29uJ3QgcmVwb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHByb3Blcmx5XG5cdFx0XHRcdGRpc3BsYXkgPSBlbGVtZW50LnN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0XHRcdFx0Ym91bmRzID0gX2dldEJvdW5kcyhlbGVtZW50KTtcblx0XHRcdFx0ZGlzcGxheSA/IChlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5KSA6IGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJkaXNwbGF5XCIpO1xuXHRcdFx0fVxuXHRcdFx0bG9jYWxPZmZzZXQgPSBfb2Zmc2V0VG9QeChvZmZzZXRzWzBdLCBib3VuZHNbZGlyZWN0aW9uLmRdKTtcblx0XHRcdGdsb2JhbE9mZnNldCA9IF9vZmZzZXRUb1B4KG9mZnNldHNbMV0gfHwgXCIwXCIsIHNjcm9sbGVyU2l6ZSk7XG5cdFx0XHR2YWx1ZSA9IGJvdW5kc1tkaXJlY3Rpb24ucF0gLSBzY3JvbGxlckJvdW5kc1tkaXJlY3Rpb24ucF0gLSBib3JkZXJXaWR0aCArIGxvY2FsT2Zmc2V0ICsgc2Nyb2xsIC0gZ2xvYmFsT2Zmc2V0O1xuXHRcdFx0bWFya2VyU2Nyb2xsZXIgJiYgX3Bvc2l0aW9uTWFya2VyKG1hcmtlclNjcm9sbGVyLCBnbG9iYWxPZmZzZXQsIGRpcmVjdGlvbiwgKHNjcm9sbGVyU2l6ZSAtIGdsb2JhbE9mZnNldCA8IDIwIHx8IChtYXJrZXJTY3JvbGxlci5faXNTdGFydCAmJiBnbG9iYWxPZmZzZXQgPiAyMCkpKTtcblx0XHRcdHNjcm9sbGVyU2l6ZSAtPSBzY3JvbGxlclNpemUgLSBnbG9iYWxPZmZzZXQ7IC8vIGFkanVzdCBmb3IgdGhlIG1hcmtlclxuXHRcdH0gZWxzZSBpZiAobWFya2VyU2Nyb2xsZXIpIHtcblx0XHRcdF9wb3NpdGlvbk1hcmtlcihtYXJrZXJTY3JvbGxlciwgc2Nyb2xsZXJTaXplLCBkaXJlY3Rpb24sIHRydWUpO1xuXHRcdH1cblx0XHRpZiAobWFya2VyKSB7XG5cdFx0XHRsZXQgcG9zaXRpb24gPSB2YWx1ZSArIHNjcm9sbGVyU2l6ZSxcblx0XHRcdFx0aXNTdGFydCA9IG1hcmtlci5faXNTdGFydDtcblx0XHRcdHNjcm9sbGVyTWF4ID0gXCJzY3JvbGxcIiArIGRpcmVjdGlvbi5kMjtcblx0XHRcdF9wb3NpdGlvbk1hcmtlcihtYXJrZXIsIHBvc2l0aW9uLCBkaXJlY3Rpb24sIChpc1N0YXJ0ICYmIHBvc2l0aW9uID4gMjApIHx8ICghaXNTdGFydCAmJiAodXNlRml4ZWRQb3NpdGlvbiA/IE1hdGgubWF4KF9ib2R5W3Njcm9sbGVyTWF4XSwgX2RvY0VsW3Njcm9sbGVyTWF4XSkgOiBtYXJrZXIucGFyZW50Tm9kZVtzY3JvbGxlck1heF0pIDw9IHBvc2l0aW9uICsgMSkpO1xuXHRcdFx0aWYgKHVzZUZpeGVkUG9zaXRpb24pIHtcblx0XHRcdFx0c2Nyb2xsZXJCb3VuZHMgPSBfZ2V0Qm91bmRzKG1hcmtlclNjcm9sbGVyKTtcblx0XHRcdFx0dXNlRml4ZWRQb3NpdGlvbiAmJiAobWFya2VyLnN0eWxlW2RpcmVjdGlvbi5vcC5wXSA9IChzY3JvbGxlckJvdW5kc1tkaXJlY3Rpb24ub3AucF0gLSBkaXJlY3Rpb24ub3AubSAtIG1hcmtlci5fb2Zmc2V0KSArIF9weCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcblx0fSxcblx0X3ByZWZpeEV4cCA9IC8oPzp3ZWJraXR8bW96fGxlbmd0aHxjc3NUZXh0fGluc2V0KS9pLFxuXHRfcmVwYXJlbnQgPSAoZWxlbWVudCwgcGFyZW50LCB0b3AsIGxlZnQpID0+IHtcblx0XHRpZiAoZWxlbWVudC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHtcblx0XHRcdGxldCBzdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG5cdFx0XHRcdHAsIGNzO1xuXHRcdFx0aWYgKHBhcmVudCA9PT0gX2JvZHkpIHtcblx0XHRcdFx0ZWxlbWVudC5fc3RPcmlnID0gc3R5bGUuY3NzVGV4dDsgLy8gcmVjb3JkIG9yaWdpbmFsIGlubGluZSBzdHlsZXMgc28gd2UgY2FuIHJldmVydCB0aGVtIGxhdGVyXG5cdFx0XHRcdGNzID0gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cdFx0XHRcdGZvciAocCBpbiBjcykgeyAvLyBtdXN0IGNvcHkgYWxsIHJlbGV2YW50IHN0eWxlcyB0byBlbnN1cmUgdGhhdCBub3RoaW5nIGNoYW5nZXMgdmlzdWFsbHkgd2hlbiB3ZSByZXBhcmVudCB0byB0aGUgPGJvZHk+LiBTa2lwIHRoZSB2ZW5kb3IgcHJlZml4ZWQgb25lcy5cblx0XHRcdFx0XHRpZiAoIStwICYmICFfcHJlZml4RXhwLnRlc3QocCkgJiYgY3NbcF0gJiYgdHlwZW9mIHN0eWxlW3BdID09PSBcInN0cmluZ1wiICYmIHAgIT09IFwiMFwiKSB7XG5cdFx0XHRcdFx0XHRzdHlsZVtwXSA9IGNzW3BdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS50b3AgPSB0b3A7XG5cdFx0XHRcdHN0eWxlLmxlZnQgPSBsZWZ0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3R5bGUuY3NzVGV4dCA9IGVsZW1lbnQuX3N0T3JpZztcblx0XHRcdH1cblx0XHRcdGdzYXAuY29yZS5nZXRDYWNoZShlbGVtZW50KS51bmNhY2hlID0gMTtcblx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcblx0XHR9XG5cdH0sXG5cdC8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHR3ZWVuIHRoZSBzY3JvbGwgcG9zaXRpb24gaW4gdGhlIGRpcmVjdGlvbiBwcm92aWRlZCwgYW5kIHdoZW4gZG9pbmcgc28gaXQnbGwgYWRkIGEgLnR3ZWVuIHByb3BlcnR5IHRvIHRoZSBGVU5DVElPTiBpdHNlbGYsIGFuZCByZW1vdmUgaXQgd2hlbiB0aGUgdHdlZW4gY29tcGxldGVzIG9yIGdldHMga2lsbGVkLiBUaGlzIGdpdmVzIHVzIGEgd2F5IHRvIGhhdmUgbXVsdGlwbGUgU2Nyb2xsVHJpZ2dlcnMgdXNlIGEgY2VudHJhbCBmdW5jdGlvbiBmb3IgYW55IGdpdmVuIHNjcm9sbGVyIGFuZCBzZWUgaWYgdGhlcmUncyBhIHNjcm9sbCB0d2VlbiBydW5uaW5nICh3aGljaCB3b3VsZCBhZmZlY3QgaWYvaG93IHRoaW5ncyBnZXQgdXBkYXRlZClcblx0X2dldFR3ZWVuQ3JlYXRvciA9IChzY3JvbGxlciwgZGlyZWN0aW9uKSA9PiB7XG5cdFx0bGV0IGdldFNjcm9sbCA9IF9nZXRTY3JvbGxGdW5jKHNjcm9sbGVyLCBkaXJlY3Rpb24pLFxuXHRcdFx0cHJvcCA9IFwiX3Njcm9sbFwiICsgZGlyZWN0aW9uLnAyLCAvLyBhZGQgYSB0d2VlbmFibGUgcHJvcGVydHkgdG8gdGhlIHNjcm9sbGVyIHRoYXQncyBhIGdldHRlci9zZXR0ZXIgZnVuY3Rpb24sIGxpa2UgX3Njcm9sbFRvcCBvciBfc2Nyb2xsTGVmdC4gVGhpcyB3YXksIGlmIHNvbWVvbmUgZG9lcyBnc2FwLmtpbGxUd2VlbnNPZihzY3JvbGxlcikgaXQnbGwga2lsbCB0aGUgc2Nyb2xsIHR3ZWVuLlxuXHRcdFx0bGFzdFNjcm9sbDEsIGxhc3RTY3JvbGwyLFxuXHRcdFx0Z2V0VHdlZW4gPSAoc2Nyb2xsVG8sIHZhcnMsIGluaXRpYWxWYWx1ZSwgY2hhbmdlMSwgY2hhbmdlMikgPT4ge1xuXHRcdFx0XHRsZXQgdHdlZW4gPSBnZXRUd2Vlbi50d2Vlbixcblx0XHRcdFx0XHRvbkNvbXBsZXRlID0gdmFycy5vbkNvbXBsZXRlLFxuXHRcdFx0XHRcdG1vZGlmaWVycyA9IHt9O1xuXHRcdFx0XHR0d2VlbiAmJiB0d2Vlbi5raWxsKCk7XG5cdFx0XHRcdGxhc3RTY3JvbGwxID0gTWF0aC5yb3VuZChpbml0aWFsVmFsdWUpO1xuXHRcdFx0XHR2YXJzW3Byb3BdID0gc2Nyb2xsVG87XG5cdFx0XHRcdHZhcnMubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuXHRcdFx0XHRtb2RpZmllcnNbcHJvcF0gPSB2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0dmFsdWUgPSBfcm91bmQoZ2V0U2Nyb2xsKCkpOyAvLyByb3VuZCBiZWNhdXNlIGluIHNvbWUgW3ZlcnkgdW5jb21tb25dIFdpbmRvd3MgZW52aXJvbm1lbnRzLCBpdCBjYW4gZ2V0IHJlcG9ydGVkIHdpdGggZGVjaW1hbHMgZXZlbiB0aG91Z2ggaXQgd2FzIHNldCB3aXRob3V0LlxuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gbGFzdFNjcm9sbDEgJiYgdmFsdWUgIT09IGxhc3RTY3JvbGwyICYmIE1hdGguYWJzKHZhbHVlIC0gbGFzdFNjcm9sbDEpID4gMikgeyAvLyBpZiB0aGUgdXNlciBzY3JvbGxzLCBraWxsIHRoZSB0d2Vlbi4gaU9TIFNhZmFyaSBpbnRlcm1pdHRlbnRseSBtaXNyZXBvcnRzIHRoZSBzY3JvbGwgcG9zaXRpb24sIGl0IG1heSBiZSB0aGUgbW9zdCByZWNlbnRseS1zZXQgb25lIG9yIHRoZSBvbmUgYmVmb3JlIHRoYXQhIFdoZW4gU2FmYXJpIGlzIHpvb21lZCAoQ01ELSspLCBpdCBvZnRlbiBtaXNyZXBvcnRzIGFzIDEgcGl4ZWwgb2ZmIHRvbyEgU28gaWYgd2Ugc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gdG8gMTI1LCBmb3IgZXhhbXBsZSwgaXQnbGwgYWN0dWFsbHkgcmVwb3J0IGl0IGFzIDEyNC5cblx0XHRcdFx0XHRcdHR3ZWVuLmtpbGwoKTtcblx0XHRcdFx0XHRcdGdldFR3ZWVuLnR3ZWVuID0gMDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBpbml0aWFsVmFsdWUgKyBjaGFuZ2UxICogdHdlZW4ucmF0aW8gKyBjaGFuZ2UyICogdHdlZW4ucmF0aW8gKiB0d2Vlbi5yYXRpbztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGFzdFNjcm9sbDIgPSBsYXN0U2Nyb2xsMTtcblx0XHRcdFx0XHRyZXR1cm4gKGxhc3RTY3JvbGwxID0gX3JvdW5kKHZhbHVlKSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHZhcnMub25Db21wbGV0ZSA9ICgpID0+IHtcblx0XHRcdFx0XHRnZXRUd2Vlbi50d2VlbiA9IDA7XG5cdFx0XHRcdFx0b25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlLmNhbGwodHdlZW4pO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR0d2VlbiA9IGdldFR3ZWVuLnR3ZWVuID0gZ3NhcC50byhzY3JvbGxlciwgdmFycyk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH07XG5cdFx0c2Nyb2xsZXJbcHJvcF0gPSBnZXRTY3JvbGw7XG5cdFx0c2Nyb2xsZXIuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsICgpID0+IGdldFR3ZWVuLnR3ZWVuICYmIGdldFR3ZWVuLnR3ZWVuLmtpbGwoKSAmJiAoZ2V0VHdlZW4udHdlZW4gPSAwKSk7IC8vIFdpbmRvd3MgbWFjaGluZXMgaGFuZGxlIG1vdXNld2hlZWwgc2Nyb2xsaW5nIGluIGNodW5rcyAobGlrZSBcIjMgbGluZXMgcGVyIHNjcm9sbFwiKSBtZWFuaW5nIHRoZSB0eXBpY2FsIHN0cmF0ZWd5IGZvciBjYW5jZWxsaW5nIHRoZSBzY3JvbGwgaXNuJ3QgYXMgc2Vuc2l0aXZlLiBJdCdzIG11Y2ggbW9yZSBsaWtlbHkgdG8gbWF0Y2ggb25lIG9mIHRoZSBwcmV2aW91cyAyIHNjcm9sbCBldmVudCBwb3NpdGlvbnMuIFNvIHdlIGtpbGwgYW55IHNuYXBwaW5nIGFzIHNvb24gYXMgdGhlcmUncyBhIHdoZWVsIGV2ZW50LlxuXHRcdHJldHVybiBnZXRUd2Vlbjtcblx0fTtcblxuX2hvcml6b250YWwub3AgPSBfdmVydGljYWw7XG5cblxuXG5leHBvcnQgY2xhc3MgU2Nyb2xsVHJpZ2dlciB7XG5cblx0Y29uc3RydWN0b3IodmFycywgYW5pbWF0aW9uKSB7XG5cdFx0X2NvcmVJbml0dGVkIHx8IFNjcm9sbFRyaWdnZXIucmVnaXN0ZXIoZ3NhcCkgfHwgY29uc29sZS53YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVHJpZ2dlcilcIik7XG5cdFx0dGhpcy5pbml0KHZhcnMsIGFuaW1hdGlvbik7XG5cdH1cblxuXHRpbml0KHZhcnMsIGFuaW1hdGlvbikge1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSB0aGlzLnN0YXJ0ID0gMDtcblx0XHR0aGlzLnZhcnMgJiYgdGhpcy5raWxsKDEpOyAvLyBpbiBjYXNlIGl0J3MgYmVpbmcgaW5pdHRlZCBhZ2FpblxuXHRcdGlmICghX2VuYWJsZWQpIHtcblx0XHRcdHRoaXMudXBkYXRlID0gdGhpcy5yZWZyZXNoID0gdGhpcy5raWxsID0gX3Bhc3NUaHJvdWdoO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXJzID0gX3NldERlZmF1bHRzKChfaXNTdHJpbmcodmFycykgfHwgX2lzTnVtYmVyKHZhcnMpIHx8IHZhcnMubm9kZVR5cGUpID8ge3RyaWdnZXI6IHZhcnN9IDogdmFycywgX2RlZmF1bHRzKTtcblx0XHRsZXQgZGlyZWN0aW9uID0gdmFycy5ob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwsXG5cdFx0XHR7b25VcGRhdGUsIHRvZ2dsZUNsYXNzLCBpZCwgb25Ub2dnbGUsIG9uUmVmcmVzaCwgc2NydWIsIHRyaWdnZXIsIHBpbiwgcGluU3BhY2luZywgaW52YWxpZGF0ZU9uUmVmcmVzaCwgYW50aWNpcGF0ZVBpbiwgb25TY3J1YkNvbXBsZXRlLCBvblNuYXBDb21wbGV0ZSwgb25jZSwgc25hcCwgcGluUmVwYXJlbnR9ID0gdmFycyxcblx0XHRcdGlzVG9nZ2xlID0gIXNjcnViICYmIHNjcnViICE9PSAwLFxuXHRcdFx0c2Nyb2xsZXIgPSBfdG9BcnJheSh2YXJzLnNjcm9sbGVyIHx8IF93aW4pWzBdLFxuXHRcdFx0c2Nyb2xsZXJDYWNoZSA9IGdzYXAuY29yZS5nZXRDYWNoZShzY3JvbGxlciksXG5cdFx0XHRpc1ZpZXdwb3J0ID0gX2lzVmlld3BvcnQoc2Nyb2xsZXIpLFxuXHRcdFx0dXNlRml4ZWRQb3NpdGlvbiA9IFwicGluVHlwZVwiIGluIHZhcnMgPyB2YXJzLnBpblR5cGUgPT09IFwiZml4ZWRcIiA6IGlzVmlld3BvcnQgfHwgX2dldFByb3h5UHJvcChzY3JvbGxlciwgXCJwaW5UeXBlXCIpID09PSBcImZpeGVkXCIsXG5cdFx0XHRjYWxsYmFja3MgPSBbdmFycy5vbkVudGVyLCB2YXJzLm9uTGVhdmUsIHZhcnMub25FbnRlckJhY2ssIHZhcnMub25MZWF2ZUJhY2tdLFxuXHRcdFx0dG9nZ2xlQWN0aW9ucyA9IGlzVG9nZ2xlICYmIHZhcnMudG9nZ2xlQWN0aW9ucy5zcGxpdChcIiBcIiksXG5cdFx0XHRtYXJrZXJzID0gXCJtYXJrZXJzXCIgaW4gdmFycyA/IHZhcnMubWFya2VycyA6IF9kZWZhdWx0cy5tYXJrZXJzLFxuXHRcdFx0Ym9yZGVyV2lkdGggPSBpc1ZpZXdwb3J0ID8gMCA6IHBhcnNlRmxvYXQoX2dldENvbXB1dGVkU3R5bGUoc2Nyb2xsZXIpW1wiYm9yZGVyXCIgKyBkaXJlY3Rpb24ucDIgKyBfV2lkdGhdKSB8fCAwLFxuXHRcdFx0c2VsZiA9IHRoaXMsXG5cdFx0XHRvblJlZnJlc2hJbml0ID0gdmFycy5vblJlZnJlc2hJbml0ICYmICgoKSA9PiB2YXJzLm9uUmVmcmVzaEluaXQoc2VsZikpLFxuXHRcdFx0Z2V0U2Nyb2xsZXJTaXplID0gX2dldFNpemVGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCBkaXJlY3Rpb24pLFxuXHRcdFx0Z2V0U2Nyb2xsZXJPZmZzZXRzID0gX2dldE9mZnNldHNGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0KSxcblx0XHRcdGxhc3RTbmFwID0gMCxcblx0XHRcdHR3ZWVuVG8sIHBpbkNhY2hlLCBzbmFwRnVuYywgc2Nyb2xsMSwgc2Nyb2xsMiwgc3RhcnQsIGVuZCwgbWFya2VyU3RhcnQsIG1hcmtlckVuZCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyLCBtYXJrZXJWYXJzLFxuXHRcdFx0Y2hhbmdlLCBwaW5PcmlnaW5hbFN0YXRlLCBwaW5BY3RpdmVTdGF0ZSwgcGluU3RhdGUsIHNwYWNlciwgb2Zmc2V0LCBwaW5HZXR0ZXIsIHBpblNldHRlciwgcGluU3RhcnQsIHBpbkNoYW5nZSwgc3BhY2luZ1N0YXJ0LCBzcGFjZXJTdGF0ZSwgbWFya2VyU3RhcnRTZXR0ZXIsXG5cdFx0XHRtYXJrZXJFbmRTZXR0ZXIsIGNzLCBzbmFwMSwgc25hcDIsIHNjcnViVHdlZW4sIHNjcnViU21vb3RoLCBzbmFwRHVyQ2xhbXAsIHNuYXBEZWxheWVkQ2FsbCwgcHJldlByb2dyZXNzLCBwcmV2U2Nyb2xsLCBwcmV2QW5pbVByb2dyZXNzO1xuXG5cdFx0c2VsZi5tZWRpYSA9IF9jcmVhdGluZ01lZGlhO1xuXHRcdGFudGljaXBhdGVQaW4gKj0gNDU7XG5cdFx0c2VsZi5zY3JvbGxlciA9IHNjcm9sbGVyO1xuXHRcdHNlbGYuc2Nyb2xsID0gX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGRpcmVjdGlvbik7XG5cdFx0c2Nyb2xsMSA9IHNlbGYuc2Nyb2xsKCk7XG5cdFx0c2VsZi52YXJzID0gdmFycztcblx0XHRhbmltYXRpb24gPSBhbmltYXRpb24gfHwgdmFycy5hbmltYXRpb247XG5cdFx0KFwicmVmcmVzaFByaW9yaXR5XCIgaW4gdmFycykgJiYgKF9zb3J0ID0gMSk7XG5cdFx0c2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbCA9IHNjcm9sbGVyQ2FjaGUudHdlZW5TY3JvbGwgfHwge1xuXHRcdFx0dG9wOiBfZ2V0VHdlZW5DcmVhdG9yKHNjcm9sbGVyLCBfdmVydGljYWwpLFxuXHRcdFx0bGVmdDogX2dldFR3ZWVuQ3JlYXRvcihzY3JvbGxlciwgX2hvcml6b250YWwpXG5cdFx0fTtcblx0XHRzZWxmLnR3ZWVuVG8gPSB0d2VlblRvID0gc2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbFtkaXJlY3Rpb24ucF07XG5cdFx0aWYgKGFuaW1hdGlvbikge1xuXHRcdFx0YW5pbWF0aW9uLnZhcnMubGF6eSA9IGZhbHNlO1xuXHRcdFx0YW5pbWF0aW9uLl9pbml0dGVkIHx8IChhbmltYXRpb24udmFycy5pbW1lZGlhdGVSZW5kZXIgIT09IGZhbHNlICYmIHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZSAmJiBhbmltYXRpb24ucmVuZGVyKDAsIHRydWUsIHRydWUpKTtcblx0XHRcdHNlbGYuYW5pbWF0aW9uID0gYW5pbWF0aW9uLnBhdXNlKCk7XG5cdFx0XHRhbmltYXRpb24uc2Nyb2xsVHJpZ2dlciA9IHNlbGY7XG5cdFx0XHRzY3J1YlNtb290aCA9IF9pc051bWJlcihzY3J1YikgJiYgc2NydWI7XG5cdFx0XHRzY3J1YlNtb290aCAmJiAoc2NydWJUd2VlbiA9IGdzYXAudG8oYW5pbWF0aW9uLCB7ZWFzZTogXCJwb3dlcjNcIiwgZHVyYXRpb246IHNjcnViU21vb3RoLCBvbkNvbXBsZXRlOiAoKSA9PiBvblNjcnViQ29tcGxldGUgJiYgb25TY3J1YkNvbXBsZXRlKHNlbGYpfSkpO1xuXHRcdFx0c25hcDEgPSAwO1xuXHRcdFx0aWQgfHwgKGlkID0gYW5pbWF0aW9uLnZhcnMuaWQpO1xuXHRcdH1cblx0XHRfdHJpZ2dlcnMucHVzaChzZWxmKTtcblx0XHRpZiAoc25hcCkge1xuXHRcdFx0X2lzT2JqZWN0KHNuYXApIHx8IChzbmFwID0ge3NuYXBUbzogc25hcH0pO1xuXHRcdFx0KFwic2Nyb2xsQmVoYXZpb3JcIiBpbiBfYm9keS5zdHlsZSkgJiYgZ3NhcC5zZXQoaXNWaWV3cG9ydCA/IFtfYm9keSwgX2RvY0VsXSA6IHNjcm9sbGVyLCB7c2Nyb2xsQmVoYXZpb3I6IFwiYXV0b1wifSk7IC8vIHNtb290aCBzY3JvbGxpbmcgZG9lc24ndCB3b3JrIHdpdGggc25hcC5cblx0XHRcdHNuYXBGdW5jID0gX2lzRnVuY3Rpb24oc25hcC5zbmFwVG8pID8gc25hcC5zbmFwVG8gOiBzbmFwLnNuYXBUbyA9PT0gXCJsYWJlbHNcIiA/IF9nZXRDbG9zZXN0TGFiZWwoYW5pbWF0aW9uKSA6IHNuYXAuc25hcFRvID09PSBcImxhYmVsc0RpcmVjdGlvbmFsXCIgPyBfZ2V0TGFiZWxBdERpcmVjdGlvbihhbmltYXRpb24pIDogZ3NhcC51dGlscy5zbmFwKHNuYXAuc25hcFRvKTtcblx0XHRcdHNuYXBEdXJDbGFtcCA9IHNuYXAuZHVyYXRpb24gfHwge21pbjogMC4xLCBtYXg6IDJ9O1xuXHRcdFx0c25hcER1ckNsYW1wID0gX2lzT2JqZWN0KHNuYXBEdXJDbGFtcCkgPyBfY2xhbXAoc25hcER1ckNsYW1wLm1pbiwgc25hcER1ckNsYW1wLm1heCkgOiBfY2xhbXAoc25hcER1ckNsYW1wLCBzbmFwRHVyQ2xhbXApO1xuXHRcdFx0c25hcERlbGF5ZWRDYWxsID0gZ3NhcC5kZWxheWVkQ2FsbChzbmFwLmRlbGF5IHx8IChzY3J1YlNtb290aCAvIDIpIHx8IDAuMSwgKCkgPT4ge1xuXHRcdFx0XHRpZiAoTWF0aC5hYnMoc2VsZi5nZXRWZWxvY2l0eSgpKSA8IDEwICYmICFfcG9pbnRlcklzRG93biAmJiBsYXN0U25hcCAhPT0gc2VsZi5zY3JvbGwoKSkge1xuXHRcdFx0XHRcdGxldCB0b3RhbFByb2dyZXNzID0gYW5pbWF0aW9uICYmICFpc1RvZ2dsZSA/IGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKCkgOiBzZWxmLnByb2dyZXNzLFxuXHRcdFx0XHRcdFx0dmVsb2NpdHkgPSAoKHRvdGFsUHJvZ3Jlc3MgLSBzbmFwMikgLyAoX2dldFRpbWUoKSAtIF90aW1lMikgKiAxMDAwKSB8fCAwLFxuXHRcdFx0XHRcdFx0Y2hhbmdlMSA9IGdzYXAudXRpbHMuY2xhbXAoLXNlbGYucHJvZ3Jlc3MsIDEgLSBzZWxmLnByb2dyZXNzLCBfYWJzKHZlbG9jaXR5IC8gMikgKiB2ZWxvY2l0eSAvIDAuMTg1KSxcblx0XHRcdFx0XHRcdG5hdHVyYWxFbmQgPSBzZWxmLnByb2dyZXNzICsgKHNuYXAuaW5lcnRpYSA9PT0gZmFsc2UgPyAwIDogY2hhbmdlMSksXG5cdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IF9jbGFtcCgwLCAxLCBzbmFwRnVuYyhuYXR1cmFsRW5kLCBzZWxmKSksXG5cdFx0XHRcdFx0XHRzY3JvbGwgPSBzZWxmLnNjcm9sbCgpLFxuXHRcdFx0XHRcdFx0ZW5kU2Nyb2xsID0gTWF0aC5yb3VuZChzdGFydCArIGVuZFZhbHVlICogY2hhbmdlKSxcblx0XHRcdFx0XHRcdHsgb25TdGFydCwgb25JbnRlcnJ1cHQsIG9uQ29tcGxldGUgfSA9IHNuYXAsXG5cdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuVG8udHdlZW47XG5cdFx0XHRcdFx0aWYgKHNjcm9sbCA8PSBlbmQgJiYgc2Nyb2xsID49IHN0YXJ0ICYmIGVuZFNjcm9sbCAhPT0gc2Nyb2xsKSB7XG5cdFx0XHRcdFx0XHRpZiAodHdlZW4gJiYgIXR3ZWVuLl9pbml0dGVkICYmIHR3ZWVuLmRhdGEgPD0gTWF0aC5hYnMoZW5kU2Nyb2xsIC0gc2Nyb2xsKSkgeyAvLyB0aGVyZSdzIGFuIG92ZXJsYXBwaW5nIHNuYXAhIFNvIHdlIG11c3QgZmlndXJlIG91dCB3aGljaCBvbmUgaXMgY2xvc2VyIGFuZCBsZXQgdGhhdCB0d2VlbiBsaXZlLlxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoc25hcC5pbmVydGlhID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0XHRjaGFuZ2UxID0gZW5kVmFsdWUgLSBzZWxmLnByb2dyZXNzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHdlZW5UbyhlbmRTY3JvbGwsIHtcblx0XHRcdFx0XHRcdFx0ZHVyYXRpb246IHNuYXBEdXJDbGFtcChfYWJzKCAoTWF0aC5tYXgoX2FicyhuYXR1cmFsRW5kIC0gdG90YWxQcm9ncmVzcyksIF9hYnMoZW5kVmFsdWUgLSB0b3RhbFByb2dyZXNzKSkgKiAwLjE4NSAvIHZlbG9jaXR5IC8gMC4wNSkgfHwgMCkpLFxuXHRcdFx0XHRcdFx0XHRlYXNlOiBzbmFwLmVhc2UgfHwgXCJwb3dlcjNcIixcblx0XHRcdFx0XHRcdFx0ZGF0YTogTWF0aC5hYnMoZW5kU2Nyb2xsIC0gc2Nyb2xsKSwgLy8gcmVjb3JkIHRoZSBkaXN0YW5jZSBzbyB0aGF0IGlmIGFub3RoZXIgc25hcCB0d2VlbiBvY2N1cnMgKGNvbmZsaWN0KSB3ZSBjYW4gcHJpb3JpdGl6ZSB0aGUgY2xvc2VzdCBzbmFwLlxuXHRcdFx0XHRcdFx0XHRvbkludGVycnVwdDogKCkgPT4gc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSkgJiYgb25JbnRlcnJ1cHQgJiYgb25JbnRlcnJ1cHQoc2VsZiksXG5cdFx0XHRcdFx0XHRcdG9uQ29tcGxldGU6ICgpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRsYXN0U25hcCA9IHNlbGYuc2Nyb2xsKCk7XG5cdFx0XHRcdFx0XHRcdFx0c25hcDEgPSBzbmFwMiA9IGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUgPyBhbmltYXRpb24udG90YWxQcm9ncmVzcygpIDogc2VsZi5wcm9ncmVzcztcblx0XHRcdFx0XHRcdFx0XHRvblNuYXBDb21wbGV0ZSAmJiBvblNuYXBDb21wbGV0ZShzZWxmKTtcblx0XHRcdFx0XHRcdFx0XHRvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUoc2VsZik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sIHNjcm9sbCwgY2hhbmdlMSAqIGNoYW5nZSwgZW5kU2Nyb2xsIC0gc2Nyb2xsIC0gY2hhbmdlMSAqIGNoYW5nZSk7XG5cdFx0XHRcdFx0XHRvblN0YXJ0ICYmIG9uU3RhcnQoc2VsZiwgdHdlZW5Uby50d2Vlbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHNlbGYuaXNBY3RpdmUpIHtcblx0XHRcdFx0XHRzbmFwRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSkucGF1c2UoKTtcblx0XHR9XG5cdFx0aWQgJiYgKF9pZHNbaWRdID0gc2VsZik7XG5cdFx0dHJpZ2dlciA9IHNlbGYudHJpZ2dlciA9IF90b0FycmF5KHRyaWdnZXIgfHwgcGluKVswXTtcblx0XHRwaW4gPSBwaW4gPT09IHRydWUgPyB0cmlnZ2VyIDogX3RvQXJyYXkocGluKVswXTtcblx0XHRfaXNTdHJpbmcodG9nZ2xlQ2xhc3MpICYmICh0b2dnbGVDbGFzcyA9IHt0YXJnZXRzOiB0cmlnZ2VyLCBjbGFzc05hbWU6IHRvZ2dsZUNsYXNzfSk7XG5cdFx0aWYgKHBpbikge1xuXHRcdFx0KHBpblNwYWNpbmcgPT09IGZhbHNlIHx8IHBpblNwYWNpbmcgPT09IF9tYXJnaW4pIHx8IChwaW5TcGFjaW5nID0gIXBpblNwYWNpbmcgJiYgX2dldENvbXB1dGVkU3R5bGUocGluLnBhcmVudE5vZGUpLmRpc3BsYXkgPT09IFwiZmxleFwiID8gZmFsc2UgOiBfcGFkZGluZyk7IC8vIGlmIHRoZSBwYXJlbnQgaXMgZGlzcGxheTogZmxleCwgZG9uJ3QgYXBwbHkgcGluU3BhY2luZyBieSBkZWZhdWx0LlxuXHRcdFx0c2VsZi5waW4gPSBwaW47XG5cdFx0XHR2YXJzLmZvcmNlM0QgIT09IGZhbHNlICYmIGdzYXAuc2V0KHBpbiwge2ZvcmNlM0Q6IHRydWV9KTtcblx0XHRcdHBpbkNhY2hlID0gZ3NhcC5jb3JlLmdldENhY2hlKHBpbik7XG5cdFx0XHRpZiAoIXBpbkNhY2hlLnNwYWNlcikgeyAvLyByZWNvcmQgdGhlIHNwYWNlciBhbmQgcGluT3JpZ2luYWxTdGF0ZSBvbiB0aGUgY2FjaGUgaW4gY2FzZSBzb21lb25lIHRyaWVzIHBpbm5pbmcgdGhlIHNhbWUgZWxlbWVudCB3aXRoIE1VTFRJUExFIFNjcm9sbFRyaWdnZXJzIC0gd2UgZG9uJ3Qgd2FudCB0byBoYXZlIG11bHRpcGxlIHNwYWNlcnMgb3IgcmVjb3JkIHRoZSBcIm9yaWdpbmFsXCIgcGluIHN0YXRlIGFmdGVyIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWZmZWN0ZWQgYnkgYW5vdGhlciBTY3JvbGxUcmlnZ2VyLlxuXHRcdFx0XHRwaW5DYWNoZS5zcGFjZXIgPSBzcGFjZXIgPSBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0XHRcdHNwYWNlci5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInBpbi1zcGFjZXJcIiArIChpZCA/IFwiIHBpbi1zcGFjZXItXCIgKyBpZCA6IFwiXCIpKTtcblx0XHRcdFx0cGluQ2FjaGUucGluU3RhdGUgPSBwaW5PcmlnaW5hbFN0YXRlID0gX2dldFN0YXRlKHBpbik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwaW5PcmlnaW5hbFN0YXRlID0gcGluQ2FjaGUucGluU3RhdGU7XG5cdFx0XHR9XG5cdFx0XHRzZWxmLnNwYWNlciA9IHNwYWNlciA9IHBpbkNhY2hlLnNwYWNlcjtcblx0XHRcdGNzID0gX2dldENvbXB1dGVkU3R5bGUocGluKTtcblx0XHRcdHNwYWNpbmdTdGFydCA9IGNzW3BpblNwYWNpbmcgKyBkaXJlY3Rpb24ub3MyXTtcblx0XHRcdHBpbkdldHRlciA9IGdzYXAuZ2V0UHJvcGVydHkocGluKTtcblx0XHRcdHBpblNldHRlciA9IGdzYXAucXVpY2tTZXR0ZXIocGluLCBkaXJlY3Rpb24uYSwgX3B4KTtcblx0XHRcdC8vIHBpbi5maXJzdENoaWxkICYmICFfbWF4U2Nyb2xsKHBpbiwgZGlyZWN0aW9uKSAmJiAocGluLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIik7IC8vIHByb3RlY3RzIGZyb20gY29sbGFwc2luZyBtYXJnaW5zLCBidXQgY2FuIGhhdmUgdW5pbnRlbmRlZCBjb25zZXF1ZW5jZXMgYXMgZGVtb25zdHJhdGVkIGhlcmU6IGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuLzFlNDJjN2E3M2JmYTQwOWQyY2YxZTE4NGU3YTQyNDhkIHNvIGl0IHdhcyByZW1vdmVkIGluIGZhdm9yIG9mIGp1c3QgdGVsbGluZyBwZW9wbGUgdG8gc2V0IHVwIHRoZWlyIENTUyB0byBhdm9pZCB0aGUgY29sbGFwc2luZyBtYXJnaW5zIChvdmVyZmxvdzogaGlkZGVuIHwgYXV0byBpcyBqdXN0IG9uZSBvcHRpb24uIEFub3RoZXIgaXMgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHRyYW5zcGFyZW50KS5cblx0XHRcdF9zd2FwUGluSW4ocGluLCBzcGFjZXIsIGNzKTtcblx0XHRcdHBpblN0YXRlID0gX2dldFN0YXRlKHBpbik7XG5cdFx0fVxuXHRcdGlmIChtYXJrZXJzKSB7XG5cdFx0XHRtYXJrZXJWYXJzID0gX2lzT2JqZWN0KG1hcmtlcnMpID8gX3NldERlZmF1bHRzKG1hcmtlcnMsIF9tYXJrZXJEZWZhdWx0cykgOiBfbWFya2VyRGVmYXVsdHM7XG5cdFx0XHRtYXJrZXJTdGFydFRyaWdnZXIgPSBfY3JlYXRlTWFya2VyKFwic2Nyb2xsZXItc3RhcnRcIiwgaWQsIHNjcm9sbGVyLCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIDApO1xuXHRcdFx0bWFya2VyRW5kVHJpZ2dlciA9IF9jcmVhdGVNYXJrZXIoXCJzY3JvbGxlci1lbmRcIiwgaWQsIHNjcm9sbGVyLCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIDAsIG1hcmtlclN0YXJ0VHJpZ2dlcik7XG5cdFx0XHRvZmZzZXQgPSBtYXJrZXJTdGFydFRyaWdnZXJbXCJvZmZzZXRcIiArIGRpcmVjdGlvbi5vcC5kMl07XG5cdFx0XHRtYXJrZXJTdGFydCA9IF9jcmVhdGVNYXJrZXIoXCJzdGFydFwiLCBpZCwgc2Nyb2xsZXIsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgb2Zmc2V0KTtcblx0XHRcdG1hcmtlckVuZCA9X2NyZWF0ZU1hcmtlcihcImVuZFwiLCBpZCwgc2Nyb2xsZXIsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgb2Zmc2V0KTtcblx0XHRcdGlmICghdXNlRml4ZWRQb3NpdGlvbiAmJiAhKF9wcm94aWVzLmxlbmd0aCAmJiBfZ2V0UHJveHlQcm9wKHNjcm9sbGVyLCBcImZpeGVkTWFya2Vyc1wiKSA9PT0gdHJ1ZSkpIHtcblx0XHRcdFx0X21ha2VQb3NpdGlvbmFibGUoaXNWaWV3cG9ydCA/IF9ib2R5IDogc2Nyb2xsZXIpO1xuXHRcdFx0XHRnc2FwLnNldChbbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXSwge2ZvcmNlM0Q6IHRydWV9KTtcblx0XHRcdFx0bWFya2VyU3RhcnRTZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKG1hcmtlclN0YXJ0VHJpZ2dlciwgZGlyZWN0aW9uLmEsIF9weCk7XG5cdFx0XHRcdG1hcmtlckVuZFNldHRlciA9IGdzYXAucXVpY2tTZXR0ZXIobWFya2VyRW5kVHJpZ2dlciwgZGlyZWN0aW9uLmEsIF9weCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VsZi5yZXZlcnQgPSByZXZlcnQgPT4ge1xuXHRcdFx0bGV0IHIgPSByZXZlcnQgIT09IGZhbHNlIHx8ICFzZWxmLmVuYWJsZWQsXG5cdFx0XHRcdHByZXZSZWZyZXNoaW5nID0gX3JlZnJlc2hpbmc7XG5cdFx0XHRpZiAociAhPT0gc2VsZi5pc1JldmVydGVkKSB7XG5cdFx0XHRcdGlmIChyKSB7XG5cdFx0XHRcdFx0c2VsZi5zY3JvbGwucmVjIHx8IChzZWxmLnNjcm9sbC5yZWMgPSBzZWxmLnNjcm9sbCgpKTtcblx0XHRcdFx0XHRwcmV2U2Nyb2xsID0gTWF0aC5tYXgoc2VsZi5zY3JvbGwoKSwgc2VsZi5zY3JvbGwucmVjIHx8IDApOyAvLyByZWNvcmQgdGhlIHNjcm9sbCBzbyB3ZSBjYW4gcmV2ZXJ0IGxhdGVyIChyZXBvc2l0aW9uaW5nL3Bpbm5pbmcgdGhpbmdzIGNhbiBhZmZlY3Qgc2Nyb2xsIHBvc2l0aW9uKS4gSW4gdGhlIHN0YXRpYyByZWZyZXNoKCkgbWV0aG9kLCB3ZSBmaXJzdCByZWNvcmQgYWxsIHRoZSBzY3JvbGwgcG9zaXRpb25zIGFzIGEgcmVmZXJlbmNlLlxuXHRcdFx0XHRcdHByZXZQcm9ncmVzcyA9IHNlbGYucHJvZ3Jlc3M7XG5cdFx0XHRcdFx0cHJldkFuaW1Qcm9ncmVzcyA9IGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucHJvZ3Jlc3MoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtYXJrZXJTdGFydCAmJiBbbWFya2VyU3RhcnQsIG1hcmtlckVuZCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXS5mb3JFYWNoKG0gPT4gbS5zdHlsZS5kaXNwbGF5ID0gciA/IFwibm9uZVwiIDogXCJibG9ja1wiKTtcblx0XHRcdFx0ciAmJiAoX3JlZnJlc2hpbmcgPSAxKTtcblx0XHRcdFx0c2VsZi51cGRhdGUocik7IC8vIG1ha2Ugc3VyZSB0aGUgcGluIGlzIGJhY2sgaW4gaXRzIG9yaWdpbmFsIHBvc2l0aW9uIHNvIHRoYXQgYWxsIHRoZSBtZWFzdXJlbWVudHMgYXJlIGNvcnJlY3QuXG5cdFx0XHRcdF9yZWZyZXNoaW5nID0gcHJldlJlZnJlc2hpbmc7XG5cdFx0XHRcdHBpbiAmJiAociA/IF9zd2FwUGluT3V0KHBpbiwgc3BhY2VyLCBwaW5PcmlnaW5hbFN0YXRlKSA6ICghcGluUmVwYXJlbnQgfHwgIXNlbGYuaXNBY3RpdmUpICYmIF9zd2FwUGluSW4ocGluLCBzcGFjZXIsIF9nZXRDb21wdXRlZFN0eWxlKHBpbiksIHNwYWNlclN0YXRlKSk7XG5cdFx0XHRcdHNlbGYuaXNSZXZlcnRlZCA9IHI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHRzZWxmLnJlZnJlc2ggPSAoc29mdCwgZm9yY2UpID0+IHtcblx0XHRcdGlmICgoX3JlZnJlc2hpbmcgfHwgIXNlbGYuZW5hYmxlZCkgJiYgIWZvcmNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmIChwaW4gJiYgc29mdCAmJiBfbGFzdFNjcm9sbFRpbWUpIHtcblx0XHRcdFx0X2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwic2Nyb2xsRW5kXCIsIF9zb2Z0UmVmcmVzaCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0X3JlZnJlc2hpbmcgPSAxO1xuXHRcdFx0c2NydWJUd2VlbiAmJiBzY3J1YlR3ZWVuLnBhdXNlKCk7XG5cdFx0XHRpbnZhbGlkYXRlT25SZWZyZXNoICYmIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucHJvZ3Jlc3MoMCkuaW52YWxpZGF0ZSgpO1xuXHRcdFx0c2VsZi5pc1JldmVydGVkIHx8IHNlbGYucmV2ZXJ0KCk7XG5cdFx0XHRsZXQgc2l6ZSA9IGdldFNjcm9sbGVyU2l6ZSgpLFxuXHRcdFx0XHRzY3JvbGxlckJvdW5kcyA9IGdldFNjcm9sbGVyT2Zmc2V0cygpLFxuXHRcdFx0XHRtYXggPSBfbWF4U2Nyb2xsKHNjcm9sbGVyLCBkaXJlY3Rpb24pLFxuXHRcdFx0XHRvZmZzZXQgPSAwLFxuXHRcdFx0XHRvdGhlclBpbk9mZnNldCA9IDAsXG5cdFx0XHRcdHBhcnNlZEVuZCA9IHZhcnMuZW5kLFxuXHRcdFx0XHRwYXJzZWRFbmRUcmlnZ2VyID0gdmFycy5lbmRUcmlnZ2VyIHx8IHRyaWdnZXIsXG5cdFx0XHRcdHBhcnNlZFN0YXJ0ID0gdmFycy5zdGFydCB8fCAodmFycy5zdGFydCA9PT0gMCB8fCAhdHJpZ2dlciA/IDAgOiAocGluID8gXCIwIDBcIiA6IFwiMCAxMDAlXCIpKSxcblx0XHRcdFx0cGlubmVkQ29udGFpbmVyID0gdmFycy5waW5uZWRDb250YWluZXIgJiYgX3RvQXJyYXkodmFycy5waW5uZWRDb250YWluZXIpWzBdLFxuXHRcdFx0XHR0cmlnZ2VySW5kZXggPSAodHJpZ2dlciAmJiBNYXRoLm1heCgwLCBfdHJpZ2dlcnMuaW5kZXhPZihzZWxmKSkpIHx8IDAsXG5cdFx0XHRcdGkgPSB0cmlnZ2VySW5kZXgsXG5cdFx0XHRcdGNzLCBib3VuZHMsIHNjcm9sbCwgaXNWZXJ0aWNhbCwgb3ZlcnJpZGUsIGN1clRyaWdnZXIsIGN1clBpbiwgb3Bwb3NpdGVTY3JvbGwsIGluaXR0ZWQsIHJldmVydGVkUGlucztcblx0XHRcdHdoaWxlIChpLS0pIHsgLy8gdXNlciBtaWdodCB0cnkgdG8gcGluIHRoZSBzYW1lIGVsZW1lbnQgbW9yZSB0aGFuIG9uY2UsIHNvIHdlIG11c3QgZmluZCBhbnkgcHJpb3IgdHJpZ2dlcnMgd2l0aCB0aGUgc2FtZSBwaW4sIHJldmVydCB0aGVtLCBhbmQgZGV0ZXJtaW5lIGhvdyBsb25nIHRoZXkncmUgcGlubmluZyBzbyB0aGF0IHdlIGNhbiBvZmZzZXQgdGhpbmdzIGFwcHJvcHJpYXRlbHkuIE1ha2Ugc3VyZSB3ZSByZXZlcnQgZnJvbSBsYXN0IHRvIGZpcnN0IHNvIHRoYXQgdGhpbmdzIFwicmV3aW5kXCIgcHJvcGVybHkuXG5cdFx0XHRcdGN1clRyaWdnZXIgPSBfdHJpZ2dlcnNbaV07XG5cdFx0XHRcdGN1clRyaWdnZXIuZW5kIHx8IGN1clRyaWdnZXIucmVmcmVzaCgwLCAxKSB8fCAoX3JlZnJlc2hpbmcgPSAxKTsgLy8gaWYgaXQncyBhIHRpbWVsaW5lLWJhc2VkIHRyaWdnZXIgdGhhdCBoYXNuJ3QgYmVlbiBmdWxseSBpbml0aWFsaXplZCB5ZXQgYmVjYXVzZSBpdCdzIHdhaXRpbmcgZm9yIDEgdGljaywganVzdCBmb3JjZSB0aGUgcmVmcmVzaCgpIGhlcmUsIG90aGVyd2lzZSBpZiBpdCBjb250YWlucyBhIHBpbiB0aGF0J3Mgc3VwcG9zZWQgdG8gYWZmZWN0IG90aGVyIFNjcm9sbFRyaWdnZXJzIGZ1cnRoZXIgZG93biB0aGUgcGFnZSwgdGhleSB3b24ndCBiZSBhZGp1c3RlZCBwcm9wZXJseS5cblx0XHRcdFx0Y3VyUGluID0gY3VyVHJpZ2dlci5waW47XG5cdFx0XHRcdGlmIChjdXJQaW4gJiYgKGN1clBpbiA9PT0gdHJpZ2dlciB8fCBjdXJQaW4gPT09IHBpbikgJiYgIWN1clRyaWdnZXIuaXNSZXZlcnRlZCkge1xuXHRcdFx0XHRcdHJldmVydGVkUGlucyB8fCAocmV2ZXJ0ZWRQaW5zID0gW10pO1xuXHRcdFx0XHRcdHJldmVydGVkUGlucy51bnNoaWZ0KGN1clRyaWdnZXIpOyAvLyB3ZSdsbCByZXZlcnQgZnJvbSBmaXJzdCB0byBsYXN0IHRvIG1ha2Ugc3VyZSB0aGluZ3MgcmVhY2ggdGhlaXIgZW5kIHN0YXRlIHByb3Blcmx5XG5cdFx0XHRcdFx0Y3VyVHJpZ2dlci5yZXZlcnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c3RhcnQgPSBfcGFyc2VQb3NpdGlvbihwYXJzZWRTdGFydCwgdHJpZ2dlciwgc2l6ZSwgZGlyZWN0aW9uLCBzZWxmLnNjcm9sbCgpLCBtYXJrZXJTdGFydCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBzZWxmLCBzY3JvbGxlckJvdW5kcywgYm9yZGVyV2lkdGgsIHVzZUZpeGVkUG9zaXRpb24sIG1heCkgfHwgKHBpbiA/IC0wLjAwMSA6IDApO1xuXHRcdFx0X2lzRnVuY3Rpb24ocGFyc2VkRW5kKSAmJiAocGFyc2VkRW5kID0gcGFyc2VkRW5kKHNlbGYpKTtcblx0XHRcdGlmIChfaXNTdHJpbmcocGFyc2VkRW5kKSAmJiAhcGFyc2VkRW5kLmluZGV4T2YoXCIrPVwiKSkge1xuXHRcdFx0XHRpZiAofnBhcnNlZEVuZC5pbmRleE9mKFwiIFwiKSkge1xuXHRcdFx0XHRcdHBhcnNlZEVuZCA9IChfaXNTdHJpbmcocGFyc2VkU3RhcnQpID8gcGFyc2VkU3RhcnQuc3BsaXQoXCIgXCIpWzBdIDogXCJcIikgKyBwYXJzZWRFbmQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b2Zmc2V0ID0gX29mZnNldFRvUHgocGFyc2VkRW5kLnN1YnN0cigyKSwgc2l6ZSk7XG5cdFx0XHRcdFx0cGFyc2VkRW5kID0gX2lzU3RyaW5nKHBhcnNlZFN0YXJ0KSA/IHBhcnNlZFN0YXJ0IDogc3RhcnQgKyBvZmZzZXQ7IC8vIF9wYXJzZVBvc2l0aW9uIHdvbid0IGZhY3RvciBpbiB0aGUgb2Zmc2V0IGlmIHRoZSBzdGFydCBpcyBhIG51bWJlciwgc28gZG8gaXQgaGVyZS5cblx0XHRcdFx0XHRwYXJzZWRFbmRUcmlnZ2VyID0gdHJpZ2dlcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZW5kID0gTWF0aC5tYXgoc3RhcnQsIF9wYXJzZVBvc2l0aW9uKHBhcnNlZEVuZCB8fCAocGFyc2VkRW5kVHJpZ2dlciA/IFwiMTAwJSAwXCIgOiBtYXgpLCBwYXJzZWRFbmRUcmlnZ2VyLCBzaXplLCBkaXJlY3Rpb24sIHNlbGYuc2Nyb2xsKCkgKyBvZmZzZXQsIG1hcmtlckVuZCwgbWFya2VyRW5kVHJpZ2dlciwgc2VsZiwgc2Nyb2xsZXJCb3VuZHMsIGJvcmRlcldpZHRoLCB1c2VGaXhlZFBvc2l0aW9uLCBtYXgpKSB8fCAtMC4wMDE7XG5cdFx0XHRjaGFuZ2UgPSAoZW5kIC0gc3RhcnQpIHx8ICgoc3RhcnQgLT0gMC4wMSkgJiYgMC4wMDEpO1xuXG5cdFx0XHRvZmZzZXQgPSAwO1xuXHRcdFx0aSA9IHRyaWdnZXJJbmRleDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0Y3VyVHJpZ2dlciA9IF90cmlnZ2Vyc1tpXTtcblx0XHRcdFx0Y3VyUGluID0gY3VyVHJpZ2dlci5waW47XG5cdFx0XHRcdGlmIChjdXJQaW4gJiYgY3VyVHJpZ2dlci5zdGFydCAtIGN1clRyaWdnZXIuX3BpblB1c2ggPCBzdGFydCkge1xuXHRcdFx0XHRcdGNzID0gY3VyVHJpZ2dlci5lbmQgLSBjdXJUcmlnZ2VyLnN0YXJ0O1xuXHRcdFx0XHRcdChjdXJQaW4gPT09IHRyaWdnZXIgfHwgY3VyUGluID09PSBwaW5uZWRDb250YWluZXIpICYmIChvZmZzZXQgKz0gY3MpO1xuXHRcdFx0XHRcdGN1clBpbiA9PT0gcGluICYmIChvdGhlclBpbk9mZnNldCArPSBjcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHN0YXJ0ICs9IG9mZnNldDtcblx0XHRcdGVuZCArPSBvZmZzZXQ7XG5cdFx0XHRzZWxmLl9waW5QdXNoID0gb3RoZXJQaW5PZmZzZXQ7XG5cdFx0XHRpZiAobWFya2VyU3RhcnQgJiYgb2Zmc2V0KSB7IC8vIG9mZnNldCB0aGUgbWFya2VycyBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0Y3MgPSB7fTtcblx0XHRcdFx0Y3NbZGlyZWN0aW9uLmFdID0gXCIrPVwiICsgb2Zmc2V0O1xuXHRcdFx0XHRwaW5uZWRDb250YWluZXIgJiYgKGNzW2RpcmVjdGlvbi5wXSA9IFwiLT1cIiArIHNlbGYuc2Nyb2xsKCkpO1xuXHRcdFx0XHRnc2FwLnNldChbbWFya2VyU3RhcnQsIG1hcmtlckVuZF0sIGNzKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHBpbikge1xuXHRcdFx0XHRjcyA9IF9nZXRDb21wdXRlZFN0eWxlKHBpbik7XG5cdFx0XHRcdGlzVmVydGljYWwgPSBkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbDtcblx0XHRcdFx0c2Nyb2xsID0gc2VsZi5zY3JvbGwoKTsgLy8gcmVjYWxjdWxhdGUgYmVjYXVzZSB0aGUgdHJpZ2dlcnMgY2FuIGFmZmVjdCB0aGUgc2Nyb2xsXG5cdFx0XHRcdHBpblN0YXJ0ID0gcGFyc2VGbG9hdChwaW5HZXR0ZXIoZGlyZWN0aW9uLmEpKSArIG90aGVyUGluT2Zmc2V0O1xuXHRcdFx0XHQhbWF4ICYmIGVuZCA+IDEgJiYgKChpc1ZpZXdwb3J0ID8gX2JvZHkgOiBzY3JvbGxlcikuc3R5bGVbXCJvdmVyZmxvdy1cIiArIGRpcmVjdGlvbi5hXSA9IFwic2Nyb2xsXCIpOyAvLyBtYWtlcyBzdXJlIHRoZSBzY3JvbGxlciBoYXMgYSBzY3JvbGxiYXIsIG90aGVyd2lzZSBpZiBzb21ldGhpbmcgaGFzIHdpZHRoOiAxMDAlLCBmb3IgZXhhbXBsZSwgaXQgd291bGQgYmUgdG9vIGJpZyAoZXhjbHVkZSB0aGUgc2Nyb2xsYmFyKS4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjUxODItc2Nyb2xsdHJpZ2dlci13aWR0aC1vZi1wYWdlLWluY3JlYXNlLXdoZXJlLW1hcmtlcnMtYXJlLXNldC10by1mYWxzZS9cblx0XHRcdFx0X3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MpO1xuXHRcdFx0XHRwaW5TdGF0ZSA9IF9nZXRTdGF0ZShwaW4pO1xuXHRcdFx0XHQvLyB0cmFuc2Zvcm1zIHdpbGwgaW50ZXJmZXJlIHdpdGggdGhlIHRvcC9sZWZ0L3JpZ2h0L2JvdHRvbSBwbGFjZW1lbnQsIHNvIHJlbW92ZSB0aGVtIHRlbXBvcmFyaWx5LiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBmYWN0b3JzIGluIHRyYW5zZm9ybXMuXG5cdFx0XHRcdGJvdW5kcyA9IF9nZXRCb3VuZHMocGluLCB0cnVlKTtcblx0XHRcdFx0b3Bwb3NpdGVTY3JvbGwgPSB1c2VGaXhlZFBvc2l0aW9uICYmIF9nZXRTY3JvbGxGdW5jKHNjcm9sbGVyLCBpc1ZlcnRpY2FsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwpKCk7XG5cdFx0XHRcdGlmIChwaW5TcGFjaW5nKSB7XG5cdFx0XHRcdFx0c3BhY2VyU3RhdGUgPSBbcGluU3BhY2luZyArIGRpcmVjdGlvbi5vczIsIGNoYW5nZSArIG90aGVyUGluT2Zmc2V0ICsgX3B4XTtcblx0XHRcdFx0XHRzcGFjZXJTdGF0ZS50ID0gc3BhY2VyO1xuXHRcdFx0XHRcdGkgPSAocGluU3BhY2luZyA9PT0gX3BhZGRpbmcpID8gX2dldFNpemUocGluLCBkaXJlY3Rpb24pICsgY2hhbmdlICsgb3RoZXJQaW5PZmZzZXQgOiAwO1xuXHRcdFx0XHRcdGkgJiYgc3BhY2VyU3RhdGUucHVzaChkaXJlY3Rpb24uZCwgaSArIF9weCk7IC8vIGZvciBib3gtc2l6aW5nOiBib3JkZXItYm94IChtdXN0IGluY2x1ZGUgcGFkZGluZykuXG5cdFx0XHRcdFx0X3NldFN0YXRlKHNwYWNlclN0YXRlKTtcblx0XHRcdFx0XHR1c2VGaXhlZFBvc2l0aW9uICYmIHNlbGYuc2Nyb2xsKHByZXZTY3JvbGwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh1c2VGaXhlZFBvc2l0aW9uKSB7XG5cdFx0XHRcdFx0b3ZlcnJpZGUgPSB7XG5cdFx0XHRcdFx0XHR0b3A6IChib3VuZHMudG9wICsgKGlzVmVydGljYWwgPyBzY3JvbGwgLSBzdGFydCA6IG9wcG9zaXRlU2Nyb2xsKSkgKyBfcHgsXG5cdFx0XHRcdFx0XHRsZWZ0OiAoYm91bmRzLmxlZnQgKyAoaXNWZXJ0aWNhbCA/IG9wcG9zaXRlU2Nyb2xsIDogc2Nyb2xsIC0gc3RhcnQpKSArIF9weCxcblx0XHRcdFx0XHRcdGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogXCJmaXhlZFwiXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRvdmVycmlkZVtfd2lkdGhdID0gb3ZlcnJpZGVbXCJtYXhcIiArIF9XaWR0aF0gPSBNYXRoLmNlaWwoYm91bmRzLndpZHRoKSArIF9weDtcblx0XHRcdFx0XHRvdmVycmlkZVtfaGVpZ2h0XSA9IG92ZXJyaWRlW1wibWF4XCIgKyBfSGVpZ2h0XSA9IE1hdGguY2VpbChib3VuZHMuaGVpZ2h0KSArIF9weDtcblx0XHRcdFx0XHRvdmVycmlkZVtfbWFyZ2luXSA9IG92ZXJyaWRlW19tYXJnaW4gKyBfVG9wXSA9IG92ZXJyaWRlW19tYXJnaW4gKyBfUmlnaHRdID0gb3ZlcnJpZGVbX21hcmdpbiArIF9Cb3R0b21dID0gb3ZlcnJpZGVbX21hcmdpbiArIF9MZWZ0XSA9IFwiMFwiO1xuXHRcdFx0XHRcdG92ZXJyaWRlW19wYWRkaW5nXSA9IGNzW19wYWRkaW5nXTtcblx0XHRcdFx0XHRvdmVycmlkZVtfcGFkZGluZyArIF9Ub3BdID0gY3NbX3BhZGRpbmcgKyBfVG9wXTtcblx0XHRcdFx0XHRvdmVycmlkZVtfcGFkZGluZyArIF9SaWdodF0gPSBjc1tfcGFkZGluZyArIF9SaWdodF07XG5cdFx0XHRcdFx0b3ZlcnJpZGVbX3BhZGRpbmcgKyBfQm90dG9tXSA9IGNzW19wYWRkaW5nICsgX0JvdHRvbV07XG5cdFx0XHRcdFx0b3ZlcnJpZGVbX3BhZGRpbmcgKyBfTGVmdF0gPSBjc1tfcGFkZGluZyArIF9MZWZ0XTtcblx0XHRcdFx0XHRwaW5BY3RpdmVTdGF0ZSA9IF9jb3B5U3RhdGUocGluT3JpZ2luYWxTdGF0ZSwgb3ZlcnJpZGUsIHBpblJlcGFyZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYW5pbWF0aW9uKSB7IC8vIHRoZSBhbmltYXRpb24gbWlnaHQgYmUgYWZmZWN0aW5nIHRoZSB0cmFuc2Zvcm0sIHNvIHdlIG11c3QganVtcCB0byB0aGUgZW5kLCBjaGVjayB0aGUgdmFsdWUsIGFuZCBjb21wZW5zYXRlIGFjY29yZGluZ2x5LiBPdGhlcndpc2UsIHdoZW4gaXQgYmVjb21lcyB1bnBpbm5lZCwgdGhlIHBpblNldHRlcigpIHdpbGwgZ2V0IHNldCB0byBhIHZhbHVlIHRoYXQgZG9lc24ndCBpbmNsdWRlIHdoYXRldmVyIHRoZSBhbmltYXRpb24gZGlkLlxuXHRcdFx0XHRcdGluaXR0ZWQgPSBhbmltYXRpb24uX2luaXR0ZWQ7IC8vIGlmIG5vdCwgd2UgbXVzdCBpbnZhbGlkYXRlKCkgYWZ0ZXIgdGhpcyBzdGVwLCBvdGhlcndpc2UgaXQgY291bGQgbG9jayBpbiBzdGFydGluZyB2YWx1ZXMgcHJlbWF0dXJlbHkuXG5cdFx0XHRcdFx0X3N1cHByZXNzT3ZlcndyaXRlcygxKTtcblx0XHRcdFx0XHRhbmltYXRpb24ucmVuZGVyKGFuaW1hdGlvbi5kdXJhdGlvbigpLCB0cnVlLCB0cnVlKTtcblx0XHRcdFx0XHRwaW5DaGFuZ2UgPSBwaW5HZXR0ZXIoZGlyZWN0aW9uLmEpIC0gcGluU3RhcnQgKyBjaGFuZ2UgKyBvdGhlclBpbk9mZnNldDtcblx0XHRcdFx0XHRjaGFuZ2UgIT09IHBpbkNoYW5nZSAmJiBwaW5BY3RpdmVTdGF0ZS5zcGxpY2UocGluQWN0aXZlU3RhdGUubGVuZ3RoIC0gMiwgMik7IC8vIHRyYW5zZm9ybSBpcyB0aGUgbGFzdCBwcm9wZXJ0eS92YWx1ZSBzZXQgaW4gdGhlIHN0YXRlIEFycmF5LiBTaW5jZSB0aGUgYW5pbWF0aW9uIGlzIGNvbnRyb2xsaW5nIHRoYXQsIHdlIHNob3VsZCBvbWl0IGl0LlxuXHRcdFx0XHRcdGFuaW1hdGlvbi5yZW5kZXIoMCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0aW5pdHRlZCB8fCBhbmltYXRpb24uaW52YWxpZGF0ZSgpO1xuXHRcdFx0XHRcdF9zdXBwcmVzc092ZXJ3cml0ZXMoMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGluQ2hhbmdlID0gY2hhbmdlXG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodHJpZ2dlciAmJiBzZWxmLnNjcm9sbCgpKSB7IC8vIGl0IG1heSBiZSBJTlNJREUgYSBwaW5uZWQgZWxlbWVudCwgc28gd2FsayB1cCB0aGUgdHJlZSBhbmQgbG9vayBmb3IgYW55IGVsZW1lbnRzIHdpdGggX3Bpbk9mZnNldCB0byBjb21wZW5zYXRlIGJlY2F1c2UgYW55dGhpbmcgd2l0aCBwaW5TcGFjaW5nIHRoYXQncyBhbHJlYWR5IHNjcm9sbGVkIHdvdWxkIHRocm93IG9mZiB0aGUgbWVhc3VyZW1lbnRzIGluIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cdFx0XHRcdGJvdW5kcyA9IHRyaWdnZXIucGFyZW50Tm9kZTtcblx0XHRcdFx0d2hpbGUgKGJvdW5kcyAmJiBib3VuZHMgIT09IF9ib2R5KSB7XG5cdFx0XHRcdFx0aWYgKGJvdW5kcy5fcGluT2Zmc2V0KSB7XG5cdFx0XHRcdFx0XHRzdGFydCAtPSBib3VuZHMuX3Bpbk9mZnNldDtcblx0XHRcdFx0XHRcdGVuZCAtPSBib3VuZHMuX3Bpbk9mZnNldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ym91bmRzID0gYm91bmRzLnBhcmVudE5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldmVydGVkUGlucyAmJiByZXZlcnRlZFBpbnMuZm9yRWFjaCh0ID0+IHQucmV2ZXJ0KGZhbHNlKSk7XG5cdFx0XHRzZWxmLnN0YXJ0ID0gc3RhcnQ7XG5cdFx0XHRzZWxmLmVuZCA9IGVuZDtcblx0XHRcdHNjcm9sbDEgPSBzY3JvbGwyID0gc2VsZi5zY3JvbGwoKTsgLy8gcmVzZXQgdmVsb2NpdHlcblx0XHRcdHNjcm9sbDEgPCBwcmV2U2Nyb2xsICYmIHNlbGYuc2Nyb2xsKHByZXZTY3JvbGwpO1xuXHRcdFx0c2VsZi5yZXZlcnQoZmFsc2UpO1xuXHRcdFx0X3JlZnJlc2hpbmcgPSAwO1xuXHRcdFx0YW5pbWF0aW9uICYmIGlzVG9nZ2xlICYmIGFuaW1hdGlvbi5faW5pdHRlZCAmJiBhbmltYXRpb24ucHJvZ3Jlc3MoKSAhPT0gcHJldkFuaW1Qcm9ncmVzcyAmJiBhbmltYXRpb24ucHJvZ3Jlc3MocHJldkFuaW1Qcm9ncmVzcywgdHJ1ZSkucmVuZGVyKGFuaW1hdGlvbi50aW1lKCksIHRydWUsIHRydWUpOyAvLyBtdXN0IGZvcmNlIGEgcmUtcmVuZGVyIGJlY2F1c2UgaWYgc2F2ZVN0eWxlcygpIHdhcyB1c2VkIG9uIHRoZSB0YXJnZXQocyksIHRoZSBzdHlsZXMgY291bGQgaGF2ZSBiZWVuIHdpcGVkIG91dCBkdXJpbmcgdGhlIHJlZnJlc2goKS5cblx0XHRcdGlmIChwcmV2UHJvZ3Jlc3MgIT09IHNlbGYucHJvZ3Jlc3MpIHsgLy8gZW5zdXJlcyB0aGF0IHRoZSBkaXJlY3Rpb24gaXMgc2V0IHByb3Blcmx5ICh3aGVuIHJlZnJlc2hpbmcsIHByb2dyZXNzIGlzIHNldCBiYWNrIHRvIDAgaW5pdGlhbGx5LCB0aGVuIGJhY2sgYWdhaW4gdG8gd2hlcmV2ZXIgaXQgbmVlZHMgdG8gYmUpIGFuZCB0aGF0IGNhbGxiYWNrcyBhcmUgdHJpZ2dlcmVkLlxuXHRcdFx0XHRzY3J1YlR3ZWVuICYmIGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKHByZXZQcm9ncmVzcywgdHJ1ZSk7IC8vIHRvIGF2b2lkIGlzc3VlcyB3aGVyZSBhbmltYXRpb24gY2FsbGJhY2tzIGxpa2Ugb25TdGFydCBhcmVuJ3QgdHJpZ2dlcmVkLlxuXHRcdFx0XHRzZWxmLnByb2dyZXNzID0gcHJldlByb2dyZXNzO1xuXHRcdFx0XHRzZWxmLnVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0cGluICYmIHBpblNwYWNpbmcgJiYgKHNwYWNlci5fcGluT2Zmc2V0ID0gTWF0aC5yb3VuZChzZWxmLnByb2dyZXNzICogcGluQ2hhbmdlKSk7XG5cdFx0XHRvblJlZnJlc2ggJiYgb25SZWZyZXNoKHNlbGYpO1xuXHRcdH07XG5cblx0XHRzZWxmLmdldFZlbG9jaXR5ID0gKCkgPT4gKChzZWxmLnNjcm9sbCgpIC0gc2Nyb2xsMikgLyAoX2dldFRpbWUoKSAtIF90aW1lMikgKiAxMDAwKSB8fCAwO1xuXG5cdFx0c2VsZi51cGRhdGUgPSAocmVzZXQsIHJlY29yZFZlbG9jaXR5KSA9PiB7XG5cdFx0XHRsZXQgc2Nyb2xsID0gc2VsZi5zY3JvbGwoKSxcblx0XHRcdFx0cCA9IHJlc2V0ID8gMCA6IChzY3JvbGwgLSBzdGFydCkgLyBjaGFuZ2UsXG5cdFx0XHRcdGNsaXBwZWQgPSBwIDwgMCA/IDAgOiBwID4gMSA/IDEgOiBwIHx8IDAsXG5cdFx0XHRcdHByZXZQcm9ncmVzcyA9IHNlbGYucHJvZ3Jlc3MsXG5cdFx0XHRcdGlzQWN0aXZlLCB3YXNBY3RpdmUsIHRvZ2dsZVN0YXRlLCBhY3Rpb24sIHN0YXRlQ2hhbmdlZCwgdG9nZ2xlZDtcblx0XHRcdGlmIChyZWNvcmRWZWxvY2l0eSkge1xuXHRcdFx0XHRzY3JvbGwyID0gc2Nyb2xsMTtcblx0XHRcdFx0c2Nyb2xsMSA9IHNjcm9sbDtcblx0XHRcdFx0aWYgKHNuYXApIHtcblx0XHRcdFx0XHRzbmFwMiA9IHNuYXAxO1xuXHRcdFx0XHRcdHNuYXAxID0gYW5pbWF0aW9uICYmICFpc1RvZ2dsZSA/IGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKCkgOiBjbGlwcGVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBhbnRpY2lwYXRlIHRoZSBwaW5uaW5nIGEgZmV3IHRpY2tzIGFoZWFkIG9mIHRpbWUgYmFzZWQgb24gdmVsb2NpdHkgdG8gYXZvaWQgYSB2aXN1YWwgZ2xpdGNoIGR1ZSB0byB0aGUgZmFjdCB0aGF0IG1vc3QgYnJvd3NlcnMgZG8gc2Nyb2xsaW5nIG9uIGEgc2VwYXJhdGUgdGhyZWFkIChub3Qgc3luY2VkIHdpdGggcmVxdWVzdEFuaW1hdGlvbkZyYW1lKS5cblx0XHRcdChhbnRpY2lwYXRlUGluICYmICFjbGlwcGVkICYmIHBpbiAmJiAhX3JlZnJlc2hpbmcgJiYgIV9zdGFydHVwICYmIF9sYXN0U2Nyb2xsVGltZSAmJiBzdGFydCA8IHNjcm9sbCArICgoc2Nyb2xsIC0gc2Nyb2xsMikgLyAoX2dldFRpbWUoKSAtIF90aW1lMikpICogYW50aWNpcGF0ZVBpbikgJiYgKGNsaXBwZWQgPSAwLjAwMDEpO1xuXHRcdFx0aWYgKGNsaXBwZWQgIT09IHByZXZQcm9ncmVzcyAmJiBzZWxmLmVuYWJsZWQpIHtcblx0XHRcdFx0aXNBY3RpdmUgPSBzZWxmLmlzQWN0aXZlID0gISFjbGlwcGVkICYmIGNsaXBwZWQgPCAxO1xuXHRcdFx0XHR3YXNBY3RpdmUgPSAhIXByZXZQcm9ncmVzcyAmJiBwcmV2UHJvZ3Jlc3MgPCAxO1xuXHRcdFx0XHR0b2dnbGVkID0gaXNBY3RpdmUgIT09IHdhc0FjdGl2ZTtcblx0XHRcdFx0c3RhdGVDaGFuZ2VkID0gdG9nZ2xlZCB8fCAhIWNsaXBwZWQgIT09ICEhcHJldlByb2dyZXNzOyAvLyBjb3VsZCBnbyBmcm9tIHN0YXJ0IGFsbCB0aGUgd2F5IHRvIGVuZCwgdGh1cyBpdCBkaWRuJ3QgdG9nZ2xlIGJ1dCBpdCBkaWQgY2hhbmdlIHN0YXRlIGluIGEgc2Vuc2UgKG1heSBuZWVkIHRvIGZpcmUgYSBjYWxsYmFjaylcblx0XHRcdFx0c2VsZi5kaXJlY3Rpb24gPSBjbGlwcGVkID4gcHJldlByb2dyZXNzID8gMSA6IC0xO1xuXHRcdFx0XHRzZWxmLnByb2dyZXNzID0gY2xpcHBlZDtcblx0XHRcdFx0aWYgKCFpc1RvZ2dsZSkge1xuXHRcdFx0XHRcdGlmIChzY3J1YlR3ZWVuICYmICFfcmVmcmVzaGluZyAmJiAhX3N0YXJ0dXApIHtcblx0XHRcdFx0XHRcdHNjcnViVHdlZW4udmFycy50b3RhbFByb2dyZXNzID0gY2xpcHBlZDtcblx0XHRcdFx0XHRcdHNjcnViVHdlZW4uaW52YWxpZGF0ZSgpLnJlc3RhcnQoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGFuaW1hdGlvbikge1xuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLnRvdGFsUHJvZ3Jlc3MoY2xpcHBlZCwgISFfcmVmcmVzaGluZyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwaW4pIHtcblx0XHRcdFx0XHRyZXNldCAmJiBwaW5TcGFjaW5nICYmIChzcGFjZXIuc3R5bGVbcGluU3BhY2luZyArIGRpcmVjdGlvbi5vczJdID0gc3BhY2luZ1N0YXJ0KTtcblx0XHRcdFx0XHRpZiAoIXVzZUZpeGVkUG9zaXRpb24pIHtcblx0XHRcdFx0XHRcdHBpblNldHRlcihwaW5TdGFydCArIHBpbkNoYW5nZSAqIGNsaXBwZWQpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoc3RhdGVDaGFuZ2VkKSB7XG5cdFx0XHRcdFx0XHRhY3Rpb24gPSAhcmVzZXQgJiYgY2xpcHBlZCA+IHByZXZQcm9ncmVzcyAmJiBlbmQgKyAxID4gc2Nyb2xsICYmIHNjcm9sbCArIDEgPj0gX21heFNjcm9sbChzY3JvbGxlciwgZGlyZWN0aW9uKTsgLy8gaWYgaXQncyBhdCB0aGUgVkVSWSBlbmQgb2YgdGhlIHBhZ2UsIGRvbid0IHN3aXRjaCBhd2F5IGZyb20gcG9zaXRpb246IGZpeGVkIGJlY2F1c2UgaXQncyBwb2ludGxlc3MgYW5kIGl0IGNvdWxkIGNhdXNlIGEgYnJpZWYgZmxhc2ggd2hlbiB0aGUgdXNlciBzY3JvbGxzIGJhY2sgdXAgKHdoZW4gaXQgZ2V0cyBwaW5uZWQgYWdhaW4pXG5cdFx0XHRcdFx0XHRpZiAocGluUmVwYXJlbnQpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFyZXNldCAmJiAoaXNBY3RpdmUgfHwgYWN0aW9uKSkge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBib3VuZHMgPSBfZ2V0Qm91bmRzKHBpbiwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgPSBzY3JvbGwgLSBzdGFydDtcblx0XHRcdFx0XHRcdFx0XHRfcmVwYXJlbnQocGluLCBfYm9keSwgKGJvdW5kcy50b3AgKyAoZGlyZWN0aW9uID09PSBfdmVydGljYWwgPyBvZmZzZXQgOiAwKSkgKyBfcHgsIChib3VuZHMubGVmdCArIChkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbCA/IDAgOiBvZmZzZXQpKSArIF9weCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0X3JlcGFyZW50KHBpbiwgc3BhY2VyKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0X3NldFN0YXRlKGlzQWN0aXZlIHx8IGFjdGlvbiA/IHBpbkFjdGl2ZVN0YXRlIDogcGluU3RhdGUpO1xuXHRcdFx0XHRcdFx0KHBpbkNoYW5nZSAhPT0gY2hhbmdlICYmIGNsaXBwZWQgPCAxICYmIGlzQWN0aXZlKSB8fCBwaW5TZXR0ZXIocGluU3RhcnQgKyAoY2xpcHBlZCA9PT0gMSAmJiAhYWN0aW9uID8gcGluQ2hhbmdlIDogMCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzbmFwICYmICF0d2VlblRvLnR3ZWVuICYmICFfcmVmcmVzaGluZyAmJiAhX3N0YXJ0dXAgJiYgc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG5cdFx0XHRcdHRvZ2dsZUNsYXNzICYmICh0b2dnbGVkIHx8IChvbmNlICYmIGNsaXBwZWQgJiYgKGNsaXBwZWQgPCAxIHx8ICFfbGltaXRDYWxsYmFja3MpKSkgJiYgX3RvQXJyYXkodG9nZ2xlQ2xhc3MudGFyZ2V0cykuZm9yRWFjaChlbCA9PiBlbC5jbGFzc0xpc3RbaXNBY3RpdmUgfHwgb25jZSA/IFwiYWRkXCIgOiBcInJlbW92ZVwiXSh0b2dnbGVDbGFzcy5jbGFzc05hbWUpKTsgLy8gY2xhc3NlcyBjb3VsZCBhZmZlY3QgcG9zaXRpb25pbmcsIHNvIGRvIGl0IGV2ZW4gaWYgcmVzZXQgb3IgcmVmcmVzaGluZyBpcyB0cnVlLlxuXHRcdFx0XHRvblVwZGF0ZSAmJiAhaXNUb2dnbGUgJiYgIXJlc2V0ICYmIG9uVXBkYXRlKHNlbGYpO1xuXHRcdFx0XHRpZiAoc3RhdGVDaGFuZ2VkICYmICFfcmVmcmVzaGluZykge1xuXHRcdFx0XHRcdHRvZ2dsZVN0YXRlID0gY2xpcHBlZCAmJiAhcHJldlByb2dyZXNzID8gMCA6IGNsaXBwZWQgPT09IDEgPyAxIDogcHJldlByb2dyZXNzID09PSAxID8gMiA6IDM7IC8vIDAgPSBlbnRlciwgMSA9IGxlYXZlLCAyID0gZW50ZXJCYWNrLCAzID0gbGVhdmVCYWNrICh3ZSBwcmlvcml0aXplIHRoZSBGSVJTVCBlbmNvdW50ZXIsIHRodXMgaWYgeW91IHNjcm9sbCByZWFsbHkgZmFzdCBwYXN0IHRoZSBvbkVudGVyIGFuZCBvbkxlYXZlIGluIG9uZSB0aWNrLCBpdCdkIHByaW9yaXRpemUgb25FbnRlci5cblx0XHRcdFx0XHRpZiAoaXNUb2dnbGUpIHtcblx0XHRcdFx0XHRcdGFjdGlvbiA9ICghdG9nZ2xlZCAmJiB0b2dnbGVBY3Rpb25zW3RvZ2dsZVN0YXRlICsgMV0gIT09IFwibm9uZVwiICYmIHRvZ2dsZUFjdGlvbnNbdG9nZ2xlU3RhdGUgKyAxXSkgfHwgdG9nZ2xlQWN0aW9uc1t0b2dnbGVTdGF0ZV07IC8vIGlmIGl0IGRpZG4ndCB0b2dnbGUsIHRoYXQgbWVhbnMgaXQgc2hvdCByaWdodCBwYXN0IGFuZCBzaW5jZSB3ZSBwcmlvcml0aXplIHRoZSBcImVudGVyXCIgYWN0aW9uLCB3ZSBzaG91bGQgc3dpdGNoIHRvIHRoZSBcImxlYXZlXCIgaW4gdGhpcyBjYXNlIChidXQgb25seSBpZiBvbmUgaXMgZGVmaW5lZClcblx0XHRcdFx0XHRcdGlmIChhbmltYXRpb24gJiYgKGFjdGlvbiA9PT0gXCJjb21wbGV0ZVwiIHx8IGFjdGlvbiA9PT0gXCJyZXNldFwiIHx8IGFjdGlvbiBpbiBhbmltYXRpb24pKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhY3Rpb24gPT09IFwiY29tcGxldGVcIikge1xuXHRcdFx0XHRcdFx0XHRcdGFuaW1hdGlvbi5wYXVzZSgpLnRvdGFsUHJvZ3Jlc3MoMSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoYWN0aW9uID09PSBcInJlc2V0XCIpIHtcblx0XHRcdFx0XHRcdFx0XHRhbmltYXRpb24ucmVzdGFydCh0cnVlKS5wYXVzZSgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJyZXN0YXJ0XCIpIHtcblx0XHRcdFx0XHRcdFx0XHRhbmltYXRpb24ucmVzdGFydCh0cnVlKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRhbmltYXRpb25bYWN0aW9uXSgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRvblVwZGF0ZSAmJiBvblVwZGF0ZShzZWxmKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRvZ2dsZWQgfHwgIV9saW1pdENhbGxiYWNrcykgeyAvLyBvbiBzdGFydHVwLCB0aGUgcGFnZSBjb3VsZCBiZSBzY3JvbGxlZCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBmaXJlIGNhbGxiYWNrcyB0aGF0IGRpZG4ndCB0b2dnbGUuIEZvciBleGFtcGxlIG9uRW50ZXIgc2hvdWxkbid0IGZpcmUgaWYgdGhlIFNjcm9sbFRyaWdnZXIgaXNuJ3QgYWN0dWFsbHkgZW50ZXJlZC5cblx0XHRcdFx0XHRcdG9uVG9nZ2xlICYmIHRvZ2dsZWQgJiYgb25Ub2dnbGUoc2VsZik7XG5cdFx0XHRcdFx0XHRjYWxsYmFja3NbdG9nZ2xlU3RhdGVdICYmIGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0oc2VsZik7XG5cdFx0XHRcdFx0XHRvbmNlICYmIChjbGlwcGVkID09PSAxID8gc2VsZi5raWxsKGZhbHNlLCAxKSA6IChjYWxsYmFja3NbdG9nZ2xlU3RhdGVdID0gMCkpOyAvLyBhIGNhbGxiYWNrIHNob3VsZG4ndCBiZSBjYWxsZWQgYWdhaW4gaWYgb25jZSBpcyB0cnVlLlxuXHRcdFx0XHRcdFx0aWYgKCF0b2dnbGVkKSB7IC8vIGl0J3MgcG9zc2libGUgdG8gZ28gY29tcGxldGVseSBwYXN0LCBsaWtlIGZyb20gYmVmb3JlIHRoZSBzdGFydCB0byBhZnRlciB0aGUgZW5kIChvciB2aWNlLXZlcnNhKSBpbiB3aGljaCBjYXNlIEJPVEggY2FsbGJhY2tzIHNob3VsZCBiZSBmaXJlZCBpbiB0aGF0IG9yZGVyXG5cdFx0XHRcdFx0XHRcdHRvZ2dsZVN0YXRlID0gY2xpcHBlZCA9PT0gMSA/IDEgOiAzO1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFja3NbdG9nZ2xlU3RhdGVdICYmIGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0oc2VsZik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGlzVG9nZ2xlICYmIG9uVXBkYXRlICYmICFfcmVmcmVzaGluZykge1xuXHRcdFx0XHRcdG9uVXBkYXRlKHNlbGYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyB1cGRhdGUgYWJzb2x1dGVseS1wb3NpdGlvbmVkIG1hcmtlcnMgKG9ubHkgaWYgdGhlIHNjcm9sbGVyIGlzbid0IHRoZSB2aWV3cG9ydClcblx0XHRcdGlmIChtYXJrZXJFbmRTZXR0ZXIpIHtcblx0XHRcdFx0bWFya2VyU3RhcnRTZXR0ZXIoc2Nyb2xsICsgKG1hcmtlclN0YXJ0VHJpZ2dlci5faXNGbGlwcGVkID8gMSA6IDApKTtcblx0XHRcdFx0bWFya2VyRW5kU2V0dGVyKHNjcm9sbCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHNlbGYuZW5hYmxlID0gKHJlc2V0LCByZWZyZXNoKSA9PiB7XG5cdFx0XHRpZiAoIXNlbGYuZW5hYmxlZCkge1xuXHRcdFx0XHRzZWxmLmVuYWJsZWQgPSB0cnVlO1xuXHRcdFx0XHRfYWRkTGlzdGVuZXIoc2Nyb2xsZXIsIFwicmVzaXplXCIsIF9vblJlc2l6ZSk7XG5cdFx0XHRcdF9hZGRMaXN0ZW5lcihzY3JvbGxlciwgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTtcblx0XHRcdFx0b25SZWZyZXNoSW5pdCAmJiBfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJyZWZyZXNoSW5pdFwiLCBvblJlZnJlc2hJbml0KTtcblx0XHRcdFx0aWYgKHJlc2V0ICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdHNlbGYucHJvZ3Jlc3MgPSBwcmV2UHJvZ3Jlc3MgPSAwO1xuXHRcdFx0XHRcdHNjcm9sbDEgPSBzY3JvbGwyID0gbGFzdFNuYXAgPSBzZWxmLnNjcm9sbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlZnJlc2ggIT09IGZhbHNlICYmIHNlbGYucmVmcmVzaCgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRzZWxmLmdldFR3ZWVuID0gc25hcCA9PiBzbmFwICYmIHR3ZWVuVG8gPyB0d2VlblRvLnR3ZWVuIDogc2NydWJUd2VlbjtcblxuXHRcdHNlbGYuZGlzYWJsZSA9IChyZXNldCwgYWxsb3dBbmltYXRpb24pID0+IHtcblx0XHRcdGlmIChzZWxmLmVuYWJsZWQpIHtcblx0XHRcdFx0cmVzZXQgIT09IGZhbHNlICYmIHNlbGYucmV2ZXJ0KCk7XG5cdFx0XHRcdHNlbGYuZW5hYmxlZCA9IHNlbGYuaXNBY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0YWxsb3dBbmltYXRpb24gfHwgKHNjcnViVHdlZW4gJiYgc2NydWJUd2Vlbi5wYXVzZSgpKTtcblx0XHRcdFx0cHJldlNjcm9sbCA9IDA7XG5cdFx0XHRcdHBpbkNhY2hlICYmIChwaW5DYWNoZS51bmNhY2hlID0gMSk7XG5cdFx0XHRcdG9uUmVmcmVzaEluaXQgJiYgX3JlbW92ZUxpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwicmVmcmVzaEluaXRcIiwgb25SZWZyZXNoSW5pdCk7XG5cdFx0XHRcdGlmIChzbmFwRGVsYXllZENhbGwpIHtcblx0XHRcdFx0XHRzbmFwRGVsYXllZENhbGwucGF1c2UoKTtcblx0XHRcdFx0XHR0d2VlblRvLnR3ZWVuICYmIHR3ZWVuVG8udHdlZW4ua2lsbCgpICYmICh0d2VlblRvLnR3ZWVuID0gMCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFpc1ZpZXdwb3J0KSB7XG5cdFx0XHRcdFx0bGV0IGkgPSBfdHJpZ2dlcnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRcdGlmIChfdHJpZ2dlcnNbaV0uc2Nyb2xsZXIgPT09IHNjcm9sbGVyICYmIF90cmlnZ2Vyc1tpXSAhPT0gc2VsZikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47IC8vZG9uJ3QgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgaWYgdGhlcmUgYXJlIHN0aWxsIG90aGVyIHRyaWdnZXJzIHJlZmVyZW5jaW5nIGl0LlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfcmVtb3ZlTGlzdGVuZXIoc2Nyb2xsZXIsIFwicmVzaXplXCIsIF9vblJlc2l6ZSk7XG5cdFx0XHRcdFx0X3JlbW92ZUxpc3RlbmVyKHNjcm9sbGVyLCBcInNjcm9sbFwiLCBfb25TY3JvbGwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHNlbGYua2lsbCA9IChyZXZlcnQsIGFsbG93QW5pbWF0aW9uKSA9PiB7XG5cdFx0XHRzZWxmLmRpc2FibGUocmV2ZXJ0LCBhbGxvd0FuaW1hdGlvbik7XG5cdFx0XHRpZCAmJiAoZGVsZXRlIF9pZHNbaWRdKTtcblx0XHRcdGxldCBpID0gX3RyaWdnZXJzLmluZGV4T2Yoc2VsZik7XG5cdFx0XHRfdHJpZ2dlcnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0aSA9PT0gX2kgJiYgX2RpcmVjdGlvbiA+IDAgJiYgX2ktLTsgLy8gaWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHJlZnJlc2goKSBvciB1cGRhdGUoKSwgc3BsaWNpbmcgd291bGQgY2F1c2Ugc2tpcHMgaW4gdGhlIGluZGV4LCBzbyBhZGp1c3QuLi5cblx0XHRcdGlmIChhbmltYXRpb24pIHtcblx0XHRcdFx0YW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIgPSBudWxsO1xuXHRcdFx0XHRyZXZlcnQgJiYgYW5pbWF0aW9uLnJlbmRlcigtMSk7XG5cdFx0XHRcdGFsbG93QW5pbWF0aW9uIHx8IGFuaW1hdGlvbi5raWxsKCk7XG5cdFx0XHR9XG5cdFx0XHRtYXJrZXJTdGFydCAmJiBbbWFya2VyU3RhcnQsIG1hcmtlckVuZCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXS5mb3JFYWNoKG0gPT4gbS5wYXJlbnROb2RlICYmIG0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtKSk7XG5cdFx0XHRpZiAocGluKSB7XG5cdFx0XHRcdHBpbkNhY2hlICYmIChwaW5DYWNoZS51bmNhY2hlID0gMSk7XG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRfdHJpZ2dlcnMuZm9yRWFjaCh0ID0+IHQucGluID09PSBwaW4gJiYgaSsrKTtcblx0XHRcdFx0aSB8fCAocGluQ2FjaGUuc3BhY2VyID0gMCk7IC8vIGlmIHRoZXJlIGFyZW4ndCBhbnkgbW9yZSBTY3JvbGxUcmlnZ2VycyB3aXRoIHRoZSBzYW1lIHBpbiwgcmVtb3ZlIHRoZSBzcGFjZXIsIG90aGVyd2lzZSBpdCBjb3VsZCBiZSBjb250YW1pbmF0ZWQgd2l0aCBvbGQvc3RhbGUgdmFsdWVzIGlmIHRoZSB1c2VyIHJlLWNyZWF0ZXMgYSBTY3JvbGxUcmlnZ2VyIGZvciB0aGUgc2FtZSBlbGVtZW50LlxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRzZWxmLmVuYWJsZShmYWxzZSwgZmFsc2UpO1xuXHRcdCFhbmltYXRpb24gfHwgIWFuaW1hdGlvbi5hZGQgfHwgY2hhbmdlID8gc2VsZi5yZWZyZXNoKCkgOiBnc2FwLmRlbGF5ZWRDYWxsKDAuMDEsICgpID0+IHN0YXJ0IHx8IGVuZCB8fCBzZWxmLnJlZnJlc2goKSkgJiYgKGNoYW5nZSA9IDAuMDEpICYmIChzdGFydCA9IGVuZCA9IDApOyAvLyBpZiB0aGUgYW5pbWF0aW9uIGlzIGEgdGltZWxpbmUsIGl0IG1heSBub3QgaGF2ZSBiZWVuIHBvcHVsYXRlZCB5ZXQsIHNvIGl0IHdvdWxkbid0IHJlbmRlciBhdCB0aGUgcHJvcGVyIHBsYWNlIG9uIHRoZSBmaXJzdCByZWZyZXNoKCksIHRodXMgd2Ugc2hvdWxkIHNjaGVkdWxlIG9uZSBmb3IgdGhlIG5leHQgdGljay4gSWYgXCJjaGFuZ2VcIiBpcyBkZWZpbmVkLCB3ZSBrbm93IGl0IG11c3QgYmUgcmUtZW5hYmxpbmcsIHRodXMgd2UgY2FuIHJlZnJlc2goKSByaWdodCBhd2F5LlxuXHR9XG5cblxuXHRzdGF0aWMgcmVnaXN0ZXIoY29yZSkge1xuXHRcdGlmICghX2NvcmVJbml0dGVkKSB7XG5cdFx0XHRnc2FwID0gY29yZSB8fCBfZ2V0R1NBUCgpO1xuXHRcdFx0aWYgKF93aW5kb3dFeGlzdHMoKSAmJiB3aW5kb3cuZG9jdW1lbnQpIHtcblx0XHRcdFx0X3dpbiA9IHdpbmRvdztcblx0XHRcdFx0X2RvYyA9IGRvY3VtZW50O1xuXHRcdFx0XHRfZG9jRWwgPSBfZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdFx0X2JvZHkgPSBfZG9jLmJvZHk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZ3NhcCkge1xuXHRcdFx0XHRfdG9BcnJheSA9IGdzYXAudXRpbHMudG9BcnJheTtcblx0XHRcdFx0X2NsYW1wID0gZ3NhcC51dGlscy5jbGFtcDtcblx0XHRcdFx0X3N1cHByZXNzT3ZlcndyaXRlcyA9IGdzYXAuY29yZS5zdXBwcmVzc092ZXJ3cml0ZXMgfHwgX3Bhc3NUaHJvdWdoO1xuXHRcdFx0XHRnc2FwLmNvcmUuZ2xvYmFscyhcIlNjcm9sbFRyaWdnZXJcIiwgU2Nyb2xsVHJpZ2dlcik7IC8vIG11c3QgcmVnaXN0ZXIgdGhlIGdsb2JhbCBtYW51YWxseSBiZWNhdXNlIGluIEludGVybmV0IEV4cGxvcmVyLCBmdW5jdGlvbnMgKGNsYXNzZXMpIGRvbid0IGhhdmUgYSBcIm5hbWVcIiBwcm9wZXJ0eS5cblx0XHRcdFx0aWYgKF9ib2R5KSB7XG5cdFx0XHRcdFx0X3JhZiA9IF93aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IChmID0+IHNldFRpbWVvdXQoZiwgMTYpKTtcblx0XHRcdFx0XHRfYWRkTGlzdGVuZXIoX3dpbiwgXCJ3aGVlbFwiLCBfb25TY3JvbGwpO1xuXHRcdFx0XHRcdF9yb290ID0gW193aW4sIF9kb2MsIF9kb2NFbCwgX2JvZHldO1xuXHRcdFx0XHRcdF9hZGRMaXN0ZW5lcihfZG9jLCBcInNjcm9sbFwiLCBfb25TY3JvbGwpOyAvLyBzb21lIGJyb3dzZXJzIChsaWtlIENocm9tZSksIHRoZSB3aW5kb3cgc3RvcHMgZGlzcGF0Y2hpbmcgc2Nyb2xsIGV2ZW50cyBvbiB0aGUgd2luZG93IGlmIHlvdSBzY3JvbGwgcmVhbGx5IGZhc3QsIGJ1dCBpdCdzIGNvbnNpc3RlbnQgb24gdGhlIGRvY3VtZW50IVxuXHRcdFx0XHRcdGxldCBib2R5U3R5bGUgPSBfYm9keS5zdHlsZSxcblx0XHRcdFx0XHRcdGJvcmRlciA9IGJvZHlTdHlsZS5ib3JkZXJUb3AsXG5cdFx0XHRcdFx0XHRib3VuZHM7XG5cdFx0XHRcdFx0Ym9keVN0eWxlLmJvcmRlclRvcCA9IFwiMXB4IHNvbGlkICMwMDBcIjsgLy8gd29ya3MgYXJvdW5kIGFuIGlzc3VlIHdoZXJlIGEgbWFyZ2luIG9mIGEgY2hpbGQgZWxlbWVudCBjb3VsZCB0aHJvdyBvZmYgdGhlIGJvdW5kcyBvZiB0aGUgX2JvZHksIG1ha2luZyBpdCBzZWVtIGxpa2UgdGhlcmUncyBhIG1hcmdpbiB3aGVuIHRoZXJlIGFjdHVhbGx5IGlzbid0LiBUaGUgYm9yZGVyIGVuc3VyZXMgdGhhdCB0aGUgYm91bmRzIGFyZSBhY2N1cmF0ZS5cblx0XHRcdFx0XHRib3VuZHMgPSBfZ2V0Qm91bmRzKF9ib2R5KTtcblx0XHRcdFx0XHRfdmVydGljYWwubSA9IE1hdGgucm91bmQoYm91bmRzLnRvcCArIF92ZXJ0aWNhbC5zYygpKSB8fCAwOyAvLyBhY2NvbW1vZGF0ZSB0aGUgb2Zmc2V0IG9mIHRoZSA8Ym9keT4gY2F1c2VkIGJ5IG1hcmdpbnMgYW5kL29yIHBhZGRpbmdcblx0XHRcdFx0XHRfaG9yaXpvbnRhbC5tID0gTWF0aC5yb3VuZChib3VuZHMubGVmdCArIF9ob3Jpem9udGFsLnNjKCkpIHx8IDA7XG5cdFx0XHRcdFx0Ym9yZGVyID8gKGJvZHlTdHlsZS5ib3JkZXJUb3AgPSBib3JkZXIpIDogYm9keVN0eWxlLnJlbW92ZVByb3BlcnR5KFwiYm9yZGVyLXRvcFwiKTtcblx0XHRcdFx0XHRfc3luY0ludGVydmFsID0gc2V0SW50ZXJ2YWwoX3N5bmMsIDIwMCk7XG5cdFx0XHRcdFx0Z3NhcC5kZWxheWVkQ2FsbCgwLjUsICgpID0+IF9zdGFydHVwID0gMCk7XG5cdFx0XHRcdFx0X2FkZExpc3RlbmVyKF9kb2MsIFwidG91Y2hjYW5jZWxcIiwgX3Bhc3NUaHJvdWdoKTsgLy8gc29tZSBvbGRlciBBbmRyb2lkIGRldmljZXMgaW50ZXJtaXR0ZW50bHkgc3RvcCBkaXNwYXRjaGluZyBcInRvdWNobW92ZVwiIGV2ZW50cyBpZiB3ZSBkb24ndCBsaXN0ZW4gZm9yIFwidG91Y2hjYW5jZWxcIiBvbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRcdFx0X2FkZExpc3RlbmVyKF9ib2R5LCBcInRvdWNoc3RhcnRcIiwgX3Bhc3NUaHJvdWdoKTsgLy93b3JrcyBhcm91bmQgU2FmYXJpIGJ1ZzogaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMTQ1MC1kcmFnZ2FibGUtaW4taWZyYW1lLW9uLW1vYmlsZS1pcy1idWdneS9cblx0XHRcdFx0XHRfbXVsdGlMaXN0ZW5lcihfYWRkTGlzdGVuZXIsIF9kb2MsIFwicG9pbnRlcmRvd24sdG91Y2hzdGFydCxtb3VzZWRvd25cIiwgKCkgPT4gX3BvaW50ZXJJc0Rvd24gPSAxKTtcblx0XHRcdFx0XHRfbXVsdGlMaXN0ZW5lcihfYWRkTGlzdGVuZXIsIF9kb2MsIFwicG9pbnRlcnVwLHRvdWNoZW5kLG1vdXNldXBcIiwgKCkgPT4gX3BvaW50ZXJJc0Rvd24gPSAwKTtcblx0XHRcdFx0XHRfdHJhbnNmb3JtUHJvcCA9IGdzYXAudXRpbHMuY2hlY2tQcmVmaXgoXCJ0cmFuc2Zvcm1cIik7XG5cdFx0XHRcdFx0X3N0YXRlUHJvcHMucHVzaChfdHJhbnNmb3JtUHJvcCk7XG5cdFx0XHRcdFx0X2NvcmVJbml0dGVkID0gX2dldFRpbWUoKTtcblx0XHRcdFx0XHRfcmVzaXplRGVsYXkgPSBnc2FwLmRlbGF5ZWRDYWxsKDAuMiwgX3JlZnJlc2hBbGwpLnBhdXNlKCk7XG5cdFx0XHRcdFx0X2F1dG9SZWZyZXNoID0gW19kb2MsIFwidmlzaWJpbGl0eWNoYW5nZVwiLCAoKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgdyA9IF93aW4uaW5uZXJXaWR0aCxcblx0XHRcdFx0XHRcdFx0aCA9IF93aW4uaW5uZXJIZWlnaHQ7XG5cdFx0XHRcdFx0XHRpZiAoX2RvYy5oaWRkZW4pIHtcblx0XHRcdFx0XHRcdFx0X3ByZXZXaWR0aCA9IHc7XG5cdFx0XHRcdFx0XHRcdF9wcmV2SGVpZ2h0ID0gaDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoX3ByZXZXaWR0aCAhPT0gdyB8fCBfcHJldkhlaWdodCAhPT0gaCkge1xuXHRcdFx0XHRcdFx0XHRfb25SZXNpemUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCBfZG9jLCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgX3JlZnJlc2hBbGwsIF93aW4sIFwibG9hZFwiLCAoKSA9PiBfbGFzdFNjcm9sbFRpbWUgfHwgX3JlZnJlc2hBbGwoKSwgX3dpbiwgXCJyZXNpemVcIiwgX29uUmVzaXplXTtcblx0XHRcdFx0XHRfaXRlcmF0ZUF1dG9SZWZyZXNoKF9hZGRMaXN0ZW5lcik7XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX2NvcmVJbml0dGVkO1xuXHR9XG5cblx0c3RhdGljIGRlZmF1bHRzKGNvbmZpZykge1xuXHRcdGZvciAobGV0IHAgaW4gY29uZmlnKSB7XG5cdFx0XHRfZGVmYXVsdHNbcF0gPSBjb25maWdbcF07XG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIGtpbGwoKSB7XG5cdFx0X2VuYWJsZWQgPSAwO1xuXHRcdF90cmlnZ2Vycy5zbGljZSgwKS5mb3JFYWNoKHRyaWdnZXIgPT4gdHJpZ2dlci5raWxsKDEpKTtcblx0fVxuXG5cdHN0YXRpYyBjb25maWcodmFycykge1xuXHRcdChcImxpbWl0Q2FsbGJhY2tzXCIgaW4gdmFycykgJiYgKF9saW1pdENhbGxiYWNrcyA9ICEhdmFycy5saW1pdENhbGxiYWNrcyk7XG5cdFx0bGV0IG1zID0gdmFycy5zeW5jSW50ZXJ2YWw7XG5cdFx0bXMgJiYgY2xlYXJJbnRlcnZhbChfc3luY0ludGVydmFsKSB8fCAoKF9zeW5jSW50ZXJ2YWwgPSBtcykgJiYgc2V0SW50ZXJ2YWwoX3N5bmMsIG1zKSk7XG5cdFx0aWYgKFwiYXV0b1JlZnJlc2hFdmVudHNcIiBpbiB2YXJzKSB7XG5cdFx0XHRfaXRlcmF0ZUF1dG9SZWZyZXNoKF9yZW1vdmVMaXN0ZW5lcikgfHwgX2l0ZXJhdGVBdXRvUmVmcmVzaChfYWRkTGlzdGVuZXIsIHZhcnMuYXV0b1JlZnJlc2hFdmVudHMgfHwgXCJub25lXCIpO1xuXHRcdFx0X2lnbm9yZVJlc2l6ZSA9ICh2YXJzLmF1dG9SZWZyZXNoRXZlbnRzICsgXCJcIikuaW5kZXhPZihcInJlc2l6ZVwiKSA9PT0gLTE7XG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIHNjcm9sbGVyUHJveHkodGFyZ2V0LCB2YXJzKSB7XG5cdFx0bGV0IHQgPSBfdG9BcnJheSh0YXJnZXQpWzBdLFxuXHRcdFx0aSA9IF9zY3JvbGxlcnMuaW5kZXhPZih0KSxcblx0XHRcdGlzVmlld3BvcnQgPSBfaXNWaWV3cG9ydCh0KTtcblx0XHRpZiAofmkpIHtcblx0XHRcdF9zY3JvbGxlcnMuc3BsaWNlKGksIGlzVmlld3BvcnQgPyA2IDogMik7XG5cdFx0fVxuXHRcdGlzVmlld3BvcnQgPyBfcHJveGllcy51bnNoaWZ0KF93aW4sIHZhcnMsIF9ib2R5LCB2YXJzLCBfZG9jRWwsIHZhcnMpIDogX3Byb3hpZXMudW5zaGlmdCh0LCB2YXJzKTtcblx0fVxuXG5cdHN0YXRpYyBtYXRjaE1lZGlhKHZhcnMpIHsgLy8gX21lZGlhIGlzIHBvcHVsYXRlZCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOiBtZWRpYVF1ZXJ5U3RyaW5nLCBvbk1hdGNoLCBvblVubWF0Y2gsIGlzTWF0Y2hlZC4gU28gaWYgdGhlcmUgYXJlIHR3byBtZWRpYSBxdWVyaWVzLCB0aGUgQXJyYXkgd291bGQgaGF2ZSBhIGxlbmd0aCBvZiA4XG5cdFx0bGV0IG1xLCBwLCBpLCBmdW5jLCByZXN1bHQ7XG5cdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdGkgPSBfbWVkaWEuaW5kZXhPZihwKTtcblx0XHRcdGZ1bmMgPSB2YXJzW3BdO1xuXHRcdFx0X2NyZWF0aW5nTWVkaWEgPSBwO1xuXHRcdFx0aWYgKHAgPT09IFwiYWxsXCIpIHtcblx0XHRcdFx0ZnVuYygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bXEgPSBfd2luLm1hdGNoTWVkaWEocCk7XG5cdFx0XHRcdGlmIChtcSkge1xuXHRcdFx0XHRcdG1xLm1hdGNoZXMgJiYgKHJlc3VsdCA9IGZ1bmMoKSk7XG5cdFx0XHRcdFx0aWYgKH5pKSB7XG5cdFx0XHRcdFx0XHRfbWVkaWFbaSArIDFdID0gX2NvbWJpbmVGdW5jKF9tZWRpYVtpICsgMV0sIGZ1bmMpO1xuXHRcdFx0XHRcdFx0X21lZGlhW2kgKyAyXSA9IF9jb21iaW5lRnVuYyhfbWVkaWFbaSArIDJdLCByZXN1bHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpID0gX21lZGlhLmxlbmd0aDtcblx0XHRcdFx0XHRcdF9tZWRpYS5wdXNoKHAsIGZ1bmMsIHJlc3VsdCk7XG5cdFx0XHRcdFx0XHRtcS5hZGRMaXN0ZW5lciA/IG1xLmFkZExpc3RlbmVyKF9vbk1lZGlhQ2hhbmdlKSA6IG1xLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgX29uTWVkaWFDaGFuZ2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfbWVkaWFbaSArIDNdID0gbXEubWF0Y2hlcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0X2NyZWF0aW5nTWVkaWEgPSAwO1xuXHRcdH1cblx0XHRyZXR1cm4gX21lZGlhO1xuXHR9XG5cblx0c3RhdGljIGNsZWFyTWF0Y2hNZWRpYShxdWVyeSkge1xuXHRcdHF1ZXJ5IHx8IChfbWVkaWEubGVuZ3RoID0gMCk7XG5cdFx0cXVlcnkgPSBfbWVkaWEuaW5kZXhPZihxdWVyeSk7XG5cdFx0cXVlcnkgPj0gMCAmJiBfbWVkaWEuc3BsaWNlKHF1ZXJ5LCA0KTtcblx0fVxuXG59XG5cblNjcm9sbFRyaWdnZXIudmVyc2lvbiA9IFwiMy43LjBcIjtcblNjcm9sbFRyaWdnZXIuc2F2ZVN0eWxlcyA9IHRhcmdldHMgPT4gdGFyZ2V0cyA/IF90b0FycmF5KHRhcmdldHMpLmZvckVhY2godGFyZ2V0ID0+IHsgLy8gc2F2ZWQgc3R5bGVzIGFyZSByZWNvcmRlZCBpbiBhIGNvbnNlY3V0aXZlIGFsdGVybmF0aW5nIEFycmF5LCBsaWtlIFtlbGVtZW50LCBjc3NUZXh0LCB0cmFuc2Zvcm0gYXR0cmlidXRlLCBjYWNoZSwgbWF0Y2hNZWRpYSwgLi4uXVxuXHRpZiAodGFyZ2V0ICYmIHRhcmdldC5zdHlsZSkge1xuXHRcdGxldCBpID0gX3NhdmVkU3R5bGVzLmluZGV4T2YodGFyZ2V0KTtcblx0XHRpID49IDAgJiYgX3NhdmVkU3R5bGVzLnNwbGljZShpLCA1KTtcblx0XHRfc2F2ZWRTdHlsZXMucHVzaCh0YXJnZXQsIHRhcmdldC5zdHlsZS5jc3NUZXh0LCB0YXJnZXQuZ2V0QkJveCAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpLCBnc2FwLmNvcmUuZ2V0Q2FjaGUodGFyZ2V0KSwgX2NyZWF0aW5nTWVkaWEpO1xuXHR9XG59KSA6IF9zYXZlZFN0eWxlcztcblNjcm9sbFRyaWdnZXIucmV2ZXJ0ID0gKHNvZnQsIG1lZGlhKSA9PiBfcmV2ZXJ0QWxsKCFzb2Z0LCBtZWRpYSk7XG5TY3JvbGxUcmlnZ2VyLmNyZWF0ZSA9ICh2YXJzLCBhbmltYXRpb24pID0+IG5ldyBTY3JvbGxUcmlnZ2VyKHZhcnMsIGFuaW1hdGlvbik7XG5TY3JvbGxUcmlnZ2VyLnJlZnJlc2ggPSBzYWZlID0+IHNhZmUgPyBfb25SZXNpemUoKSA6IF9yZWZyZXNoQWxsKHRydWUpO1xuU2Nyb2xsVHJpZ2dlci51cGRhdGUgPSBfdXBkYXRlQWxsO1xuU2Nyb2xsVHJpZ2dlci5tYXhTY3JvbGwgPSAoZWxlbWVudCwgaG9yaXpvbnRhbCkgPT4gX21heFNjcm9sbChlbGVtZW50LCBob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwpO1xuU2Nyb2xsVHJpZ2dlci5nZXRTY3JvbGxGdW5jID0gKGVsZW1lbnQsIGhvcml6b250YWwpID0+IF9nZXRTY3JvbGxGdW5jKF90b0FycmF5KGVsZW1lbnQpWzBdLCBob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwpO1xuU2Nyb2xsVHJpZ2dlci5nZXRCeUlkID0gaWQgPT4gX2lkc1tpZF07XG5TY3JvbGxUcmlnZ2VyLmdldEFsbCA9ICgpID0+IF90cmlnZ2Vycy5zbGljZSgwKTtcblNjcm9sbFRyaWdnZXIuaXNTY3JvbGxpbmcgPSAoKSA9PiAhIV9sYXN0U2Nyb2xsVGltZTtcblNjcm9sbFRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lciA9ICh0eXBlLCBjYWxsYmFjaykgPT4ge1xuXHRsZXQgYSA9IF9saXN0ZW5lcnNbdHlwZV0gfHwgKF9saXN0ZW5lcnNbdHlwZV0gPSBbXSk7XG5cdH5hLmluZGV4T2YoY2FsbGJhY2spIHx8IGEucHVzaChjYWxsYmFjayk7XG59O1xuU2Nyb2xsVHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyID0gKHR5cGUsIGNhbGxiYWNrKSA9PiB7XG5cdGxldCBhID0gX2xpc3RlbmVyc1t0eXBlXSxcblx0XHRpID0gYSAmJiBhLmluZGV4T2YoY2FsbGJhY2spO1xuXHRpID49IDAgJiYgYS5zcGxpY2UoaSwgMSk7XG59O1xuU2Nyb2xsVHJpZ2dlci5iYXRjaCA9ICh0YXJnZXRzLCB2YXJzKSA9PiB7XG5cdGxldCByZXN1bHQgPSBbXSxcblx0XHR2YXJzQ29weSA9IHt9LFxuXHRcdGludGVydmFsID0gdmFycy5pbnRlcnZhbCB8fCAwLjAxNixcblx0XHRiYXRjaE1heCA9IHZhcnMuYmF0Y2hNYXggfHwgMWU5LFxuXHRcdHByb3h5Q2FsbGJhY2sgPSAodHlwZSwgY2FsbGJhY2spID0+IHtcblx0XHRcdGxldCBlbGVtZW50cyA9IFtdLFxuXHRcdFx0XHR0cmlnZ2VycyA9IFtdLFxuXHRcdFx0XHRkZWxheSA9IGdzYXAuZGVsYXllZENhbGwoaW50ZXJ2YWwsICgpID0+IHtjYWxsYmFjayhlbGVtZW50cywgdHJpZ2dlcnMpOyBlbGVtZW50cyA9IFtdOyB0cmlnZ2VycyA9IFtdO30pLnBhdXNlKCk7XG5cdFx0XHRyZXR1cm4gc2VsZiA9PiB7XG5cdFx0XHRcdGVsZW1lbnRzLmxlbmd0aCB8fCBkZWxheS5yZXN0YXJ0KHRydWUpO1xuXHRcdFx0XHRlbGVtZW50cy5wdXNoKHNlbGYudHJpZ2dlcik7XG5cdFx0XHRcdHRyaWdnZXJzLnB1c2goc2VsZik7XG5cdFx0XHRcdGJhdGNoTWF4IDw9IGVsZW1lbnRzLmxlbmd0aCAmJiBkZWxheS5wcm9ncmVzcygxKTtcblx0XHRcdH07XG5cdFx0fSxcblx0XHRwO1xuXHRmb3IgKHAgaW4gdmFycykge1xuXHRcdHZhcnNDb3B5W3BdID0gKHAuc3Vic3RyKDAsIDIpID09PSBcIm9uXCIgJiYgX2lzRnVuY3Rpb24odmFyc1twXSkgJiYgcCAhPT0gXCJvblJlZnJlc2hJbml0XCIpID8gcHJveHlDYWxsYmFjayhwLCB2YXJzW3BdKSA6IHZhcnNbcF07XG5cdH1cblx0aWYgKF9pc0Z1bmN0aW9uKGJhdGNoTWF4KSkge1xuXHRcdGJhdGNoTWF4ID0gYmF0Y2hNYXgoKTtcblx0XHRfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJyZWZyZXNoXCIsICgpID0+IGJhdGNoTWF4ID0gdmFycy5iYXRjaE1heCgpKTtcblx0fVxuXHRfdG9BcnJheSh0YXJnZXRzKS5mb3JFYWNoKHRhcmdldCA9PiB7XG5cdFx0bGV0IGNvbmZpZyA9IHt9O1xuXHRcdGZvciAocCBpbiB2YXJzQ29weSkge1xuXHRcdFx0Y29uZmlnW3BdID0gdmFyc0NvcHlbcF07XG5cdFx0fVxuXHRcdGNvbmZpZy50cmlnZ2VyID0gdGFyZ2V0O1xuXHRcdHJlc3VsdC5wdXNoKFNjcm9sbFRyaWdnZXIuY3JlYXRlKGNvbmZpZykpO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblNjcm9sbFRyaWdnZXIuc29ydCA9IGZ1bmMgPT4gX3RyaWdnZXJzLnNvcnQoZnVuYyB8fCAoKGEsIGIpID0+IChhLnZhcnMucmVmcmVzaFByaW9yaXR5IHx8IDApICogLTFlNiArIGEuc3RhcnQgLSAoYi5zdGFydCArIChiLnZhcnMucmVmcmVzaFByaW9yaXR5IHx8IDApICogLTFlNikpKTtcblxuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpO1xuXG5leHBvcnQgeyBTY3JvbGxUcmlnZ2VyIGFzIGRlZmF1bHQgfTsiLCIvKiFcbiAqIEdTQVAgMy43LjBcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5sZXQgX2NvbmZpZyA9IHtcblx0XHRhdXRvU2xlZXA6IDEyMCxcblx0XHRmb3JjZTNEOiBcImF1dG9cIixcblx0XHRudWxsVGFyZ2V0V2FybjogMSxcblx0XHR1bml0czoge2xpbmVIZWlnaHQ6XCJcIn1cblx0fSxcblx0X2RlZmF1bHRzID0ge1xuXHRcdGR1cmF0aW9uOiAuNSxcblx0XHRvdmVyd3JpdGU6IGZhbHNlLFxuXHRcdGRlbGF5OiAwXG5cdH0sXG5cdF9zdXBwcmVzc092ZXJ3cml0ZXMsXG5cdF9iaWdOdW0gPSAxZTgsXG5cdF90aW55TnVtID0gMSAvIF9iaWdOdW0sXG5cdF8yUEkgPSBNYXRoLlBJICogMixcblx0X0hBTEZfUEkgPSBfMlBJIC8gNCxcblx0X2dzSUQgPSAwLFxuXHRfc3FydCA9IE1hdGguc3FydCxcblx0X2NvcyA9IE1hdGguY29zLFxuXHRfc2luID0gTWF0aC5zaW4sXG5cdF9pc1N0cmluZyA9IHZhbHVlID0+IHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIsXG5cdF9pc0Z1bmN0aW9uID0gdmFsdWUgPT4gdHlwZW9mKHZhbHVlKSA9PT0gXCJmdW5jdGlvblwiLFxuXHRfaXNOdW1iZXIgPSB2YWx1ZSA9PiB0eXBlb2YodmFsdWUpID09PSBcIm51bWJlclwiLFxuXHRfaXNVbmRlZmluZWQgPSB2YWx1ZSA9PiB0eXBlb2YodmFsdWUpID09PSBcInVuZGVmaW5lZFwiLFxuXHRfaXNPYmplY3QgPSB2YWx1ZSA9PiB0eXBlb2YodmFsdWUpID09PSBcIm9iamVjdFwiLFxuXHRfaXNOb3RGYWxzZSA9IHZhbHVlID0+IHZhbHVlICE9PSBmYWxzZSxcblx0X3dpbmRvd0V4aXN0cyA9ICgpID0+IHR5cGVvZih3aW5kb3cpICE9PSBcInVuZGVmaW5lZFwiLFxuXHRfaXNGdW5jT3JTdHJpbmcgPSB2YWx1ZSA9PiBfaXNGdW5jdGlvbih2YWx1ZSkgfHwgX2lzU3RyaW5nKHZhbHVlKSxcblx0X2lzVHlwZWRBcnJheSA9ICh0eXBlb2YgQXJyYXlCdWZmZXIgPT09IFwiZnVuY3Rpb25cIiAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcpIHx8IGZ1bmN0aW9uKCkge30sIC8vIG5vdGU6IElFMTAgaGFzIEFycmF5QnVmZmVyLCBidXQgTk9UIEFycmF5QnVmZmVyLmlzVmlldygpLlxuXHRfaXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG5cdF9zdHJpY3ROdW1FeHAgPSAvKD86LT9cXC4/XFxkfFxcLikrL2dpLCAvL29ubHkgbnVtYmVycyAoaW5jbHVkaW5nIG5lZ2F0aXZlcyBhbmQgZGVjaW1hbHMpIGJ1dCBOT1QgcmVsYXRpdmUgdmFsdWVzLlxuXHRfbnVtRXhwID0gL1stKz0uXSpcXGQrWy5lXFwtK10qXFxkKltlXFwtK10qXFxkKi9nLCAvL2ZpbmRzIGFueSBudW1iZXJzLCBpbmNsdWRpbmcgb25lcyB0aGF0IHN0YXJ0IHdpdGggKz0gb3IgLT0sIG5lZ2F0aXZlIG51bWJlcnMsIGFuZCBvbmVzIGluIHNjaWVudGlmaWMgbm90YXRpb24gbGlrZSAxZS04LlxuXHRfbnVtV2l0aFVuaXRFeHAgPSAvWy0rPS5dKlxcZCtbLmUtXSpcXGQqW2EteiVdKi9nLFxuXHRfY29tcGxleFN0cmluZ051bUV4cCA9IC9bLSs9Ll0qXFxkK1xcLj9cXGQqKD86ZS18ZVxcKyk/XFxkKi9naSwgLy9kdXBsaWNhdGUgc28gdGhhdCB3aGlsZSB3ZSdyZSBsb29waW5nIHRocm91Z2ggbWF0Y2hlcyBmcm9tIGV4ZWMoKSwgaXQgZG9lc24ndCBjb250YW1pbmF0ZSB0aGUgbGFzdEluZGV4IG9mIF9udW1FeHAgd2hpY2ggd2UgdXNlIHRvIHNlYXJjaCBmb3IgY29sb3JzIHRvby5cblx0X3JlbEV4cCA9IC9bKy1dPS0/Wy5cXGRdKy8sXG5cdF9kZWxpbWl0ZWRWYWx1ZUV4cCA9IC9bXiwnXCJcXFtcXF1cXHNdKy9naSwgLy8gcHJldmlvdXNseSAvWyNcXC0rLl0qXFxiW2EtelxcZFxcLT0rJS5dKy9naSBidXQgZGlkbid0IGNhdGNoIHNwZWNpYWwgY2hhcmFjdGVycy5cblx0X3VuaXRFeHAgPSAvW1xcZC4rXFwtPV0rKD86ZVstK11cXGQqKSovaSxcblx0X2dsb2JhbFRpbWVsaW5lLCBfd2luLCBfY29yZUluaXR0ZWQsIF9kb2MsXG5cdF9nbG9iYWxzID0ge30sXG5cdF9pbnN0YWxsU2NvcGUgPSB7fSxcblx0X2NvcmVSZWFkeSxcblx0X2luc3RhbGwgPSBzY29wZSA9PiAoX2luc3RhbGxTY29wZSA9IF9tZXJnZShzY29wZSwgX2dsb2JhbHMpKSAmJiBnc2FwLFxuXHRfbWlzc2luZ1BsdWdpbiA9IChwcm9wZXJ0eSwgdmFsdWUpID0+IGNvbnNvbGUud2FybihcIkludmFsaWQgcHJvcGVydHlcIiwgcHJvcGVydHksIFwic2V0IHRvXCIsIHZhbHVlLCBcIk1pc3NpbmcgcGx1Z2luPyBnc2FwLnJlZ2lzdGVyUGx1Z2luKClcIiksXG5cdF93YXJuID0gKG1lc3NhZ2UsIHN1cHByZXNzKSA9PiAhc3VwcHJlc3MgJiYgY29uc29sZS53YXJuKG1lc3NhZ2UpLFxuXHRfYWRkR2xvYmFsID0gKG5hbWUsIG9iaikgPT4gKG5hbWUgJiYgKF9nbG9iYWxzW25hbWVdID0gb2JqKSAmJiAoX2luc3RhbGxTY29wZSAmJiAoX2luc3RhbGxTY29wZVtuYW1lXSA9IG9iaikpKSB8fCBfZ2xvYmFscyxcblx0X2VtcHR5RnVuYyA9ICgpID0+IDAsXG5cdF9yZXNlcnZlZFByb3BzID0ge30sXG5cdF9sYXp5VHdlZW5zID0gW10sXG5cdF9sYXp5TG9va3VwID0ge30sXG5cdF9sYXN0UmVuZGVyZWRGcmFtZSxcblx0X3BsdWdpbnMgPSB7fSxcblx0X2VmZmVjdHMgPSB7fSxcblx0X25leHRHQ0ZyYW1lID0gMzAsXG5cdF9oYXJuZXNzUGx1Z2lucyA9IFtdLFxuXHRfY2FsbGJhY2tOYW1lcyA9IFwiXCIsXG5cdF9oYXJuZXNzID0gdGFyZ2V0cyA9PiB7XG5cdFx0bGV0IHRhcmdldCA9IHRhcmdldHNbMF0sXG5cdFx0XHRoYXJuZXNzUGx1Z2luLCBpO1xuXHRcdF9pc09iamVjdCh0YXJnZXQpIHx8IF9pc0Z1bmN0aW9uKHRhcmdldCkgfHwgKHRhcmdldHMgPSBbdGFyZ2V0c10pO1xuXHRcdGlmICghKGhhcm5lc3NQbHVnaW4gPSAodGFyZ2V0Ll9nc2FwIHx8IHt9KS5oYXJuZXNzKSkgeyAvLyBmaW5kIHRoZSBmaXJzdCB0YXJnZXQgd2l0aCBhIGhhcm5lc3MuIFdlIGFzc3VtZSB0YXJnZXRzIHBhc3NlZCBpbnRvIGFuIGFuaW1hdGlvbiB3aWxsIGJlIG9mIHNpbWlsYXIgdHlwZSwgbWVhbmluZyB0aGUgc2FtZSBraW5kIG9mIGhhcm5lc3MgY2FuIGJlIHVzZWQgZm9yIHRoZW0gYWxsIChwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pXG5cdFx0XHRpID0gX2hhcm5lc3NQbHVnaW5zLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0gJiYgIV9oYXJuZXNzUGx1Z2luc1tpXS50YXJnZXRUZXN0KHRhcmdldCkpIHtcdH1cblx0XHRcdGhhcm5lc3NQbHVnaW4gPSBfaGFybmVzc1BsdWdpbnNbaV07XG5cdFx0fVxuXHRcdGkgPSB0YXJnZXRzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHQodGFyZ2V0c1tpXSAmJiAodGFyZ2V0c1tpXS5fZ3NhcCB8fCAodGFyZ2V0c1tpXS5fZ3NhcCA9IG5ldyBHU0NhY2hlKHRhcmdldHNbaV0sIGhhcm5lc3NQbHVnaW4pKSkpIHx8IHRhcmdldHMuc3BsaWNlKGksIDEpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0cztcblx0fSxcblx0X2dldENhY2hlID0gdGFyZ2V0ID0+IHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0b0FycmF5KHRhcmdldCkpWzBdLl9nc2FwLFxuXHRfZ2V0UHJvcGVydHkgPSAodGFyZ2V0LCBwcm9wZXJ0eSwgdikgPT4gKHYgPSB0YXJnZXRbcHJvcGVydHldKSAmJiBfaXNGdW5jdGlvbih2KSA/IHRhcmdldFtwcm9wZXJ0eV0oKSA6IChfaXNVbmRlZmluZWQodikgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKHByb3BlcnR5KSkgfHwgdixcblx0X2ZvckVhY2hOYW1lID0gKG5hbWVzLCBmdW5jKSA9PiAoKG5hbWVzID0gbmFtZXMuc3BsaXQoXCIsXCIpKS5mb3JFYWNoKGZ1bmMpKSB8fCBuYW1lcywgLy9zcGxpdCBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIG5hbWVzIGludG8gYW4gYXJyYXksIHRoZW4gcnVuIGEgZm9yRWFjaCgpIGZ1bmN0aW9uIGFuZCByZXR1cm4gdGhlIHNwbGl0IGFycmF5ICh0aGlzIGlzIGp1c3QgYSB3YXkgdG8gY29uc29saWRhdGUvc2hvcnRlbiBzb21lIGNvZGUpLlxuXHRfcm91bmQgPSB2YWx1ZSA9PiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwKSAvIDEwMDAwMCB8fCAwLFxuXHRfYXJyYXlDb250YWluc0FueSA9ICh0b1NlYXJjaCwgdG9GaW5kKSA9PiB7IC8vc2VhcmNoZXMgb25lIGFycmF5IHRvIGZpbmQgbWF0Y2hlcyBmb3IgYW55IG9mIHRoZSBpdGVtcyBpbiB0aGUgdG9GaW5kIGFycmF5LiBBcyBzb29uIGFzIG9uZSBpcyBmb3VuZCwgaXQgcmV0dXJucyB0cnVlLiBJdCBkb2VzIE5PVCByZXR1cm4gYWxsIHRoZSBtYXRjaGVzOyBpdCdzIHNpbXBseSBhIGJvb2xlYW4gc2VhcmNoLlxuXHRcdGxldCBsID0gdG9GaW5kLmxlbmd0aCxcblx0XHRcdGkgPSAwO1xuXHRcdGZvciAoOyB0b1NlYXJjaC5pbmRleE9mKHRvRmluZFtpXSkgPCAwICYmICsraSA8IGw7KSB7IH1cblx0XHRyZXR1cm4gKGkgPCBsKTtcblx0fSxcblx0X2xhenlSZW5kZXIgPSAoKSA9PiB7XG5cdFx0bGV0IGwgPSBfbGF6eVR3ZWVucy5sZW5ndGgsXG5cdFx0XHRhID0gX2xhenlUd2VlbnMuc2xpY2UoMCksXG5cdFx0XHRpLCB0d2Vlbjtcblx0XHRfbGF6eUxvb2t1cCA9IHt9O1xuXHRcdF9sYXp5VHdlZW5zLmxlbmd0aCA9IDA7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dHdlZW4gPSBhW2ldO1xuXHRcdFx0dHdlZW4gJiYgdHdlZW4uX2xhenkgJiYgKHR3ZWVuLnJlbmRlcih0d2Vlbi5fbGF6eVswXSwgdHdlZW4uX2xhenlbMV0sIHRydWUpLl9sYXp5ID0gMCk7XG5cdFx0fVxuXHR9LFxuXHRfbGF6eVNhZmVSZW5kZXIgPSAoYW5pbWF0aW9uLCB0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpID0+IHtcblx0XHRfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTtcblx0XHRhbmltYXRpb24ucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0X2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBzb21lb25lIGNhbGxzIHNlZWsoKSBvciB0aW1lKCkgb3IgcHJvZ3Jlc3MoKSwgdGhleSBleHBlY3QgYW4gaW1tZWRpYXRlIHJlbmRlci5cblx0fSxcblx0X251bWVyaWNJZlBvc3NpYmxlID0gdmFsdWUgPT4ge1xuXHRcdGxldCBuID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cdFx0cmV0dXJuIChuIHx8IG4gPT09IDApICYmICh2YWx1ZSArIFwiXCIpLm1hdGNoKF9kZWxpbWl0ZWRWYWx1ZUV4cCkubGVuZ3RoIDwgMiA/IG4gOiBfaXNTdHJpbmcodmFsdWUpID8gdmFsdWUudHJpbSgpIDogdmFsdWU7XG5cdH0sXG5cdF9wYXNzVGhyb3VnaCA9IHAgPT4gcCxcblx0X3NldERlZmF1bHRzID0gKG9iaiwgZGVmYXVsdHMpID0+IHtcblx0XHRmb3IgKGxldCBwIGluIGRlZmF1bHRzKSB7XG5cdFx0XHQocCBpbiBvYmopIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG5cdFx0fVxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cdF9zZXRLZXlmcmFtZURlZmF1bHRzID0gKG9iaiwgZGVmYXVsdHMpID0+IHtcblx0XHRmb3IgKGxldCBwIGluIGRlZmF1bHRzKSB7XG5cdFx0XHQocCBpbiBvYmopIHx8IHAgPT09IFwiZHVyYXRpb25cIiB8fCBwID09PSBcImVhc2VcIiB8fCAob2JqW3BdID0gZGVmYXVsdHNbcF0pO1xuXHRcdH1cblx0fSxcblx0X21lcmdlID0gKGJhc2UsIHRvTWVyZ2UpID0+IHtcblx0XHRmb3IgKGxldCBwIGluIHRvTWVyZ2UpIHtcblx0XHRcdGJhc2VbcF0gPSB0b01lcmdlW3BdO1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fSxcblx0X21lcmdlRGVlcCA9IChiYXNlLCB0b01lcmdlKSA9PiB7XG5cdFx0Zm9yIChsZXQgcCBpbiB0b01lcmdlKSB7XG5cdFx0XHRwICE9PSBcIl9fcHJvdG9fX1wiICYmIHAgIT09IFwiY29uc3RydWN0b3JcIiAmJiBwICE9PSBcInByb3RvdHlwZVwiICYmIChiYXNlW3BdID0gX2lzT2JqZWN0KHRvTWVyZ2VbcF0pID8gX21lcmdlRGVlcChiYXNlW3BdIHx8IChiYXNlW3BdID0ge30pLCB0b01lcmdlW3BdKSA6IHRvTWVyZ2VbcF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fSxcblx0X2NvcHlFeGNsdWRpbmcgPSAob2JqLCBleGNsdWRpbmcpID0+IHtcblx0XHRsZXQgY29weSA9IHt9LFxuXHRcdFx0cDtcblx0XHRmb3IgKHAgaW4gb2JqKSB7XG5cdFx0XHQocCBpbiBleGNsdWRpbmcpIHx8IChjb3B5W3BdID0gb2JqW3BdKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvcHk7XG5cdH0sXG5cdF9pbmhlcml0RGVmYXVsdHMgPSB2YXJzID0+IHtcblx0XHRsZXQgcGFyZW50ID0gdmFycy5wYXJlbnQgfHwgX2dsb2JhbFRpbWVsaW5lLFxuXHRcdFx0ZnVuYyA9IHZhcnMua2V5ZnJhbWVzID8gX3NldEtleWZyYW1lRGVmYXVsdHMgOiBfc2V0RGVmYXVsdHM7XG5cdFx0aWYgKF9pc05vdEZhbHNlKHZhcnMuaW5oZXJpdCkpIHtcblx0XHRcdHdoaWxlIChwYXJlbnQpIHtcblx0XHRcdFx0ZnVuYyh2YXJzLCBwYXJlbnQudmFycy5kZWZhdWx0cyk7XG5cdFx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnQgfHwgcGFyZW50Ll9kcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHZhcnM7XG5cdH0sXG5cdF9hcnJheXNNYXRjaCA9IChhMSwgYTIpID0+IHtcblx0XHRsZXQgaSA9IGExLmxlbmd0aCxcblx0XHRcdG1hdGNoID0gaSA9PT0gYTIubGVuZ3RoO1xuXHRcdHdoaWxlIChtYXRjaCAmJiBpLS0gJiYgYTFbaV0gPT09IGEyW2ldKSB7IH1cblx0XHRyZXR1cm4gaSA8IDA7XG5cdH0sXG5cdF9hZGRMaW5rZWRMaXN0SXRlbSA9IChwYXJlbnQsIGNoaWxkLCBmaXJzdFByb3AgPSBcIl9maXJzdFwiLCBsYXN0UHJvcCA9IFwiX2xhc3RcIiwgc29ydEJ5KSA9PiB7XG5cdFx0bGV0IHByZXYgPSBwYXJlbnRbbGFzdFByb3BdLFxuXHRcdFx0dDtcblx0XHRpZiAoc29ydEJ5KSB7XG5cdFx0XHR0ID0gY2hpbGRbc29ydEJ5XTtcblx0XHRcdHdoaWxlIChwcmV2ICYmIHByZXZbc29ydEJ5XSA+IHQpIHtcblx0XHRcdFx0cHJldiA9IHByZXYuX3ByZXY7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRjaGlsZC5fbmV4dCA9IHByZXYuX25leHQ7XG5cdFx0XHRwcmV2Ll9uZXh0ID0gY2hpbGQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNoaWxkLl9uZXh0ID0gcGFyZW50W2ZpcnN0UHJvcF07XG5cdFx0XHRwYXJlbnRbZmlyc3RQcm9wXSA9IGNoaWxkO1xuXHRcdH1cblx0XHRpZiAoY2hpbGQuX25leHQpIHtcblx0XHRcdGNoaWxkLl9uZXh0Ll9wcmV2ID0gY2hpbGQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhcmVudFtsYXN0UHJvcF0gPSBjaGlsZDtcblx0XHR9XG5cdFx0Y2hpbGQuX3ByZXYgPSBwcmV2O1xuXHRcdGNoaWxkLnBhcmVudCA9IGNoaWxkLl9kcCA9IHBhcmVudDtcblx0XHRyZXR1cm4gY2hpbGQ7XG5cdH0sXG5cdF9yZW1vdmVMaW5rZWRMaXN0SXRlbSA9IChwYXJlbnQsIGNoaWxkLCBmaXJzdFByb3AgPSBcIl9maXJzdFwiLCBsYXN0UHJvcCA9IFwiX2xhc3RcIikgPT4ge1xuXHRcdGxldCBwcmV2ID0gY2hpbGQuX3ByZXYsXG5cdFx0XHRuZXh0ID0gY2hpbGQuX25leHQ7XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYuX25leHQgPSBuZXh0O1xuXHRcdH0gZWxzZSBpZiAocGFyZW50W2ZpcnN0UHJvcF0gPT09IGNoaWxkKSB7XG5cdFx0XHRwYXJlbnRbZmlyc3RQcm9wXSA9IG5leHQ7XG5cdFx0fVxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0Ll9wcmV2ID0gcHJldjtcblx0XHR9IGVsc2UgaWYgKHBhcmVudFtsYXN0UHJvcF0gPT09IGNoaWxkKSB7XG5cdFx0XHRwYXJlbnRbbGFzdFByb3BdID0gcHJldjtcblx0XHR9XG5cdFx0Y2hpbGQuX25leHQgPSBjaGlsZC5fcHJldiA9IGNoaWxkLnBhcmVudCA9IG51bGw7IC8vIGRvbid0IGRlbGV0ZSB0aGUgX2RwIGp1c3Qgc28gd2UgY2FuIHJldmVydCBpZiBuZWNlc3NhcnkuIEJ1dCBwYXJlbnQgc2hvdWxkIGJlIG51bGwgdG8gaW5kaWNhdGUgdGhlIGl0ZW0gaXNuJ3QgaW4gYSBsaW5rZWQgbGlzdC5cblx0fSxcblx0X3JlbW92ZUZyb21QYXJlbnQgPSAoY2hpbGQsIG9ubHlJZlBhcmVudEhhc0F1dG9SZW1vdmUpID0+IHtcblx0XHRjaGlsZC5wYXJlbnQgJiYgKCFvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlIHx8IGNoaWxkLnBhcmVudC5hdXRvUmVtb3ZlQ2hpbGRyZW4pICYmIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xuXHRcdGNoaWxkLl9hY3QgPSAwO1xuXHR9LFxuXHRfdW5jYWNoZSA9IChhbmltYXRpb24sIGNoaWxkKSA9PiB7XG5cdFx0aWYgKGFuaW1hdGlvbiAmJiAoIWNoaWxkIHx8IGNoaWxkLl9lbmQgPiBhbmltYXRpb24uX2R1ciB8fCBjaGlsZC5fc3RhcnQgPCAwKSkgeyAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IGlmIGEgY2hpbGQgYW5pbWF0aW9uIGlzIHBhc3NlZCBpbiB3ZSBzaG91bGQgb25seSB1bmNhY2hlIGlmIHRoYXQgY2hpbGQgRVhURU5EUyB0aGUgYW5pbWF0aW9uIChpdHMgZW5kIHRpbWUgaXMgYmV5b25kIHRoZSBlbmQpXG5cdFx0XHRsZXQgYSA9IGFuaW1hdGlvbjtcblx0XHRcdHdoaWxlIChhKSB7XG5cdFx0XHRcdGEuX2RpcnR5ID0gMTtcblx0XHRcdFx0YSA9IGEucGFyZW50O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYW5pbWF0aW9uO1xuXHR9LFxuXHRfcmVjYWNoZUFuY2VzdG9ycyA9IGFuaW1hdGlvbiA9PiB7XG5cdFx0bGV0IHBhcmVudCA9IGFuaW1hdGlvbi5wYXJlbnQ7XG5cdFx0d2hpbGUgKHBhcmVudCAmJiBwYXJlbnQucGFyZW50KSB7IC8vc29tZXRpbWVzIHdlIG11c3QgZm9yY2UgYSByZS1zb3J0IG9mIGFsbCBjaGlsZHJlbiBhbmQgdXBkYXRlIHRoZSBkdXJhdGlvbi90b3RhbER1cmF0aW9uIG9mIGFsbCBhbmNlc3RvciB0aW1lbGluZXMgaW1tZWRpYXRlbHkgaW4gY2FzZSwgZm9yIGV4YW1wbGUsIGluIHRoZSBtaWRkbGUgb2YgYSByZW5kZXIgbG9vcCwgb25lIHR3ZWVuIGFsdGVycyBhbm90aGVyIHR3ZWVuJ3MgdGltZVNjYWxlIHdoaWNoIHNob3ZlcyBpdHMgc3RhcnRUaW1lIGJlZm9yZSAwLCBmb3JjaW5nIHRoZSBwYXJlbnQgdGltZWxpbmUgdG8gc2hpZnQgYXJvdW5kIGFuZCBzaGlmdENoaWxkcmVuKCkgd2hpY2ggY291bGQgYWZmZWN0IHRoYXQgbmV4dCB0d2VlbidzIHJlbmRlciAoc3RhcnRUaW1lKS4gRG9lc24ndCBtYXR0ZXIgZm9yIHRoZSByb290IHRpbWVsaW5lIHRob3VnaC5cblx0XHRcdHBhcmVudC5fZGlydHkgPSAxO1xuXHRcdFx0cGFyZW50LnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBhbmltYXRpb247XG5cdH0sXG5cdF9oYXNOb1BhdXNlZEFuY2VzdG9ycyA9IGFuaW1hdGlvbiA9PiAhYW5pbWF0aW9uIHx8IChhbmltYXRpb24uX3RzICYmIF9oYXNOb1BhdXNlZEFuY2VzdG9ycyhhbmltYXRpb24ucGFyZW50KSksXG5cdF9lbGFwc2VkQ3ljbGVEdXJhdGlvbiA9IGFuaW1hdGlvbiA9PiBhbmltYXRpb24uX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZShhbmltYXRpb24uX3RUaW1lLCAoYW5pbWF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uKCkgKyBhbmltYXRpb24uX3JEZWxheSkpICogYW5pbWF0aW9uIDogMCxcblx0Ly8gZmVlZCBpbiB0aGUgdG90YWxUaW1lIGFuZCBjeWNsZUR1cmF0aW9uIGFuZCBpdCdsbCByZXR1cm4gdGhlIGN5Y2xlIChpdGVyYXRpb24gbWludXMgMSkgYW5kIGlmIHRoZSBwbGF5aGVhZCBpcyBleGFjdGx5IGF0IHRoZSB2ZXJ5IEVORCwgaXQgd2lsbCBOT1QgYnVtcCB1cCB0byB0aGUgbmV4dCBjeWNsZS5cblx0X2FuaW1hdGlvbkN5Y2xlID0gKHRUaW1lLCBjeWNsZUR1cmF0aW9uKSA9PiB7XG5cdFx0bGV0IHdob2xlID0gTWF0aC5mbG9vcih0VGltZSAvPSBjeWNsZUR1cmF0aW9uKTtcblx0XHRyZXR1cm4gdFRpbWUgJiYgKHdob2xlID09PSB0VGltZSkgPyB3aG9sZSAtIDEgOiB3aG9sZTtcblx0fSxcblx0X3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUgPSAocGFyZW50VGltZSwgY2hpbGQpID0+IChwYXJlbnRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cyArIChjaGlsZC5fdHMgPj0gMCA/IDAgOiAoY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpKSxcblx0X3NldEVuZCA9IGFuaW1hdGlvbiA9PiAoYW5pbWF0aW9uLl9lbmQgPSBfcm91bmQoYW5pbWF0aW9uLl9zdGFydCArICgoYW5pbWF0aW9uLl90RHVyIC8gTWF0aC5hYnMoYW5pbWF0aW9uLl90cyB8fCBhbmltYXRpb24uX3J0cyB8fCBfdGlueU51bSkpIHx8IDApKSksXG5cdF9hbGlnblBsYXloZWFkID0gKGFuaW1hdGlvbiwgdG90YWxUaW1lKSA9PiB7IC8vIGFkanVzdHMgdGhlIGFuaW1hdGlvbidzIF9zdGFydCBhbmQgX2VuZCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIHRvdGFsVGltZSAob25seSBpZiB0aGUgcGFyZW50J3Mgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSBhbmQgdGhlIGFuaW1hdGlvbiBpc24ndCBwYXVzZWQpLiBJdCBkb2Vzbid0IGRvIGFueSByZW5kZXJpbmcgb3IgZm9yY2luZyB0aGluZ3MgYmFjayBpbnRvIHBhcmVudCB0aW1lbGluZXMsIGV0Yy4gLSB0aGF0J3Mgd2hhdCB0b3RhbFRpbWUoKSBpcyBmb3IuXG5cdFx0bGV0IHBhcmVudCA9IGFuaW1hdGlvbi5fZHA7XG5cdFx0aWYgKHBhcmVudCAmJiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgYW5pbWF0aW9uLl90cykge1xuXHRcdFx0YW5pbWF0aW9uLl9zdGFydCA9IF9yb3VuZChwYXJlbnQuX3RpbWUgLSAoYW5pbWF0aW9uLl90cyA+IDAgPyB0b3RhbFRpbWUgLyBhbmltYXRpb24uX3RzIDogKChhbmltYXRpb24uX2RpcnR5ID8gYW5pbWF0aW9uLnRvdGFsRHVyYXRpb24oKSA6IGFuaW1hdGlvbi5fdER1cikgLSB0b3RhbFRpbWUpIC8gLWFuaW1hdGlvbi5fdHMpKTtcblx0XHRcdF9zZXRFbmQoYW5pbWF0aW9uKTtcblx0XHRcdHBhcmVudC5fZGlydHkgfHwgX3VuY2FjaGUocGFyZW50LCBhbmltYXRpb24pOyAvL2ZvciBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudC4gSWYgdGhlIHBhcmVudCdzIGNhY2hlIGlzIGFscmVhZHkgZGlydHksIGl0IGFscmVhZHkgdG9vayBjYXJlIG9mIG1hcmtpbmcgdGhlIGFuY2VzdG9ycyBhcyBkaXJ0eSB0b28sIHNvIHNraXAgdGhlIGZ1bmN0aW9uIGNhbGwgaGVyZS5cblx0XHR9XG5cdFx0cmV0dXJuIGFuaW1hdGlvbjtcblx0fSxcblx0Lypcblx0X3RvdGFsVGltZVRvVGltZSA9IChjbGFtcGVkVG90YWxUaW1lLCBkdXJhdGlvbiwgcmVwZWF0LCByZXBlYXREZWxheSwgeW95bykgPT4ge1xuXHRcdGxldCBjeWNsZUR1cmF0aW9uID0gZHVyYXRpb24gKyByZXBlYXREZWxheSxcblx0XHRcdHRpbWUgPSBfcm91bmQoY2xhbXBlZFRvdGFsVGltZSAlIGN5Y2xlRHVyYXRpb24pO1xuXHRcdGlmICh0aW1lID4gZHVyYXRpb24pIHtcblx0XHRcdHRpbWUgPSBkdXJhdGlvbjtcblx0XHR9XG5cdFx0cmV0dXJuICh5b3lvICYmICh+fihjbGFtcGVkVG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbikgJiAxKSkgPyBkdXJhdGlvbiAtIHRpbWUgOiB0aW1lO1xuXHR9LFxuXHQqL1xuXHRfcG9zdEFkZENoZWNrcyA9ICh0aW1lbGluZSwgY2hpbGQpID0+IHtcblx0XHRsZXQgdDtcblx0XHRpZiAoY2hpbGQuX3RpbWUgfHwgKGNoaWxkLl9pbml0dGVkICYmICFjaGlsZC5fZHVyKSkgeyAvL2luIGNhc2UsIGZvciBleGFtcGxlLCB0aGUgX3N0YXJ0IGlzIG1vdmVkIG9uIGEgdHdlZW4gdGhhdCBoYXMgYWxyZWFkeSByZW5kZXJlZC4gSW1hZ2luZSBpdCdzIGF0IGl0cyBlbmQgc3RhdGUsIHRoZW4gdGhlIHN0YXJ0VGltZSBpcyBtb3ZlZCBXQVkgbGF0ZXIgKGFmdGVyIHRoZSBlbmQgb2YgdGhpcyB0aW1lbGluZSksIGl0IHNob3VsZCByZW5kZXIgYXQgaXRzIGJlZ2lubmluZy5cblx0XHRcdHQgPSBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSh0aW1lbGluZS5yYXdUaW1lKCksIGNoaWxkKTtcblx0XHRcdGlmICghY2hpbGQuX2R1ciB8fCBfY2xhbXAoMCwgY2hpbGQudG90YWxEdXJhdGlvbigpLCB0KSAtIGNoaWxkLl90VGltZSA+IF90aW55TnVtKSB7XG5cdFx0XHRcdGNoaWxkLnJlbmRlcih0LCB0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly9pZiB0aGUgdGltZWxpbmUgaGFzIGFscmVhZHkgZW5kZWQgYnV0IHRoZSBpbnNlcnRlZCB0d2Vlbi90aW1lbGluZSBleHRlbmRzIHRoZSBkdXJhdGlvbiwgd2Ugc2hvdWxkIGVuYWJsZSB0aGlzIHRpbWVsaW5lIGFnYWluIHNvIHRoYXQgaXQgcmVuZGVycyBwcm9wZXJseS4gV2Ugc2hvdWxkIGFsc28gYWxpZ24gdGhlIHBsYXloZWFkIHdpdGggdGhlIHBhcmVudCB0aW1lbGluZSdzIHdoZW4gYXBwcm9wcmlhdGUuXG5cdFx0aWYgKF91bmNhY2hlKHRpbWVsaW5lLCBjaGlsZCkuX2RwICYmIHRpbWVsaW5lLl9pbml0dGVkICYmIHRpbWVsaW5lLl90aW1lID49IHRpbWVsaW5lLl9kdXIgJiYgdGltZWxpbmUuX3RzKSB7XG5cdFx0XHQvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvcnMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLi4uXG5cdFx0XHRpZiAodGltZWxpbmUuX2R1ciA8IHRpbWVsaW5lLmR1cmF0aW9uKCkpIHtcblx0XHRcdFx0dCA9IHRpbWVsaW5lO1xuXHRcdFx0XHR3aGlsZSAodC5fZHApIHtcblx0XHRcdFx0XHQodC5yYXdUaW1lKCkgPj0gMCkgJiYgdC50b3RhbFRpbWUodC5fdFRpbWUpOyAvL21vdmVzIHRoZSB0aW1lbGluZSAoc2hpZnRzIGl0cyBzdGFydFRpbWUpIGlmIG5lY2Vzc2FyeSwgYW5kIGFsc28gZW5hYmxlcyBpdC4gSWYgaXQncyBjdXJyZW50bHkgemVybywgdGhvdWdoLCBpdCBtYXkgbm90IGJlIHNjaGVkdWxlZCB0byByZW5kZXIgdW50aWwgbGF0ZXIgc28gdGhlcmUncyBubyBuZWVkIHRvIGZvcmNlIGl0IHRvIGFsaWduIHdpdGggdGhlIGN1cnJlbnQgcGxheWhlYWQgcG9zaXRpb24uIE9ubHkgbW92ZSB0byBjYXRjaCB1cCB3aXRoIHRoZSBwbGF5aGVhZC5cblx0XHRcdFx0XHR0ID0gdC5fZHA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRpbWVsaW5lLl96VGltZSA9IC1fdGlueU51bTsgLy8gaGVscHMgZW5zdXJlIHRoYXQgdGhlIG5leHQgcmVuZGVyKCkgd2lsbCBiZSBmb3JjZWQgKGNyb3NzaW5nU3RhcnQgPSB0cnVlIGluIHJlbmRlcigpKSwgZXZlbiBpZiB0aGUgZHVyYXRpb24gaGFzbid0IGNoYW5nZWQgKHdlJ3JlIGFkZGluZyBhIGNoaWxkIHdoaWNoIHdvdWxkIG5lZWQgdG8gZ2V0IHJlbmRlcmVkKS4gRGVmaW5pdGVseSBhbiBlZGdlIGNhc2UuIE5vdGU6IHdlIE1VU1QgZG8gdGhpcyBBRlRFUiB0aGUgbG9vcCBhYm92ZSB3aGVyZSB0aGUgdG90YWxUaW1lKCkgbWlnaHQgdHJpZ2dlciBhIHJlbmRlcigpIGJlY2F1c2UgdGhpcyBfYWRkVG9UaW1lbGluZSgpIG1ldGhvZCBnZXRzIGNhbGxlZCBmcm9tIHRoZSBBbmltYXRpb24gY29uc3RydWN0b3IsIEJFRk9SRSB0d2VlbnMgZXZlbiByZWNvcmQgdGhlaXIgdGFyZ2V0cywgZXRjLiBzbyB3ZSB3b3VsZG4ndCB3YW50IHRoaW5ncyB0byBnZXQgdHJpZ2dlcmVkIGluIHRoZSB3cm9uZyBvcmRlci5cblx0XHR9XG5cdH0sXG5cdF9hZGRUb1RpbWVsaW5lID0gKHRpbWVsaW5lLCBjaGlsZCwgcG9zaXRpb24sIHNraXBDaGVja3MpID0+IHtcblx0XHRjaGlsZC5wYXJlbnQgJiYgX3JlbW92ZUZyb21QYXJlbnQoY2hpbGQpO1xuXHRcdGNoaWxkLl9zdGFydCA9IF9yb3VuZCgoX2lzTnVtYmVyKHBvc2l0aW9uKSA/IHBvc2l0aW9uIDogcG9zaXRpb24gfHwgdGltZWxpbmUgIT09IF9nbG9iYWxUaW1lbGluZSA/IF9wYXJzZVBvc2l0aW9uKHRpbWVsaW5lLCBwb3NpdGlvbiwgY2hpbGQpIDogdGltZWxpbmUuX3RpbWUpICsgY2hpbGQuX2RlbGF5KTtcblx0XHRjaGlsZC5fZW5kID0gX3JvdW5kKGNoaWxkLl9zdGFydCArICgoY2hpbGQudG90YWxEdXJhdGlvbigpIC8gTWF0aC5hYnMoY2hpbGQudGltZVNjYWxlKCkpKSB8fCAwKSk7XG5cdFx0X2FkZExpbmtlZExpc3RJdGVtKHRpbWVsaW5lLCBjaGlsZCwgXCJfZmlyc3RcIiwgXCJfbGFzdFwiLCB0aW1lbGluZS5fc29ydCA/IFwiX3N0YXJ0XCIgOiAwKTtcblx0XHRfaXNGcm9tT3JGcm9tU3RhcnQoY2hpbGQpIHx8ICh0aW1lbGluZS5fcmVjZW50ID0gY2hpbGQpO1xuXHRcdHNraXBDaGVja3MgfHwgX3Bvc3RBZGRDaGVja3ModGltZWxpbmUsIGNoaWxkKTtcblx0XHRyZXR1cm4gdGltZWxpbmU7XG5cdH0sXG5cdF9zY3JvbGxUcmlnZ2VyID0gKGFuaW1hdGlvbiwgdHJpZ2dlcikgPT4gKF9nbG9iYWxzLlNjcm9sbFRyaWdnZXIgfHwgX21pc3NpbmdQbHVnaW4oXCJzY3JvbGxUcmlnZ2VyXCIsIHRyaWdnZXIpKSAmJiBfZ2xvYmFscy5TY3JvbGxUcmlnZ2VyLmNyZWF0ZSh0cmlnZ2VyLCBhbmltYXRpb24pLFxuXHRfYXR0ZW1wdEluaXRUd2VlbiA9ICh0d2VlbiwgdG90YWxUaW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMpID0+IHtcblx0XHRfaW5pdFR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUpO1xuXHRcdGlmICghdHdlZW4uX2luaXR0ZWQpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0XHRpZiAoIWZvcmNlICYmIHR3ZWVuLl9wdCAmJiAoKHR3ZWVuLl9kdXIgJiYgdHdlZW4udmFycy5sYXp5ICE9PSBmYWxzZSkgfHwgKCF0d2Vlbi5fZHVyICYmIHR3ZWVuLnZhcnMubGF6eSkpICYmIF9sYXN0UmVuZGVyZWRGcmFtZSAhPT0gX3RpY2tlci5mcmFtZSkge1xuXHRcdFx0X2xhenlUd2VlbnMucHVzaCh0d2Vlbik7XG5cdFx0XHR0d2Vlbi5fbGF6eSA9IFt0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzXTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0fSxcblx0X3BhcmVudFBsYXloZWFkSXNCZWZvcmVTdGFydCA9ICh7cGFyZW50fSkgPT4gcGFyZW50ICYmIHBhcmVudC5fdHMgJiYgcGFyZW50Ll9pbml0dGVkICYmICFwYXJlbnQuX2xvY2sgJiYgKHBhcmVudC5yYXdUaW1lKCkgPCAwIHx8IF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQocGFyZW50KSksIC8vIGNoZWNrIHBhcmVudCdzIF9sb2NrIGJlY2F1c2Ugd2hlbiBhIHRpbWVsaW5lIHJlcGVhdHMveW95b3MgYW5kIGRvZXMgaXRzIGFydGlmaWNpYWwgd3JhcHBpbmcsIHdlIHNob3VsZG4ndCBmb3JjZSB0aGUgcmF0aW8gYmFjayB0byAwXG5cdF9pc0Zyb21PckZyb21TdGFydCA9ICh7ZGF0YX0pID0+IGRhdGEgPT09IFwiaXNGcm9tU3RhcnRcIiB8fCBkYXRhID09PSBcImlzU3RhcnRcIixcblx0X3JlbmRlclplcm9EdXJhdGlvblR3ZWVuID0gKHR3ZWVuLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkgPT4ge1xuXHRcdGxldCBwcmV2UmF0aW8gPSB0d2Vlbi5yYXRpbyxcblx0XHRcdHJhdGlvID0gdG90YWxUaW1lIDwgMCB8fCAoIXRvdGFsVGltZSAmJiAoKCF0d2Vlbi5fc3RhcnQgJiYgX3BhcmVudFBsYXloZWFkSXNCZWZvcmVTdGFydCh0d2VlbikgJiYgISghdHdlZW4uX2luaXR0ZWQgJiYgX2lzRnJvbU9yRnJvbVN0YXJ0KHR3ZWVuKSkpIHx8ICgodHdlZW4uX3RzIDwgMCB8fCB0d2Vlbi5fZHAuX3RzIDwgMCkgJiYgIV9pc0Zyb21PckZyb21TdGFydCh0d2VlbikpKSkgPyAwIDogMSwgLy8gaWYgdGhlIHR3ZWVuIG9yIGl0cyBwYXJlbnQgaXMgcmV2ZXJzZWQgYW5kIHRoZSB0b3RhbFRpbWUgaXMgMCwgd2Ugc2hvdWxkIGdvIHRvIGEgcmF0aW8gb2YgMC4gRWRnZSBjYXNlOiBpZiBhIGZyb20oKSBvciBmcm9tVG8oKSBzdGFnZ2VyIHR3ZWVuIGlzIHBsYWNlZCBsYXRlciBpbiBhIHRpbWVsaW5lLCB0aGUgXCJzdGFydEF0XCIgemVyby1kdXJhdGlvbiB0d2VlbiBjb3VsZCBpbml0aWFsbHkgcmVuZGVyIGF0IGEgdGltZSB3aGVuIHRoZSBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBpcyB0ZWNobmljYWxseSBCRUZPUkUgd2hlcmUgdGhpcyB0d2VlbiBpcywgc28gbWFrZSBzdXJlIHRoYXQgYW55IFwiZnJvbVwiIGFuZCBcImZyb21Ub1wiIHN0YXJ0QXQgdHdlZW5zIGFyZSByZW5kZXJlZCB0aGUgZmlyc3QgdGltZSBhdCBhIHJhdGlvIG9mIDEuXG5cdFx0XHRyZXBlYXREZWxheSA9IHR3ZWVuLl9yRGVsYXksXG5cdFx0XHR0VGltZSA9IDAsXG5cdFx0XHRwdCwgaXRlcmF0aW9uLCBwcmV2SXRlcmF0aW9uO1xuXHRcdGlmIChyZXBlYXREZWxheSAmJiB0d2Vlbi5fcmVwZWF0KSB7IC8vIGluIGNhc2UgdGhlcmUncyBhIHplcm8tZHVyYXRpb24gdHdlZW4gdGhhdCBoYXMgYSByZXBlYXQgd2l0aCBhIHJlcGVhdERlbGF5XG5cdFx0XHR0VGltZSA9IF9jbGFtcCgwLCB0d2Vlbi5fdER1ciwgdG90YWxUaW1lKTtcblx0XHRcdGl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0VGltZSwgcmVwZWF0RGVsYXkpO1xuXHRcdFx0cHJldkl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0d2Vlbi5fdFRpbWUsIHJlcGVhdERlbGF5KTtcblx0XHRcdHR3ZWVuLl95b3lvICYmIChpdGVyYXRpb24gJiAxKSAmJiAocmF0aW8gPSAxIC0gcmF0aW8pO1xuXHRcdFx0aWYgKGl0ZXJhdGlvbiAhPT0gcHJldkl0ZXJhdGlvbikge1xuXHRcdFx0XHRwcmV2UmF0aW8gPSAxIC0gcmF0aW87XG5cdFx0XHRcdHR3ZWVuLnZhcnMucmVwZWF0UmVmcmVzaCAmJiB0d2Vlbi5faW5pdHRlZCAmJiB0d2Vlbi5pbnZhbGlkYXRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChyYXRpbyAhPT0gcHJldlJhdGlvIHx8IGZvcmNlIHx8IHR3ZWVuLl96VGltZSA9PT0gX3RpbnlOdW0gfHwgKCF0b3RhbFRpbWUgJiYgdHdlZW4uX3pUaW1lKSkge1xuXHRcdFx0aWYgKCF0d2Vlbi5faW5pdHRlZCAmJiBfYXR0ZW1wdEluaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMpKSB7IC8vIGlmIHdlIHJlbmRlciB0aGUgdmVyeSBiZWdpbm5pbmcgKHRpbWUgPT0gMCkgb2YgYSBmcm9tVG8oKSwgd2UgbXVzdCBmb3JjZSB0aGUgcmVuZGVyIChub3JtYWwgdHdlZW5zIHdvdWxkbid0IG5lZWQgdG8gcmVuZGVyIGF0IGEgdGltZSBvZiAwIHdoZW4gdGhlIHByZXZUaW1lIHdhcyBhbHNvIDApLiBUaGlzIGlzIGFsc28gbWFuZGF0b3J5IHRvIG1ha2Ugc3VyZSBvdmVyd3JpdGluZyBraWNrcyBpbiBpbW1lZGlhdGVseS5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0cHJldkl0ZXJhdGlvbiA9IHR3ZWVuLl96VGltZTtcblx0XHRcdHR3ZWVuLl96VGltZSA9IHRvdGFsVGltZSB8fCAoc3VwcHJlc3NFdmVudHMgPyBfdGlueU51bSA6IDApOyAvLyB3aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC5cblx0XHRcdHN1cHByZXNzRXZlbnRzIHx8IChzdXBwcmVzc0V2ZW50cyA9IHRvdGFsVGltZSAmJiAhcHJldkl0ZXJhdGlvbik7IC8vIGlmIGl0IHdhcyByZW5kZXJlZCBwcmV2aW91c2x5IGF0IGV4YWN0bHkgMCAoX3pUaW1lKSBhbmQgbm93IHRoZSBwbGF5aGVhZCBpcyBtb3ZpbmcgYXdheSwgRE9OJ1QgZmlyZSBjYWxsYmFja3Mgb3RoZXJ3aXNlIHRoZXknbGwgc2VlbSBsaWtlIGR1cGxpY2F0ZXMuXG5cdFx0XHR0d2Vlbi5yYXRpbyA9IHJhdGlvO1xuXHRcdFx0dHdlZW4uX2Zyb20gJiYgKHJhdGlvID0gMSAtIHJhdGlvKTtcblx0XHRcdHR3ZWVuLl90aW1lID0gMDtcblx0XHRcdHR3ZWVuLl90VGltZSA9IHRUaW1lO1xuXHRcdFx0cHQgPSB0d2Vlbi5fcHQ7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0cHQucihyYXRpbywgcHQuZCk7XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0XHR0d2Vlbi5fc3RhcnRBdCAmJiB0b3RhbFRpbWUgPCAwICYmIHR3ZWVuLl9zdGFydEF0LnJlbmRlcih0b3RhbFRpbWUsIHRydWUsIHRydWUpO1xuXHRcdFx0dHdlZW4uX29uVXBkYXRlICYmICFzdXBwcmVzc0V2ZW50cyAmJiBfY2FsbGJhY2sodHdlZW4sIFwib25VcGRhdGVcIik7XG5cdFx0XHR0VGltZSAmJiB0d2Vlbi5fcmVwZWF0ICYmICFzdXBwcmVzc0V2ZW50cyAmJiB0d2Vlbi5wYXJlbnQgJiYgX2NhbGxiYWNrKHR3ZWVuLCBcIm9uUmVwZWF0XCIpO1xuXHRcdFx0aWYgKCh0b3RhbFRpbWUgPj0gdHdlZW4uX3REdXIgfHwgdG90YWxUaW1lIDwgMCkgJiYgdHdlZW4ucmF0aW8gPT09IHJhdGlvKSB7XG5cdFx0XHRcdHJhdGlvICYmIF9yZW1vdmVGcm9tUGFyZW50KHR3ZWVuLCAxKTtcblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRcdF9jYWxsYmFjayh0d2VlbiwgKHJhdGlvID8gXCJvbkNvbXBsZXRlXCIgOiBcIm9uUmV2ZXJzZUNvbXBsZXRlXCIpLCB0cnVlKTtcblx0XHRcdFx0XHR0d2Vlbi5fcHJvbSAmJiB0d2Vlbi5fcHJvbSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICghdHdlZW4uX3pUaW1lKSB7XG5cdFx0XHR0d2Vlbi5felRpbWUgPSB0b3RhbFRpbWU7XG5cdFx0fVxuXHR9LFxuXHRfZmluZE5leHRQYXVzZVR3ZWVuID0gKGFuaW1hdGlvbiwgcHJldlRpbWUsIHRpbWUpID0+IHtcblx0XHRsZXQgY2hpbGQ7XG5cdFx0aWYgKHRpbWUgPiBwcmV2VGltZSkge1xuXHRcdFx0Y2hpbGQgPSBhbmltYXRpb24uX2ZpcnN0O1xuXHRcdFx0d2hpbGUgKGNoaWxkICYmIGNoaWxkLl9zdGFydCA8PSB0aW1lKSB7XG5cdFx0XHRcdGlmICghY2hpbGQuX2R1ciAmJiBjaGlsZC5kYXRhID09PSBcImlzUGF1c2VcIiAmJiBjaGlsZC5fc3RhcnQgPiBwcmV2VGltZSkge1xuXHRcdFx0XHRcdHJldHVybiBjaGlsZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGlsZCA9IGNoaWxkLl9uZXh0O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaGlsZCA9IGFuaW1hdGlvbi5fbGFzdDtcblx0XHRcdHdoaWxlIChjaGlsZCAmJiBjaGlsZC5fc3RhcnQgPj0gdGltZSkge1xuXHRcdFx0XHRpZiAoIWNoaWxkLl9kdXIgJiYgY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgY2hpbGQuX3N0YXJ0IDwgcHJldlRpbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hpbGQgPSBjaGlsZC5fcHJldjtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdF9zZXREdXJhdGlvbiA9IChhbmltYXRpb24sIGR1cmF0aW9uLCBza2lwVW5jYWNoZSwgbGVhdmVQbGF5aGVhZCkgPT4ge1xuXHRcdGxldCByZXBlYXQgPSBhbmltYXRpb24uX3JlcGVhdCxcblx0XHRcdGR1ciA9IF9yb3VuZChkdXJhdGlvbikgfHwgMCxcblx0XHRcdHRvdGFsUHJvZ3Jlc3MgPSBhbmltYXRpb24uX3RUaW1lIC8gYW5pbWF0aW9uLl90RHVyO1xuXHRcdHRvdGFsUHJvZ3Jlc3MgJiYgIWxlYXZlUGxheWhlYWQgJiYgKGFuaW1hdGlvbi5fdGltZSAqPSBkdXIgLyBhbmltYXRpb24uX2R1cik7XG5cdFx0YW5pbWF0aW9uLl9kdXIgPSBkdXI7XG5cdFx0YW5pbWF0aW9uLl90RHVyID0gIXJlcGVhdCA/IGR1ciA6IHJlcGVhdCA8IDAgPyAxZTEwIDogX3JvdW5kKGR1ciAqIChyZXBlYXQgKyAxKSArIChhbmltYXRpb24uX3JEZWxheSAqIHJlcGVhdCkpO1xuXHRcdHRvdGFsUHJvZ3Jlc3MgJiYgIWxlYXZlUGxheWhlYWQgPyBfYWxpZ25QbGF5aGVhZChhbmltYXRpb24sIChhbmltYXRpb24uX3RUaW1lID0gYW5pbWF0aW9uLl90RHVyICogdG90YWxQcm9ncmVzcykpIDogYW5pbWF0aW9uLnBhcmVudCAmJiBfc2V0RW5kKGFuaW1hdGlvbik7XG5cdFx0c2tpcFVuY2FjaGUgfHwgX3VuY2FjaGUoYW5pbWF0aW9uLnBhcmVudCwgYW5pbWF0aW9uKTtcblx0XHRyZXR1cm4gYW5pbWF0aW9uO1xuXHR9LFxuXHRfb25VcGRhdGVUb3RhbER1cmF0aW9uID0gYW5pbWF0aW9uID0+IChhbmltYXRpb24gaW5zdGFuY2VvZiBUaW1lbGluZSkgPyBfdW5jYWNoZShhbmltYXRpb24pIDogX3NldER1cmF0aW9uKGFuaW1hdGlvbiwgYW5pbWF0aW9uLl9kdXIpLFxuXHRfemVyb1Bvc2l0aW9uID0ge19zdGFydDowLCBlbmRUaW1lOl9lbXB0eUZ1bmMsIHRvdGFsRHVyYXRpb246X2VtcHR5RnVuY30sXG5cdF9wYXJzZVBvc2l0aW9uID0gKGFuaW1hdGlvbiwgcG9zaXRpb24sIHBlcmNlbnRBbmltYXRpb24pID0+IHtcblx0XHRsZXQgbGFiZWxzID0gYW5pbWF0aW9uLmxhYmVscyxcblx0XHRcdHJlY2VudCA9IGFuaW1hdGlvbi5fcmVjZW50IHx8IF96ZXJvUG9zaXRpb24sXG5cdFx0XHRjbGlwcGVkRHVyYXRpb24gPSBhbmltYXRpb24uZHVyYXRpb24oKSA+PSBfYmlnTnVtID8gcmVjZW50LmVuZFRpbWUoZmFsc2UpIDogYW5pbWF0aW9uLl9kdXIsIC8vaW4gY2FzZSB0aGVyZSdzIGEgY2hpbGQgdGhhdCBpbmZpbml0ZWx5IHJlcGVhdHMsIHVzZXJzIGFsbW9zdCBuZXZlciBpbnRlbmQgZm9yIHRoZSBpbnNlcnRpb24gcG9pbnQgb2YgYSBuZXcgY2hpbGQgdG8gYmUgYmFzZWQgb24gYSBTVVBFUiBsb25nIHZhbHVlIGxpa2UgdGhhdCBzbyB3ZSBjbGlwIGl0IGFuZCBhc3N1bWUgdGhlIG1vc3QgcmVjZW50bHktYWRkZWQgY2hpbGQncyBlbmRUaW1lIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG5cdFx0XHRpLCBvZmZzZXQsIGlzUGVyY2VudDtcblx0XHRpZiAoX2lzU3RyaW5nKHBvc2l0aW9uKSAmJiAoaXNOYU4ocG9zaXRpb24pIHx8IChwb3NpdGlvbiBpbiBsYWJlbHMpKSkgeyAvL2lmIHRoZSBzdHJpbmcgaXMgYSBudW1iZXIgbGlrZSBcIjFcIiwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBsYWJlbCB3aXRoIHRoYXQgbmFtZSwgb3RoZXJ3aXNlIGludGVycHJldCBpdCBhcyBhIG51bWJlciAoYWJzb2x1dGUgdmFsdWUpLlxuXHRcdFx0b2Zmc2V0ID0gcG9zaXRpb24uY2hhckF0KDApO1xuXHRcdFx0aXNQZXJjZW50ID0gcG9zaXRpb24uc3Vic3RyKC0xKSA9PT0gXCIlXCI7XG5cdFx0XHRpID0gcG9zaXRpb24uaW5kZXhPZihcIj1cIik7XG5cdFx0XHRpZiAob2Zmc2V0ID09PSBcIjxcIiB8fCBvZmZzZXQgPT09IFwiPlwiKSB7XG5cdFx0XHRcdGkgPj0gMCAmJiAocG9zaXRpb24gPSBwb3NpdGlvbi5yZXBsYWNlKC89LywgXCJcIikpO1xuXHRcdFx0XHRyZXR1cm4gKG9mZnNldCA9PT0gXCI8XCIgPyByZWNlbnQuX3N0YXJ0IDogcmVjZW50LmVuZFRpbWUocmVjZW50Ll9yZXBlYXQgPj0gMCkpICsgKHBhcnNlRmxvYXQocG9zaXRpb24uc3Vic3RyKDEpKSB8fCAwKSAqIChpc1BlcmNlbnQgPyAoaSA8IDAgPyByZWNlbnQgOiBwZXJjZW50QW5pbWF0aW9uKS50b3RhbER1cmF0aW9uKCkgLyAxMDAgOiAxKTtcblx0XHRcdH1cblx0XHRcdGlmIChpIDwgMCkge1xuXHRcdFx0XHQocG9zaXRpb24gaW4gbGFiZWxzKSB8fCAobGFiZWxzW3Bvc2l0aW9uXSA9IGNsaXBwZWREdXJhdGlvbik7XG5cdFx0XHRcdHJldHVybiBsYWJlbHNbcG9zaXRpb25dO1xuXHRcdFx0fVxuXHRcdFx0b2Zmc2V0ID0gcGFyc2VGbG9hdChwb3NpdGlvbi5jaGFyQXQoaS0xKSArIHBvc2l0aW9uLnN1YnN0cihpKzEpKTtcblx0XHRcdGlmIChpc1BlcmNlbnQgJiYgcGVyY2VudEFuaW1hdGlvbikge1xuXHRcdFx0XHRvZmZzZXQgPSBvZmZzZXQgLyAxMDAgKiAoX2lzQXJyYXkocGVyY2VudEFuaW1hdGlvbikgPyBwZXJjZW50QW5pbWF0aW9uWzBdIDogcGVyY2VudEFuaW1hdGlvbikudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIChpID4gMSkgPyBfcGFyc2VQb3NpdGlvbihhbmltYXRpb24sIHBvc2l0aW9uLnN1YnN0cigwLCBpLTEpLCBwZXJjZW50QW5pbWF0aW9uKSArIG9mZnNldCA6IGNsaXBwZWREdXJhdGlvbiArIG9mZnNldDtcblx0XHR9XG5cdFx0cmV0dXJuIChwb3NpdGlvbiA9PSBudWxsKSA/IGNsaXBwZWREdXJhdGlvbiA6ICtwb3NpdGlvbjtcblx0fSxcblx0X2NyZWF0ZVR3ZWVuVHlwZSA9ICh0eXBlLCBwYXJhbXMsIHRpbWVsaW5lKSA9PiB7XG5cdFx0bGV0IGlzTGVnYWN5ID0gX2lzTnVtYmVyKHBhcmFtc1sxXSksXG5cdFx0XHR2YXJzSW5kZXggPSAoaXNMZWdhY3kgPyAyIDogMSkgKyAodHlwZSA8IDIgPyAwIDogMSksXG5cdFx0XHR2YXJzID0gcGFyYW1zW3ZhcnNJbmRleF0sXG5cdFx0XHRpclZhcnMsIHBhcmVudDtcblx0XHRpc0xlZ2FjeSAmJiAodmFycy5kdXJhdGlvbiA9IHBhcmFtc1sxXSk7XG5cdFx0dmFycy5wYXJlbnQgPSB0aW1lbGluZTtcblx0XHRpZiAodHlwZSkge1xuXHRcdFx0aXJWYXJzID0gdmFycztcblx0XHRcdHBhcmVudCA9IHRpbWVsaW5lO1xuXHRcdFx0d2hpbGUgKHBhcmVudCAmJiAhKFwiaW1tZWRpYXRlUmVuZGVyXCIgaW4gaXJWYXJzKSkgeyAvLyBpbmhlcml0YW5jZSBoYXNuJ3QgaGFwcGVuZWQgeWV0LCBidXQgc29tZW9uZSBtYXkgaGF2ZSBzZXQgYSBkZWZhdWx0IGluIGFuIGFuY2VzdG9yIHRpbWVsaW5lLiBXZSBjb3VsZCBkbyB2YXJzLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKF9pbmhlcml0RGVmYXVsdHModmFycykuaW1tZWRpYXRlUmVuZGVyKSBidXQgdGhhdCdkIGV4YWN0IGEgc2xpZ2h0IHBlcmZvcm1hbmNlIHBlbmFsdHkgYmVjYXVzZSBfaW5oZXJpdERlZmF1bHRzKCkgYWxzbyBydW5zIGluIHRoZSBUd2VlbiBjb25zdHJ1Y3Rvci4gV2UncmUgcGF5aW5nIGEgc21hbGwga2IgcHJpY2UgaGVyZSB0byBnYWluIHNwZWVkLlxuXHRcdFx0XHRpclZhcnMgPSBwYXJlbnQudmFycy5kZWZhdWx0cyB8fCB7fTtcblx0XHRcdFx0cGFyZW50ID0gX2lzTm90RmFsc2UocGFyZW50LnZhcnMuaW5oZXJpdCkgJiYgcGFyZW50LnBhcmVudDtcblx0XHRcdH1cblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UoaXJWYXJzLmltbWVkaWF0ZVJlbmRlcik7XG5cdFx0XHR0eXBlIDwgMiA/ICh2YXJzLnJ1bkJhY2t3YXJkcyA9IDEpIDogKHZhcnMuc3RhcnRBdCA9IHBhcmFtc1t2YXJzSW5kZXggLSAxXSk7IC8vIFwiZnJvbVwiIHZhcnNcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBUd2VlbihwYXJhbXNbMF0sIHZhcnMsIHBhcmFtc1t2YXJzSW5kZXggKyAxXSk7XG5cdH0sXG5cdF9jb25kaXRpb25hbFJldHVybiA9ICh2YWx1ZSwgZnVuYykgPT4gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyBmdW5jKHZhbHVlKSA6IGZ1bmMsXG5cdF9jbGFtcCA9IChtaW4sIG1heCwgdmFsdWUpID0+IHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZSxcblx0Z2V0VW5pdCA9IHZhbHVlID0+IHtcblx0XHRpZiAodHlwZW9mKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0fVxuXHRcdGxldCB2ID0gX3VuaXRFeHAuZXhlYyh2YWx1ZSk7XG5cdFx0cmV0dXJuIHYgPyB2YWx1ZS5zdWJzdHIodi5pbmRleCArIHZbMF0ubGVuZ3RoKSA6IFwiXCI7XG5cdH0sIC8vIG5vdGU6IHByb3RlY3QgYWdhaW5zdCBwYWRkZWQgbnVtYmVycyBhcyBzdHJpbmdzLCBsaWtlIFwiMTAwLjEwMFwiLiBUaGF0IHNob3VsZG4ndCByZXR1cm4gXCIwMFwiIGFzIHRoZSB1bml0LiBJZiBpdCdzIG51bWVyaWMsIHJldHVybiBubyB1bml0LlxuXHRjbGFtcCA9IChtaW4sIG1heCwgdmFsdWUpID0+IF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgdiA9PiBfY2xhbXAobWluLCBtYXgsIHYpKSxcblx0X3NsaWNlID0gW10uc2xpY2UsXG5cdF9pc0FycmF5TGlrZSA9ICh2YWx1ZSwgbm9uRW1wdHkpID0+IHZhbHVlICYmIChfaXNPYmplY3QodmFsdWUpICYmIFwibGVuZ3RoXCIgaW4gdmFsdWUgJiYgKCghbm9uRW1wdHkgJiYgIXZhbHVlLmxlbmd0aCkgfHwgKCh2YWx1ZS5sZW5ndGggLSAxKSBpbiB2YWx1ZSAmJiBfaXNPYmplY3QodmFsdWVbMF0pKSkgJiYgIXZhbHVlLm5vZGVUeXBlICYmIHZhbHVlICE9PSBfd2luKSxcblx0X2ZsYXR0ZW4gPSAoYXIsIGxlYXZlU3RyaW5ncywgYWNjdW11bGF0b3IgPSBbXSkgPT4gYXIuZm9yRWFjaCh2YWx1ZSA9PiAoX2lzU3RyaW5nKHZhbHVlKSAmJiAhbGVhdmVTdHJpbmdzKSB8fCBfaXNBcnJheUxpa2UodmFsdWUsIDEpID8gYWNjdW11bGF0b3IucHVzaCguLi50b0FycmF5KHZhbHVlKSkgOiBhY2N1bXVsYXRvci5wdXNoKHZhbHVlKSkgfHwgYWNjdW11bGF0b3IsXG5cdC8vdGFrZXMgYW55IHZhbHVlIGFuZCByZXR1cm5zIGFuIGFycmF5LiBJZiBpdCdzIGEgc3RyaW5nIChhbmQgbGVhdmVTdHJpbmdzIGlzbid0IHRydWUpLCBpdCdsbCB1c2UgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgpIGFuZCBjb252ZXJ0IHRoYXQgdG8gYW4gYXJyYXkuIEl0J2xsIGFsc28gYWNjZXB0IGl0ZXJhYmxlcyBsaWtlIGpRdWVyeSBvYmplY3RzLlxuXHR0b0FycmF5ID0gKHZhbHVlLCBzY29wZSwgbGVhdmVTdHJpbmdzKSA9PiBfaXNTdHJpbmcodmFsdWUpICYmICFsZWF2ZVN0cmluZ3MgJiYgKF9jb3JlSW5pdHRlZCB8fCAhX3dha2UoKSkgPyBfc2xpY2UuY2FsbCgoc2NvcGUgfHwgX2RvYykucXVlcnlTZWxlY3RvckFsbCh2YWx1ZSksIDApIDogX2lzQXJyYXkodmFsdWUpID8gX2ZsYXR0ZW4odmFsdWUsIGxlYXZlU3RyaW5ncykgOiBfaXNBcnJheUxpa2UodmFsdWUpID8gX3NsaWNlLmNhbGwodmFsdWUsIDApIDogdmFsdWUgPyBbdmFsdWVdIDogW10sXG5cdHNlbGVjdG9yID0gdmFsdWUgPT4ge1xuXHRcdHZhbHVlID0gdG9BcnJheSh2YWx1ZSlbMF0gfHwgX3dhcm4oXCJJbnZhbGlkIHNjb3BlXCIpIHx8IHt9O1xuXHRcdHJldHVybiB2ID0+IHtcblx0XHRcdGxldCBlbCA9IHZhbHVlLmN1cnJlbnQgfHwgdmFsdWUubmF0aXZlRWxlbWVudCB8fCB2YWx1ZTtcblx0XHRcdHJldHVybiB0b0FycmF5KHYsIGVsLnF1ZXJ5U2VsZWN0b3JBbGwgPyBlbCA6IGVsID09PSB2YWx1ZSA/IF93YXJuKFwiSW52YWxpZCBzY29wZVwiKSB8fCBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgOiB2YWx1ZSk7XG5cdFx0fTtcblx0fSxcblx0c2h1ZmZsZSA9IGEgPT4gYS5zb3J0KCgpID0+IC41IC0gTWF0aC5yYW5kb20oKSksIC8vIGFsdGVybmF0aXZlIHRoYXQncyBhIGJpdCBmYXN0ZXIgYW5kIG1vcmUgcmVsaWFibHkgZGl2ZXJzZSBidXQgYmlnZ2VyOiAgIGZvciAobGV0IGosIHYsIGkgPSBhLmxlbmd0aDsgaTsgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGkpLCB2ID0gYVstLWldLCBhW2ldID0gYVtqXSwgYVtqXSA9IHYpOyByZXR1cm4gYTtcblx0Ly9mb3IgZGlzdHJpYnV0aW5nIHZhbHVlcyBhY3Jvc3MgYW4gYXJyYXkuIENhbiBhY2NlcHQgYSBudW1iZXIsIGEgZnVuY3Rpb24gb3IgKG1vc3QgY29tbW9ubHkpIGEgZnVuY3Rpb24gd2hpY2ggY2FuIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOiB7YmFzZSwgYW1vdW50LCBmcm9tLCBlYXNlLCBncmlkLCBheGlzLCBsZW5ndGgsIGVhY2h9LiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBleHBlY3RzIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczogaW5kZXgsIHRhcmdldCwgYXJyYXkuIFJlY29nbml6ZXMgdGhlIGZvbGxvd2luZ1xuXHRkaXN0cmlidXRlID0gdiA9PiB7XG5cdFx0aWYgKF9pc0Z1bmN0aW9uKHYpKSB7XG5cdFx0XHRyZXR1cm4gdjtcblx0XHR9XG5cdFx0bGV0IHZhcnMgPSBfaXNPYmplY3QodikgPyB2IDoge2VhY2g6dn0sIC8vbjoxIGlzIGp1c3QgdG8gaW5kaWNhdGUgdiB3YXMgYSBudW1iZXI7IHdlIGxldmVyYWdlIHRoYXQgbGF0ZXIgdG8gc2V0IHYgYWNjb3JkaW5nIHRvIHRoZSBsZW5ndGggd2UgZ2V0LiBJZiBhIG51bWJlciBpcyBwYXNzZWQgaW4sIHdlIHRyZWF0IGl0IGxpa2UgdGhlIG9sZCBzdGFnZ2VyIHZhbHVlIHdoZXJlIDAuMSwgZm9yIGV4YW1wbGUsIHdvdWxkIG1lYW4gdGhhdCB0aGluZ3Mgd291bGQgYmUgZGlzdHJpYnV0ZWQgd2l0aCAwLjEgYmV0d2VlbiBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IHJhdGhlciB0aGFuIGEgdG90YWwgXCJhbW91bnRcIiB0aGF0J3MgY2h1bmtlZCBvdXQgYW1vbmcgdGhlbSBhbGwuXG5cdFx0XHRlYXNlID0gX3BhcnNlRWFzZSh2YXJzLmVhc2UpLFxuXHRcdFx0ZnJvbSA9IHZhcnMuZnJvbSB8fCAwLFxuXHRcdFx0YmFzZSA9IHBhcnNlRmxvYXQodmFycy5iYXNlKSB8fCAwLFxuXHRcdFx0Y2FjaGUgPSB7fSxcblx0XHRcdGlzRGVjaW1hbCA9IChmcm9tID4gMCAmJiBmcm9tIDwgMSksXG5cdFx0XHRyYXRpb3MgPSBpc05hTihmcm9tKSB8fCBpc0RlY2ltYWwsXG5cdFx0XHRheGlzID0gdmFycy5heGlzLFxuXHRcdFx0cmF0aW9YID0gZnJvbSxcblx0XHRcdHJhdGlvWSA9IGZyb207XG5cdFx0aWYgKF9pc1N0cmluZyhmcm9tKSkge1xuXHRcdFx0cmF0aW9YID0gcmF0aW9ZID0ge2NlbnRlcjouNSwgZWRnZXM6LjUsIGVuZDoxfVtmcm9tXSB8fCAwO1xuXHRcdH0gZWxzZSBpZiAoIWlzRGVjaW1hbCAmJiByYXRpb3MpIHtcblx0XHRcdHJhdGlvWCA9IGZyb21bMF07XG5cdFx0XHRyYXRpb1kgPSBmcm9tWzFdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGksIHRhcmdldCwgYSkgPT4ge1xuXHRcdFx0bGV0IGwgPSAoYSB8fCB2YXJzKS5sZW5ndGgsXG5cdFx0XHRcdGRpc3RhbmNlcyA9IGNhY2hlW2xdLFxuXHRcdFx0XHRvcmlnaW5YLCBvcmlnaW5ZLCB4LCB5LCBkLCBqLCBtYXgsIG1pbiwgd3JhcEF0O1xuXHRcdFx0aWYgKCFkaXN0YW5jZXMpIHtcblx0XHRcdFx0d3JhcEF0ID0gKHZhcnMuZ3JpZCA9PT0gXCJhdXRvXCIpID8gMCA6ICh2YXJzLmdyaWQgfHwgWzEsIF9iaWdOdW1dKVsxXTtcblx0XHRcdFx0aWYgKCF3cmFwQXQpIHtcblx0XHRcdFx0XHRtYXggPSAtX2JpZ051bTtcblx0XHRcdFx0XHR3aGlsZSAobWF4IDwgKG1heCA9IGFbd3JhcEF0KytdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpICYmIHdyYXBBdCA8IGwpIHsgfVxuXHRcdFx0XHRcdHdyYXBBdC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRpc3RhbmNlcyA9IGNhY2hlW2xdID0gW107XG5cdFx0XHRcdG9yaWdpblggPSByYXRpb3MgPyAoTWF0aC5taW4od3JhcEF0LCBsKSAqIHJhdGlvWCkgLSAuNSA6IGZyb20gJSB3cmFwQXQ7XG5cdFx0XHRcdG9yaWdpblkgPSByYXRpb3MgPyBsICogcmF0aW9ZIC8gd3JhcEF0IC0gLjUgOiAoZnJvbSAvIHdyYXBBdCkgfCAwO1xuXHRcdFx0XHRtYXggPSAwO1xuXHRcdFx0XHRtaW4gPSBfYmlnTnVtO1xuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG5cdFx0XHRcdFx0eCA9IChqICUgd3JhcEF0KSAtIG9yaWdpblg7XG5cdFx0XHRcdFx0eSA9IG9yaWdpblkgLSAoKGogLyB3cmFwQXQpIHwgMCk7XG5cdFx0XHRcdFx0ZGlzdGFuY2VzW2pdID0gZCA9ICFheGlzID8gX3NxcnQoeCAqIHggKyB5ICogeSkgOiBNYXRoLmFicygoYXhpcyA9PT0gXCJ5XCIpID8geSA6IHgpO1xuXHRcdFx0XHRcdChkID4gbWF4KSAmJiAobWF4ID0gZCk7XG5cdFx0XHRcdFx0KGQgPCBtaW4pICYmIChtaW4gPSBkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQoZnJvbSA9PT0gXCJyYW5kb21cIikgJiYgc2h1ZmZsZShkaXN0YW5jZXMpO1xuXHRcdFx0XHRkaXN0YW5jZXMubWF4ID0gbWF4IC0gbWluO1xuXHRcdFx0XHRkaXN0YW5jZXMubWluID0gbWluO1xuXHRcdFx0XHRkaXN0YW5jZXMudiA9IGwgPSAocGFyc2VGbG9hdCh2YXJzLmFtb3VudCkgfHwgKHBhcnNlRmxvYXQodmFycy5lYWNoKSAqICh3cmFwQXQgPiBsID8gbCAtIDEgOiAhYXhpcyA/IE1hdGgubWF4KHdyYXBBdCwgbCAvIHdyYXBBdCkgOiBheGlzID09PSBcInlcIiA/IGwgLyB3cmFwQXQgOiB3cmFwQXQpKSB8fCAwKSAqIChmcm9tID09PSBcImVkZ2VzXCIgPyAtMSA6IDEpO1xuXHRcdFx0XHRkaXN0YW5jZXMuYiA9IChsIDwgMCkgPyBiYXNlIC0gbCA6IGJhc2U7XG5cdFx0XHRcdGRpc3RhbmNlcy51ID0gZ2V0VW5pdCh2YXJzLmFtb3VudCB8fCB2YXJzLmVhY2gpIHx8IDA7IC8vdW5pdFxuXHRcdFx0XHRlYXNlID0gKGVhc2UgJiYgbCA8IDApID8gX2ludmVydEVhc2UoZWFzZSkgOiBlYXNlO1xuXHRcdFx0fVxuXHRcdFx0bCA9ICgoZGlzdGFuY2VzW2ldIC0gZGlzdGFuY2VzLm1pbikgLyBkaXN0YW5jZXMubWF4KSB8fCAwO1xuXHRcdFx0cmV0dXJuIF9yb3VuZChkaXN0YW5jZXMuYiArIChlYXNlID8gZWFzZShsKSA6IGwpICogZGlzdGFuY2VzLnYpICsgZGlzdGFuY2VzLnU7IC8vcm91bmQgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzXG5cdFx0fTtcblx0fSxcblx0X3JvdW5kTW9kaWZpZXIgPSB2ID0+IHsgLy9wYXNzIGluIDAuMSBnZXQgYSBmdW5jdGlvbiB0aGF0J2xsIHJvdW5kIHRvIHRoZSBuZWFyZXN0IHRlbnRoLCBvciA1IHRvIHJvdW5kIHRvIHRoZSBjbG9zZXN0IDUsIG9yIDAuMDAxIHRvIHRoZSBjbG9zZXN0IDEwMDB0aCwgZXRjLlxuXHRcdGxldCBwID0gdiA8IDEgPyBNYXRoLnBvdygxMCwgKHYgKyBcIlwiKS5sZW5ndGggLSAyKSA6IDE7IC8vdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGxpa2UgMjQgKiAwLjEgPT0gMi40MDAwMDAwMDAwMDAwMDA0KSwgd2UgY2hvcCBvZmYgYXQgYSBzcGVjaWZpYyBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgKG11Y2ggZmFzdGVyIHRoYW4gdG9GaXhlZCgpXG5cdFx0cmV0dXJuIHJhdyA9PiB7XG5cdFx0XHRsZXQgbiA9IE1hdGgucm91bmQocGFyc2VGbG9hdChyYXcpIC8gdikgKiB2ICogcDtcblx0XHRcdHJldHVybiAobiAtIG4gJSAxKSAvIHAgKyAoX2lzTnVtYmVyKHJhdykgPyAwIDogZ2V0VW5pdChyYXcpKTsgLy8gbiAtIG4gJSAxIHJlcGxhY2VzIE1hdGguZmxvb3IoKSBpbiBvcmRlciB0byBoYW5kbGUgbmVnYXRpdmUgdmFsdWVzIHByb3Blcmx5LiBGb3IgZXhhbXBsZSwgTWF0aC5mbG9vcigtMTUwLjAwMDAwMDAwMDAwMDAzKSBpcyAxNTEhXG5cdFx0fTtcblx0fSxcblx0c25hcCA9IChzbmFwVG8sIHZhbHVlKSA9PiB7XG5cdFx0bGV0IGlzQXJyYXkgPSBfaXNBcnJheShzbmFwVG8pLFxuXHRcdFx0cmFkaXVzLCBpczJEO1xuXHRcdGlmICghaXNBcnJheSAmJiBfaXNPYmplY3Qoc25hcFRvKSkge1xuXHRcdFx0cmFkaXVzID0gaXNBcnJheSA9IHNuYXBUby5yYWRpdXMgfHwgX2JpZ051bTtcblx0XHRcdGlmIChzbmFwVG8udmFsdWVzKSB7XG5cdFx0XHRcdHNuYXBUbyA9IHRvQXJyYXkoc25hcFRvLnZhbHVlcyk7XG5cdFx0XHRcdGlmICgoaXMyRCA9ICFfaXNOdW1iZXIoc25hcFRvWzBdKSkpIHtcblx0XHRcdFx0XHRyYWRpdXMgKj0gcmFkaXVzOyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBzbyB3ZSBkb24ndCBoYXZlIHRvIE1hdGguc3FydCgpIGluIHRoZSBsb29wLlxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzbmFwVG8gPSBfcm91bmRNb2RpZmllcihzbmFwVG8uaW5jcmVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgIWlzQXJyYXkgPyBfcm91bmRNb2RpZmllcihzbmFwVG8pIDogX2lzRnVuY3Rpb24oc25hcFRvKSA/IHJhdyA9PiB7aXMyRCA9IHNuYXBUbyhyYXcpOyByZXR1cm4gTWF0aC5hYnMoaXMyRCAtIHJhdykgPD0gcmFkaXVzID8gaXMyRCA6IHJhdzsgfSA6IHJhdyA9PiB7XG5cdFx0XHRsZXQgeCA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy54IDogcmF3KSxcblx0XHRcdFx0eSA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy55IDogMCksXG5cdFx0XHRcdG1pbiA9IF9iaWdOdW0sXG5cdFx0XHRcdGNsb3Nlc3QgPSAwLFxuXHRcdFx0XHRpID0gc25hcFRvLmxlbmd0aCxcblx0XHRcdFx0ZHgsIGR5O1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRpZiAoaXMyRCkge1xuXHRcdFx0XHRcdGR4ID0gc25hcFRvW2ldLnggLSB4O1xuXHRcdFx0XHRcdGR5ID0gc25hcFRvW2ldLnkgLSB5O1xuXHRcdFx0XHRcdGR4ID0gZHggKiBkeCArIGR5ICogZHk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZHggPSBNYXRoLmFicyhzbmFwVG9baV0gLSB4KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZHggPCBtaW4pIHtcblx0XHRcdFx0XHRtaW4gPSBkeDtcblx0XHRcdFx0XHRjbG9zZXN0ID0gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2xvc2VzdCA9ICghcmFkaXVzIHx8IG1pbiA8PSByYWRpdXMpID8gc25hcFRvW2Nsb3Nlc3RdIDogcmF3O1xuXHRcdFx0cmV0dXJuIChpczJEIHx8IGNsb3Nlc3QgPT09IHJhdyB8fCBfaXNOdW1iZXIocmF3KSkgPyBjbG9zZXN0IDogY2xvc2VzdCArIGdldFVuaXQocmF3KTtcblx0XHR9KTtcblx0fSxcblx0cmFuZG9tID0gKG1pbiwgbWF4LCByb3VuZGluZ0luY3JlbWVudCwgcmV0dXJuRnVuY3Rpb24pID0+IF9jb25kaXRpb25hbFJldHVybihfaXNBcnJheShtaW4pID8gIW1heCA6IHJvdW5kaW5nSW5jcmVtZW50ID09PSB0cnVlID8gISEocm91bmRpbmdJbmNyZW1lbnQgPSAwKSA6ICFyZXR1cm5GdW5jdGlvbiwgKCkgPT4gX2lzQXJyYXkobWluKSA/IG1pblt+fihNYXRoLnJhbmRvbSgpICogbWluLmxlbmd0aCldIDogKHJvdW5kaW5nSW5jcmVtZW50ID0gcm91bmRpbmdJbmNyZW1lbnQgfHwgMWUtNSkgJiYgKHJldHVybkZ1bmN0aW9uID0gcm91bmRpbmdJbmNyZW1lbnQgPCAxID8gMTAgKiogKChyb3VuZGluZ0luY3JlbWVudCArIFwiXCIpLmxlbmd0aCAtIDIpIDogMSkgJiYgKE1hdGguZmxvb3IoTWF0aC5yb3VuZCgobWluIC0gcm91bmRpbmdJbmNyZW1lbnQgLyAyICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyByb3VuZGluZ0luY3JlbWVudCAqIC45OSkpIC8gcm91bmRpbmdJbmNyZW1lbnQpICogcm91bmRpbmdJbmNyZW1lbnQgKiByZXR1cm5GdW5jdGlvbikgLyByZXR1cm5GdW5jdGlvbikpLFxuXHRwaXBlID0gKC4uLmZ1bmN0aW9ucykgPT4gdmFsdWUgPT4gZnVuY3Rpb25zLnJlZHVjZSgodiwgZikgPT4gZih2KSwgdmFsdWUpLFxuXHR1bml0aXplID0gKGZ1bmMsIHVuaXQpID0+IHZhbHVlID0+IGZ1bmMocGFyc2VGbG9hdCh2YWx1ZSkpICsgKHVuaXQgfHwgZ2V0VW5pdCh2YWx1ZSkpLFxuXHRub3JtYWxpemUgPSAobWluLCBtYXgsIHZhbHVlKSA9PiBtYXBSYW5nZShtaW4sIG1heCwgMCwgMSwgdmFsdWUpLFxuXHRfd3JhcEFycmF5ID0gKGEsIHdyYXBwZXIsIHZhbHVlKSA9PiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGluZGV4ID0+IGFbfn53cmFwcGVyKGluZGV4KV0pLFxuXHR3cmFwID0gZnVuY3Rpb24obWluLCBtYXgsIHZhbHVlKSB7IC8vIE5PVEU6IHdyYXAoKSBDQU5OT1QgYmUgYW4gYXJyb3cgZnVuY3Rpb24hIEEgdmVyeSBvZGQgY29tcGlsaW5nIGJ1ZyBjYXVzZXMgcHJvYmxlbXMgKHVucmVsYXRlZCB0byBHU0FQKS5cblx0XHRsZXQgcmFuZ2UgPSBtYXggLSBtaW47XG5cdFx0cmV0dXJuIF9pc0FycmF5KG1pbikgPyBfd3JhcEFycmF5KG1pbiwgd3JhcCgwLCBtaW4ubGVuZ3RoKSwgbWF4KSA6IF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgdmFsdWUgPT4gKChyYW5nZSArICh2YWx1ZSAtIG1pbikgJSByYW5nZSkgJSByYW5nZSkgKyBtaW4pO1xuXHR9LFxuXHR3cmFwWW95byA9IChtaW4sIG1heCwgdmFsdWUpID0+IHtcblx0XHRsZXQgcmFuZ2UgPSBtYXggLSBtaW4sXG5cdFx0XHR0b3RhbCA9IHJhbmdlICogMjtcblx0XHRyZXR1cm4gX2lzQXJyYXkobWluKSA/IF93cmFwQXJyYXkobWluLCB3cmFwWW95bygwLCBtaW4ubGVuZ3RoIC0gMSksIG1heCkgOiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIHZhbHVlID0+IHtcblx0XHRcdHZhbHVlID0gKHRvdGFsICsgKHZhbHVlIC0gbWluKSAlIHRvdGFsKSAlIHRvdGFsIHx8IDA7XG5cdFx0XHRyZXR1cm4gbWluICsgKCh2YWx1ZSA+IHJhbmdlKSA/ICh0b3RhbCAtIHZhbHVlKSA6IHZhbHVlKTtcblx0XHR9KTtcblx0fSxcblx0X3JlcGxhY2VSYW5kb20gPSB2YWx1ZSA9PiB7IC8vcmVwbGFjZXMgYWxsIG9jY3VycmVuY2VzIG9mIHJhbmRvbSguLi4pIGluIGEgc3RyaW5nIHdpdGggdGhlIGNhbGN1bGF0ZWQgcmFuZG9tIHZhbHVlLiBjYW4gYmUgYSByYW5nZSBsaWtlIHJhbmRvbSgtMTAwLCAxMDAsIDUpIG9yIGFuIGFycmF5IGxpa2UgcmFuZG9tKFswLCAxMDAsIDUwMF0pXG5cdFx0bGV0IHByZXYgPSAwLFxuXHRcdFx0cyA9IFwiXCIsXG5cdFx0XHRpLCBudW1zLCBlbmQsIGlzQXJyYXk7XG5cdFx0d2hpbGUgKH4oaSA9IHZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIsIHByZXYpKSkge1xuXHRcdFx0ZW5kID0gdmFsdWUuaW5kZXhPZihcIilcIiwgaSk7XG5cdFx0XHRpc0FycmF5ID0gdmFsdWUuY2hhckF0KGkgKyA3KSA9PT0gXCJbXCI7XG5cdFx0XHRudW1zID0gdmFsdWUuc3Vic3RyKGkgKyA3LCBlbmQgLSBpIC0gNykubWF0Y2goaXNBcnJheSA/IF9kZWxpbWl0ZWRWYWx1ZUV4cCA6IF9zdHJpY3ROdW1FeHApO1xuXHRcdFx0cyArPSB2YWx1ZS5zdWJzdHIocHJldiwgaSAtIHByZXYpICsgcmFuZG9tKGlzQXJyYXkgPyBudW1zIDogK251bXNbMF0sIGlzQXJyYXkgPyAwIDogK251bXNbMV0sICtudW1zWzJdIHx8IDFlLTUpO1xuXHRcdFx0cHJldiA9IGVuZCArIDE7XG5cdFx0fVxuXHRcdHJldHVybiBzICsgdmFsdWUuc3Vic3RyKHByZXYsIHZhbHVlLmxlbmd0aCAtIHByZXYpO1xuXHR9LFxuXHRtYXBSYW5nZSA9IChpbk1pbiwgaW5NYXgsIG91dE1pbiwgb3V0TWF4LCB2YWx1ZSkgPT4ge1xuXHRcdGxldCBpblJhbmdlID0gaW5NYXggLSBpbk1pbixcblx0XHRcdG91dFJhbmdlID0gb3V0TWF4IC0gb3V0TWluO1xuXHRcdHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIHZhbHVlID0+IG91dE1pbiArICgoKCh2YWx1ZSAtIGluTWluKSAvIGluUmFuZ2UpICogb3V0UmFuZ2UpIHx8IDApKTtcblx0fSxcblx0aW50ZXJwb2xhdGUgPSAoc3RhcnQsIGVuZCwgcHJvZ3Jlc3MsIG11dGF0ZSkgPT4ge1xuXHRcdGxldCBmdW5jID0gaXNOYU4oc3RhcnQgKyBlbmQpID8gMCA6IHAgPT4gKDEgLSBwKSAqIHN0YXJ0ICsgcCAqIGVuZDtcblx0XHRpZiAoIWZ1bmMpIHtcblx0XHRcdGxldCBpc1N0cmluZyA9IF9pc1N0cmluZyhzdGFydCksXG5cdFx0XHRcdG1hc3RlciA9IHt9LFxuXHRcdFx0XHRwLCBpLCBpbnRlcnBvbGF0b3JzLCBsLCBpbDtcblx0XHRcdHByb2dyZXNzID09PSB0cnVlICYmIChtdXRhdGUgPSAxKSAmJiAocHJvZ3Jlc3MgPSBudWxsKTtcblx0XHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0XHRzdGFydCA9IHtwOiBzdGFydH07XG5cdFx0XHRcdGVuZCA9IHtwOiBlbmR9O1xuXG5cdFx0XHR9IGVsc2UgaWYgKF9pc0FycmF5KHN0YXJ0KSAmJiAhX2lzQXJyYXkoZW5kKSkge1xuXHRcdFx0XHRpbnRlcnBvbGF0b3JzID0gW107XG5cdFx0XHRcdGwgPSBzdGFydC5sZW5ndGg7XG5cdFx0XHRcdGlsID0gbCAtIDI7XG5cdFx0XHRcdGZvciAoaSA9IDE7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRpbnRlcnBvbGF0b3JzLnB1c2goaW50ZXJwb2xhdGUoc3RhcnRbaS0xXSwgc3RhcnRbaV0pKTsgLy9idWlsZCB0aGUgaW50ZXJwb2xhdG9ycyB1cCBmcm9udCBhcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBzbyB0aGF0IHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBtYW55IHRpbWVzLCBpdCBjYW4ganVzdCByZXVzZSB0aGVtLlxuXHRcdFx0XHR9XG5cdFx0XHRcdGwtLTtcblx0XHRcdFx0ZnVuYyA9IHAgPT4ge1xuXHRcdFx0XHRcdHAgKj0gbDtcblx0XHRcdFx0XHRsZXQgaSA9IE1hdGgubWluKGlsLCB+fnApO1xuXHRcdFx0XHRcdHJldHVybiBpbnRlcnBvbGF0b3JzW2ldKHAgLSBpKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cHJvZ3Jlc3MgPSBlbmQ7XG5cdFx0XHR9IGVsc2UgaWYgKCFtdXRhdGUpIHtcblx0XHRcdFx0c3RhcnQgPSBfbWVyZ2UoX2lzQXJyYXkoc3RhcnQpID8gW10gOiB7fSwgc3RhcnQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFpbnRlcnBvbGF0b3JzKSB7XG5cdFx0XHRcdGZvciAocCBpbiBlbmQpIHtcblx0XHRcdFx0XHRfYWRkUHJvcFR3ZWVuLmNhbGwobWFzdGVyLCBzdGFydCwgcCwgXCJnZXRcIiwgZW5kW3BdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmdW5jID0gcCA9PiBfcmVuZGVyUHJvcFR3ZWVucyhwLCBtYXN0ZXIpIHx8IChpc1N0cmluZyA/IHN0YXJ0LnAgOiBzdGFydCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4ocHJvZ3Jlc3MsIGZ1bmMpO1xuXHR9LFxuXHRfZ2V0TGFiZWxJbkRpcmVjdGlvbiA9ICh0aW1lbGluZSwgZnJvbVRpbWUsIGJhY2t3YXJkKSA9PiB7IC8vdXNlZCBmb3IgbmV4dExhYmVsKCkgYW5kIHByZXZpb3VzTGFiZWwoKVxuXHRcdGxldCBsYWJlbHMgPSB0aW1lbGluZS5sYWJlbHMsXG5cdFx0XHRtaW4gPSBfYmlnTnVtLFxuXHRcdFx0cCwgZGlzdGFuY2UsIGxhYmVsO1xuXHRcdGZvciAocCBpbiBsYWJlbHMpIHtcblx0XHRcdGRpc3RhbmNlID0gbGFiZWxzW3BdIC0gZnJvbVRpbWU7XG5cdFx0XHRpZiAoKGRpc3RhbmNlIDwgMCkgPT09ICEhYmFja3dhcmQgJiYgZGlzdGFuY2UgJiYgbWluID4gKGRpc3RhbmNlID0gTWF0aC5hYnMoZGlzdGFuY2UpKSkge1xuXHRcdFx0XHRsYWJlbCA9IHA7XG5cdFx0XHRcdG1pbiA9IGRpc3RhbmNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbGFiZWw7XG5cdH0sXG5cdF9jYWxsYmFjayA9IChhbmltYXRpb24sIHR5cGUsIGV4ZWN1dGVMYXp5Rmlyc3QpID0+IHtcblx0XHRsZXQgdiA9IGFuaW1hdGlvbi52YXJzLFxuXHRcdFx0Y2FsbGJhY2sgPSB2W3R5cGVdLFxuXHRcdFx0cGFyYW1zLCBzY29wZTtcblx0XHRpZiAoIWNhbGxiYWNrKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHBhcmFtcyA9IHZbdHlwZSArIFwiUGFyYW1zXCJdO1xuXHRcdHNjb3BlID0gdi5jYWxsYmFja1Njb3BlIHx8IGFuaW1hdGlvbjtcblx0XHRleGVjdXRlTGF6eUZpcnN0ICYmIF9sYXp5VHdlZW5zLmxlbmd0aCAmJiBfbGF6eVJlbmRlcigpOyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gYSB0aW1lbGluZSBmaW5pc2hlcywgdXNlcnMgZXhwZWN0IHRoaW5ncyB0byBoYXZlIHJlbmRlcmVkIGZ1bGx5LiBJbWFnaW5lIGFuIG9uVXBkYXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblx0XHRyZXR1cm4gcGFyYW1zID8gY2FsbGJhY2suYXBwbHkoc2NvcGUsIHBhcmFtcykgOiBjYWxsYmFjay5jYWxsKHNjb3BlKTtcblx0fSxcblx0X2ludGVycnVwdCA9IGFuaW1hdGlvbiA9PiB7XG5cdFx0X3JlbW92ZUZyb21QYXJlbnQoYW5pbWF0aW9uKTtcblx0XHRhbmltYXRpb24uc2Nyb2xsVHJpZ2dlciAmJiBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlci5raWxsKGZhbHNlKTtcblx0XHRhbmltYXRpb24ucHJvZ3Jlc3MoKSA8IDEgJiYgX2NhbGxiYWNrKGFuaW1hdGlvbiwgXCJvbkludGVycnVwdFwiKTtcblx0XHRyZXR1cm4gYW5pbWF0aW9uO1xuXHR9LFxuXHRfcXVpY2tUd2Vlbixcblx0X2NyZWF0ZVBsdWdpbiA9IGNvbmZpZyA9PiB7XG5cdFx0Y29uZmlnID0gIWNvbmZpZy5uYW1lICYmIGNvbmZpZy5kZWZhdWx0IHx8IGNvbmZpZzsgLy9VTUQgcGFja2FnaW5nIHdyYXBzIHRoaW5ncyBvZGRseSwgc28gZm9yIGV4YW1wbGUgTW90aW9uUGF0aEhlbHBlciBiZWNvbWVzIHtNb3Rpb25QYXRoSGVscGVyOk1vdGlvblBhdGhIZWxwZXIsIGRlZmF1bHQ6TW90aW9uUGF0aEhlbHBlcn0uXG5cdFx0bGV0IG5hbWUgPSBjb25maWcubmFtZSxcblx0XHRcdGlzRnVuYyA9IF9pc0Z1bmN0aW9uKGNvbmZpZyksXG5cdFx0XHRQbHVnaW4gPSAobmFtZSAmJiAhaXNGdW5jICYmIGNvbmZpZy5pbml0KSA/IGZ1bmN0aW9uKCkgeyB0aGlzLl9wcm9wcyA9IFtdOyB9IDogY29uZmlnLCAvL2luIGNhc2Ugc29tZW9uZSBwYXNzZXMgaW4gYW4gb2JqZWN0IHRoYXQncyBub3QgYSBwbHVnaW4sIGxpa2UgQ3VzdG9tRWFzZVxuXHRcdFx0aW5zdGFuY2VEZWZhdWx0cyA9IHtpbml0Ol9lbXB0eUZ1bmMsIHJlbmRlcjpfcmVuZGVyUHJvcFR3ZWVucywgYWRkOl9hZGRQcm9wVHdlZW4sIGtpbGw6X2tpbGxQcm9wVHdlZW5zT2YsIG1vZGlmaWVyOl9hZGRQbHVnaW5Nb2RpZmllciwgcmF3VmFyczowfSxcblx0XHRcdHN0YXRpY3MgPSB7dGFyZ2V0VGVzdDowLCBnZXQ6MCwgZ2V0U2V0dGVyOl9nZXRTZXR0ZXIsIGFsaWFzZXM6e30sIHJlZ2lzdGVyOjB9O1xuXHRcdF93YWtlKCk7XG5cdFx0aWYgKGNvbmZpZyAhPT0gUGx1Z2luKSB7XG5cdFx0XHRpZiAoX3BsdWdpbnNbbmFtZV0pIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0X3NldERlZmF1bHRzKFBsdWdpbiwgX3NldERlZmF1bHRzKF9jb3B5RXhjbHVkaW5nKGNvbmZpZywgaW5zdGFuY2VEZWZhdWx0cyksIHN0YXRpY3MpKTsgLy9zdGF0aWMgbWV0aG9kc1xuXHRcdFx0X21lcmdlKFBsdWdpbi5wcm90b3R5cGUsIF9tZXJnZShpbnN0YW5jZURlZmF1bHRzLCBfY29weUV4Y2x1ZGluZyhjb25maWcsIHN0YXRpY3MpKSk7IC8vaW5zdGFuY2UgbWV0aG9kc1xuXHRcdFx0X3BsdWdpbnNbKFBsdWdpbi5wcm9wID0gbmFtZSldID0gUGx1Z2luO1xuXHRcdFx0aWYgKGNvbmZpZy50YXJnZXRUZXN0KSB7XG5cdFx0XHRcdF9oYXJuZXNzUGx1Z2lucy5wdXNoKFBsdWdpbik7XG5cdFx0XHRcdF9yZXNlcnZlZFByb3BzW25hbWVdID0gMTtcblx0XHRcdH1cblx0XHRcdG5hbWUgPSAobmFtZSA9PT0gXCJjc3NcIiA/IFwiQ1NTXCIgOiBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSkpICsgXCJQbHVnaW5cIjsgLy9mb3IgdGhlIGdsb2JhbCBuYW1lLiBcIm1vdGlvblBhdGhcIiBzaG91bGQgYmVjb21lIE1vdGlvblBhdGhQbHVnaW5cblx0XHR9XG5cdFx0X2FkZEdsb2JhbChuYW1lLCBQbHVnaW4pO1xuXHRcdGNvbmZpZy5yZWdpc3RlciAmJiBjb25maWcucmVnaXN0ZXIoZ3NhcCwgUGx1Z2luLCBQcm9wVHdlZW4pO1xuXHR9LFxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENPTE9SU1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cdF8yNTUgPSAyNTUsXG5cdF9jb2xvckxvb2t1cCA9IHtcblx0XHRhcXVhOlswLF8yNTUsXzI1NV0sXG5cdFx0bGltZTpbMCxfMjU1LDBdLFxuXHRcdHNpbHZlcjpbMTkyLDE5MiwxOTJdLFxuXHRcdGJsYWNrOlswLDAsMF0sXG5cdFx0bWFyb29uOlsxMjgsMCwwXSxcblx0XHR0ZWFsOlswLDEyOCwxMjhdLFxuXHRcdGJsdWU6WzAsMCxfMjU1XSxcblx0XHRuYXZ5OlswLDAsMTI4XSxcblx0XHR3aGl0ZTpbXzI1NSxfMjU1LF8yNTVdLFxuXHRcdG9saXZlOlsxMjgsMTI4LDBdLFxuXHRcdHllbGxvdzpbXzI1NSxfMjU1LDBdLFxuXHRcdG9yYW5nZTpbXzI1NSwxNjUsMF0sXG5cdFx0Z3JheTpbMTI4LDEyOCwxMjhdLFxuXHRcdHB1cnBsZTpbMTI4LDAsMTI4XSxcblx0XHRncmVlbjpbMCwxMjgsMF0sXG5cdFx0cmVkOltfMjU1LDAsMF0sXG5cdFx0cGluazpbXzI1NSwxOTIsMjAzXSxcblx0XHRjeWFuOlswLF8yNTUsXzI1NV0sXG5cdFx0dHJhbnNwYXJlbnQ6W18yNTUsXzI1NSxfMjU1LDBdXG5cdH0sXG5cdF9odWUgPSAoaCwgbTEsIG0yKSA9PiB7XG5cdFx0aCA9IChoIDwgMCkgPyBoICsgMSA6IChoID4gMSkgPyBoIC0gMSA6IGg7XG5cdFx0cmV0dXJuICgoKChoICogNiA8IDEpID8gbTEgKyAobTIgLSBtMSkgKiBoICogNiA6IChoIDwgLjUpID8gbTIgOiAoaCAqIDMgPCAyKSA/IG0xICsgKG0yIC0gbTEpICogKDIgLyAzIC0gaCkgKiA2IDogbTEpICogXzI1NSkgKyAuNSkgfCAwO1xuXHR9LFxuXHRzcGxpdENvbG9yID0gKHYsIHRvSFNMLCBmb3JjZUFscGhhKSA9PiB7XG5cdFx0bGV0IGEgPSAhdiA/IF9jb2xvckxvb2t1cC5ibGFjayA6IF9pc051bWJlcih2KSA/IFt2ID4+IDE2LCAodiA+PiA4KSAmIF8yNTUsIHYgJiBfMjU1XSA6IDAsXG5cdFx0XHRyLCBnLCBiLCBoLCBzLCBsLCBtYXgsIG1pbiwgZCwgd2FzSFNMO1xuXHRcdGlmICghYSkge1xuXHRcdFx0aWYgKHYuc3Vic3RyKC0xKSA9PT0gXCIsXCIpIHsgLy9zb21ldGltZXMgYSB0cmFpbGluZyBjb21tYSBpcyBpbmNsdWRlZCBhbmQgd2Ugc2hvdWxkIGNob3AgaXQgb2ZmICh0eXBpY2FsbHkgZnJvbSBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHZhbHVlcyBsaWtlIGEgdGV4dFNoYWRvdzpcIjJweCAycHggMnB4IGJsdWUsIDVweCA1cHggNXB4IHJnYigyNTUsMCwwKVwiIC0gaW4gdGhpcyBleGFtcGxlIFwiYmx1ZSxcIiBoYXMgYSB0cmFpbGluZyBjb21tYS4gV2UgY291bGQgc3RyaXAgaXQgb3V0IGluc2lkZSBwYXJzZUNvbXBsZXgoKSBidXQgd2UnZCBuZWVkIHRvIGRvIGl0IHRvIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgcGx1cyBpdCB3b3VsZG4ndCBwcm92aWRlIHByb3RlY3Rpb24gZnJvbSBvdGhlciBwb3RlbnRpYWwgc2NlbmFyaW9zIGxpa2UgaWYgdGhlIHVzZXIgcGFzc2VzIGluIGEgc2ltaWxhciB2YWx1ZS5cblx0XHRcdFx0diA9IHYuc3Vic3RyKDAsIHYubGVuZ3RoIC0gMSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoX2NvbG9yTG9va3VwW3ZdKSB7XG5cdFx0XHRcdGEgPSBfY29sb3JMb29rdXBbdl07XG5cdFx0XHR9IGVsc2UgaWYgKHYuY2hhckF0KDApID09PSBcIiNcIikge1xuXHRcdFx0XHRpZiAodi5sZW5ndGggPCA2KSB7IC8vZm9yIHNob3J0aGFuZCBsaWtlICM5RjAgb3IgIzlGMEYgKGNvdWxkIGhhdmUgYWxwaGEpXG5cdFx0XHRcdFx0ciA9IHYuY2hhckF0KDEpO1xuXHRcdFx0XHRcdGcgPSB2LmNoYXJBdCgyKTtcblx0XHRcdFx0XHRiID0gdi5jaGFyQXQoMyk7XG5cdFx0XHRcdFx0diA9IFwiI1wiICsgciArIHIgKyBnICsgZyArIGIgKyBiICsgKHYubGVuZ3RoID09PSA1ID8gdi5jaGFyQXQoNCkgKyB2LmNoYXJBdCg0KSA6IFwiXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2Lmxlbmd0aCA9PT0gOSkgeyAvLyBoZXggd2l0aCBhbHBoYSwgbGlrZSAjZmQ1ZTUzZmZcblx0XHRcdFx0XHRhID0gcGFyc2VJbnQodi5zdWJzdHIoMSwgNiksIDE2KTtcblx0XHRcdFx0XHRyZXR1cm4gW2EgPj4gMTYsIChhID4+IDgpICYgXzI1NSwgYSAmIF8yNTUsIHBhcnNlSW50KHYuc3Vic3RyKDcpLCAxNikgLyAyNTVdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHYgPSBwYXJzZUludCh2LnN1YnN0cigxKSwgMTYpO1xuXHRcdFx0XHRhID0gW3YgPj4gMTYsICh2ID4+IDgpICYgXzI1NSwgdiAmIF8yNTVdO1xuXHRcdFx0fSBlbHNlIGlmICh2LnN1YnN0cigwLCAzKSA9PT0gXCJoc2xcIikge1xuXHRcdFx0XHRhID0gd2FzSFNMID0gdi5tYXRjaChfc3RyaWN0TnVtRXhwKTtcblx0XHRcdFx0aWYgKCF0b0hTTCkge1xuXHRcdFx0XHRcdGggPSAoK2FbMF0gJSAzNjApIC8gMzYwO1xuXHRcdFx0XHRcdHMgPSArYVsxXSAvIDEwMDtcblx0XHRcdFx0XHRsID0gK2FbMl0gLyAxMDA7XG5cdFx0XHRcdFx0ZyA9IChsIDw9IC41KSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcblx0XHRcdFx0XHRyID0gbCAqIDIgLSBnO1xuXHRcdFx0XHRcdGEubGVuZ3RoID4gMyAmJiAoYVszXSAqPSAxKTsgLy9jYXN0IGFzIG51bWJlclxuXHRcdFx0XHRcdGFbMF0gPSBfaHVlKGggKyAxIC8gMywgciwgZyk7XG5cdFx0XHRcdFx0YVsxXSA9IF9odWUoaCwgciwgZyk7XG5cdFx0XHRcdFx0YVsyXSA9IF9odWUoaCAtIDEgLyAzLCByLCBnKTtcblx0XHRcdFx0fSBlbHNlIGlmICh+di5pbmRleE9mKFwiPVwiKSkgeyAvL2lmIHJlbGF0aXZlIHZhbHVlcyBhcmUgZm91bmQsIGp1c3QgcmV0dXJuIHRoZSByYXcgc3RyaW5ncyB3aXRoIHRoZSByZWxhdGl2ZSBwcmVmaXhlcyBpbiBwbGFjZS5cblx0XHRcdFx0XHRhID0gdi5tYXRjaChfbnVtRXhwKTtcblx0XHRcdFx0XHRmb3JjZUFscGhhICYmIGEubGVuZ3RoIDwgNCAmJiAoYVszXSA9IDEpO1xuXHRcdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhID0gdi5tYXRjaChfc3RyaWN0TnVtRXhwKSB8fCBfY29sb3JMb29rdXAudHJhbnNwYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHRhID0gYS5tYXAoTnVtYmVyKTtcblx0XHR9XG5cdFx0aWYgKHRvSFNMICYmICF3YXNIU0wpIHtcblx0XHRcdHIgPSBhWzBdIC8gXzI1NTtcblx0XHRcdGcgPSBhWzFdIC8gXzI1NTtcblx0XHRcdGIgPSBhWzJdIC8gXzI1NTtcblx0XHRcdG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXHRcdFx0bWluID0gTWF0aC5taW4ociwgZywgYik7XG5cdFx0XHRsID0gKG1heCArIG1pbikgLyAyO1xuXHRcdFx0aWYgKG1heCA9PT0gbWluKSB7XG5cdFx0XHRcdGggPSBzID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGQgPSBtYXggLSBtaW47XG5cdFx0XHRcdHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcblx0XHRcdFx0aCA9IChtYXggPT09IHIpID8gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCkgOiAobWF4ID09PSBnKSA/IChiIC0gcikgLyBkICsgMiA6IChyIC0gZykgLyBkICsgNDtcblx0XHRcdFx0aCAqPSA2MDtcblx0XHRcdH1cblx0XHRcdGFbMF0gPSB+fihoICsgLjUpO1xuXHRcdFx0YVsxXSA9IH5+KHMgKiAxMDAgKyAuNSk7XG5cdFx0XHRhWzJdID0gfn4obCAqIDEwMCArIC41KTtcblx0XHR9XG5cdFx0Zm9yY2VBbHBoYSAmJiBhLmxlbmd0aCA8IDQgJiYgKGFbM10gPSAxKTtcblx0XHRyZXR1cm4gYTtcblx0fSxcblx0X2NvbG9yT3JkZXJEYXRhID0gdiA9PiB7IC8vIHN0cmlwcyBvdXQgdGhlIGNvbG9ycyBmcm9tIHRoZSBzdHJpbmcsIGZpbmRzIGFsbCB0aGUgbnVtZXJpYyBzbG90cyAod2l0aCB1bml0cykgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhvc2UuIFRoZSBBcnJheSBhbHNvIGhhcyBhIFwiY1wiIHByb3BlcnR5IHdoaWNoIGlzIGFuIEFycmF5IG9mIHRoZSBpbmRleCB2YWx1ZXMgd2hlcmUgdGhlIGNvbG9ycyBiZWxvbmcuIFRoaXMgaXMgdG8gaGVscCB3b3JrIGFyb3VuZCBpc3N1ZXMgd2hlcmUgdGhlcmUncyBhIG1pcy1tYXRjaGVkIG9yZGVyIG9mIGNvbG9yL251bWVyaWMgZGF0YSBsaWtlIGRyb3Atc2hhZG93KCNmMDAgMHB4IDFweCAycHgpIGFuZCBkcm9wLXNoYWRvdygweCAxcHggMnB4ICNmMDApLiBUaGlzIGlzIGJhc2ljYWxseSBhIGhlbHBlciBmdW5jdGlvbiB1c2VkIGluIF9mb3JtYXRDb2xvcnMoKVxuXHRcdGxldCB2YWx1ZXMgPSBbXSxcblx0XHRcdGMgPSBbXSxcblx0XHRcdGkgPSAtMTtcblx0XHR2LnNwbGl0KF9jb2xvckV4cCkuZm9yRWFjaCh2ID0+IHtcblx0XHRcdGxldCBhID0gdi5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xuXHRcdFx0dmFsdWVzLnB1c2goLi4uYSk7XG5cdFx0XHRjLnB1c2goaSArPSBhLmxlbmd0aCArIDEpO1xuXHRcdH0pO1xuXHRcdHZhbHVlcy5jID0gYztcblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXHRfZm9ybWF0Q29sb3JzID0gKHMsIHRvSFNMLCBvcmRlck1hdGNoRGF0YSkgPT4ge1xuXHRcdGxldCByZXN1bHQgPSBcIlwiLFxuXHRcdFx0Y29sb3JzID0gKHMgKyByZXN1bHQpLm1hdGNoKF9jb2xvckV4cCksXG5cdFx0XHR0eXBlID0gdG9IU0wgPyBcImhzbGEoXCIgOiBcInJnYmEoXCIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGMsIHNoZWxsLCBkLCBsO1xuXHRcdGlmICghY29sb3JzKSB7XG5cdFx0XHRyZXR1cm4gcztcblx0XHR9XG5cdFx0Y29sb3JzID0gY29sb3JzLm1hcChjb2xvciA9PiAoY29sb3IgPSBzcGxpdENvbG9yKGNvbG9yLCB0b0hTTCwgMSkpICYmIHR5cGUgKyAodG9IU0wgPyBjb2xvclswXSArIFwiLFwiICsgY29sb3JbMV0gKyBcIiUsXCIgKyBjb2xvclsyXSArIFwiJSxcIiArIGNvbG9yWzNdIDogY29sb3Iuam9pbihcIixcIikpICsgXCIpXCIpO1xuXHRcdGlmIChvcmRlck1hdGNoRGF0YSkge1xuXHRcdFx0ZCA9IF9jb2xvck9yZGVyRGF0YShzKTtcblx0XHRcdGMgPSBvcmRlck1hdGNoRGF0YS5jO1xuXHRcdFx0aWYgKGMuam9pbihyZXN1bHQpICE9PSBkLmMuam9pbihyZXN1bHQpKSB7XG5cdFx0XHRcdHNoZWxsID0gcy5yZXBsYWNlKF9jb2xvckV4cCwgXCIxXCIpLnNwbGl0KF9udW1XaXRoVW5pdEV4cCk7XG5cdFx0XHRcdGwgPSBzaGVsbC5sZW5ndGggLSAxO1xuXHRcdFx0XHRmb3IgKDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHJlc3VsdCArPSBzaGVsbFtpXSArICh+Yy5pbmRleE9mKGkpID8gY29sb3JzLnNoaWZ0KCkgfHwgdHlwZSArIFwiMCwwLDAsMClcIiA6IChkLmxlbmd0aCA/IGQgOiBjb2xvcnMubGVuZ3RoID8gY29sb3JzIDogb3JkZXJNYXRjaERhdGEpLnNoaWZ0KCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghc2hlbGwpIHtcblx0XHRcdHNoZWxsID0gcy5zcGxpdChfY29sb3JFeHApO1xuXHRcdFx0bCA9IHNoZWxsLmxlbmd0aCAtIDE7XG5cdFx0XHRmb3IgKDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRyZXN1bHQgKz0gc2hlbGxbaV0gKyBjb2xvcnNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQgKyBzaGVsbFtsXTtcblx0fSxcblx0X2NvbG9yRXhwID0gKGZ1bmN0aW9uKCkge1xuXHRcdGxldCBzID0gXCIoPzpcXFxcYig/Oig/OnJnYnxyZ2JhfGhzbHxoc2xhKVxcXFwoLis/XFxcXCkpfFxcXFxCIyg/OlswLTlhLWZdezMsNH0pezEsMn1cXFxcYlwiLCAvL3dlJ2xsIGR5bmFtaWNhbGx5IGJ1aWxkIHRoaXMgUmVndWxhciBFeHByZXNzaW9uIHRvIGNvbnNlcnZlIGZpbGUgc2l6ZS4gQWZ0ZXIgYnVpbGRpbmcgaXQsIGl0IHdpbGwgYmUgYWJsZSB0byBmaW5kIHJnYigpLCByZ2JhKCksICMgKGhleGFkZWNpbWFsKSwgYW5kIG5hbWVkIGNvbG9yIHZhbHVlcyBsaWtlIHJlZCwgYmx1ZSwgcHVycGxlLCBldGMuLFxuXHRcdFx0cDtcblx0XHRmb3IgKHAgaW4gX2NvbG9yTG9va3VwKSB7XG5cdFx0XHRzICs9IFwifFwiICsgcCArIFwiXFxcXGJcIjtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBSZWdFeHAocyArIFwiKVwiLCBcImdpXCIpO1xuXHR9KSgpLFxuXHRfaHNsRXhwID0gL2hzbFthXT9cXCgvLFxuXHRfY29sb3JTdHJpbmdGaWx0ZXIgPSBhID0+IHtcblx0XHRsZXQgY29tYmluZWQgPSBhLmpvaW4oXCIgXCIpLFxuXHRcdFx0dG9IU0w7XG5cdFx0X2NvbG9yRXhwLmxhc3RJbmRleCA9IDA7XG5cdFx0aWYgKF9jb2xvckV4cC50ZXN0KGNvbWJpbmVkKSkge1xuXHRcdFx0dG9IU0wgPSBfaHNsRXhwLnRlc3QoY29tYmluZWQpO1xuXHRcdFx0YVsxXSA9IF9mb3JtYXRDb2xvcnMoYVsxXSwgdG9IU0wpO1xuXHRcdFx0YVswXSA9IF9mb3JtYXRDb2xvcnMoYVswXSwgdG9IU0wsIF9jb2xvck9yZGVyRGF0YShhWzFdKSk7IC8vIG1ha2Ugc3VyZSB0aGUgb3JkZXIgb2YgbnVtYmVycy9jb2xvcnMgbWF0Y2ggd2l0aCB0aGUgRU5EIHZhbHVlLlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRJQ0tFUlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRfdGlja2VyQWN0aXZlLFxuXHRfdGlja2VyID0gKGZ1bmN0aW9uKCkge1xuXHRcdGxldCBfZ2V0VGltZSA9IERhdGUubm93LFxuXHRcdFx0X2xhZ1RocmVzaG9sZCA9IDUwMCxcblx0XHRcdF9hZGp1c3RlZExhZyA9IDMzLFxuXHRcdFx0X3N0YXJ0VGltZSA9IF9nZXRUaW1lKCksXG5cdFx0XHRfbGFzdFVwZGF0ZSA9IF9zdGFydFRpbWUsXG5cdFx0XHRfZ2FwID0gMTAwMCAvIDI0MCxcblx0XHRcdF9uZXh0VGltZSA9IF9nYXAsXG5cdFx0XHRfbGlzdGVuZXJzID0gW10sXG5cdFx0XHRfaWQsIF9yZXEsIF9yYWYsIF9zZWxmLCBfZGVsdGEsIF9pLFxuXHRcdFx0X3RpY2sgPSB2ID0+IHtcblx0XHRcdFx0bGV0IGVsYXBzZWQgPSBfZ2V0VGltZSgpIC0gX2xhc3RVcGRhdGUsXG5cdFx0XHRcdFx0bWFudWFsID0gdiA9PT0gdHJ1ZSxcblx0XHRcdFx0XHRvdmVybGFwLCBkaXNwYXRjaCwgdGltZSwgZnJhbWU7XG5cdFx0XHRcdGVsYXBzZWQgPiBfbGFnVGhyZXNob2xkICYmIChfc3RhcnRUaW1lICs9IGVsYXBzZWQgLSBfYWRqdXN0ZWRMYWcpO1xuXHRcdFx0XHRfbGFzdFVwZGF0ZSArPSBlbGFwc2VkO1xuXHRcdFx0XHR0aW1lID0gX2xhc3RVcGRhdGUgLSBfc3RhcnRUaW1lO1xuXHRcdFx0XHRvdmVybGFwID0gdGltZSAtIF9uZXh0VGltZTtcblx0XHRcdFx0aWYgKG92ZXJsYXAgPiAwIHx8IG1hbnVhbCkge1xuXHRcdFx0XHRcdGZyYW1lID0gKytfc2VsZi5mcmFtZTtcblx0XHRcdFx0XHRfZGVsdGEgPSB0aW1lIC0gX3NlbGYudGltZSAqIDEwMDA7XG5cdFx0XHRcdFx0X3NlbGYudGltZSA9IHRpbWUgPSB0aW1lIC8gMTAwMDtcblx0XHRcdFx0XHRfbmV4dFRpbWUgKz0gb3ZlcmxhcCArIChvdmVybGFwID49IF9nYXAgPyA0IDogX2dhcCAtIG92ZXJsYXApO1xuXHRcdFx0XHRcdGRpc3BhdGNoID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtYW51YWwgfHwgKF9pZCA9IF9yZXEoX3RpY2spKTsgLy9tYWtlIHN1cmUgdGhlIHJlcXVlc3QgaXMgbWFkZSBiZWZvcmUgd2UgZGlzcGF0Y2ggdGhlIFwidGlja1wiIGV2ZW50IHNvIHRoYXQgdGltaW5nIGlzIG1haW50YWluZWQuIE90aGVyd2lzZSwgaWYgcHJvY2Vzc2luZyB0aGUgXCJ0aWNrXCIgcmVxdWlyZXMgYSBidW5jaCBvZiB0aW1lIChsaWtlIDE1bXMpIGFuZCB3ZSdyZSB1c2luZyBhIHNldFRpbWVvdXQoKSB0aGF0J3MgYmFzZWQgb24gMTYuN21zLCBpdCdkIHRlY2huaWNhbGx5IHRha2UgMzEuN21zIGJldHdlZW4gZnJhbWVzIG90aGVyd2lzZS5cblx0XHRcdFx0aWYgKGRpc3BhdGNoKSB7XG5cdFx0XHRcdFx0Zm9yIChfaSA9IDA7IF9pIDwgX2xpc3RlbmVycy5sZW5ndGg7IF9pKyspIHsgLy8gdXNlIF9pIGFuZCBjaGVjayBfbGlzdGVuZXJzLmxlbmd0aCBpbnN0ZWFkIG9mIGEgdmFyaWFibGUgYmVjYXVzZSBhIGxpc3RlbmVyIGNvdWxkIGdldCByZW1vdmVkIGR1cmluZyB0aGUgbG9vcCwgYW5kIGlmIHRoYXQgaGFwcGVucyB0byBhbiBlbGVtZW50IGxlc3MgdGhhbiB0aGUgY3VycmVudCBpbmRleCwgaXQnZCB0aHJvdyB0aGluZ3Mgb2ZmIGluIHRoZSBsb29wLlxuXHRcdFx0XHRcdFx0X2xpc3RlbmVyc1tfaV0odGltZSwgX2RlbHRhLCBmcmFtZSwgdik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdF9zZWxmID0ge1xuXHRcdFx0dGltZTowLFxuXHRcdFx0ZnJhbWU6MCxcblx0XHRcdHRpY2soKSB7XG5cdFx0XHRcdF90aWNrKHRydWUpO1xuXHRcdFx0fSxcblx0XHRcdGRlbHRhUmF0aW8oZnBzKSB7XG5cdFx0XHRcdHJldHVybiBfZGVsdGEgLyAoMTAwMCAvIChmcHMgfHwgNjApKTtcblx0XHRcdH0sXG5cdFx0XHR3YWtlKCkge1xuXHRcdFx0XHRpZiAoX2NvcmVSZWFkeSkge1xuXHRcdFx0XHRcdGlmICghX2NvcmVJbml0dGVkICYmIF93aW5kb3dFeGlzdHMoKSkge1xuXHRcdFx0XHRcdFx0X3dpbiA9IF9jb3JlSW5pdHRlZCA9IHdpbmRvdztcblx0XHRcdFx0XHRcdF9kb2MgPSBfd2luLmRvY3VtZW50IHx8IHt9O1xuXHRcdFx0XHRcdFx0X2dsb2JhbHMuZ3NhcCA9IGdzYXA7XG5cdFx0XHRcdFx0XHQoX3dpbi5nc2FwVmVyc2lvbnMgfHwgKF93aW4uZ3NhcFZlcnNpb25zID0gW10pKS5wdXNoKGdzYXAudmVyc2lvbik7XG5cdFx0XHRcdFx0XHRfaW5zdGFsbChfaW5zdGFsbFNjb3BlIHx8IF93aW4uR3JlZW5Tb2NrR2xvYmFscyB8fCAoIV93aW4uZ3NhcCAmJiBfd2luKSB8fCB7fSk7XG5cdFx0XHRcdFx0XHRfcmFmID0gX3dpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF9pZCAmJiBfc2VsZi5zbGVlcCgpO1xuXHRcdFx0XHRcdF9yZXEgPSBfcmFmIHx8IChmID0+IHNldFRpbWVvdXQoZiwgKF9uZXh0VGltZSAtIF9zZWxmLnRpbWUgKiAxMDAwICsgMSkgfCAwKSk7XG5cdFx0XHRcdFx0X3RpY2tlckFjdGl2ZSA9IDE7XG5cdFx0XHRcdFx0X3RpY2soMik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzbGVlcCgpIHtcblx0XHRcdFx0KF9yYWYgPyBfd2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lIDogY2xlYXJUaW1lb3V0KShfaWQpO1xuXHRcdFx0XHRfdGlja2VyQWN0aXZlID0gMDtcblx0XHRcdFx0X3JlcSA9IF9lbXB0eUZ1bmM7XG5cdFx0XHR9LFxuXHRcdFx0bGFnU21vb3RoaW5nKHRocmVzaG9sZCwgYWRqdXN0ZWRMYWcpIHtcblx0XHRcdFx0X2xhZ1RocmVzaG9sZCA9IHRocmVzaG9sZCB8fCAoMSAvIF90aW55TnVtKTsgLy96ZXJvIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBiYXNpY2FsbHkgdW5saW1pdGVkXG5cdFx0XHRcdF9hZGp1c3RlZExhZyA9IE1hdGgubWluKGFkanVzdGVkTGFnLCBfbGFnVGhyZXNob2xkLCAwKTtcblx0XHRcdH0sXG5cdFx0XHRmcHMoZnBzKSB7XG5cdFx0XHRcdF9nYXAgPSAxMDAwIC8gKGZwcyB8fCAyNDApO1xuXHRcdFx0XHRfbmV4dFRpbWUgPSBfc2VsZi50aW1lICogMTAwMCArIF9nYXA7XG5cdFx0XHR9LFxuXHRcdFx0YWRkKGNhbGxiYWNrKSB7XG5cdFx0XHRcdF9saXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjaykgPCAwICYmIF9saXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG5cdFx0XHRcdF93YWtlKCk7XG5cdFx0XHR9LFxuXHRcdFx0cmVtb3ZlKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGxldCBpO1xuXHRcdFx0XHR+KGkgPSBfbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spKSAmJiBfbGlzdGVuZXJzLnNwbGljZShpLCAxKSAmJiBfaSA+PSBpICYmIF9pLS07XG5cdFx0XHR9LFxuXHRcdFx0X2xpc3RlbmVyczpfbGlzdGVuZXJzXG5cdFx0fTtcblx0XHRyZXR1cm4gX3NlbGY7XG5cdH0pKCksXG5cdF93YWtlID0gKCkgPT4gIV90aWNrZXJBY3RpdmUgJiYgX3RpY2tlci53YWtlKCksIC8vYWxzbyBlbnN1cmVzIHRoZSBjb3JlIGNsYXNzZXMgYXJlIGluaXRpYWxpemVkLlxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qXG4qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogRUFTSU5HXG4qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiovXG5cdF9lYXNlTWFwID0ge30sXG5cdF9jdXN0b21FYXNlRXhwID0gL15bXFxkLlxcLU1dW1xcZC5cXC0sXFxzXS8sXG5cdF9xdW90ZXNFeHAgPSAvW1wiJ10vZyxcblx0X3BhcnNlT2JqZWN0SW5TdHJpbmcgPSB2YWx1ZSA9PiB7IC8vdGFrZXMgYSBzdHJpbmcgbGlrZSBcInt3aWdnbGVzOjEwLCB0eXBlOmFudGljaXBhdGV9KVwiIGFuZCB0dXJucyBpdCBpbnRvIGEgcmVhbCBvYmplY3QuIE5vdGljZSBpdCBlbmRzIGluIFwiKVwiIGFuZCBpbmNsdWRlcyB0aGUge30gd3JhcHBlcnMuIFRoaXMgaXMgYmVjYXVzZSB3ZSBvbmx5IHVzZSB0aGlzIGZ1bmN0aW9uIGZvciBwYXJzaW5nIGVhc2UgY29uZmlncyBhbmQgcHJpb3JpdGl6ZWQgb3B0aW1pemF0aW9uIHJhdGhlciB0aGFuIHJldXNhYmlsaXR5LlxuXHRcdGxldCBvYmogPSB7fSxcblx0XHRcdHNwbGl0ID0gdmFsdWUuc3Vic3RyKDEsIHZhbHVlLmxlbmd0aC0zKS5zcGxpdChcIjpcIiksXG5cdFx0XHRrZXkgPSBzcGxpdFswXSxcblx0XHRcdGkgPSAxLFxuXHRcdFx0bCA9IHNwbGl0Lmxlbmd0aCxcblx0XHRcdGluZGV4LCB2YWwsIHBhcnNlZFZhbDtcblx0XHRmb3IgKDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFsID0gc3BsaXRbaV07XG5cdFx0XHRpbmRleCA9IGkgIT09IGwtMSA/IHZhbC5sYXN0SW5kZXhPZihcIixcIikgOiB2YWwubGVuZ3RoO1xuXHRcdFx0cGFyc2VkVmFsID0gdmFsLnN1YnN0cigwLCBpbmRleCk7XG5cdFx0XHRvYmpba2V5XSA9IGlzTmFOKHBhcnNlZFZhbCkgPyBwYXJzZWRWYWwucmVwbGFjZShfcXVvdGVzRXhwLCBcIlwiKS50cmltKCkgOiArcGFyc2VkVmFsO1xuXHRcdFx0a2V5ID0gdmFsLnN1YnN0cihpbmRleCsxKS50cmltKCk7XG5cdFx0fVxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cdF92YWx1ZUluUGFyZW50aGVzZXMgPSB2YWx1ZSA9PiB7XG5cdFx0bGV0IG9wZW4gPSB2YWx1ZS5pbmRleE9mKFwiKFwiKSArIDEsXG5cdFx0XHRjbG9zZSA9IHZhbHVlLmluZGV4T2YoXCIpXCIpLFxuXHRcdFx0bmVzdGVkID0gdmFsdWUuaW5kZXhPZihcIihcIiwgb3Blbik7XG5cdFx0cmV0dXJuIHZhbHVlLnN1YnN0cmluZyhvcGVuLCB+bmVzdGVkICYmIG5lc3RlZCA8IGNsb3NlID8gdmFsdWUuaW5kZXhPZihcIilcIiwgY2xvc2UgKyAxKSA6IGNsb3NlKTtcblx0fSxcblx0X2NvbmZpZ0Vhc2VGcm9tU3RyaW5nID0gbmFtZSA9PiB7IC8vbmFtZSBjYW4gYmUgYSBzdHJpbmcgbGlrZSBcImVsYXN0aWMub3V0KDEsMC41KVwiLCBhbmQgcGFzcyBpbiBfZWFzZU1hcCBhcyBvYmogYW5kIGl0J2xsIHBhcnNlIGl0IG91dCBhbmQgY2FsbCB0aGUgYWN0dWFsIGZ1bmN0aW9uIGxpa2UgX2Vhc2VNYXAuRWxhc3RpYy5lYXNlT3V0LmNvbmZpZygxLDAuNSkuIEl0IHdpbGwgYWxzbyBwYXJzZSBjdXN0b20gZWFzZSBzdHJpbmdzIGFzIGxvbmcgYXMgQ3VzdG9tRWFzZSBpcyBsb2FkZWQgYW5kIHJlZ2lzdGVyZWQgKGludGVybmFsbHkgYXMgX2Vhc2VNYXAuX0NFKS5cblx0XHRsZXQgc3BsaXQgPSAobmFtZSArIFwiXCIpLnNwbGl0KFwiKFwiKSxcblx0XHRcdGVhc2UgPSBfZWFzZU1hcFtzcGxpdFswXV07XG5cdFx0cmV0dXJuIChlYXNlICYmIHNwbGl0Lmxlbmd0aCA+IDEgJiYgZWFzZS5jb25maWcpID8gZWFzZS5jb25maWcuYXBwbHkobnVsbCwgfm5hbWUuaW5kZXhPZihcIntcIikgPyBbX3BhcnNlT2JqZWN0SW5TdHJpbmcoc3BsaXRbMV0pXSA6IF92YWx1ZUluUGFyZW50aGVzZXMobmFtZSkuc3BsaXQoXCIsXCIpLm1hcChfbnVtZXJpY0lmUG9zc2libGUpKSA6IChfZWFzZU1hcC5fQ0UgJiYgX2N1c3RvbUVhc2VFeHAudGVzdChuYW1lKSkgPyBfZWFzZU1hcC5fQ0UoXCJcIiwgbmFtZSkgOiBlYXNlO1xuXHR9LFxuXHRfaW52ZXJ0RWFzZSA9IGVhc2UgPT4gcCA9PiAxIC0gZWFzZSgxIC0gcCksXG5cdC8vIGFsbG93IHlveW9FYXNlIHRvIGJlIHNldCBpbiBjaGlsZHJlbiBhbmQgaGF2ZSB0aG9zZSBhZmZlY3RlZCB3aGVuIHRoZSBwYXJlbnQvYW5jZXN0b3IgdGltZWxpbmUgeW95b3MuXG5cdF9wcm9wYWdhdGVZb3lvRWFzZSA9ICh0aW1lbGluZSwgaXNZb3lvKSA9PiB7XG5cdFx0bGV0IGNoaWxkID0gdGltZWxpbmUuX2ZpcnN0LCBlYXNlO1xuXHRcdHdoaWxlIChjaGlsZCkge1xuXHRcdFx0aWYgKGNoaWxkIGluc3RhbmNlb2YgVGltZWxpbmUpIHtcblx0XHRcdFx0X3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLCBpc1lveW8pO1xuXHRcdFx0fSBlbHNlIGlmIChjaGlsZC52YXJzLnlveW9FYXNlICYmICghY2hpbGQuX3lveW8gfHwgIWNoaWxkLl9yZXBlYXQpICYmIGNoaWxkLl95b3lvICE9PSBpc1lveW8pIHtcblx0XHRcdFx0aWYgKGNoaWxkLnRpbWVsaW5lKSB7XG5cdFx0XHRcdFx0X3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLnRpbWVsaW5lLCBpc1lveW8pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVhc2UgPSBjaGlsZC5fZWFzZTtcblx0XHRcdFx0XHRjaGlsZC5fZWFzZSA9IGNoaWxkLl95RWFzZTtcblx0XHRcdFx0XHRjaGlsZC5feUVhc2UgPSBlYXNlO1xuXHRcdFx0XHRcdGNoaWxkLl95b3lvID0gaXNZb3lvO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjaGlsZCA9IGNoaWxkLl9uZXh0O1xuXHRcdH1cblx0fSxcblx0X3BhcnNlRWFzZSA9IChlYXNlLCBkZWZhdWx0RWFzZSkgPT4gIWVhc2UgPyBkZWZhdWx0RWFzZSA6IChfaXNGdW5jdGlvbihlYXNlKSA/IGVhc2UgOiBfZWFzZU1hcFtlYXNlXSB8fCBfY29uZmlnRWFzZUZyb21TdHJpbmcoZWFzZSkpIHx8IGRlZmF1bHRFYXNlLFxuXHRfaW5zZXJ0RWFzZSA9IChuYW1lcywgZWFzZUluLCBlYXNlT3V0ID0gcCA9PiAxIC0gZWFzZUluKDEgLSBwKSwgZWFzZUluT3V0ID0gKHAgPT4gcCA8IC41ID8gZWFzZUluKHAgKiAyKSAvIDIgOiAxIC0gZWFzZUluKCgxIC0gcCkgKiAyKSAvIDIpKSA9PiB7XG5cdFx0bGV0IGVhc2UgPSB7ZWFzZUluLCBlYXNlT3V0LCBlYXNlSW5PdXR9LFxuXHRcdFx0bG93ZXJjYXNlTmFtZTtcblx0XHRfZm9yRWFjaE5hbWUobmFtZXMsIG5hbWUgPT4ge1xuXHRcdFx0X2Vhc2VNYXBbbmFtZV0gPSBfZ2xvYmFsc1tuYW1lXSA9IGVhc2U7XG5cdFx0XHRfZWFzZU1hcFsobG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKSldID0gZWFzZU91dDtcblx0XHRcdGZvciAobGV0IHAgaW4gZWFzZSkge1xuXHRcdFx0XHRfZWFzZU1hcFtsb3dlcmNhc2VOYW1lICsgKHAgPT09IFwiZWFzZUluXCIgPyBcIi5pblwiIDogcCA9PT0gXCJlYXNlT3V0XCIgPyBcIi5vdXRcIiA6IFwiLmluT3V0XCIpXSA9IF9lYXNlTWFwW25hbWUgKyBcIi5cIiArIHBdID0gZWFzZVtwXTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gZWFzZTtcblx0fSxcblx0X2Vhc2VJbk91dEZyb21PdXQgPSBlYXNlT3V0ID0+IChwID0+IHAgPCAuNSA/ICgxIC0gZWFzZU91dCgxIC0gKHAgKiAyKSkpIC8gMiA6IC41ICsgZWFzZU91dCgocCAtIC41KSAqIDIpIC8gMiksXG5cdF9jb25maWdFbGFzdGljID0gKHR5cGUsIGFtcGxpdHVkZSwgcGVyaW9kKSA9PiB7XG5cdFx0bGV0IHAxID0gKGFtcGxpdHVkZSA+PSAxKSA/IGFtcGxpdHVkZSA6IDEsIC8vbm90ZTogaWYgYW1wbGl0dWRlIGlzIDwgMSwgd2Ugc2ltcGx5IGFkanVzdCB0aGUgcGVyaW9kIGZvciBhIG1vcmUgbmF0dXJhbCBmZWVsLiBPdGhlcndpc2UgdGhlIG1hdGggZG9lc24ndCB3b3JrIHJpZ2h0IGFuZCB0aGUgY3VydmUgc3RhcnRzIGF0IDEuXG5cdFx0XHRwMiA9IChwZXJpb2QgfHwgKHR5cGUgPyAuMyA6IC40NSkpIC8gKGFtcGxpdHVkZSA8IDEgPyBhbXBsaXR1ZGUgOiAxKSxcblx0XHRcdHAzID0gcDIgLyBfMlBJICogKE1hdGguYXNpbigxIC8gcDEpIHx8IDApLFxuXHRcdFx0ZWFzZU91dCA9IHAgPT4gcCA9PT0gMSA/IDEgOiBwMSAqICgyICoqICgtMTAgKiBwKSkgKiBfc2luKChwIC0gcDMpICogcDIpICsgMSxcblx0XHRcdGVhc2UgPSAodHlwZSA9PT0gXCJvdXRcIikgPyBlYXNlT3V0IDogKHR5cGUgPT09IFwiaW5cIikgPyBwID0+IDEgLSBlYXNlT3V0KDEgLSBwKSA6IF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpO1xuXHRcdHAyID0gXzJQSSAvIHAyOyAvL3ByZWNhbGN1bGF0ZSB0byBvcHRpbWl6ZVxuXHRcdGVhc2UuY29uZmlnID0gKGFtcGxpdHVkZSwgcGVyaW9kKSA9PiBfY29uZmlnRWxhc3RpYyh0eXBlLCBhbXBsaXR1ZGUsIHBlcmlvZCk7XG5cdFx0cmV0dXJuIGVhc2U7XG5cdH0sXG5cdF9jb25maWdCYWNrID0gKHR5cGUsIG92ZXJzaG9vdCA9IDEuNzAxNTgpID0+IHtcblx0XHRsZXQgZWFzZU91dCA9IHAgPT4gcCA/ICgoLS1wKSAqIHAgKiAoKG92ZXJzaG9vdCArIDEpICogcCArIG92ZXJzaG9vdCkgKyAxKSA6IDAsXG5cdFx0XHRlYXNlID0gKHR5cGUgPT09IFwib3V0XCIpID8gZWFzZU91dCA6ICh0eXBlID09PSBcImluXCIpID8gcCA9PiAxIC0gZWFzZU91dCgxIC0gcCkgOiBfZWFzZUluT3V0RnJvbU91dChlYXNlT3V0KTtcblx0XHRlYXNlLmNvbmZpZyA9IG92ZXJzaG9vdCA9PiBfY29uZmlnQmFjayh0eXBlLCBvdmVyc2hvb3QpO1xuXHRcdHJldHVybiBlYXNlO1xuXHR9O1xuXHQvLyBhIGNoZWFwZXIgKGtiIGFuZCBjcHUpIGJ1dCBtb3JlIG1pbGQgd2F5IHRvIGdldCBhIHBhcmFtZXRlcml6ZWQgd2VpZ2h0ZWQgZWFzZSBieSBmZWVkaW5nIGluIGEgdmFsdWUgYmV0d2VlbiAtMSAoZWFzZUluKSBhbmQgMSAoZWFzZU91dCkgd2hlcmUgMCBpcyBsaW5lYXIuXG5cdC8vIF93ZWlnaHRlZEVhc2UgPSByYXRpbyA9PiB7XG5cdC8vIFx0bGV0IHkgPSAwLjUgKyByYXRpbyAvIDI7XG5cdC8vIFx0cmV0dXJuIHAgPT4gKDIgKiAoMSAtIHApICogcCAqIHkgKyBwICogcCk7XG5cdC8vIH0sXG5cdC8vIGEgc3Ryb25nZXIgKGJ1dCBtb3JlIGV4cGVuc2l2ZSBrYi9jcHUpIHBhcmFtZXRlcml6ZWQgd2VpZ2h0ZWQgZWFzZSB0aGF0IGxldHMgeW91IGZlZWQgaW4gYSB2YWx1ZSBiZXR3ZWVuIC0xIChlYXNlSW4pIGFuZCAxIChlYXNlT3V0KSB3aGVyZSAwIGlzIGxpbmVhci5cblx0Ly8gX3dlaWdodGVkRWFzZVN0cm9uZyA9IHJhdGlvID0+IHtcblx0Ly8gXHRyYXRpbyA9IC41ICsgcmF0aW8gLyAyO1xuXHQvLyBcdGxldCBvID0gMSAvIDMgKiAocmF0aW8gPCAuNSA/IHJhdGlvIDogMSAtIHJhdGlvKSxcblx0Ly8gXHRcdGIgPSByYXRpbyAtIG8sXG5cdC8vIFx0XHRjID0gcmF0aW8gKyBvO1xuXHQvLyBcdHJldHVybiBwID0+IHAgPT09IDEgPyBwIDogMyAqIGIgKiAoMSAtIHApICogKDEgLSBwKSAqIHAgKyAzICogYyAqICgxIC0gcCkgKiBwICogcCArIHAgKiBwICogcDtcblx0Ly8gfTtcblxuX2ZvckVhY2hOYW1lKFwiTGluZWFyLFF1YWQsQ3ViaWMsUXVhcnQsUXVpbnQsU3Ryb25nXCIsIChuYW1lLCBpKSA9PiB7XG5cdGxldCBwb3dlciA9IGkgPCA1ID8gaSArIDEgOiBpO1xuXHRfaW5zZXJ0RWFzZShuYW1lICsgXCIsUG93ZXJcIiArIChwb3dlciAtIDEpLCBpID8gcCA9PiBwICoqIHBvd2VyIDogcCA9PiBwLCBwID0+IDEgLSAoMSAtIHApICoqIHBvd2VyLCBwID0+IHAgPCAuNSA/IChwICogMikgKiogcG93ZXIgLyAyIDogMSAtICgoMSAtIHApICogMikgKiogcG93ZXIgLyAyKTtcbn0pO1xuX2Vhc2VNYXAuTGluZWFyLmVhc2VOb25lID0gX2Vhc2VNYXAubm9uZSA9IF9lYXNlTWFwLkxpbmVhci5lYXNlSW47XG5faW5zZXJ0RWFzZShcIkVsYXN0aWNcIiwgX2NvbmZpZ0VsYXN0aWMoXCJpblwiKSwgX2NvbmZpZ0VsYXN0aWMoXCJvdXRcIiksIF9jb25maWdFbGFzdGljKCkpO1xuKChuLCBjKSA9PiB7XG5cdGxldCBuMSA9IDEgLyBjLFxuXHRcdG4yID0gMiAqIG4xLFxuXHRcdG4zID0gMi41ICogbjEsXG5cdFx0ZWFzZU91dCA9IHAgPT4gKHAgPCBuMSkgPyBuICogcCAqIHAgOiAocCA8IG4yKSA/IG4gKiAocCAtIDEuNSAvIGMpICoqIDIgKyAuNzUgOiAocCA8IG4zKSA/IG4gKiAocCAtPSAyLjI1IC8gYykgKiBwICsgLjkzNzUgOiBuICogKHAgLSAyLjYyNSAvIGMpICoqIDIgKyAuOTg0Mzc1O1xuXHRfaW5zZXJ0RWFzZShcIkJvdW5jZVwiLCBwID0+IDEgLSBlYXNlT3V0KDEgLSBwKSwgZWFzZU91dCk7XG59KSg3LjU2MjUsIDIuNzUpO1xuX2luc2VydEVhc2UoXCJFeHBvXCIsIHAgPT4gcCA/IDIgKiogKDEwICogKHAgLSAxKSkgOiAwKTtcbl9pbnNlcnRFYXNlKFwiQ2lyY1wiLCBwID0+IC0oX3NxcnQoMSAtIChwICogcCkpIC0gMSkpO1xuX2luc2VydEVhc2UoXCJTaW5lXCIsIHAgPT4gcCA9PT0gMSA/IDEgOiAtX2NvcyhwICogX0hBTEZfUEkpICsgMSk7XG5faW5zZXJ0RWFzZShcIkJhY2tcIiwgX2NvbmZpZ0JhY2soXCJpblwiKSwgX2NvbmZpZ0JhY2soXCJvdXRcIiksIF9jb25maWdCYWNrKCkpO1xuX2Vhc2VNYXAuU3RlcHBlZEVhc2UgPSBfZWFzZU1hcC5zdGVwcyA9IF9nbG9iYWxzLlN0ZXBwZWRFYXNlID0ge1xuXHRjb25maWcoc3RlcHMgPSAxLCBpbW1lZGlhdGVTdGFydCkge1xuXHRcdGxldCBwMSA9IDEgLyBzdGVwcyxcblx0XHRcdHAyID0gc3RlcHMgKyAoaW1tZWRpYXRlU3RhcnQgPyAwIDogMSksXG5cdFx0XHRwMyA9IGltbWVkaWF0ZVN0YXJ0ID8gMSA6IDAsXG5cdFx0XHRtYXggPSAxIC0gX3RpbnlOdW07XG5cdFx0cmV0dXJuIHAgPT4gKCgocDIgKiBfY2xhbXAoMCwgbWF4LCBwKSkgfCAwKSArIHAzKSAqIHAxO1xuXHR9XG59O1xuX2RlZmF1bHRzLmVhc2UgPSBfZWFzZU1hcFtcInF1YWQub3V0XCJdO1xuXG5cbl9mb3JFYWNoTmFtZShcIm9uQ29tcGxldGUsb25VcGRhdGUsb25TdGFydCxvblJlcGVhdCxvblJldmVyc2VDb21wbGV0ZSxvbkludGVycnVwdFwiLCBuYW1lID0+IF9jYWxsYmFja05hbWVzICs9IG5hbWUgKyBcIixcIiArIG5hbWUgKyBcIlBhcmFtcyxcIik7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDQUNIRVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuZXhwb3J0IGNsYXNzIEdTQ2FjaGUge1xuXG5cdGNvbnN0cnVjdG9yKHRhcmdldCwgaGFybmVzcykge1xuXHRcdHRoaXMuaWQgPSBfZ3NJRCsrO1xuXHRcdHRhcmdldC5fZ3NhcCA9IHRoaXM7XG5cdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cdFx0dGhpcy5oYXJuZXNzID0gaGFybmVzcztcblx0XHR0aGlzLmdldCA9IGhhcm5lc3MgPyBoYXJuZXNzLmdldCA6IF9nZXRQcm9wZXJ0eTtcblx0XHR0aGlzLnNldCA9IGhhcm5lc3MgPyBoYXJuZXNzLmdldFNldHRlciA6IF9nZXRTZXR0ZXI7XG5cdH1cblxufVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBTklNQVRJT05cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuZXhwb3J0IGNsYXNzIEFuaW1hdGlvbiB7XG5cblx0Y29uc3RydWN0b3IodmFycykge1xuXHRcdHRoaXMudmFycyA9IHZhcnM7XG5cdFx0dGhpcy5fZGVsYXkgPSArdmFycy5kZWxheSB8fCAwO1xuXHRcdGlmICgodGhpcy5fcmVwZWF0ID0gdmFycy5yZXBlYXQgPT09IEluZmluaXR5ID8gLTIgOiB2YXJzLnJlcGVhdCB8fCAwKSkgeyAvLyBUT0RPOiByZXBlYXQ6IEluZmluaXR5IG9uIGEgdGltZWxpbmUncyBjaGlsZHJlbiBtdXN0IGZsYWcgdGhhdCB0aW1lbGluZSBpbnRlcm5hbGx5IGFuZCBhZmZlY3QgaXRzIHRvdGFsRHVyYXRpb24sIG90aGVyd2lzZSBpdCdsbCBzdG9wIGluIHRoZSBuZWdhdGl2ZSBkaXJlY3Rpb24gd2hlbiByZWFjaGluZyB0aGUgc3RhcnQuXG5cdFx0XHR0aGlzLl9yRGVsYXkgPSB2YXJzLnJlcGVhdERlbGF5IHx8IDA7XG5cdFx0XHR0aGlzLl95b3lvID0gISF2YXJzLnlveW8gfHwgISF2YXJzLnlveW9FYXNlO1xuXHRcdH1cblx0XHR0aGlzLl90cyA9IDE7XG5cdFx0X3NldER1cmF0aW9uKHRoaXMsICt2YXJzLmR1cmF0aW9uLCAxLCAxKTtcblx0XHR0aGlzLmRhdGEgPSB2YXJzLmRhdGE7XG5cdFx0X3RpY2tlckFjdGl2ZSB8fCBfdGlja2VyLndha2UoKTtcblx0fVxuXG5cdGRlbGF5KHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlIHx8IHZhbHVlID09PSAwKSB7XG5cdFx0XHR0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiAodGhpcy5zdGFydFRpbWUodGhpcy5fc3RhcnQgKyB2YWx1ZSAtIHRoaXMuX2RlbGF5KSk7XG5cdFx0XHR0aGlzLl9kZWxheSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9kZWxheTtcblx0fVxuXG5cdGR1cmF0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsRHVyYXRpb24odGhpcy5fcmVwZWF0ID4gMCA/IHZhbHVlICsgKHZhbHVlICsgdGhpcy5fckRlbGF5KSAqIHRoaXMuX3JlcGVhdCA6IHZhbHVlKSA6IHRoaXMudG90YWxEdXJhdGlvbigpICYmIHRoaXMuX2R1cjtcblx0fVxuXG5cdHRvdGFsRHVyYXRpb24odmFsdWUpIHtcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiB0aGlzLl90RHVyO1xuXHRcdH1cblx0XHR0aGlzLl9kaXJ0eSA9IDA7XG5cdFx0cmV0dXJuIF9zZXREdXJhdGlvbih0aGlzLCB0aGlzLl9yZXBlYXQgPCAwID8gdmFsdWUgOiAodmFsdWUgLSAodGhpcy5fcmVwZWF0ICogdGhpcy5fckRlbGF5KSkgLyAodGhpcy5fcmVwZWF0ICsgMSkpO1xuXHR9XG5cblx0dG90YWxUaW1lKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRfd2FrZSgpO1xuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3RUaW1lO1xuXHRcdH1cblx0XHRsZXQgcGFyZW50ID0gdGhpcy5fZHA7XG5cdFx0aWYgKHBhcmVudCAmJiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgdGhpcy5fdHMpIHtcblx0XHRcdF9hbGlnblBsYXloZWFkKHRoaXMsIHRvdGFsVGltZSk7XG5cdFx0XHQhcGFyZW50Ll9kcCB8fCBwYXJlbnQucGFyZW50IHx8IF9wb3N0QWRkQ2hlY2tzKHBhcmVudCwgdGhpcyk7IC8vIGVkZ2UgY2FzZTogaWYgdGhpcyBpcyBhIGNoaWxkIG9mIGEgdGltZWxpbmUgdGhhdCBhbHJlYWR5IGNvbXBsZXRlZCwgZm9yIGV4YW1wbGUsIHdlIG11c3QgcmUtYWN0aXZhdGUgdGhlIHBhcmVudC5cblx0XHRcdC8vaW4gY2FzZSBhbnkgb2YgdGhlIGFuY2VzdG9yIHRpbWVsaW5lcyBoYWQgY29tcGxldGVkIGJ1dCBzaG91bGQgbm93IGJlIGVuYWJsZWQsIHdlIHNob3VsZCByZXNldCB0aGVpciB0b3RhbFRpbWUoKSB3aGljaCB3aWxsIGFsc28gZW5zdXJlIHRoYXQgdGhleSdyZSBsaW5lZCB1cCBwcm9wZXJseSBhbmQgZW5hYmxlZC4gU2tpcCBmb3IgYW5pbWF0aW9ucyB0aGF0IGFyZSBvbiB0aGUgcm9vdCAod2FzdGVmdWwpLiBFeGFtcGxlOiBhIFRpbWVsaW5lTGl0ZS5leHBvcnRSb290KCkgaXMgcGVyZm9ybWVkIHdoZW4gdGhlcmUncyBhIHBhdXNlZCB0d2VlbiBvbiB0aGUgcm9vdCwgdGhlIGV4cG9ydCB3aWxsIG5vdCBjb21wbGV0ZSB1bnRpbCB0aGF0IHR3ZWVuIGlzIHVucGF1c2VkLCBidXQgaW1hZ2luZSBhIGNoaWxkIGdldHMgcmVzdGFydGVkIGxhdGVyLCBhZnRlciBhbGwgW3VucGF1c2VkXSB0d2VlbnMgaGF2ZSBjb21wbGV0ZWQuIFRoZSBzdGFydCBvZiB0aGF0IGNoaWxkIHdvdWxkIGdldCBwdXNoZWQgb3V0LCBidXQgb25lIG9mIHRoZSBhbmNlc3RvcnMgbWF5IGhhdmUgY29tcGxldGVkLlxuXHRcdFx0d2hpbGUgKHBhcmVudC5wYXJlbnQpIHtcblx0XHRcdFx0aWYgKHBhcmVudC5wYXJlbnQuX3RpbWUgIT09IHBhcmVudC5fc3RhcnQgKyAocGFyZW50Ll90cyA+PSAwID8gcGFyZW50Ll90VGltZSAvIHBhcmVudC5fdHMgOiAocGFyZW50LnRvdGFsRHVyYXRpb24oKSAtIHBhcmVudC5fdFRpbWUpIC8gLXBhcmVudC5fdHMpKSB7XG5cdFx0XHRcdFx0cGFyZW50LnRvdGFsVGltZShwYXJlbnQuX3RUaW1lLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCF0aGlzLnBhcmVudCAmJiB0aGlzLl9kcC5hdXRvUmVtb3ZlQ2hpbGRyZW4gJiYgKCh0aGlzLl90cyA+IDAgJiYgdG90YWxUaW1lIDwgdGhpcy5fdER1cikgfHwgKHRoaXMuX3RzIDwgMCAmJiB0b3RhbFRpbWUgPiAwKSB8fCAoIXRoaXMuX3REdXIgJiYgIXRvdGFsVGltZSkgKSkgeyAvL2lmIHRoZSBhbmltYXRpb24gZG9lc24ndCBoYXZlIGEgcGFyZW50LCBwdXQgaXQgYmFjayBpbnRvIGl0cyBsYXN0IHBhcmVudCAocmVjb3JkZWQgYXMgX2RwIGZvciBleGFjdGx5IGNhc2VzIGxpa2UgdGhpcykuIExpbWl0IHRvIHBhcmVudHMgd2l0aCBhdXRvUmVtb3ZlQ2hpbGRyZW4gKGxpa2UgZ2xvYmFsVGltZWxpbmUpIHNvIHRoYXQgaWYgdGhlIHVzZXIgbWFudWFsbHkgcmVtb3ZlcyBhbiBhbmltYXRpb24gZnJvbSBhIHRpbWVsaW5lIGFuZCB0aGVuIGFsdGVycyBpdHMgcGxheWhlYWQsIGl0IGRvZXNuJ3QgZ2V0IGFkZGVkIGJhY2sgaW4uXG5cdFx0XHRcdF9hZGRUb1RpbWVsaW5lKHRoaXMuX2RwLCB0aGlzLCB0aGlzLl9zdGFydCAtIHRoaXMuX2RlbGF5KTtcblx0XHRcdH1cblx0XHR9XG4gICAgICAgIGlmICh0aGlzLl90VGltZSAhPT0gdG90YWxUaW1lIHx8ICghdGhpcy5fZHVyICYmICFzdXBwcmVzc0V2ZW50cykgfHwgKHRoaXMuX2luaXR0ZWQgJiYgTWF0aC5hYnModGhpcy5felRpbWUpID09PSBfdGlueU51bSkgfHwgKCF0b3RhbFRpbWUgJiYgIXRoaXMuX2luaXR0ZWQgJiYgKHRoaXMuYWRkIHx8IHRoaXMuX3B0TG9va3VwKSkpIHsgLy8gY2hlY2sgZm9yIF9wdExvb2t1cCBvbiBhIFR3ZWVuIGluc3RhbmNlIHRvIGVuc3VyZSBpdCBoYXMgYWN0dWFsbHkgZmluaXNoZWQgYmVpbmcgaW5zdGFudGlhdGVkLCBvdGhlcndpc2UgaWYgdGhpcy5yZXZlcnNlKCkgZ2V0cyBjYWxsZWQgaW4gdGhlIEFuaW1hdGlvbiBjb25zdHJ1Y3RvciwgaXQgY291bGQgdHJpZ2dlciBhIHJlbmRlcigpIGhlcmUgZXZlbiB0aG91Z2ggdGhlIF90YXJnZXRzIHdlcmVuJ3QgcG9wdWxhdGVkLCB0aHVzIHdoZW4gX2luaXQoKSBpcyBjYWxsZWQgdGhlcmUgd29uJ3QgYmUgYW55IFByb3BUd2VlbnMgKGl0J2xsIGFjdCBsaWtlIHRoZSB0d2VlbiBpcyBub24tZnVuY3Rpb25hbClcbiAgICAgICAgXHR0aGlzLl90cyB8fCAodGhpcy5fcFRpbWUgPSB0b3RhbFRpbWUpOyAvLyBvdGhlcndpc2UsIGlmIGFuIGFuaW1hdGlvbiBpcyBwYXVzZWQsIHRoZW4gdGhlIHBsYXloZWFkIGlzIG1vdmVkIGJhY2sgdG8gemVybywgdGhlbiByZXN1bWVkLCBpdCdkIHJldmVydCBiYWNrIHRvIHRoZSBvcmlnaW5hbCB0aW1lIGF0IHRoZSBwYXVzZVxuXHQgICAgICAgIC8vaWYgKCF0aGlzLl9sb2NrKSB7IC8vIGF2b2lkIGVuZGxlc3MgcmVjdXJzaW9uIChub3Qgc3VyZSB3ZSBuZWVkIHRoaXMgeWV0IG9yIGlmIGl0J3Mgd29ydGggdGhlIHBlcmZvcm1hbmNlIGhpdClcblx0XHQgICAgLy8gICB0aGlzLl9sb2NrID0gMTtcblx0XHQgICAgICAgIF9sYXp5U2FmZVJlbmRlcih0aGlzLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHQgICAgLy8gICB0aGlzLl9sb2NrID0gMDtcblx0ICAgICAgICAvL31cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHR0aW1lKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUoKE1hdGgubWluKHRoaXMudG90YWxEdXJhdGlvbigpLCB2YWx1ZSArIF9lbGFwc2VkQ3ljbGVEdXJhdGlvbih0aGlzKSkgJSB0aGlzLl9kdXIpIHx8ICh2YWx1ZSA/IHRoaXMuX2R1ciA6IDApLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLl90aW1lOyAvLyBub3RlOiBpZiB0aGUgbW9kdWx1cyByZXN1bHRzIGluIDAsIHRoZSBwbGF5aGVhZCBjb3VsZCBiZSBleGFjdGx5IGF0IHRoZSBlbmQgb3IgdGhlIGJlZ2lubmluZywgYW5kIHdlIGFsd2F5cyBkZWZlciB0byB0aGUgRU5EIHdpdGggYSBub24temVybyB2YWx1ZSwgb3RoZXJ3aXNlIGlmIHlvdSBzZXQgdGhlIHRpbWUoKSB0byB0aGUgdmVyeSBlbmQgKGR1cmF0aW9uKCkpLCBpdCB3b3VsZCByZW5kZXIgYXQgdGhlIFNUQVJUIVxuXHR9XG5cblx0dG90YWxQcm9ncmVzcyh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKCB0aGlzLnRvdGFsRHVyYXRpb24oKSAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLnRvdGFsRHVyYXRpb24oKSA/IE1hdGgubWluKDEsIHRoaXMuX3RUaW1lIC8gdGhpcy5fdER1cikgOiB0aGlzLnJhdGlvO1xuXHR9XG5cblx0cHJvZ3Jlc3ModmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZSggdGhpcy5kdXJhdGlvbigpICogKHRoaXMuX3lveW8gJiYgISh0aGlzLml0ZXJhdGlvbigpICYgMSkgPyAxIC0gdmFsdWUgOiB2YWx1ZSkgKyBfZWxhcHNlZEN5Y2xlRHVyYXRpb24odGhpcyksIHN1cHByZXNzRXZlbnRzKSA6ICh0aGlzLmR1cmF0aW9uKCkgPyBNYXRoLm1pbigxLCB0aGlzLl90aW1lIC8gdGhpcy5fZHVyKSA6IHRoaXMucmF0aW8pO1xuXHR9XG5cblx0aXRlcmF0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdGxldCBjeWNsZUR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbigpICsgdGhpcy5fckRlbGF5O1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUodGhpcy5fdGltZSArICh2YWx1ZSAtIDEpICogY3ljbGVEdXJhdGlvbiwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy5fcmVwZWF0ID8gX2FuaW1hdGlvbkN5Y2xlKHRoaXMuX3RUaW1lLCBjeWNsZUR1cmF0aW9uKSArIDEgOiAxO1xuXHR9XG5cblx0Ly8gcG90ZW50aWFsIGZ1dHVyZSBhZGRpdGlvbjpcblx0Ly8gaXNQbGF5aW5nQmFja3dhcmRzKCkge1xuXHQvLyBcdGxldCBhbmltYXRpb24gPSB0aGlzLFxuXHQvLyBcdFx0b3JpZW50YXRpb24gPSAxOyAvLyAxID0gZm9yd2FyZCwgLTEgPSBiYWNrd2FyZFxuXHQvLyBcdHdoaWxlIChhbmltYXRpb24pIHtcblx0Ly8gXHRcdG9yaWVudGF0aW9uICo9IGFuaW1hdGlvbi5yZXZlcnNlZCgpIHx8IChhbmltYXRpb24ucmVwZWF0KCkgJiYgIShhbmltYXRpb24uaXRlcmF0aW9uKCkgJiAxKSkgPyAtMSA6IDE7XG5cdC8vIFx0XHRhbmltYXRpb24gPSBhbmltYXRpb24ucGFyZW50O1xuXHQvLyBcdH1cblx0Ly8gXHRyZXR1cm4gb3JpZW50YXRpb24gPCAwO1xuXHQvLyB9XG5cblx0dGltZVNjYWxlKHZhbHVlKSB7XG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcnRzID09PSAtX3RpbnlOdW0gPyAwIDogdGhpcy5fcnRzOyAvLyByZWNvcmRlZCB0aW1lU2NhbGUuIFNwZWNpYWwgY2FzZTogaWYgc29tZW9uZSBjYWxscyByZXZlcnNlKCkgb24gYW4gYW5pbWF0aW9uIHdpdGggdGltZVNjYWxlIG9mIDAsIHdlIGFzc2lnbiBpdCAtX3RpbnlOdW0gdG8gcmVtZW1iZXIgaXQncyByZXZlcnNlZC5cblx0XHR9XG5cdFx0aWYgKHRoaXMuX3J0cyA9PT0gdmFsdWUpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRsZXQgdFRpbWUgPSB0aGlzLnBhcmVudCAmJiB0aGlzLl90cyA/IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRoaXMucGFyZW50Ll90aW1lLCB0aGlzKSA6IHRoaXMuX3RUaW1lOyAvLyBtYWtlIHN1cmUgdG8gZG8gdGhlIHBhcmVudFRvQ2hpbGRUb3RhbFRpbWUoKSBCRUZPUkUgc2V0dGluZyB0aGUgbmV3IF90cyBiZWNhdXNlIHRoZSBvbGQgb25lIG11c3QgYmUgdXNlZCBpbiB0aGF0IGNhbGN1bGF0aW9uLlxuXG5cdFx0Ly8gZnV0dXJlIGFkZGl0aW9uPyBVcCBzaWRlOiBmYXN0IGFuZCBtaW5pbWFsIGZpbGUgc2l6ZS4gRG93biBzaWRlOiBvbmx5IHdvcmtzIG9uIHRoaXMgYW5pbWF0aW9uOyBpZiBhIHRpbWVsaW5lIGlzIHJldmVyc2VkLCBmb3IgZXhhbXBsZSwgaXRzIGNoaWxkcmVucycgb25SZXZlcnNlIHdvdWxkbid0IGdldCBjYWxsZWQuXG5cdFx0Ly8oK3ZhbHVlIDwgMCAmJiB0aGlzLl9ydHMgPj0gMCkgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25SZXZlcnNlXCIsIHRydWUpO1xuXG5cdFx0Ly8gcHJpb3JpdGl6ZSByZW5kZXJpbmcgd2hlcmUgdGhlIHBhcmVudCdzIHBsYXloZWFkIGxpbmVzIHVwIGluc3RlYWQgb2YgdGhpcy5fdFRpbWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBhIHR3ZWVuIHRoYXQncyBhbmltYXRpbmcgYW5vdGhlciB0d2VlbidzIHRpbWVTY2FsZSBpbiB0aGUgc2FtZSByZW5kZXJpbmcgbG9vcCAoc2FtZSBwYXJlbnQpLCB0aHVzIGlmIHRoZSB0aW1lU2NhbGUgdHdlZW4gcmVuZGVycyBmaXJzdCwgaXQgd291bGQgYWx0ZXIgX3N0YXJ0IEJFRk9SRSBfdFRpbWUgd2FzIHNldCBvbiB0aGF0IHRpY2sgKGluIHRoZSByZW5kZXJpbmcgbG9vcCksIGVmZmVjdGl2ZWx5IGZyZWV6aW5nIGl0IHVudGlsIHRoZSB0aW1lU2NhbGUgdHdlZW4gZmluaXNoZXMuXG5cdFx0dGhpcy5fcnRzID0gK3ZhbHVlIHx8IDA7XG5cdFx0dGhpcy5fdHMgPSAodGhpcy5fcHMgfHwgdmFsdWUgPT09IC1fdGlueU51bSkgPyAwIDogdGhpcy5fcnRzOyAvLyBfdHMgaXMgdGhlIGZ1bmN0aW9uYWwgdGltZVNjYWxlIHdoaWNoIHdvdWxkIGJlIDAgaWYgdGhlIGFuaW1hdGlvbiBpcyBwYXVzZWQuXG5cdFx0cmV0dXJuIF9yZWNhY2hlQW5jZXN0b3JzKHRoaXMudG90YWxUaW1lKF9jbGFtcCgtdGhpcy5fZGVsYXksIHRoaXMuX3REdXIsIHRUaW1lKSwgdHJ1ZSkpO1xuXHR9XG5cblx0cGF1c2VkKHZhbHVlKSB7XG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcHM7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9wcyAhPT0gdmFsdWUpIHtcblx0XHRcdHRoaXMuX3BzID0gdmFsdWU7XG5cdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0dGhpcy5fcFRpbWUgPSB0aGlzLl90VGltZSB8fCBNYXRoLm1heCgtdGhpcy5fZGVsYXksIHRoaXMucmF3VGltZSgpKTsgLy8gaWYgdGhlIHBhdXNlIG9jY3VycyBkdXJpbmcgdGhlIGRlbGF5IHBoYXNlLCBtYWtlIHN1cmUgdGhhdCdzIGZhY3RvcmVkIGluIHdoZW4gcmVzdW1pbmcuXG5cdFx0XHRcdHRoaXMuX3RzID0gdGhpcy5fYWN0ID0gMDsgLy8gX3RzIGlzIHRoZSBmdW5jdGlvbmFsIHRpbWVTY2FsZSwgc28gYSBwYXVzZWQgdHdlZW4gd291bGQgZWZmZWN0aXZlbHkgaGF2ZSBhIHRpbWVTY2FsZSBvZiAwLiBXZSByZWNvcmQgdGhlIFwicmVhbFwiIHRpbWVTY2FsZSBhcyBfcnRzIChyZWNvcmRlZCB0aW1lIHNjYWxlKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X3dha2UoKTtcblx0XHRcdFx0dGhpcy5fdHMgPSB0aGlzLl9ydHM7XG5cdFx0XHRcdC8vb25seSBkZWZlciB0byBfcFRpbWUgKHBhdXNlVGltZSkgaWYgdFRpbWUgaXMgemVyby4gUmVtZW1iZXIsIHNvbWVvbmUgY291bGQgcGF1c2UoKSBhbiBhbmltYXRpb24sIHRoZW4gc2NydWIgdGhlIHBsYXloZWFkIGFuZCByZXN1bWUoKS4gSWYgdGhlIHBhcmVudCBkb2Vzbid0IGhhdmUgc21vb3RoQ2hpbGRUaW1pbmcsIHdlIHJlbmRlciBhdCB0aGUgcmF3VGltZSgpIGJlY2F1c2UgdGhlIHN0YXJ0VGltZSB3b24ndCBnZXQgdXBkYXRlZC5cblx0XHRcdFx0dGhpcy50b3RhbFRpbWUodGhpcy5wYXJlbnQgJiYgIXRoaXMucGFyZW50LnNtb290aENoaWxkVGltaW5nID8gdGhpcy5yYXdUaW1lKCkgOiB0aGlzLl90VGltZSB8fCB0aGlzLl9wVGltZSwgKHRoaXMucHJvZ3Jlc3MoKSA9PT0gMSkgJiYgKHRoaXMuX3RUaW1lIC09IF90aW55TnVtKSAmJiBNYXRoLmFicyh0aGlzLl96VGltZSkgIT09IF90aW55TnVtKTsgLy8gZWRnZSBjYXNlOiBhbmltYXRpb24ucHJvZ3Jlc3MoMSkucGF1c2UoKS5wbGF5KCkgd291bGRuJ3QgcmVuZGVyIGFnYWluIGJlY2F1c2UgdGhlIHBsYXloZWFkIGlzIGFscmVhZHkgYXQgdGhlIGVuZCwgYnV0IHRoZSBjYWxsIHRvIHRvdGFsVGltZSgpIGJlbG93IHdpbGwgYWRkIGl0IGJhY2sgdG8gaXRzIHBhcmVudC4uLmFuZCBub3QgcmVtb3ZlIGl0IGFnYWluIChzaW5jZSByZW1vdmluZyBvbmx5IGhhcHBlbnMgdXBvbiByZW5kZXJpbmcgYXQgYSBuZXcgdGltZSkuIE9mZnNldHRpbmcgdGhlIF90VGltZSBzbGlnaHRseSBpcyBkb25lIHNpbXBseSB0byBjYXVzZSB0aGUgZmluYWwgcmVuZGVyIGluIHRvdGFsVGltZSgpIHRoYXQnbGwgcG9wIGl0IG9mZiBpdHMgdGltZWxpbmUgKGlmIGF1dG9SZW1vdmVDaGlsZHJlbiBpcyB0cnVlLCBvZiBjb3Vyc2UpLiBDaGVjayB0byBtYWtlIHN1cmUgX3pUaW1lIGlzbid0IC1fdGlueU51bSB0byBhdm9pZCBhbiBlZGdlIGNhc2Ugd2hlcmUgdGhlIHBsYXloZWFkIGlzIHB1c2hlZCB0byB0aGUgZW5kIGJ1dCBJTlNJREUgYSB0d2Vlbi9jYWxsYmFjaywgdGhlIHRpbWVsaW5lIGl0c2VsZiBpcyBwYXVzZWQgdGh1cyBoYWx0aW5nIHJlbmRlcmluZyBhbmQgbGVhdmluZyBhIGZldyB1bnJlbmRlcmVkLiBXaGVuIHJlc3VtaW5nLCBpdCB3b3VsZG4ndCByZW5kZXIgdGhvc2Ugb3RoZXJ3aXNlLlxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHN0YXJ0VGltZSh2YWx1ZSkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLl9zdGFydCA9IHZhbHVlO1xuXHRcdFx0bGV0IHBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXMuX2RwO1xuXHRcdFx0cGFyZW50ICYmIChwYXJlbnQuX3NvcnQgfHwgIXRoaXMucGFyZW50KSAmJiBfYWRkVG9UaW1lbGluZShwYXJlbnQsIHRoaXMsIHZhbHVlIC0gdGhpcy5fZGVsYXkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9zdGFydDtcblx0fVxuXG5cdGVuZFRpbWUoaW5jbHVkZVJlcGVhdHMpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3RhcnQgKyAoX2lzTm90RmFsc2UoaW5jbHVkZVJlcGVhdHMpID8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLmR1cmF0aW9uKCkpIC8gTWF0aC5hYnModGhpcy5fdHMpO1xuXHR9XG5cblx0cmF3VGltZSh3cmFwUmVwZWF0cykge1xuXHRcdGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcDsgLy8gX2RwID0gZGV0YWNoZWQgcGFyZW50XG5cdFx0cmV0dXJuICFwYXJlbnQgPyB0aGlzLl90VGltZSA6ICh3cmFwUmVwZWF0cyAmJiAoIXRoaXMuX3RzIHx8ICh0aGlzLl9yZXBlYXQgJiYgdGhpcy5fdGltZSAmJiB0aGlzLnRvdGFsUHJvZ3Jlc3MoKSA8IDEpKSkgPyB0aGlzLl90VGltZSAlICh0aGlzLl9kdXIgKyB0aGlzLl9yRGVsYXkpIDogIXRoaXMuX3RzID8gdGhpcy5fdFRpbWUgOiBfcGFyZW50VG9DaGlsZFRvdGFsVGltZShwYXJlbnQucmF3VGltZSh3cmFwUmVwZWF0cyksIHRoaXMpO1xuXHR9XG5cblx0Z2xvYmFsVGltZShyYXdUaW1lKSB7XG5cdFx0bGV0IGFuaW1hdGlvbiA9IHRoaXMsXG5cdFx0XHR0aW1lID0gYXJndW1lbnRzLmxlbmd0aCA/IHJhd1RpbWUgOiBhbmltYXRpb24ucmF3VGltZSgpO1xuXHRcdHdoaWxlIChhbmltYXRpb24pIHtcblx0XHRcdHRpbWUgPSBhbmltYXRpb24uX3N0YXJ0ICsgdGltZSAvIChhbmltYXRpb24uX3RzIHx8IDEpO1xuXHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uLl9kcDtcblx0XHR9XG5cdFx0cmV0dXJuIHRpbWU7XG5cdH1cblxuXHRyZXBlYXQodmFsdWUpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5fcmVwZWF0ID0gdmFsdWUgPT09IEluZmluaXR5ID8gLTIgOiB2YWx1ZTtcblx0XHRcdHJldHVybiBfb25VcGRhdGVUb3RhbER1cmF0aW9uKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fcmVwZWF0ID09PSAtMiA/IEluZmluaXR5IDogdGhpcy5fcmVwZWF0O1xuXHR9XG5cblx0cmVwZWF0RGVsYXkodmFsdWUpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5fckRlbGF5ID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gX29uVXBkYXRlVG90YWxEdXJhdGlvbih0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3JEZWxheTtcblx0fVxuXG5cdHlveW8odmFsdWUpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5feW95byA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl95b3lvO1xuXHR9XG5cblx0c2Vlayhwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUoX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pLCBfaXNOb3RGYWxzZShzdXBwcmVzc0V2ZW50cykpO1xuXHR9XG5cblx0cmVzdGFydChpbmNsdWRlRGVsYXksIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0cmV0dXJuIHRoaXMucGxheSgpLnRvdGFsVGltZShpbmNsdWRlRGVsYXkgPyAtdGhpcy5fZGVsYXkgOiAwLCBfaXNOb3RGYWxzZShzdXBwcmVzc0V2ZW50cykpO1xuXHR9XG5cblx0cGxheShmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdGZyb20gIT0gbnVsbCAmJiB0aGlzLnNlZWsoZnJvbSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdHJldHVybiB0aGlzLnJldmVyc2VkKGZhbHNlKS5wYXVzZWQoZmFsc2UpO1xuXHR9XG5cblx0cmV2ZXJzZShmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdGZyb20gIT0gbnVsbCAmJiB0aGlzLnNlZWsoZnJvbSB8fCB0aGlzLnRvdGFsRHVyYXRpb24oKSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdHJldHVybiB0aGlzLnJldmVyc2VkKHRydWUpLnBhdXNlZChmYWxzZSk7XG5cdH1cblxuXHRwYXVzZShhdFRpbWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0YXRUaW1lICE9IG51bGwgJiYgdGhpcy5zZWVrKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdHJldHVybiB0aGlzLnBhdXNlZCh0cnVlKTtcblx0fVxuXG5cdHJlc3VtZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXVzZWQoZmFsc2UpO1xuXHR9XG5cblx0cmV2ZXJzZWQodmFsdWUpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0ISF2YWx1ZSAhPT0gdGhpcy5yZXZlcnNlZCgpICYmIHRoaXMudGltZVNjYWxlKC10aGlzLl9ydHMgfHwgKHZhbHVlID8gLV90aW55TnVtIDogMCkpOyAvLyBpbiBjYXNlIHRpbWVTY2FsZSBpcyB6ZXJvLCByZXZlcnNpbmcgd291bGQgaGF2ZSBubyBlZmZlY3Qgc28gd2UgdXNlIF90aW55TnVtLlxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9ydHMgPCAwO1xuXHR9XG5cblx0aW52YWxpZGF0ZSgpIHtcblx0XHR0aGlzLl9pbml0dGVkID0gdGhpcy5fYWN0ID0gMDtcblx0XHR0aGlzLl96VGltZSA9IC1fdGlueU51bTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGlzQWN0aXZlKCkge1xuXHRcdGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcCxcblx0XHRcdHN0YXJ0ID0gdGhpcy5fc3RhcnQsXG5cdFx0XHRyYXdUaW1lO1xuXHRcdHJldHVybiAhISghcGFyZW50IHx8ICh0aGlzLl90cyAmJiB0aGlzLl9pbml0dGVkICYmIHBhcmVudC5pc0FjdGl2ZSgpICYmIChyYXdUaW1lID0gcGFyZW50LnJhd1RpbWUodHJ1ZSkpID49IHN0YXJ0ICYmIHJhd1RpbWUgPCB0aGlzLmVuZFRpbWUodHJ1ZSkgLSBfdGlueU51bSkpO1xuXHR9XG5cblx0ZXZlbnRDYWxsYmFjayh0eXBlLCBjYWxsYmFjaywgcGFyYW1zKSB7XG5cdFx0bGV0IHZhcnMgPSB0aGlzLnZhcnM7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRpZiAoIWNhbGxiYWNrKSB7XG5cdFx0XHRcdGRlbGV0ZSB2YXJzW3R5cGVdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyc1t0eXBlXSA9IGNhbGxiYWNrO1xuXHRcdFx0XHRwYXJhbXMgJiYgKHZhcnNbdHlwZSArIFwiUGFyYW1zXCJdID0gcGFyYW1zKTtcblx0XHRcdFx0dHlwZSA9PT0gXCJvblVwZGF0ZVwiICYmICh0aGlzLl9vblVwZGF0ZSA9IGNhbGxiYWNrKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFyc1t0eXBlXTtcblx0fVxuXG5cdHRoZW4ob25GdWxmaWxsZWQpIHtcblx0XHRsZXQgc2VsZiA9IHRoaXM7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRcdFx0bGV0IGYgPSBfaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IF9wYXNzVGhyb3VnaCxcblx0XHRcdFx0X3Jlc29sdmUgPSAoKSA9PiB7XG5cdFx0XHRcdFx0bGV0IF90aGVuID0gc2VsZi50aGVuO1xuXHRcdFx0XHRcdHNlbGYudGhlbiA9IG51bGw7IC8vIHRlbXBvcmFyaWx5IG51bGwgdGhlIHRoZW4oKSBtZXRob2QgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbnNvY2svR1NBUC9pc3N1ZXMvMzIyKVxuXHRcdFx0XHRcdF9pc0Z1bmN0aW9uKGYpICYmIChmID0gZihzZWxmKSkgJiYgKGYudGhlbiB8fCBmID09PSBzZWxmKSAmJiAoc2VsZi50aGVuID0gX3RoZW4pO1xuXHRcdFx0XHRcdHJlc29sdmUoZik7XG5cdFx0XHRcdFx0c2VsZi50aGVuID0gX3RoZW47XG5cdFx0XHRcdH07XG5cdFx0XHRpZiAoc2VsZi5faW5pdHRlZCAmJiAoc2VsZi50b3RhbFByb2dyZXNzKCkgPT09IDEgJiYgc2VsZi5fdHMgPj0gMCkgfHwgKCFzZWxmLl90VGltZSAmJiBzZWxmLl90cyA8IDApKSB7XG5cdFx0XHRcdF9yZXNvbHZlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLl9wcm9tID0gX3Jlc29sdmU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRraWxsKCkge1xuXHRcdF9pbnRlcnJ1cHQodGhpcyk7XG5cdH1cblxufVxuXG5fc2V0RGVmYXVsdHMoQW5pbWF0aW9uLnByb3RvdHlwZSwge190aW1lOjAsIF9zdGFydDowLCBfZW5kOjAsIF90VGltZTowLCBfdER1cjowLCBfZGlydHk6MCwgX3JlcGVhdDowLCBfeW95bzpmYWxzZSwgcGFyZW50Om51bGwsIF9pbml0dGVkOmZhbHNlLCBfckRlbGF5OjAsIF90czoxLCBfZHA6MCwgcmF0aW86MCwgX3pUaW1lOi1fdGlueU51bSwgX3Byb206MCwgX3BzOmZhbHNlLCBfcnRzOjF9KTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUSU1FTElORVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmV4cG9ydCBjbGFzcyBUaW1lbGluZSBleHRlbmRzIEFuaW1hdGlvbiB7XG5cblx0Y29uc3RydWN0b3IodmFycyA9IHt9LCBwb3NpdGlvbikge1xuXHRcdHN1cGVyKHZhcnMpO1xuXHRcdHRoaXMubGFiZWxzID0ge307XG5cdFx0dGhpcy5zbW9vdGhDaGlsZFRpbWluZyA9ICEhdmFycy5zbW9vdGhDaGlsZFRpbWluZztcblx0XHR0aGlzLmF1dG9SZW1vdmVDaGlsZHJlbiA9ICEhdmFycy5hdXRvUmVtb3ZlQ2hpbGRyZW47XG5cdFx0dGhpcy5fc29ydCA9IF9pc05vdEZhbHNlKHZhcnMuc29ydENoaWxkcmVuKTtcblx0XHRfZ2xvYmFsVGltZWxpbmUgJiYgX2FkZFRvVGltZWxpbmUodmFycy5wYXJlbnQgfHwgX2dsb2JhbFRpbWVsaW5lLCB0aGlzLCBwb3NpdGlvbik7XG5cdFx0dmFycy5yZXZlcnNlZCAmJiB0aGlzLnJldmVyc2UoKTtcblx0XHR2YXJzLnBhdXNlZCAmJiB0aGlzLnBhdXNlZCh0cnVlKTtcblx0XHR2YXJzLnNjcm9sbFRyaWdnZXIgJiYgX3Njcm9sbFRyaWdnZXIodGhpcywgdmFycy5zY3JvbGxUcmlnZ2VyKTtcblx0fVxuXG5cdHRvKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XG5cdFx0X2NyZWF0ZVR3ZWVuVHlwZSgwLCBhcmd1bWVudHMsIHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0ZnJvbSh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuXHRcdF9jcmVhdGVUd2VlblR5cGUoMSwgYXJndW1lbnRzLCB0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGZyb21Ubyh0YXJnZXRzLCBmcm9tVmFycywgdG9WYXJzLCBwb3NpdGlvbikge1xuXHRcdF9jcmVhdGVUd2VlblR5cGUoMiwgYXJndW1lbnRzLCB0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHNldCh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuXHRcdHZhcnMuZHVyYXRpb24gPSAwO1xuXHRcdHZhcnMucGFyZW50ID0gdGhpcztcblx0XHRfaW5oZXJpdERlZmF1bHRzKHZhcnMpLnJlcGVhdERlbGF5IHx8ICh2YXJzLnJlcGVhdCA9IDApO1xuXHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gISF2YXJzLmltbWVkaWF0ZVJlbmRlcjtcblx0XHRuZXcgVHdlZW4odGFyZ2V0cywgdmFycywgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pLCAxKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGNhbGwoY2FsbGJhY2ssIHBhcmFtcywgcG9zaXRpb24pIHtcblx0XHRyZXR1cm4gX2FkZFRvVGltZWxpbmUodGhpcywgVHdlZW4uZGVsYXllZENhbGwoMCwgY2FsbGJhY2ssIHBhcmFtcyksIHBvc2l0aW9uKTtcblx0fVxuXG5cdC8vT05MWSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSEgTWF5YmUgZGVsZXRlP1xuXHRzdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKSB7XG5cdFx0dmFycy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXHRcdHZhcnMuc3RhZ2dlciA9IHZhcnMuc3RhZ2dlciB8fCBzdGFnZ2VyO1xuXHRcdHZhcnMub25Db21wbGV0ZSA9IG9uQ29tcGxldGVBbGw7XG5cdFx0dmFycy5vbkNvbXBsZXRlUGFyYW1zID0gb25Db21wbGV0ZUFsbFBhcmFtcztcblx0XHR2YXJzLnBhcmVudCA9IHRoaXM7XG5cdFx0bmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRzdGFnZ2VyRnJvbSh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcblx0XHR2YXJzLnJ1bkJhY2t3YXJkcyA9IDE7XG5cdFx0X2luaGVyaXREZWZhdWx0cyh2YXJzKS5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZSh2YXJzLmltbWVkaWF0ZVJlbmRlcik7XG5cdFx0cmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcyk7XG5cdH1cblxuXHRzdGFnZ2VyRnJvbVRvKHRhcmdldHMsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuXHRcdHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG5cdFx0X2luaGVyaXREZWZhdWx0cyh0b1ZhcnMpLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuXHRcdHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcyk7XG5cdH1cblxuXHRyZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRsZXQgcHJldlRpbWUgPSB0aGlzLl90aW1lLFxuXHRcdFx0dER1ciA9IHRoaXMuX2RpcnR5ID8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLl90RHVyLFxuXHRcdFx0ZHVyID0gdGhpcy5fZHVyLFxuXHRcdFx0dFRpbWUgPSAodGhpcyAhPT0gX2dsb2JhbFRpbWVsaW5lICYmIHRvdGFsVGltZSA+IHREdXIgLSBfdGlueU51bSAmJiB0b3RhbFRpbWUgPj0gMCkgPyB0RHVyIDogKHRvdGFsVGltZSA8IF90aW55TnVtKSA/IDAgOiB0b3RhbFRpbWUsXG5cdFx0XHRjcm9zc2luZ1N0YXJ0ID0gKHRoaXMuX3pUaW1lIDwgMCkgIT09ICh0b3RhbFRpbWUgPCAwKSAmJiAodGhpcy5faW5pdHRlZCB8fCAhZHVyKSxcblx0XHRcdHRpbWUsIGNoaWxkLCBuZXh0LCBpdGVyYXRpb24sIGN5Y2xlRHVyYXRpb24sIHByZXZQYXVzZWQsIHBhdXNlVHdlZW4sIHRpbWVTY2FsZSwgcHJldlN0YXJ0LCBwcmV2SXRlcmF0aW9uLCB5b3lvLCBpc1lveW87XG5cdFx0aWYgKHRUaW1lICE9PSB0aGlzLl90VGltZSB8fCBmb3JjZSB8fCBjcm9zc2luZ1N0YXJ0KSB7XG5cdFx0XHRpZiAocHJldlRpbWUgIT09IHRoaXMuX3RpbWUgJiYgZHVyKSB7IC8vaWYgdG90YWxEdXJhdGlvbigpIGZpbmRzIGEgY2hpbGQgd2l0aCBhIG5lZ2F0aXZlIHN0YXJ0VGltZSBhbmQgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSwgdGhpbmdzIGdldCBzaGlmdGVkIGFyb3VuZCBpbnRlcm5hbGx5IHNvIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSB0aW1lIGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgYSB0d2VlbiBzdGFydHMgYXQgLTMwIHdlIG11c3Qgc2hpZnQgRVZFUllUSElORyBmb3J3YXJkIDMwIHNlY29uZHMgYW5kIG1vdmUgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSBiYWNrd2FyZCBieSAzMCBzZWNvbmRzIHNvIHRoYXQgdGhpbmdzIGFsaWduIHdpdGggdGhlIHBsYXloZWFkIChubyBqdW1wKS5cblx0XHRcdFx0dFRpbWUgKz0gdGhpcy5fdGltZSAtIHByZXZUaW1lO1xuXHRcdFx0XHR0b3RhbFRpbWUgKz0gdGhpcy5fdGltZSAtIHByZXZUaW1lO1xuXHRcdFx0fVxuXHRcdFx0dGltZSA9IHRUaW1lO1xuXHRcdFx0cHJldlN0YXJ0ID0gdGhpcy5fc3RhcnQ7XG5cdFx0XHR0aW1lU2NhbGUgPSB0aGlzLl90cztcblx0XHRcdHByZXZQYXVzZWQgPSAhdGltZVNjYWxlO1xuXHRcdFx0aWYgKGNyb3NzaW5nU3RhcnQpIHtcblx0XHRcdFx0ZHVyIHx8IChwcmV2VGltZSA9IHRoaXMuX3pUaW1lKTtcblx0XHRcdFx0IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUsIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuXG5cdFx0XHRcdCh0b3RhbFRpbWUgfHwgIXN1cHByZXNzRXZlbnRzKSAmJiAodGhpcy5felRpbWUgPSB0b3RhbFRpbWUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3JlcGVhdCkgeyAvL2FkanVzdCB0aGUgdGltZSBmb3IgcmVwZWF0cyBhbmQgeW95b3Ncblx0XHRcdFx0eW95byA9IHRoaXMuX3lveW87XG5cdFx0XHRcdGN5Y2xlRHVyYXRpb24gPSBkdXIgKyB0aGlzLl9yRGVsYXk7XG5cdFx0XHRcdGlmICh0aGlzLl9yZXBlYXQgPCAtMSAmJiB0b3RhbFRpbWUgPCAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKGN5Y2xlRHVyYXRpb24gKiAxMDAgKyB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGltZSA9IF9yb3VuZCh0VGltZSAlIGN5Y2xlRHVyYXRpb24pOyAvL3JvdW5kIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IGVycm9ycy4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IHNvbWUgYnJvd3NlcnMgcmVwb3J0IGl0IGFzIDAuNzk5OTk5OTkhKVxuXHRcdFx0XHRpZiAodFRpbWUgPT09IHREdXIpIHsgLy8gdGhlIHREdXIgPT09IHRUaW1lIGlzIGZvciBlZGdlIGNhc2VzIHdoZXJlIHRoZXJlJ3MgYSBsZW5ndGh5IGRlY2ltYWwgb24gdGhlIGR1cmF0aW9uIGFuZCBpdCBtYXkgcmVhY2ggdGhlIHZlcnkgZW5kIGJ1dCB0aGUgdGltZSBpcyByZW5kZXJlZCBhcyBub3QtcXVpdGUtdGhlcmUgKHJlbWVtYmVyLCB0RHVyIGlzIHJvdW5kZWQgdG8gNCBkZWNpbWFscyB3aGVyZWFzIGR1ciBpc24ndClcblx0XHRcdFx0XHRpdGVyYXRpb24gPSB0aGlzLl9yZXBlYXQ7XG5cdFx0XHRcdFx0dGltZSA9IGR1cjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpdGVyYXRpb24gPSB+fih0VGltZSAvIGN5Y2xlRHVyYXRpb24pO1xuXHRcdFx0XHRcdGlmIChpdGVyYXRpb24gJiYgaXRlcmF0aW9uID09PSB0VGltZSAvIGN5Y2xlRHVyYXRpb24pIHtcblx0XHRcdFx0XHRcdHRpbWUgPSBkdXI7XG5cdFx0XHRcdFx0XHRpdGVyYXRpb24tLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGltZSA+IGR1ciAmJiAodGltZSA9IGR1cik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJldkl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbik7XG5cdFx0XHRcdCFwcmV2VGltZSAmJiB0aGlzLl90VGltZSAmJiBwcmV2SXRlcmF0aW9uICE9PSBpdGVyYXRpb24gJiYgKHByZXZJdGVyYXRpb24gPSBpdGVyYXRpb24pOyAvLyBlZGdlIGNhc2UgLSBpZiBzb21lb25lIGRvZXMgYWRkUGF1c2UoKSBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgYSByZXBlYXRpbmcgdGltZWxpbmUsIHRoYXQgcGF1c2UgaXMgdGVjaG5pY2FsbHkgYXQgdGhlIHNhbWUgc3BvdCBhcyB0aGUgZW5kIHdoaWNoIGNhdXNlcyB0aGlzLl90aW1lIHRvIGdldCBzZXQgdG8gMCB3aGVuIHRoZSB0b3RhbFRpbWUgd291bGQgbm9ybWFsbHkgcGxhY2UgdGhlIHBsYXloZWFkIGF0IHRoZSBlbmQuIFNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIzODIzLWNsb3NpbmctbmF2LWFuaW1hdGlvbi1ub3Qtd29ya2luZy1vbi1pZS1hbmQtaXBob25lLTYtbWF5YmUtb3RoZXItb2xkZXItYnJvd3Nlci8/dGFiPWNvbW1lbnRzI2NvbW1lbnQtMTEzMDA1XG5cdFx0XHRcdGlmICh5b3lvICYmIChpdGVyYXRpb24gJiAxKSkge1xuXHRcdFx0XHRcdHRpbWUgPSBkdXIgLSB0aW1lO1xuXHRcdFx0XHRcdGlzWW95byA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0Lypcblx0XHRcdFx0bWFrZSBzdXJlIGNoaWxkcmVuIGF0IHRoZSBlbmQvYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSBhcmUgcmVuZGVyZWQgcHJvcGVybHkuIElmLCBmb3IgZXhhbXBsZSxcblx0XHRcdFx0YSAzLXNlY29uZCBsb25nIHRpbWVsaW5lIHJlbmRlcmVkIGF0IDIuOSBzZWNvbmRzIHByZXZpb3VzbHksIGFuZCBub3cgcmVuZGVycyBhdCAzLjIgc2Vjb25kcyAod2hpY2hcblx0XHRcdFx0d291bGQgZ2V0IHRyYW5zbGF0ZWQgdG8gMi44IHNlY29uZHMgaWYgdGhlIHRpbWVsaW5lIHlveW9zIG9yIDAuMiBzZWNvbmRzIGlmIGl0IGp1c3QgcmVwZWF0cyksIHRoZXJlXG5cdFx0XHRcdGNvdWxkIGJlIGEgY2FsbGJhY2sgb3IgYSBzaG9ydCB0d2VlbiB0aGF0J3MgYXQgMi45NSBvciAzIHNlY29uZHMgaW4gd2hpY2ggd291bGRuJ3QgcmVuZGVyLiBTb1xuXHRcdFx0XHR3ZSBuZWVkIHRvIHB1c2ggdGhlIHRpbWVsaW5lIHRvIHRoZSBlbmQgKGFuZC9vciBiZWdpbm5pbmcgZGVwZW5kaW5nIG9uIGl0cyB5b3lvIHZhbHVlKS4gQWxzbyB3ZSBtdXN0XG5cdFx0XHRcdGVuc3VyZSB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvciBlbmQgb2YgdGhlIFRpbWVsaW5lIHdvcmsuXG5cdFx0XHRcdCovXG5cdFx0XHRcdGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24gJiYgIXRoaXMuX2xvY2spIHtcblx0XHRcdFx0XHRsZXQgcmV3aW5kaW5nID0gKHlveW8gJiYgKHByZXZJdGVyYXRpb24gJiAxKSksXG5cdFx0XHRcdFx0XHRkb2VzV3JhcCA9IChyZXdpbmRpbmcgPT09ICh5b3lvICYmIChpdGVyYXRpb24gJiAxKSkpO1xuXHRcdFx0XHRcdGl0ZXJhdGlvbiA8IHByZXZJdGVyYXRpb24gJiYgKHJld2luZGluZyA9ICFyZXdpbmRpbmcpO1xuXHRcdFx0XHRcdHByZXZUaW1lID0gcmV3aW5kaW5nID8gMCA6IGR1cjtcblx0XHRcdFx0XHR0aGlzLl9sb2NrID0gMTtcblx0XHRcdFx0XHR0aGlzLnJlbmRlcihwcmV2VGltZSB8fCAoaXNZb3lvID8gMCA6IF9yb3VuZChpdGVyYXRpb24gKiBjeWNsZUR1cmF0aW9uKSksIHN1cHByZXNzRXZlbnRzLCAhZHVyKS5fbG9jayA9IDA7XG5cdFx0XHRcdFx0dGhpcy5fdFRpbWUgPSB0VGltZTsgLy8gaWYgYSB1c2VyIGdldHMgdGhlIGl0ZXJhdGlvbigpIGluc2lkZSB0aGUgb25SZXBlYXQsIGZvciBleGFtcGxlLCBpdCBzaG91bGQgYmUgYWNjdXJhdGUuXG5cdFx0XHRcdFx0IXN1cHByZXNzRXZlbnRzICYmIHRoaXMucGFyZW50ICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmVwZWF0XCIpO1xuXHRcdFx0XHRcdHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgKHRoaXMuaW52YWxpZGF0ZSgpLl9sb2NrID0gMSk7XG5cdFx0XHRcdFx0aWYgKChwcmV2VGltZSAmJiBwcmV2VGltZSAhPT0gdGhpcy5fdGltZSkgfHwgcHJldlBhdXNlZCAhPT0gIXRoaXMuX3RzIHx8ICh0aGlzLnZhcnMub25SZXBlYXQgJiYgIXRoaXMucGFyZW50ICYmICF0aGlzLl9hY3QpKSB7IC8vIGlmIHByZXZUaW1lIGlzIDAgYW5kIHdlIHJlbmRlciBhdCB0aGUgdmVyeSBlbmQsIF90aW1lIHdpbGwgYmUgdGhlIGVuZCwgdGh1cyB3b24ndCBtYXRjaC4gU28gaW4gdGhpcyBlZGdlIGNhc2UsIHByZXZUaW1lIHdvbid0IG1hdGNoIF90aW1lIGJ1dCB0aGF0J3Mgb2theS4gSWYgaXQgZ2V0cyBraWxsZWQgaW4gdGhlIG9uUmVwZWF0LCBlamVjdCBhcyB3ZWxsLlxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGR1ciA9IHRoaXMuX2R1cjsgLy8gaW4gY2FzZSB0aGUgZHVyYXRpb24gY2hhbmdlZCBpbiB0aGUgb25SZXBlYXRcblx0XHRcdFx0XHR0RHVyID0gdGhpcy5fdER1cjtcblx0XHRcdFx0XHRpZiAoZG9lc1dyYXApIHtcblx0XHRcdFx0XHRcdHRoaXMuX2xvY2sgPSAyO1xuXHRcdFx0XHRcdFx0cHJldlRpbWUgPSByZXdpbmRpbmcgPyBkdXIgOiAtMC4wMDAxO1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXIocHJldlRpbWUsIHRydWUpO1xuXHRcdFx0XHRcdFx0dGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgIWlzWW95byAmJiB0aGlzLmludmFsaWRhdGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fbG9jayA9IDA7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLl90cyAmJiAhcHJldlBhdXNlZCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vaW4gb3JkZXIgZm9yIHlveW9FYXNlIHRvIHdvcmsgcHJvcGVybHkgd2hlbiB0aGVyZSdzIGEgc3RhZ2dlciwgd2UgbXVzdCBzd2FwIG91dCB0aGUgZWFzZSBpbiBlYWNoIHN1Yi10d2Vlbi5cblx0XHRcdFx0XHRfcHJvcGFnYXRlWW95b0Vhc2UodGhpcywgaXNZb3lvKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2hhc1BhdXNlICYmICF0aGlzLl9mb3JjaW5nICYmIHRoaXMuX2xvY2sgPCAyKSB7XG5cdFx0XHRcdHBhdXNlVHdlZW4gPSBfZmluZE5leHRQYXVzZVR3ZWVuKHRoaXMsIF9yb3VuZChwcmV2VGltZSksIF9yb3VuZCh0aW1lKSk7XG5cdFx0XHRcdGlmIChwYXVzZVR3ZWVuKSB7XG5cdFx0XHRcdFx0dFRpbWUgLT0gdGltZSAtICh0aW1lID0gcGF1c2VUd2Vlbi5fc3RhcnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3RUaW1lID0gdFRpbWU7XG5cdFx0XHR0aGlzLl90aW1lID0gdGltZTtcblx0XHRcdHRoaXMuX2FjdCA9ICF0aW1lU2NhbGU7IC8vYXMgbG9uZyBhcyBpdCdzIG5vdCBwYXVzZWQsIGZvcmNlIGl0IHRvIGJlIGFjdGl2ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgaW5kZXBlbmRlbnQgb2YgdGhlIHBhcmVudCB0aW1lbGluZSwgaXQnbGwgYmUgZm9yY2VkIHRvIHJlLXJlbmRlciBvbiB0aGUgbmV4dCB0aWNrLlxuXG5cdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0dGhpcy5fb25VcGRhdGUgPSB0aGlzLnZhcnMub25VcGRhdGU7XG5cdFx0XHRcdHRoaXMuX2luaXR0ZWQgPSAxO1xuXHRcdFx0XHR0aGlzLl96VGltZSA9IHRvdGFsVGltZTtcblx0XHRcdFx0cHJldlRpbWUgPSAwOyAvLyB1cG9uIGluaXQsIHRoZSBwbGF5aGVhZCBzaG91bGQgYWx3YXlzIGdvIGZvcndhcmQ7IHNvbWVvbmUgY291bGQgaW52YWxpZGF0ZSgpIGEgY29tcGxldGVkIHRpbWVsaW5lIGFuZCB0aGVuIGlmIHRoZXkgcmVzdGFydCgpLCB0aGF0IHdvdWxkIG1ha2UgY2hpbGQgdHdlZW5zIHJlbmRlciBpbiByZXZlcnNlIG9yZGVyIHdoaWNoIGNvdWxkIGxvY2sgaW4gdGhlIHdyb25nIHN0YXJ0aW5nIHZhbHVlcyBpZiB0aGV5IGJ1aWxkIG9uIGVhY2ggb3RoZXIsIGxpa2UgdGwudG8ob2JqLCB7eDogMTAwfSkudG8ob2JqLCB7eDogMH0pLlxuXHRcdFx0fVxuXHRcdFx0aWYgKCFwcmV2VGltZSAmJiB0aW1lICYmICFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRfY2FsbGJhY2sodGhpcywgXCJvblN0YXJ0XCIpO1xuXHRcdFx0XHRpZiAodGhpcy5fdFRpbWUgIT09IHRUaW1lKSB7IC8vIGluIGNhc2UgdGhlIG9uU3RhcnQgdHJpZ2dlcmVkIGEgcmVuZGVyIGF0IGEgZGlmZmVyZW50IHNwb3QsIGVqZWN0LiBMaWtlIGlmIHNvbWVvbmUgZGlkIGFuaW1hdGlvbi5wYXVzZSgwLjUpIG9yIHNvbWV0aGluZyBpbnNpZGUgdGhlIG9uU3RhcnQuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aW1lID49IHByZXZUaW1lICYmIHRvdGFsVGltZSA+PSAwKSB7XG5cdFx0XHRcdGNoaWxkID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdHdoaWxlIChjaGlsZCkge1xuXHRcdFx0XHRcdG5leHQgPSBjaGlsZC5fbmV4dDtcblx0XHRcdFx0XHRpZiAoKGNoaWxkLl9hY3QgfHwgdGltZSA+PSBjaGlsZC5fc3RhcnQpICYmIGNoaWxkLl90cyAmJiBwYXVzZVR3ZWVuICE9PSBjaGlsZCkge1xuXHRcdFx0XHRcdFx0aWYgKGNoaWxkLnBhcmVudCAhPT0gdGhpcykgeyAvLyBhbiBleHRyZW1lIGVkZ2UgY2FzZSAtIHRoZSBjaGlsZCdzIHJlbmRlciBjb3VsZCBkbyBzb21ldGhpbmcgbGlrZSBraWxsKCkgdGhlIFwibmV4dFwiIG9uZSBpbiB0aGUgbGlua2VkIGxpc3QsIG9yIHJlcGFyZW50IGl0LiBJbiB0aGF0IGNhc2Ugd2UgbXVzdCByZS1pbml0aWF0ZSB0aGUgd2hvbGUgcmVuZGVyIHRvIGJlIHNhZmUuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjaGlsZC5yZW5kZXIoY2hpbGQuX3RzID4gMCA/ICh0aW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cyA6IChjaGlsZC5fZGlydHkgPyBjaGlsZC50b3RhbER1cmF0aW9uKCkgOiBjaGlsZC5fdER1cikgKyAodGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHRpZiAodGltZSAhPT0gdGhpcy5fdGltZSB8fCAoIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSkgeyAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgb3Igc2Vla3MgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nLCBsaWtlIGluc2lkZSBvZiBhbiBvblVwZGF0ZS9vbkNvbXBsZXRlXG5cdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSAwO1xuXHRcdFx0XHRcdFx0XHRuZXh0ICYmICh0VGltZSArPSAodGhpcy5felRpbWUgPSAtX3RpbnlOdW0pKTsgIC8vIGl0IGRpZG4ndCBmaW5pc2ggcmVuZGVyaW5nLCBzbyBmbGFnIHpUaW1lIGFzIG5lZ2F0aXZlIHNvIHRoYXQgc28gdGhhdCB0aGUgbmV4dCB0aW1lIHJlbmRlcigpIGlzIGNhbGxlZCBpdCdsbCBiZSBmb3JjZWQgKHRvIHJlbmRlciBhbnkgcmVtYWluaW5nIGNoaWxkcmVuKVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2hpbGQgPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaGlsZCA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRcdGxldCBhZGp1c3RlZFRpbWUgPSB0b3RhbFRpbWUgPCAwID8gdG90YWxUaW1lIDogdGltZTsgLy93aGVuIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIGJleW9uZCB0aGUgc3RhcnQgb2YgdGhpcyB0aW1lbGluZSwgd2UgbXVzdCBwYXNzIHRoYXQgaW5mb3JtYXRpb24gZG93biB0byB0aGUgY2hpbGQgYW5pbWF0aW9ucyBzbyB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIGtub3cgd2hldGhlciB0byByZW5kZXIgdGhlaXIgc3RhcnRpbmcgb3IgZW5kaW5nIHZhbHVlcy5cblx0XHRcdFx0d2hpbGUgKGNoaWxkKSB7XG5cdFx0XHRcdFx0bmV4dCA9IGNoaWxkLl9wcmV2O1xuXHRcdFx0XHRcdGlmICgoY2hpbGQuX2FjdCB8fCBhZGp1c3RlZFRpbWUgPD0gY2hpbGQuX2VuZCkgJiYgY2hpbGQuX3RzICYmIHBhdXNlVHdlZW4gIT09IGNoaWxkKSB7XG5cdFx0XHRcdFx0XHRpZiAoY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7IC8vIGFuIGV4dHJlbWUgZWRnZSBjYXNlIC0gdGhlIGNoaWxkJ3MgcmVuZGVyIGNvdWxkIGRvIHNvbWV0aGluZyBsaWtlIGtpbGwoKSB0aGUgXCJuZXh0XCIgb25lIGluIHRoZSBsaW5rZWQgbGlzdCwgb3IgcmVwYXJlbnQgaXQuIEluIHRoYXQgY2FzZSB3ZSBtdXN0IHJlLWluaXRpYXRlIHRoZSB3aG9sZSByZW5kZXIgdG8gYmUgc2FmZS5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNoaWxkLnJlbmRlcihjaGlsZC5fdHMgPiAwID8gKGFkanVzdGVkVGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgOiAoY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpICsgKGFkanVzdGVkVGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHRpZiAodGltZSAhPT0gdGhpcy5fdGltZSB8fCAoIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSkgeyAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgb3Igc2Vla3MgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nLCBsaWtlIGluc2lkZSBvZiBhbiBvblVwZGF0ZS9vbkNvbXBsZXRlXG5cdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSAwO1xuXHRcdFx0XHRcdFx0XHRuZXh0ICYmICh0VGltZSArPSAodGhpcy5felRpbWUgPSBhZGp1c3RlZFRpbWUgPyAtX3RpbnlOdW0gOiBfdGlueU51bSkpOyAvLyBpdCBkaWRuJ3QgZmluaXNoIHJlbmRlcmluZywgc28gYWRqdXN0IHpUaW1lIHNvIHRoYXQgc28gdGhhdCB0aGUgbmV4dCB0aW1lIHJlbmRlcigpIGlzIGNhbGxlZCBpdCdsbCBiZSBmb3JjZWQgKHRvIHJlbmRlciBhbnkgcmVtYWluaW5nIGNoaWxkcmVuKVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2hpbGQgPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAocGF1c2VUd2VlbiAmJiAhc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdFx0XHRwYXVzZVR3ZWVuLnJlbmRlcih0aW1lID49IHByZXZUaW1lID8gMCA6IC1fdGlueU51bSkuX3pUaW1lID0gdGltZSA+PSBwcmV2VGltZSA/IDEgOiAtMTtcblx0XHRcdFx0aWYgKHRoaXMuX3RzKSB7IC8vdGhlIGNhbGxiYWNrIHJlc3VtZWQgcGxheWJhY2shIFNvIHNpbmNlIHdlIG1heSBoYXZlIGhlbGQgYmFjayB0aGUgcGxheWhlYWQgZHVlIHRvIHdoZXJlIHRoZSBwYXVzZSBpcyBwb3NpdGlvbmVkLCBnbyBhaGVhZCBhbmQganVtcCB0byB3aGVyZSBpdCdzIFNVUFBPU0VEIHRvIGJlIChpZiBubyBwYXVzZSBoYXBwZW5lZCkuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnQgPSBwcmV2U3RhcnQ7IC8vaWYgdGhlIHBhdXNlIHdhcyBhdCBhbiBlYXJsaWVyIHRpbWUgYW5kIHRoZSB1c2VyIHJlc3VtZWQgaW4gdGhlIGNhbGxiYWNrLCBpdCBjb3VsZCByZXBvc2l0aW9uIHRoZSB0aW1lbGluZSAoY2hhbmdpbmcgaXRzIHN0YXJ0VGltZSksIHRocm93aW5nIHRoaW5ncyBvZmYgc2xpZ2h0bHksIHNvIHdlIG1ha2Ugc3VyZSB0aGUgX3N0YXJ0IGRvZXNuJ3Qgc2hpZnQuXG5cdFx0XHRcdFx0X3NldEVuZCh0aGlzKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9vblVwZGF0ZSAmJiAhc3VwcHJlc3NFdmVudHMgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25VcGRhdGVcIiwgdHJ1ZSk7XG5cdFx0XHRpZiAoKHRUaW1lID09PSB0RHVyICYmIHREdXIgPj0gdGhpcy50b3RhbER1cmF0aW9uKCkpIHx8ICghdFRpbWUgJiYgcHJldlRpbWUpKSBpZiAocHJldlN0YXJ0ID09PSB0aGlzLl9zdGFydCB8fCBNYXRoLmFicyh0aW1lU2NhbGUpICE9PSBNYXRoLmFicyh0aGlzLl90cykpIGlmICghdGhpcy5fbG9jaykge1xuXHRcdFx0XHQodG90YWxUaW1lIHx8ICFkdXIpICYmICgodFRpbWUgPT09IHREdXIgJiYgdGhpcy5fdHMgPiAwKSB8fCAoIXRUaW1lICYmIHRoaXMuX3RzIDwgMCkpICYmIF9yZW1vdmVGcm9tUGFyZW50KHRoaXMsIDEpOyAvLyBkb24ndCByZW1vdmUgaWYgdGhlIHRpbWVsaW5lIGlzIHJldmVyc2VkIGFuZCB0aGUgcGxheWhlYWQgaXNuJ3QgYXQgMCwgb3RoZXJ3aXNlIHRsLnByb2dyZXNzKDEpLnJldmVyc2UoKSB3b24ndCB3b3JrLiBPbmx5IHJlbW92ZSBpZiB0aGUgcGxheWhlYWQgaXMgYXQgdGhlIGVuZCBhbmQgdGltZVNjYWxlIGlzIHBvc2l0aXZlLCBvciBpZiB0aGUgcGxheWhlYWQgaXMgYXQgMCBhbmQgdGhlIHRpbWVTY2FsZSBpcyBuZWdhdGl2ZS5cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiAhKHRvdGFsVGltZSA8IDAgJiYgIXByZXZUaW1lKSAmJiAodFRpbWUgfHwgcHJldlRpbWUgfHwgIXREdXIpKSB7XG5cdFx0XHRcdFx0X2NhbGxiYWNrKHRoaXMsICh0VGltZSA9PT0gdER1ciAmJiB0b3RhbFRpbWUgPj0gMCA/IFwib25Db21wbGV0ZVwiIDogXCJvblJldmVyc2VDb21wbGV0ZVwiKSwgdHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5fcHJvbSAmJiAhKHRUaW1lIDwgdER1ciAmJiB0aGlzLnRpbWVTY2FsZSgpID4gMCkgJiYgdGhpcy5fcHJvbSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0YWRkKGNoaWxkLCBwb3NpdGlvbikge1xuXHRcdF9pc051bWJlcihwb3NpdGlvbikgfHwgKHBvc2l0aW9uID0gX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24sIGNoaWxkKSk7XG5cdFx0aWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBBbmltYXRpb24pKSB7XG5cdFx0XHRpZiAoX2lzQXJyYXkoY2hpbGQpKSB7XG5cdFx0XHRcdGNoaWxkLmZvckVhY2gob2JqID0+IHRoaXMuYWRkKG9iaiwgcG9zaXRpb24pKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0XHRpZiAoX2lzU3RyaW5nKGNoaWxkKSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5hZGRMYWJlbChjaGlsZCwgcG9zaXRpb24pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKF9pc0Z1bmN0aW9uKGNoaWxkKSkge1xuXHRcdFx0XHRjaGlsZCA9IFR3ZWVuLmRlbGF5ZWRDYWxsKDAsIGNoaWxkKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcyAhPT0gY2hpbGQgPyBfYWRkVG9UaW1lbGluZSh0aGlzLCBjaGlsZCwgcG9zaXRpb24pIDogdGhpczsgLy9kb24ndCBhbGxvdyBhIHRpbWVsaW5lIHRvIGJlIGFkZGVkIHRvIGl0c2VsZiBhcyBhIGNoaWxkIVxuXHR9XG5cblx0Z2V0Q2hpbGRyZW4obmVzdGVkID0gdHJ1ZSwgdHdlZW5zID0gdHJ1ZSwgdGltZWxpbmVzID0gdHJ1ZSwgaWdub3JlQmVmb3JlVGltZSA9IC1fYmlnTnVtKSB7XG5cdFx0bGV0IGEgPSBbXSxcblx0XHRcdGNoaWxkID0gdGhpcy5fZmlyc3Q7XG5cdFx0d2hpbGUgKGNoaWxkKSB7XG5cdFx0XHRpZiAoY2hpbGQuX3N0YXJ0ID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdFx0aWYgKGNoaWxkIGluc3RhbmNlb2YgVHdlZW4pIHtcblx0XHRcdFx0XHR0d2VlbnMgJiYgYS5wdXNoKGNoaWxkKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aW1lbGluZXMgJiYgYS5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHRuZXN0ZWQgJiYgYS5wdXNoKC4uLmNoaWxkLmdldENoaWxkcmVuKHRydWUsIHR3ZWVucywgdGltZWxpbmVzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNoaWxkID0gY2hpbGQuX25leHQ7XG5cdFx0fVxuXHRcdHJldHVybiBhO1xuXHR9XG5cblx0Z2V0QnlJZChpZCkge1xuXHRcdGxldCBhbmltYXRpb25zID0gdGhpcy5nZXRDaGlsZHJlbigxLCAxLCAxKSxcblx0XHRcdGkgPSBhbmltYXRpb25zLmxlbmd0aDtcblx0XHR3aGlsZShpLS0pIHtcblx0XHRcdGlmIChhbmltYXRpb25zW2ldLnZhcnMuaWQgPT09IGlkKSB7XG5cdFx0XHRcdHJldHVybiBhbmltYXRpb25zW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJlbW92ZShjaGlsZCkge1xuXHRcdGlmIChfaXNTdHJpbmcoY2hpbGQpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmVMYWJlbChjaGlsZCk7XG5cdFx0fVxuXHRcdGlmIChfaXNGdW5jdGlvbihjaGlsZCkpIHtcblx0XHRcdHJldHVybiB0aGlzLmtpbGxUd2VlbnNPZihjaGlsZCk7XG5cdFx0fVxuXHRcdF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBjaGlsZCk7XG5cdFx0aWYgKGNoaWxkID09PSB0aGlzLl9yZWNlbnQpIHtcblx0XHRcdHRoaXMuX3JlY2VudCA9IHRoaXMuX2xhc3Q7XG5cdFx0fVxuXHRcdHJldHVybiBfdW5jYWNoZSh0aGlzKTtcblx0fVxuXG5cdHRvdGFsVGltZSh0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdFRpbWU7XG5cdFx0fVxuXHRcdHRoaXMuX2ZvcmNpbmcgPSAxO1xuXHRcdGlmICghdGhpcy5fZHAgJiYgdGhpcy5fdHMpIHsgLy9zcGVjaWFsIGNhc2UgZm9yIHRoZSBnbG9iYWwgdGltZWxpbmUgKG9yIGFueSBvdGhlciB0aGF0IGhhcyBubyBwYXJlbnQgb3IgZGV0YWNoZWQgcGFyZW50KS5cblx0XHRcdHRoaXMuX3N0YXJ0ID0gX3JvdW5kKF90aWNrZXIudGltZSAtICh0aGlzLl90cyA+IDAgPyB0b3RhbFRpbWUgLyB0aGlzLl90cyA6ICh0aGlzLnRvdGFsRHVyYXRpb24oKSAtIHRvdGFsVGltZSkgLyAtdGhpcy5fdHMpKTtcblx0XHR9XG5cdFx0c3VwZXIudG90YWxUaW1lKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdHRoaXMuX2ZvcmNpbmcgPSAwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0YWRkTGFiZWwobGFiZWwsIHBvc2l0aW9uKSB7XG5cdFx0dGhpcy5sYWJlbHNbbGFiZWxdID0gX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0cmVtb3ZlTGFiZWwobGFiZWwpIHtcblx0XHRkZWxldGUgdGhpcy5sYWJlbHNbbGFiZWxdO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0YWRkUGF1c2UocG9zaXRpb24sIGNhbGxiYWNrLCBwYXJhbXMpIHtcblx0XHRsZXQgdCA9IFR3ZWVuLmRlbGF5ZWRDYWxsKDAsIGNhbGxiYWNrIHx8IF9lbXB0eUZ1bmMsIHBhcmFtcyk7XG5cdFx0dC5kYXRhID0gXCJpc1BhdXNlXCI7XG5cdFx0dGhpcy5faGFzUGF1c2UgPSAxO1xuXHRcdHJldHVybiBfYWRkVG9UaW1lbGluZSh0aGlzLCB0LCBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbikpO1xuXHR9XG5cblx0cmVtb3ZlUGF1c2UocG9zaXRpb24pIHtcblx0XHRsZXQgY2hpbGQgPSB0aGlzLl9maXJzdDtcblx0XHRwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcblx0XHR3aGlsZSAoY2hpbGQpIHtcblx0XHRcdGlmIChjaGlsZC5fc3RhcnQgPT09IHBvc2l0aW9uICYmIGNoaWxkLmRhdGEgPT09IFwiaXNQYXVzZVwiKSB7XG5cdFx0XHRcdF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkKTtcblx0XHRcdH1cblx0XHRcdGNoaWxkID0gY2hpbGQuX25leHQ7XG5cdFx0fVxuXHR9XG5cblx0a2lsbFR3ZWVuc09mKHRhcmdldHMsIHByb3BzLCBvbmx5QWN0aXZlKSB7XG5cdFx0bGV0IHR3ZWVucyA9IHRoaXMuZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSksXG5cdFx0XHRpID0gdHdlZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHQoX292ZXJ3cml0aW5nVHdlZW4gIT09IHR3ZWVuc1tpXSkgJiYgdHdlZW5zW2ldLmtpbGwodGFyZ2V0cywgcHJvcHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpIHtcblx0XHRsZXQgYSA9IFtdLFxuXHRcdFx0cGFyc2VkVGFyZ2V0cyA9IHRvQXJyYXkodGFyZ2V0cyksXG5cdFx0XHRjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuXHRcdFx0aXNHbG9iYWxUaW1lID0gX2lzTnVtYmVyKG9ubHlBY3RpdmUpLCAvLyBhIG51bWJlciBpcyBpbnRlcnByZXRlZCBhcyBhIGdsb2JhbCB0aW1lLiBJZiB0aGUgYW5pbWF0aW9uIHNwYW5zXG5cdFx0XHRjaGlsZHJlbjtcblx0XHR3aGlsZSAoY2hpbGQpIHtcblx0XHRcdGlmIChjaGlsZCBpbnN0YW5jZW9mIFR3ZWVuKSB7XG5cdFx0XHRcdGlmIChfYXJyYXlDb250YWluc0FueShjaGlsZC5fdGFyZ2V0cywgcGFyc2VkVGFyZ2V0cykgJiYgKGlzR2xvYmFsVGltZSA/ICghX292ZXJ3cml0aW5nVHdlZW4gfHwgKGNoaWxkLl9pbml0dGVkICYmIGNoaWxkLl90cykpICYmIGNoaWxkLmdsb2JhbFRpbWUoMCkgPD0gb25seUFjdGl2ZSAmJiBjaGlsZC5nbG9iYWxUaW1lKGNoaWxkLnRvdGFsRHVyYXRpb24oKSkgPiBvbmx5QWN0aXZlIDogIW9ubHlBY3RpdmUgfHwgY2hpbGQuaXNBY3RpdmUoKSkpIHsgLy8gbm90ZTogaWYgdGhpcyBpcyBmb3Igb3ZlcndyaXRpbmcsIGl0IHNob3VsZCBvbmx5IGJlIGZvciB0d2VlbnMgdGhhdCBhcmVuJ3QgcGF1c2VkIGFuZCBhcmUgaW5pdHRlZC5cblx0XHRcdFx0XHRhLnB1c2goY2hpbGQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKChjaGlsZHJlbiA9IGNoaWxkLmdldFR3ZWVuc09mKHBhcnNlZFRhcmdldHMsIG9ubHlBY3RpdmUpKS5sZW5ndGgpIHtcblx0XHRcdFx0YS5wdXNoKC4uLmNoaWxkcmVuKTtcblx0XHRcdH1cblx0XHRcdGNoaWxkID0gY2hpbGQuX25leHQ7XG5cdFx0fVxuXHRcdHJldHVybiBhO1xuXHR9XG5cblx0Ly8gcG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlIC0gdGFyZ2V0cygpIG9uIHRpbWVsaW5lc1xuXHQvLyB0YXJnZXRzKCkge1xuXHQvLyBcdGxldCByZXN1bHQgPSBbXTtcblx0Ly8gXHR0aGlzLmdldENoaWxkcmVuKHRydWUsIHRydWUsIGZhbHNlKS5mb3JFYWNoKHQgPT4gcmVzdWx0LnB1c2goLi4udC50YXJnZXRzKCkpKTtcblx0Ly8gXHRyZXR1cm4gcmVzdWx0LmZpbHRlcigodiwgaSkgPT4gcmVzdWx0LmluZGV4T2YodikgPT09IGkpO1xuXHQvLyB9XG5cblx0dHdlZW5Ubyhwb3NpdGlvbiwgdmFycykge1xuXHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdGxldCB0bCA9IHRoaXMsXG5cdFx0XHRlbmRUaW1lID0gX3BhcnNlUG9zaXRpb24odGwsIHBvc2l0aW9uKSxcblx0XHRcdHsgc3RhcnRBdCwgb25TdGFydCwgb25TdGFydFBhcmFtcywgaW1tZWRpYXRlUmVuZGVyIH0gPSB2YXJzLFxuXHRcdFx0aW5pdHRlZCxcblx0XHRcdHR3ZWVuID0gVHdlZW4udG8odGwsIF9zZXREZWZhdWx0cyh7XG5cdFx0XHRcdGVhc2U6IHZhcnMuZWFzZSB8fCBcIm5vbmVcIixcblx0XHRcdFx0bGF6eTogZmFsc2UsXG5cdFx0XHRcdGltbWVkaWF0ZVJlbmRlcjogZmFsc2UsXG5cdFx0XHRcdHRpbWU6IGVuZFRpbWUsXG5cdFx0XHRcdG92ZXJ3cml0ZTogXCJhdXRvXCIsXG5cdFx0XHRcdGR1cmF0aW9uOiB2YXJzLmR1cmF0aW9uIHx8IChNYXRoLmFicygoZW5kVGltZSAtICgoc3RhcnRBdCAmJiBcInRpbWVcIiBpbiBzdGFydEF0KSA/IHN0YXJ0QXQudGltZSA6IHRsLl90aW1lKSkgLyB0bC50aW1lU2NhbGUoKSkpIHx8IF90aW55TnVtLFxuXHRcdFx0XHRvblN0YXJ0OiAoKSA9PiB7XG5cdFx0XHRcdFx0dGwucGF1c2UoKTtcblx0XHRcdFx0XHRpZiAoIWluaXR0ZWQpIHtcblx0XHRcdFx0XHRcdGxldCBkdXJhdGlvbiA9IHZhcnMuZHVyYXRpb24gfHwgTWF0aC5hYnMoKGVuZFRpbWUgLSAoKHN0YXJ0QXQgJiYgXCJ0aW1lXCIgaW4gc3RhcnRBdCkgPyBzdGFydEF0LnRpbWUgOiB0bC5fdGltZSkpIC8gdGwudGltZVNjYWxlKCkpO1xuXHRcdFx0XHRcdFx0KHR3ZWVuLl9kdXIgIT09IGR1cmF0aW9uKSAmJiBfc2V0RHVyYXRpb24odHdlZW4sIGR1cmF0aW9uLCAwLCAxKS5yZW5kZXIodHdlZW4uX3RpbWUsIHRydWUsIHRydWUpO1xuXHRcdFx0XHRcdFx0aW5pdHRlZCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG9uU3RhcnQgJiYgb25TdGFydC5hcHBseSh0d2Vlbiwgb25TdGFydFBhcmFtcyB8fCBbXSk7IC8vaW4gY2FzZSB0aGUgdXNlciBoYWQgYW4gb25TdGFydCBpbiB0aGUgdmFycyAtIHdlIGRvbid0IHdhbnQgdG8gb3ZlcndyaXRlIGl0LlxuXHRcdFx0XHR9XG5cdFx0XHR9LCB2YXJzKSk7XG5cdFx0cmV0dXJuIGltbWVkaWF0ZVJlbmRlciA/IHR3ZWVuLnJlbmRlcigwKSA6IHR3ZWVuO1xuXHR9XG5cblx0dHdlZW5Gcm9tVG8oZnJvbVBvc2l0aW9uLCB0b1Bvc2l0aW9uLCB2YXJzKSB7XG5cdFx0cmV0dXJuIHRoaXMudHdlZW5Ubyh0b1Bvc2l0aW9uLCBfc2V0RGVmYXVsdHMoe3N0YXJ0QXQ6e3RpbWU6X3BhcnNlUG9zaXRpb24odGhpcywgZnJvbVBvc2l0aW9uKX19LCB2YXJzKSk7XG5cdH1cblxuXHRyZWNlbnQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JlY2VudDtcblx0fVxuXG5cdG5leHRMYWJlbChhZnRlclRpbWUgPSB0aGlzLl90aW1lKSB7XG5cdFx0cmV0dXJuIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRoaXMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIGFmdGVyVGltZSkpO1xuXHR9XG5cblx0cHJldmlvdXNMYWJlbChiZWZvcmVUaW1lID0gdGhpcy5fdGltZSkge1xuXHRcdHJldHVybiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aGlzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBiZWZvcmVUaW1lKSwgMSk7XG5cdH1cblxuXHRjdXJyZW50TGFiZWwodmFsdWUpIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuc2Vlayh2YWx1ZSwgdHJ1ZSkgOiB0aGlzLnByZXZpb3VzTGFiZWwodGhpcy5fdGltZSArIF90aW55TnVtKTtcblx0fVxuXG5cdHNoaWZ0Q2hpbGRyZW4oYW1vdW50LCBhZGp1c3RMYWJlbHMsIGlnbm9yZUJlZm9yZVRpbWUgPSAwKSB7XG5cdFx0bGV0IGNoaWxkID0gdGhpcy5fZmlyc3QsXG5cdFx0XHRsYWJlbHMgPSB0aGlzLmxhYmVscyxcblx0XHRcdHA7XG5cdFx0d2hpbGUgKGNoaWxkKSB7XG5cdFx0XHRpZiAoY2hpbGQuX3N0YXJ0ID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdFx0Y2hpbGQuX3N0YXJ0ICs9IGFtb3VudDtcblx0XHRcdFx0Y2hpbGQuX2VuZCArPSBhbW91bnQ7XG5cdFx0XHR9XG5cdFx0XHRjaGlsZCA9IGNoaWxkLl9uZXh0O1xuXHRcdH1cblx0XHRpZiAoYWRqdXN0TGFiZWxzKSB7XG5cdFx0XHRmb3IgKHAgaW4gbGFiZWxzKSB7XG5cdFx0XHRcdGlmIChsYWJlbHNbcF0gPj0gaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0XHRcdGxhYmVsc1twXSArPSBhbW91bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuXHR9XG5cblx0aW52YWxpZGF0ZSgpIHtcblx0XHRsZXQgY2hpbGQgPSB0aGlzLl9maXJzdDtcblx0XHR0aGlzLl9sb2NrID0gMDtcblx0XHR3aGlsZSAoY2hpbGQpIHtcblx0XHRcdGNoaWxkLmludmFsaWRhdGUoKTtcblx0XHRcdGNoaWxkID0gY2hpbGQuX25leHQ7XG5cdFx0fVxuXHRcdHJldHVybiBzdXBlci5pbnZhbGlkYXRlKCk7XG5cdH1cblxuXHRjbGVhcihpbmNsdWRlTGFiZWxzID0gdHJ1ZSkge1xuXHRcdGxldCBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuXHRcdFx0bmV4dDtcblx0XHR3aGlsZSAoY2hpbGQpIHtcblx0XHRcdG5leHQgPSBjaGlsZC5fbmV4dDtcblx0XHRcdHRoaXMucmVtb3ZlKGNoaWxkKTtcblx0XHRcdGNoaWxkID0gbmV4dDtcblx0XHR9XG5cdFx0dGhpcy5fZHAgJiYgKHRoaXMuX3RpbWUgPSB0aGlzLl90VGltZSA9IHRoaXMuX3BUaW1lID0gMCk7XG5cdFx0aW5jbHVkZUxhYmVscyAmJiAodGhpcy5sYWJlbHMgPSB7fSk7XG5cdFx0cmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuXHR9XG5cblx0dG90YWxEdXJhdGlvbih2YWx1ZSkge1xuXHRcdGxldCBtYXggPSAwLFxuXHRcdFx0c2VsZiA9IHRoaXMsXG5cdFx0XHRjaGlsZCA9IHNlbGYuX2xhc3QsXG5cdFx0XHRwcmV2U3RhcnQgPSBfYmlnTnVtLFxuXHRcdFx0cHJldiwgc3RhcnQsIHBhcmVudDtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHNlbGYudGltZVNjYWxlKChzZWxmLl9yZXBlYXQgPCAwID8gc2VsZi5kdXJhdGlvbigpIDogc2VsZi50b3RhbER1cmF0aW9uKCkpIC8gKHNlbGYucmV2ZXJzZWQoKSA/IC12YWx1ZSA6IHZhbHVlKSk7XG5cdFx0fVxuXHRcdGlmIChzZWxmLl9kaXJ0eSkge1xuXHRcdFx0cGFyZW50ID0gc2VsZi5wYXJlbnQ7XG5cdFx0XHR3aGlsZSAoY2hpbGQpIHtcblx0XHRcdFx0cHJldiA9IGNoaWxkLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGluIGNhc2UgdGhlIHR3ZWVuIGNoYW5nZXMgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlLi4uXG5cdFx0XHRcdGNoaWxkLl9kaXJ0eSAmJiBjaGlsZC50b3RhbER1cmF0aW9uKCk7IC8vY291bGQgY2hhbmdlIHRoZSB0d2Vlbi5fc3RhcnRUaW1lLCBzbyBtYWtlIHN1cmUgdGhlIGFuaW1hdGlvbidzIGNhY2hlIGlzIGNsZWFuIGJlZm9yZSBhbmFseXppbmcgaXQuXG5cdFx0XHRcdHN0YXJ0ID0gY2hpbGQuX3N0YXJ0O1xuXHRcdFx0XHRpZiAoc3RhcnQgPiBwcmV2U3RhcnQgJiYgc2VsZi5fc29ydCAmJiBjaGlsZC5fdHMgJiYgIXNlbGYuX2xvY2spIHsgLy9pbiBjYXNlIG9uZSBvZiB0aGUgdHdlZW5zIHNoaWZ0ZWQgb3V0IG9mIG9yZGVyLCBpdCBuZWVkcyB0byBiZSByZS1pbnNlcnRlZCBpbnRvIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGluIHRoZSBzZXF1ZW5jZVxuXHRcdFx0XHRcdHNlbGYuX2xvY2sgPSAxOyAvL3ByZXZlbnQgZW5kbGVzcyByZWN1cnNpdmUgY2FsbHMgLSB0aGVyZSBhcmUgbWV0aG9kcyB0aGF0IGdldCB0cmlnZ2VyZWQgdGhhdCBjaGVjayBkdXJhdGlvbi90b3RhbER1cmF0aW9uIHdoZW4gd2UgYWRkKCkuXG5cdFx0XHRcdFx0X2FkZFRvVGltZWxpbmUoc2VsZiwgY2hpbGQsIHN0YXJ0IC0gY2hpbGQuX2RlbGF5LCAxKS5fbG9jayA9IDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHJldlN0YXJ0ID0gc3RhcnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHN0YXJ0IDwgMCAmJiBjaGlsZC5fdHMpIHsgLy9jaGlsZHJlbiBhcmVuJ3QgYWxsb3dlZCB0byBoYXZlIG5lZ2F0aXZlIHN0YXJ0VGltZXMgdW5sZXNzIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUsIHNvIGFkanVzdCBoZXJlIGlmIG9uZSBpcyBmb3VuZC5cblx0XHRcdFx0XHRtYXggLT0gc3RhcnQ7XG5cdFx0XHRcdFx0aWYgKCghcGFyZW50ICYmICFzZWxmLl9kcCkgfHwgKHBhcmVudCAmJiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcpKSB7XG5cdFx0XHRcdFx0XHRzZWxmLl9zdGFydCArPSBzdGFydCAvIHNlbGYuX3RzO1xuXHRcdFx0XHRcdFx0c2VsZi5fdGltZSAtPSBzdGFydDtcblx0XHRcdFx0XHRcdHNlbGYuX3RUaW1lIC09IHN0YXJ0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZWxmLnNoaWZ0Q2hpbGRyZW4oLXN0YXJ0LCBmYWxzZSwgLTFlOTk5KTtcblx0XHRcdFx0XHRwcmV2U3RhcnQgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNoaWxkLl9lbmQgPiBtYXggJiYgY2hpbGQuX3RzICYmIChtYXggPSBjaGlsZC5fZW5kKTtcblx0XHRcdFx0Y2hpbGQgPSBwcmV2O1xuXHRcdFx0fVxuXHRcdFx0X3NldER1cmF0aW9uKHNlbGYsIChzZWxmID09PSBfZ2xvYmFsVGltZWxpbmUgJiYgc2VsZi5fdGltZSA+IG1heCkgPyBzZWxmLl90aW1lIDogbWF4LCAxLCAxKTtcblx0XHRcdHNlbGYuX2RpcnR5ID0gMDtcblx0XHR9XG5cdFx0cmV0dXJuIHNlbGYuX3REdXI7XG5cdH1cblxuXHRzdGF0aWMgdXBkYXRlUm9vdCh0aW1lKSB7XG5cdFx0aWYgKF9nbG9iYWxUaW1lbGluZS5fdHMpIHtcblx0XHRcdF9sYXp5U2FmZVJlbmRlcihfZ2xvYmFsVGltZWxpbmUsIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRpbWUsIF9nbG9iYWxUaW1lbGluZSkpO1xuXHRcdFx0X2xhc3RSZW5kZXJlZEZyYW1lID0gX3RpY2tlci5mcmFtZTtcblx0XHR9XG5cdFx0aWYgKF90aWNrZXIuZnJhbWUgPj0gX25leHRHQ0ZyYW1lKSB7XG5cdFx0XHRfbmV4dEdDRnJhbWUgKz0gX2NvbmZpZy5hdXRvU2xlZXAgfHwgMTIwO1xuXHRcdFx0bGV0IGNoaWxkID0gX2dsb2JhbFRpbWVsaW5lLl9maXJzdDtcblx0XHRcdGlmICghY2hpbGQgfHwgIWNoaWxkLl90cykgaWYgKF9jb25maWcuYXV0b1NsZWVwICYmIF90aWNrZXIuX2xpc3RlbmVycy5sZW5ndGggPCAyKSB7XG5cdFx0XHRcdHdoaWxlIChjaGlsZCAmJiAhY2hpbGQuX3RzKSB7XG5cdFx0XHRcdFx0Y2hpbGQgPSBjaGlsZC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGlsZCB8fCBfdGlja2VyLnNsZWVwKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cbn1cblxuX3NldERlZmF1bHRzKFRpbWVsaW5lLnByb3RvdHlwZSwge19sb2NrOjAsIF9oYXNQYXVzZTowLCBfZm9yY2luZzowfSk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxubGV0IF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBzZXR0ZXIsIHN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtKSB7IC8vbm90ZTogd2UgY2FsbCBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHR3ZWVuSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblx0XHRsZXQgcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQsIHByb3AsIDAsIDEsIF9yZW5kZXJDb21wbGV4U3RyaW5nLCBudWxsLCBzZXR0ZXIpLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bWF0Y2hJbmRleCA9IDAsXG5cdFx0XHRyZXN1bHQsXHRzdGFydE51bXMsIGNvbG9yLCBlbmROdW0sIGNodW5rLCBzdGFydE51bSwgaGFzUmFuZG9tLCBhO1xuXHRcdHB0LmIgPSBzdGFydDtcblx0XHRwdC5lID0gZW5kO1xuXHRcdHN0YXJ0ICs9IFwiXCI7IC8vZW5zdXJlIHZhbHVlcyBhcmUgc3RyaW5nc1xuXHRcdGVuZCArPSBcIlwiO1xuXHRcdGlmICgoaGFzUmFuZG9tID0gfmVuZC5pbmRleE9mKFwicmFuZG9tKFwiKSkpIHtcblx0XHRcdGVuZCA9IF9yZXBsYWNlUmFuZG9tKGVuZCk7XG5cdFx0fVxuXHRcdGlmIChzdHJpbmdGaWx0ZXIpIHtcblx0XHRcdGEgPSBbc3RhcnQsIGVuZF07XG5cdFx0XHRzdHJpbmdGaWx0ZXIoYSwgdGFyZ2V0LCBwcm9wKTsgLy9wYXNzIGFuIGFycmF5IHdpdGggdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIGFuZCBsZXQgdGhlIGZpbHRlciBkbyB3aGF0ZXZlciBpdCBuZWVkcyB0byB0aGUgdmFsdWVzLlxuXHRcdFx0c3RhcnQgPSBhWzBdO1xuXHRcdFx0ZW5kID0gYVsxXTtcblx0XHR9XG5cdFx0c3RhcnROdW1zID0gc3RhcnQubWF0Y2goX2NvbXBsZXhTdHJpbmdOdW1FeHApIHx8IFtdO1xuXHRcdHdoaWxlICgocmVzdWx0ID0gX2NvbXBsZXhTdHJpbmdOdW1FeHAuZXhlYyhlbmQpKSkge1xuXHRcdFx0ZW5kTnVtID0gcmVzdWx0WzBdO1xuXHRcdFx0Y2h1bmsgPSBlbmQuc3Vic3RyaW5nKGluZGV4LCByZXN1bHQuaW5kZXgpO1xuXHRcdFx0aWYgKGNvbG9yKSB7XG5cdFx0XHRcdGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuXHRcdFx0fSBlbHNlIGlmIChjaHVuay5zdWJzdHIoLTUpID09PSBcInJnYmEoXCIpIHtcblx0XHRcdFx0Y29sb3IgPSAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVuZE51bSAhPT0gc3RhcnROdW1zW21hdGNoSW5kZXgrK10pIHtcblx0XHRcdFx0c3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0TnVtc1ttYXRjaEluZGV4LTFdKSB8fCAwO1xuXHRcdFx0XHQvL3RoZXNlIG5lc3RlZCBQcm9wVHdlZW5zIGFyZSBoYW5kbGVkIGluIGEgc3BlY2lhbCB3YXkgLSB3ZSdsbCBuZXZlciBhY3R1YWxseSBjYWxsIGEgcmVuZGVyIG9yIHNldHRlciBtZXRob2Qgb24gdGhlbS4gV2UnbGwganVzdCBsb29wIHRocm91Z2ggdGhlbSBpbiB0aGUgcGFyZW50IGNvbXBsZXggc3RyaW5nIFByb3BUd2VlbidzIHJlbmRlciBtZXRob2QuXG5cdFx0XHRcdHB0Ll9wdCA9IHtcblx0XHRcdFx0XHRfbmV4dDpwdC5fcHQsXG5cdFx0XHRcdFx0cDooY2h1bmsgfHwgbWF0Y2hJbmRleCA9PT0gMSkgPyBjaHVuayA6IFwiLFwiLCAvL25vdGU6IFNWRyBzcGVjIGFsbG93cyBvbWlzc2lvbiBvZiBjb21tYS9zcGFjZSB3aGVuIGEgbmVnYXRpdmUgc2lnbiBpcyB3ZWRnZWQgYmV0d2VlbiB0d28gbnVtYmVycywgbGlrZSAyLjUtNS4zIGluc3RlYWQgb2YgMi41LC01LjMgYnV0IHdoZW4gdHdlZW5pbmcsIHRoZSBuZWdhdGl2ZSB2YWx1ZSBtYXkgc3dpdGNoIHRvIHBvc2l0aXZlLCBzbyB3ZSBpbnNlcnQgdGhlIGNvbW1hIGp1c3QgaW4gY2FzZS5cblx0XHRcdFx0XHRzOnN0YXJ0TnVtLFxuXHRcdFx0XHRcdGM6ZW5kTnVtLmNoYXJBdCgxKSA9PT0gXCI9XCIgPyBwYXJzZUZsb2F0KGVuZE51bS5zdWJzdHIoMikpICogKGVuZE51bS5jaGFyQXQoMCkgPT09IFwiLVwiID8gLTEgOiAxKSA6IHBhcnNlRmxvYXQoZW5kTnVtKSAtIHN0YXJ0TnVtLFxuXHRcdFx0XHRcdG06KGNvbG9yICYmIGNvbG9yIDwgNCkgPyBNYXRoLnJvdW5kIDogMFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpbmRleCA9IF9jb21wbGV4U3RyaW5nTnVtRXhwLmxhc3RJbmRleDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cHQuYyA9IChpbmRleCA8IGVuZC5sZW5ndGgpID8gZW5kLnN1YnN0cmluZyhpbmRleCwgZW5kLmxlbmd0aCkgOiBcIlwiOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgcGFydCBvZiB0aGUgc3RyaW5nIChhZnRlciB0aGUgbGFzdCBudW1iZXIpXG5cdFx0cHQuZnAgPSBmdW5jUGFyYW07XG5cdFx0aWYgKF9yZWxFeHAudGVzdChlbmQpIHx8IGhhc1JhbmRvbSkge1xuXHRcdFx0cHQuZSA9IDA7IC8vaWYgdGhlIGVuZCBzdHJpbmcgY29udGFpbnMgcmVsYXRpdmUgdmFsdWVzIG9yIGR5bmFtaWMgcmFuZG9tKC4uLikgdmFsdWVzLCBkZWxldGUgdGhlIGVuZCBpdCBzbyB0aGF0IG9uIHRoZSBmaW5hbCByZW5kZXIgd2UgZG9uJ3QgYWN0dWFsbHkgc2V0IGl0IHRvIHRoZSBzdHJpbmcgd2l0aCArPSBvciAtPSBjaGFyYWN0ZXJzIChmb3JjZXMgaXQgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHZhbHVlKS5cblx0XHR9XG5cdFx0dGhpcy5fcHQgPSBwdDsgLy9zdGFydCB0aGUgbGlua2VkIGxpc3Qgd2l0aCB0aGlzIG5ldyBQcm9wVHdlZW4uIFJlbWVtYmVyLCB3ZSBjYWxsIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuLmNhbGwodHdlZW5JbnN0YW5jZS4uLikgdG8gZW5zdXJlIHRoYXQgaXQncyBzY29wZWQgcHJvcGVybHkuIFdlIG1heSBjYWxsIGl0IGZyb20gd2l0aGluIGEgcGx1Z2luIHRvbywgdGh1cyBcInRoaXNcIiB3b3VsZCByZWZlciB0byB0aGUgcGx1Z2luLlxuXHRcdHJldHVybiBwdDtcblx0fSxcblx0X2FkZFByb3BUd2VlbiA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgaW5kZXgsIHRhcmdldHMsIG1vZGlmaWVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSkge1xuXHRcdF9pc0Z1bmN0aW9uKGVuZCkgJiYgKGVuZCA9IGVuZChpbmRleCB8fCAwLCB0YXJnZXQsIHRhcmdldHMpKTtcblx0XHRsZXQgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BdLFxuXHRcdFx0cGFyc2VkU3RhcnQgPSAoc3RhcnQgIT09IFwiZ2V0XCIpID8gc3RhcnQgOiAhX2lzRnVuY3Rpb24oY3VycmVudFZhbHVlKSA/IGN1cnJlbnRWYWx1ZSA6IChmdW5jUGFyYW0gPyB0YXJnZXRbKHByb3AuaW5kZXhPZihcInNldFwiKSB8fCAhX2lzRnVuY3Rpb24odGFyZ2V0W1wiZ2V0XCIgKyBwcm9wLnN1YnN0cigzKV0pKSA/IHByb3AgOiBcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKGZ1bmNQYXJhbSkgOiB0YXJnZXRbcHJvcF0oKSksXG5cdFx0XHRzZXR0ZXIgPSAhX2lzRnVuY3Rpb24oY3VycmVudFZhbHVlKSA/IF9zZXR0ZXJQbGFpbiA6IGZ1bmNQYXJhbSA/IF9zZXR0ZXJGdW5jV2l0aFBhcmFtIDogX3NldHRlckZ1bmMsXG5cdFx0XHRwdDtcblx0XHRpZiAoX2lzU3RyaW5nKGVuZCkpIHtcblx0XHRcdGlmICh+ZW5kLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG5cdFx0XHRcdGVuZCA9IF9yZXBsYWNlUmFuZG9tKGVuZCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZW5kLmNoYXJBdCgxKSA9PT0gXCI9XCIpIHtcblx0XHRcdFx0cHQgPSBwYXJzZUZsb2F0KHBhcnNlZFN0YXJ0KSArIHBhcnNlRmxvYXQoZW5kLnN1YnN0cigyKSkgKiAoZW5kLmNoYXJBdCgwKSA9PT0gXCItXCIgPyAtMSA6IDEpICsgKGdldFVuaXQocGFyc2VkU3RhcnQpIHx8IDApO1xuXHRcdFx0XHRpZiAocHQgfHwgcHQgPT09IDApIHsgLy8gdG8gYXZvaWQgaXNOYU4sIGxpa2UgaWYgc29tZW9uZSBwYXNzZXMgaW4gYSB2YWx1ZSBsaWtlIFwiIT0gd2hhdGV2ZXJcIlxuXHRcdFx0XHRcdGVuZCA9IHB0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChwYXJzZWRTdGFydCAhPT0gZW5kKSB7XG5cdFx0XHRpZiAoIWlzTmFOKHBhcnNlZFN0YXJ0ICogZW5kKSAmJiBlbmQgIT09IFwiXCIpIHsgLy8gZnVuIGZhY3Q6IGFueSBudW1iZXIgbXVsdGlwbGllZCBieSBcIlwiIGlzIGV2YWx1YXRlZCBhcyB0aGUgbnVtYmVyIDAhXG5cdFx0XHRcdHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LCBwcm9wLCArcGFyc2VkU3RhcnQgfHwgMCwgZW5kIC0gKHBhcnNlZFN0YXJ0IHx8IDApLCB0eXBlb2YoY3VycmVudFZhbHVlKSA9PT0gXCJib29sZWFuXCIgPyBfcmVuZGVyQm9vbGVhbiA6IF9yZW5kZXJQbGFpbiwgMCwgc2V0dGVyKTtcblx0XHRcdFx0ZnVuY1BhcmFtICYmIChwdC5mcCA9IGZ1bmNQYXJhbSk7XG5cdFx0XHRcdG1vZGlmaWVyICYmIHB0Lm1vZGlmaWVyKG1vZGlmaWVyLCB0aGlzLCB0YXJnZXQpO1xuXHRcdFx0XHRyZXR1cm4gKHRoaXMuX3B0ID0gcHQpO1xuXHRcdFx0fVxuXHRcdFx0IWN1cnJlbnRWYWx1ZSAmJiAhKHByb3AgaW4gdGFyZ2V0KSAmJiBfbWlzc2luZ1BsdWdpbihwcm9wLCBlbmQpO1xuXHRcdFx0cmV0dXJuIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuLmNhbGwodGhpcywgdGFyZ2V0LCBwcm9wLCBwYXJzZWRTdGFydCwgZW5kLCBzZXR0ZXIsIHN0cmluZ0ZpbHRlciB8fCBfY29uZmlnLnN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtKTtcblx0XHR9XG5cdH0sXG5cdC8vY3JlYXRlcyBhIGNvcHkgb2YgdGhlIHZhcnMgb2JqZWN0IGFuZCBwcm9jZXNzZXMgYW55IGZ1bmN0aW9uLWJhc2VkIHZhbHVlcyAocHV0dGluZyB0aGUgcmVzdWx0aW5nIHZhbHVlcyBkaXJlY3RseSBpbnRvIHRoZSBjb3B5KSBhcyB3ZWxsIGFzIHN0cmluZ3Mgd2l0aCBcInJhbmRvbSgpXCIgaW4gdGhlbS4gSXQgZG9lcyBOT1QgcHJvY2VzcyByZWxhdGl2ZSB2YWx1ZXMuXG5cdF9wcm9jZXNzVmFycyA9ICh2YXJzLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzLCB0d2VlbikgPT4ge1xuXHRcdF9pc0Z1bmN0aW9uKHZhcnMpICYmICh2YXJzID0gX3BhcnNlRnVuY09yU3RyaW5nKHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG5cdFx0aWYgKCFfaXNPYmplY3QodmFycykgfHwgKHZhcnMuc3R5bGUgJiYgdmFycy5ub2RlVHlwZSkgfHwgX2lzQXJyYXkodmFycykgfHwgX2lzVHlwZWRBcnJheSh2YXJzKSkge1xuXHRcdFx0cmV0dXJuIF9pc1N0cmluZyh2YXJzKSA/IF9wYXJzZUZ1bmNPclN0cmluZyh2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykgOiB2YXJzO1xuXHRcdH1cblx0XHRsZXQgY29weSA9IHt9LFxuXHRcdFx0cDtcblx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0Y29weVtwXSA9IF9wYXJzZUZ1bmNPclN0cmluZyh2YXJzW3BdLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cyk7XG5cdFx0fVxuXHRcdHJldHVybiBjb3B5O1xuXHR9LFxuXHRfY2hlY2tQbHVnaW4gPSAocHJvcGVydHksIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSA9PiB7XG5cdFx0bGV0IHBsdWdpbiwgcHQsIHB0TG9va3VwLCBpO1xuXHRcdGlmIChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgKHBsdWdpbiA9IG5ldyBfcGx1Z2luc1twcm9wZXJ0eV0oKSkuaW5pdCh0YXJnZXQsIHBsdWdpbi5yYXdWYXJzID8gdmFyc1twcm9wZXJ0eV0gOiBfcHJvY2Vzc1ZhcnModmFyc1twcm9wZXJ0eV0sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMsIHR3ZWVuKSwgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSAhPT0gZmFsc2UpIHtcblx0XHRcdHR3ZWVuLl9wdCA9IHB0ID0gbmV3IFByb3BUd2Vlbih0d2Vlbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIDAsIDEsIHBsdWdpbi5yZW5kZXIsIHBsdWdpbiwgMCwgcGx1Z2luLnByaW9yaXR5KTtcblx0XHRcdGlmICh0d2VlbiAhPT0gX3F1aWNrVHdlZW4pIHtcblx0XHRcdFx0cHRMb29rdXAgPSB0d2Vlbi5fcHRMb29rdXBbdHdlZW4uX3RhcmdldHMuaW5kZXhPZih0YXJnZXQpXTsgLy9ub3RlOiB3ZSBjYW4ndCB1c2UgdHdlZW4uX3B0TG9va3VwW2luZGV4XSBiZWNhdXNlIGZvciBzdGFnZ2VyZWQgdHdlZW5zLCB0aGUgaW5kZXggZnJvbSB0aGUgZnVsbFRhcmdldHMgYXJyYXkgd29uJ3QgbWF0Y2ggd2hhdCBpdCBpcyBpbiBlYWNoIGluZGl2aWR1YWwgdHdlZW4gdGhhdCBzcGF3bnMgZnJvbSB0aGUgc3RhZ2dlci5cblx0XHRcdFx0aSA9IHBsdWdpbi5fcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0cHRMb29rdXBbcGx1Z2luLl9wcm9wc1tpXV0gPSBwdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcGx1Z2luO1xuXHR9LFxuXHRfb3ZlcndyaXRpbmdUd2VlbiwgLy9zdG9yZSBhIHJlZmVyZW5jZSB0ZW1wb3JhcmlseSBzbyB3ZSBjYW4gYXZvaWQgb3ZlcndyaXRpbmcgaXRzZWxmLlxuXHRfaW5pdFR3ZWVuID0gKHR3ZWVuLCB0aW1lKSA9PiB7XG5cdFx0bGV0IHZhcnMgPSB0d2Vlbi52YXJzLFxuXHRcdFx0eyBlYXNlLCBzdGFydEF0LCBpbW1lZGlhdGVSZW5kZXIsIGxhenksIG9uVXBkYXRlLCBvblVwZGF0ZVBhcmFtcywgY2FsbGJhY2tTY29wZSwgcnVuQmFja3dhcmRzLCB5b3lvRWFzZSwga2V5ZnJhbWVzLCBhdXRvUmV2ZXJ0IH0gPSB2YXJzLFxuXHRcdFx0ZHVyID0gdHdlZW4uX2R1cixcblx0XHRcdHByZXZTdGFydEF0ID0gdHdlZW4uX3N0YXJ0QXQsXG5cdFx0XHR0YXJnZXRzID0gdHdlZW4uX3RhcmdldHMsXG5cdFx0XHRwYXJlbnQgPSB0d2Vlbi5wYXJlbnQsXG5cdFx0XHQvL3doZW4gYSBzdGFnZ2VyIChvciBmdW5jdGlvbi1iYXNlZCBkdXJhdGlvbi9kZWxheSkgaXMgb24gYSBUd2VlbiBpbnN0YW5jZSwgd2UgY3JlYXRlIGEgbmVzdGVkIHRpbWVsaW5lIHdoaWNoIG1lYW5zIHRoYXQgdGhlIFwidGFyZ2V0c1wiIG9mIHRoYXQgdHdlZW4gZG9uJ3QgcmVmbGVjdCB0aGUgcGFyZW50LiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB1cyB0byBkaXNjZXJuIHdoZW4gaXQncyBhIG5lc3RlZCB0d2VlbiBhbmQgaW4gdGhhdCBjYXNlLCByZXR1cm4gdGhlIGZ1bGwgdGFyZ2V0cyBhcnJheSBzbyB0aGF0IGZ1bmN0aW9uLWJhc2VkIHZhbHVlcyBnZXQgY2FsY3VsYXRlZCBwcm9wZXJseS5cblx0XHRcdGZ1bGxUYXJnZXRzID0gKHBhcmVudCAmJiBwYXJlbnQuZGF0YSA9PT0gXCJuZXN0ZWRcIikgPyBwYXJlbnQucGFyZW50Ll90YXJnZXRzIDogdGFyZ2V0cyxcblx0XHRcdGF1dG9PdmVyd3JpdGUgPSAodHdlZW4uX292ZXJ3cml0ZSA9PT0gXCJhdXRvXCIpICYmICFfc3VwcHJlc3NPdmVyd3JpdGVzLFxuXHRcdFx0dGwgPSB0d2Vlbi50aW1lbGluZSxcblx0XHRcdGNsZWFuVmFycywgaSwgcCwgcHQsIHRhcmdldCwgaGFzUHJpb3JpdHksIGdzRGF0YSwgaGFybmVzcywgcGx1Z2luLCBwdExvb2t1cCwgaW5kZXgsIGhhcm5lc3NWYXJzLCBvdmVyd3JpdHRlbjtcblx0XHR0bCAmJiAoIWtleWZyYW1lcyB8fCAhZWFzZSkgJiYgKGVhc2UgPSBcIm5vbmVcIik7XG5cdFx0dHdlZW4uX2Vhc2UgPSBfcGFyc2VFYXNlKGVhc2UsIF9kZWZhdWx0cy5lYXNlKTtcblx0XHR0d2Vlbi5feUVhc2UgPSB5b3lvRWFzZSA/IF9pbnZlcnRFYXNlKF9wYXJzZUVhc2UoeW95b0Vhc2UgPT09IHRydWUgPyBlYXNlIDogeW95b0Vhc2UsIF9kZWZhdWx0cy5lYXNlKSkgOiAwO1xuXHRcdGlmICh5b3lvRWFzZSAmJiB0d2Vlbi5feW95byAmJiAhdHdlZW4uX3JlcGVhdCkgeyAvL3RoZXJlIG11c3QgaGF2ZSBiZWVuIGEgcGFyZW50IHRpbWVsaW5lIHdpdGggeW95bzp0cnVlIHRoYXQgaXMgY3VycmVudGx5IGluIGl0cyB5b3lvIHBoYXNlLCBzbyBmbGlwIHRoZSBlYXNlcy5cblx0XHRcdHlveW9FYXNlID0gdHdlZW4uX3lFYXNlO1xuXHRcdFx0dHdlZW4uX3lFYXNlID0gdHdlZW4uX2Vhc2U7XG5cdFx0XHR0d2Vlbi5fZWFzZSA9IHlveW9FYXNlO1xuXHRcdH1cblx0XHR0d2Vlbi5fZnJvbSA9ICF0bCAmJiAhIXZhcnMucnVuQmFja3dhcmRzOyAvL25lc3RlZCB0aW1lbGluZXMgc2hvdWxkIG5ldmVyIHJ1biBiYWNrd2FyZHMgLSB0aGUgYmFja3dhcmRzLW5lc3MgaXMgaW4gdGhlIGNoaWxkIHR3ZWVucy5cblx0XHRpZiAoIXRsKSB7IC8vaWYgdGhlcmUncyBhbiBpbnRlcm5hbCB0aW1lbGluZSwgc2tpcCBhbGwgdGhlIHBhcnNpbmcgYmVjYXVzZSB3ZSBwYXNzZWQgdGhhdCB0YXNrIGRvd24gdGhlIGNoYWluLlxuXHRcdFx0aGFybmVzcyA9IHRhcmdldHNbMF0gPyBfZ2V0Q2FjaGUodGFyZ2V0c1swXSkuaGFybmVzcyA6IDA7XG5cdFx0XHRoYXJuZXNzVmFycyA9IGhhcm5lc3MgJiYgdmFyc1toYXJuZXNzLnByb3BdOyAvL3NvbWVvbmUgbWF5IG5lZWQgdG8gc3BlY2lmeSBDU1Mtc3BlY2lmaWMgdmFsdWVzIEFORCBub24tQ1NTIHZhbHVlcywgbGlrZSBpZiB0aGUgZWxlbWVudCBoYXMgYW4gXCJ4XCIgcHJvcGVydHkgcGx1cyBpdCdzIGEgc3RhbmRhcmQgRE9NIGVsZW1lbnQuIFdlIGFsbG93IHBlb3BsZSB0byBkaXN0aW5ndWlzaCBieSB3cmFwcGluZyBwbHVnaW4tc3BlY2lmaWMgc3R1ZmYgaW4gYSBjc3M6e30gb2JqZWN0IGZvciBleGFtcGxlLlxuXHRcdFx0Y2xlYW5WYXJzID0gX2NvcHlFeGNsdWRpbmcodmFycywgX3Jlc2VydmVkUHJvcHMpO1xuXHRcdFx0cHJldlN0YXJ0QXQgJiYgcHJldlN0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKS5raWxsKCk7XG5cdFx0XHRpZiAoc3RhcnRBdCkge1xuXHRcdFx0XHRfcmVtb3ZlRnJvbVBhcmVudCh0d2Vlbi5fc3RhcnRBdCA9IFR3ZWVuLnNldCh0YXJnZXRzLCBfc2V0RGVmYXVsdHMoe2RhdGE6IFwiaXNTdGFydFwiLCBvdmVyd3JpdGU6IGZhbHNlLCBwYXJlbnQ6IHBhcmVudCwgaW1tZWRpYXRlUmVuZGVyOiB0cnVlLCBsYXp5OiBfaXNOb3RGYWxzZShsYXp5KSwgc3RhcnRBdDogbnVsbCwgZGVsYXk6IDAsIG9uVXBkYXRlOiBvblVwZGF0ZSwgb25VcGRhdGVQYXJhbXM6IG9uVXBkYXRlUGFyYW1zLCBjYWxsYmFja1Njb3BlOiBjYWxsYmFja1Njb3BlLCBzdGFnZ2VyOiAwfSwgc3RhcnRBdCkpKTsgLy9jb3B5IHRoZSBwcm9wZXJ0aWVzL3ZhbHVlcyBpbnRvIGEgbmV3IG9iamVjdCB0byBhdm9pZCBjb2xsaXNpb25zLCBsaWtlIHZhciB0byA9IHt4OjB9LCBmcm9tID0ge3g6NTAwfTsgdGltZWxpbmUuZnJvbVRvKGUsIGZyb20sIHRvKS5mcm9tVG8oZSwgdG8sIGZyb20pO1xuXHRcdFx0XHQodGltZSA8IDAgJiYgIWltbWVkaWF0ZVJlbmRlciAmJiAhYXV0b1JldmVydCkgJiYgdHdlZW4uX3N0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKTsgLy8gcmFyZSBlZGdlIGNhc2UsIGxpa2UgaWYgYSByZW5kZXIgaXMgZm9yY2VkIGluIHRoZSBuZWdhdGl2ZSBkaXJlY3Rpb24gb2YgYSBub24taW5pdHRlZCB0d2Vlbi5cblx0XHRcdFx0aWYgKGltbWVkaWF0ZVJlbmRlcikge1xuXHRcdFx0XHRcdCh0aW1lID4gMCkgJiYgIWF1dG9SZXZlcnQgJiYgKHR3ZWVuLl9zdGFydEF0ID0gMCk7IC8vdHdlZW5zIHRoYXQgcmVuZGVyIGltbWVkaWF0ZWx5IChsaWtlIG1vc3QgZnJvbSgpIGFuZCBmcm9tVG8oKSB0d2VlbnMpIHNob3VsZG4ndCByZXZlcnQgd2hlbiB0aGVpciBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHN0YXJ0VGltZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBjb3VsZCBoYXZlIGhhcHBlbmVkIGFueXRpbWUgYW5kIGl0IHNob3VsZG4ndCBiZSBkaXJlY3RseSBjb3JyZWxhdGVkIHRvIHRoaXMgdHdlZW4ncyBzdGFydFRpbWUuIEltYWdpbmUgc2V0dGluZyB1cCBhIGNvbXBsZXggYW5pbWF0aW9uIHdoZXJlIHRoZSBiZWdpbm5pbmcgc3RhdGVzIG9mIHZhcmlvdXMgb2JqZWN0cyBhcmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkgYnV0IHRoZSB0d2VlbiBkb2Vzbid0IGhhcHBlbiBmb3IgcXVpdGUgc29tZSB0aW1lIC0gaWYgd2UgcmV2ZXJ0IHRvIHRoZSBzdGFydGluZyB2YWx1ZXMgYXMgc29vbiBhcyB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSB0d2VlbidzIHN0YXJ0VGltZSwgaXQgd2lsbCB0aHJvdyB0aGluZ3Mgb2ZmIHZpc3VhbGx5LiBSZXZlcnNpb24gc2hvdWxkIG9ubHkgaGFwcGVuIGluIFRpbWVsaW5lIGluc3RhbmNlcyB3aGVyZSBpbW1lZGlhdGVSZW5kZXIgd2FzIGZhbHNlIG9yIHdoZW4gYXV0b1JldmVydCBpcyBleHBsaWNpdGx5IHNldCB0byB0cnVlLlxuXHRcdFx0XHRcdGlmIChkdXIgJiYgdGltZSA8PSAwKSB7XG5cdFx0XHRcdFx0XHR0aW1lICYmICh0d2Vlbi5felRpbWUgPSB0aW1lKTtcblx0XHRcdFx0XHRcdHJldHVybjsgLy93ZSBza2lwIGluaXRpYWxpemF0aW9uIGhlcmUgc28gdGhhdCBvdmVyd3JpdGluZyBkb2Vzbid0IG9jY3VyIHVudGlsIHRoZSB0d2VlbiBhY3R1YWxseSBiZWdpbnMuIE90aGVyd2lzZSwgaWYgeW91IGNyZWF0ZSBzZXZlcmFsIGltbWVkaWF0ZVJlbmRlcjp0cnVlIHR3ZWVucyBvZiB0aGUgc2FtZSB0YXJnZXQvcHJvcGVydGllcyB0byBkcm9wIGludG8gYSBUaW1lbGluZSwgdGhlIGxhc3Qgb25lIGNyZWF0ZWQgd291bGQgb3ZlcndyaXRlIHRoZSBmaXJzdCBvbmVzIGJlY2F1c2UgdGhleSBkaWRuJ3QgZ2V0IHBsYWNlZCBpbnRvIHRoZSB0aW1lbGluZSB5ZXQgYmVmb3JlIHRoZSBmaXJzdCByZW5kZXIgb2NjdXJzIGFuZCBraWNrcyBpbiBvdmVyd3JpdGluZy5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gaWYgKHRpbWUgPiAwKSB7XG5cdFx0XHRcdFx0Ly8gXHRhdXRvUmV2ZXJ0IHx8ICh0d2Vlbi5fc3RhcnRBdCA9IDApOyAvL3R3ZWVucyB0aGF0IHJlbmRlciBpbW1lZGlhdGVseSAobGlrZSBtb3N0IGZyb20oKSBhbmQgZnJvbVRvKCkgdHdlZW5zKSBzaG91bGRuJ3QgcmV2ZXJ0IHdoZW4gdGhlaXIgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSBzdGFydFRpbWUgYmVjYXVzZSB0aGUgaW5pdGlhbCByZW5kZXIgY291bGQgaGF2ZSBoYXBwZW5lZCBhbnl0aW1lIGFuZCBpdCBzaG91bGRuJ3QgYmUgZGlyZWN0bHkgY29ycmVsYXRlZCB0byB0aGlzIHR3ZWVuJ3Mgc3RhcnRUaW1lLiBJbWFnaW5lIHNldHRpbmcgdXAgYSBjb21wbGV4IGFuaW1hdGlvbiB3aGVyZSB0aGUgYmVnaW5uaW5nIHN0YXRlcyBvZiB2YXJpb3VzIG9iamVjdHMgYXJlIHJlbmRlcmVkIGltbWVkaWF0ZWx5IGJ1dCB0aGUgdHdlZW4gZG9lc24ndCBoYXBwZW4gZm9yIHF1aXRlIHNvbWUgdGltZSAtIGlmIHdlIHJldmVydCB0byB0aGUgc3RhcnRpbmcgdmFsdWVzIGFzIHNvb24gYXMgdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgcGFzdCB0aGUgdHdlZW4ncyBzdGFydFRpbWUsIGl0IHdpbGwgdGhyb3cgdGhpbmdzIG9mZiB2aXN1YWxseS4gUmV2ZXJzaW9uIHNob3VsZCBvbmx5IGhhcHBlbiBpbiBUaW1lbGluZSBpbnN0YW5jZXMgd2hlcmUgaW1tZWRpYXRlUmVuZGVyIHdhcyBmYWxzZSBvciB3aGVuIGF1dG9SZXZlcnQgaXMgZXhwbGljaXRseSBzZXQgdG8gdHJ1ZS5cblx0XHRcdFx0XHQvLyB9IGVsc2UgaWYgKGR1ciAmJiAhKHRpbWUgPCAwICYmIHByZXZTdGFydEF0KSkge1xuXHRcdFx0XHRcdC8vIFx0dGltZSAmJiAodHdlZW4uX3pUaW1lID0gdGltZSk7XG5cdFx0XHRcdFx0Ly8gXHRyZXR1cm47IC8vd2Ugc2tpcCBpbml0aWFsaXphdGlvbiBoZXJlIHNvIHRoYXQgb3ZlcndyaXRpbmcgZG9lc24ndCBvY2N1ciB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zLiBPdGhlcndpc2UsIGlmIHlvdSBjcmVhdGUgc2V2ZXJhbCBpbW1lZGlhdGVSZW5kZXI6dHJ1ZSB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0L3Byb3BlcnRpZXMgdG8gZHJvcCBpbnRvIGEgVGltZWxpbmUsIHRoZSBsYXN0IG9uZSBjcmVhdGVkIHdvdWxkIG92ZXJ3cml0ZSB0aGUgZmlyc3Qgb25lcyBiZWNhdXNlIHRoZXkgZGlkbid0IGdldCBwbGFjZWQgaW50byB0aGUgdGltZWxpbmUgeWV0IGJlZm9yZSB0aGUgZmlyc3QgcmVuZGVyIG9jY3VycyBhbmQga2lja3MgaW4gb3ZlcndyaXRpbmcuXG5cdFx0XHRcdFx0Ly8gfVxuXHRcdFx0XHR9IGVsc2UgaWYgKGF1dG9SZXZlcnQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0dHdlZW4uX3N0YXJ0QXQgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHJ1bkJhY2t3YXJkcyAmJiBkdXIpIHtcblx0XHRcdFx0Ly9mcm9tKCkgdHdlZW5zIG11c3QgYmUgaGFuZGxlZCB1bmlxdWVseTogdGhlaXIgYmVnaW5uaW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkIGJ1dCB3ZSBkb24ndCB3YW50IG92ZXJ3cml0aW5nIHRvIG9jY3VyIHlldCAod2hlbiB0aW1lIGlzIHN0aWxsIDApLiBXYWl0IHVudGlsIHRoZSB0d2VlbiBhY3R1YWxseSBiZWdpbnMgYmVmb3JlIGRvaW5nIGFsbCB0aGUgcm91dGluZXMgbGlrZSBvdmVyd3JpdGluZy4gQXQgdGhhdCB0aW1lLCB3ZSBzaG91bGQgcmVuZGVyIGF0IHRoZSBFTkQgb2YgdGhlIHR3ZWVuIHRvIGVuc3VyZSB0aGF0IHRoaW5ncyBpbml0aWFsaXplIGNvcnJlY3RseSAocmVtZW1iZXIsIGZyb20oKSB0d2VlbnMgZ28gYmFja3dhcmRzKVxuXHRcdFx0XHRpZiAocHJldlN0YXJ0QXQpIHtcblx0XHRcdFx0XHQhYXV0b1JldmVydCAmJiAodHdlZW4uX3N0YXJ0QXQgPSAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aW1lICYmIChpbW1lZGlhdGVSZW5kZXIgPSBmYWxzZSk7IC8vaW4gcmFyZSBjYXNlcyAobGlrZSBpZiBhIGZyb20oKSB0d2VlbiBydW5zIGFuZCB0aGVuIGlzIGludmFsaWRhdGUoKS1lZCksIGltbWVkaWF0ZVJlbmRlciBjb3VsZCBiZSB0cnVlIGJ1dCB0aGUgaW5pdGlhbCBmb3JjZWQtcmVuZGVyIGdldHMgc2tpcHBlZCwgc28gdGhlcmUncyBubyBuZWVkIHRvIGZvcmNlIHRoZSByZW5kZXIgaW4gdGhpcyBjb250ZXh0IHdoZW4gdGhlIF90aW1lIGlzIGdyZWF0ZXIgdGhhbiAwXG5cdFx0XHRcdFx0cCA9IF9zZXREZWZhdWx0cyh7XG5cdFx0XHRcdFx0XHRvdmVyd3JpdGU6IGZhbHNlLFxuXHRcdFx0XHRcdFx0ZGF0YTogXCJpc0Zyb21TdGFydFwiLCAvL3dlIHRhZyB0aGUgdHdlZW4gd2l0aCBhcyBcImlzRnJvbVN0YXJ0XCIgc28gdGhhdCBpZiBbaW5zaWRlIGEgcGx1Z2luXSB3ZSBuZWVkIHRvIG9ubHkgZG8gc29tZXRoaW5nIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuLCB3ZSBoYXZlIGEgd2F5IG9mIGlkZW50aWZ5aW5nIHRoaXMgdHdlZW4gYXMgbWVyZWx5IHRoZSBvbmUgdGhhdCdzIHNldHRpbmcgdGhlIGJlZ2lubmluZyB2YWx1ZXMgZm9yIGEgXCJmcm9tKClcIiB0d2Vlbi4gRm9yIGV4YW1wbGUsIGNsZWFyUHJvcHMgaW4gQ1NTUGx1Z2luIHNob3VsZCBvbmx5IGdldCBhcHBsaWVkIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuIGFuZCB3aXRob3V0IHRoaXMgdGFnLCBmcm9tKC4uLntoZWlnaHQ6MTAwLCBjbGVhclByb3BzOlwiaGVpZ2h0XCIsIGRlbGF5OjF9KSB3b3VsZCB3aXBlIHRoZSBoZWlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4gYW5kIGFmdGVyIDEgc2Vjb25kLCBpdCdkIGtpY2sgYmFjayBpbi5cblx0XHRcdFx0XHRcdGxhenk6IGltbWVkaWF0ZVJlbmRlciAmJiBfaXNOb3RGYWxzZShsYXp5KSxcblx0XHRcdFx0XHRcdGltbWVkaWF0ZVJlbmRlcjogaW1tZWRpYXRlUmVuZGVyLCAvL3plcm8tZHVyYXRpb24gdHdlZW5zIHJlbmRlciBpbW1lZGlhdGVseSBieSBkZWZhdWx0LCBidXQgaWYgd2UncmUgbm90IHNwZWNpZmljYWxseSBpbnN0cnVjdGVkIHRvIHJlbmRlciB0aGlzIHR3ZWVuIGltbWVkaWF0ZWx5LCB3ZSBzaG91bGQgc2tpcCB0aGlzIGFuZCBtZXJlbHkgX2luaXQoKSB0byByZWNvcmQgdGhlIHN0YXJ0aW5nIHZhbHVlcyAocmVuZGVyaW5nIHRoZW0gaW1tZWRpYXRlbHkgd291bGQgcHVzaCB0aGVtIHRvIGNvbXBsZXRpb24gd2hpY2ggaXMgd2FzdGVmdWwgaW4gdGhhdCBjYXNlIC0gd2UnZCBoYXZlIHRvIHJlbmRlcigtMSkgaW1tZWRpYXRlbHkgYWZ0ZXIpXG5cdFx0XHRcdFx0XHRzdGFnZ2VyOiAwLFxuXHRcdFx0XHRcdFx0cGFyZW50OiBwYXJlbnQgLy9lbnN1cmVzIHRoYXQgbmVzdGVkIHR3ZWVucyB0aGF0IGhhZCBhIHN0YWdnZXIgYXJlIGhhbmRsZWQgcHJvcGVybHksIGxpa2UgZ3NhcC5mcm9tKFwiLmNsYXNzXCIsIHt5OmdzYXAudXRpbHMud3JhcChbLTEwMCwxMDBdKX0pXG5cdFx0XHRcdFx0fSwgY2xlYW5WYXJzKTtcblx0XHRcdFx0XHRoYXJuZXNzVmFycyAmJiAocFtoYXJuZXNzLnByb3BdID0gaGFybmVzc1ZhcnMpOyAvLyBpbiBjYXNlIHNvbWVvbmUgZG9lcyBzb21ldGhpbmcgbGlrZSAuZnJvbSguLi4sIHtjc3M6e319KVxuXHRcdFx0XHRcdF9yZW1vdmVGcm9tUGFyZW50KHR3ZWVuLl9zdGFydEF0ID0gVHdlZW4uc2V0KHRhcmdldHMsIHApKTtcblx0XHRcdFx0XHQodGltZSA8IDApICYmIHR3ZWVuLl9zdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSk7IC8vIHJhcmUgZWRnZSBjYXNlLCBsaWtlIGlmIGEgcmVuZGVyIGlzIGZvcmNlZCBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uIG9mIGEgbm9uLWluaXR0ZWQgZnJvbSgpIHR3ZWVuLlxuXHRcdFx0XHRcdGlmICghaW1tZWRpYXRlUmVuZGVyKSB7XG5cdFx0XHRcdFx0XHRfaW5pdFR3ZWVuKHR3ZWVuLl9zdGFydEF0LCBfdGlueU51bSk7IC8vZW5zdXJlcyB0aGF0IHRoZSBpbml0aWFsIHZhbHVlcyBhcmUgcmVjb3JkZWRcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCF0aW1lKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0d2Vlbi5fcHQgPSAwO1xuXHRcdFx0bGF6eSA9IChkdXIgJiYgX2lzTm90RmFsc2UobGF6eSkpIHx8IChsYXp5ICYmICFkdXIpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGFyZ2V0ID0gdGFyZ2V0c1tpXTtcblx0XHRcdFx0Z3NEYXRhID0gdGFyZ2V0Ll9nc2FwIHx8IF9oYXJuZXNzKHRhcmdldHMpW2ldLl9nc2FwO1xuXHRcdFx0XHR0d2Vlbi5fcHRMb29rdXBbaV0gPSBwdExvb2t1cCA9IHt9O1xuXHRcdFx0XHRfbGF6eUxvb2t1cFtnc0RhdGEuaWRdICYmIF9sYXp5VHdlZW5zLmxlbmd0aCAmJiBfbGF6eVJlbmRlcigpOyAvL2lmIG90aGVyIHR3ZWVucyBvZiB0aGUgc2FtZSB0YXJnZXQgaGF2ZSByZWNlbnRseSBpbml0dGVkIGJ1dCBoYXZlbid0IHJlbmRlcmVkIHlldCwgd2UndmUgZ290IHRvIGZvcmNlIHRoZSByZW5kZXIgc28gdGhhdCB0aGUgc3RhcnRpbmcgdmFsdWVzIGFyZSBjb3JyZWN0IChpbWFnaW5lIHBvcHVsYXRpbmcgYSB0aW1lbGluZSB3aXRoIGEgYnVuY2ggb2Ygc2VxdWVudGlhbCB0d2VlbnMgYW5kIHRoZW4ganVtcGluZyB0byB0aGUgZW5kKVxuXHRcdFx0XHRpbmRleCA9IGZ1bGxUYXJnZXRzID09PSB0YXJnZXRzID8gaSA6IGZ1bGxUYXJnZXRzLmluZGV4T2YodGFyZ2V0KTtcblx0XHRcdFx0aWYgKGhhcm5lc3MgJiYgKHBsdWdpbiA9IG5ldyBoYXJuZXNzKCkpLmluaXQodGFyZ2V0LCBoYXJuZXNzVmFycyB8fCBjbGVhblZhcnMsIHR3ZWVuLCBpbmRleCwgZnVsbFRhcmdldHMpICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdHR3ZWVuLl9wdCA9IHB0ID0gbmV3IFByb3BUd2Vlbih0d2Vlbi5fcHQsIHRhcmdldCwgcGx1Z2luLm5hbWUsIDAsIDEsIHBsdWdpbi5yZW5kZXIsIHBsdWdpbiwgMCwgcGx1Z2luLnByaW9yaXR5KTtcblx0XHRcdFx0XHRwbHVnaW4uX3Byb3BzLmZvckVhY2gobmFtZSA9PiB7cHRMb29rdXBbbmFtZV0gPSBwdDt9KTtcblx0XHRcdFx0XHRwbHVnaW4ucHJpb3JpdHkgJiYgKGhhc1ByaW9yaXR5ID0gMSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFoYXJuZXNzIHx8IGhhcm5lc3NWYXJzKSB7XG5cdFx0XHRcdFx0Zm9yIChwIGluIGNsZWFuVmFycykge1xuXHRcdFx0XHRcdFx0aWYgKF9wbHVnaW5zW3BdICYmIChwbHVnaW4gPSBfY2hlY2tQbHVnaW4ocCwgY2xlYW5WYXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgZnVsbFRhcmdldHMpKSkge1xuXHRcdFx0XHRcdFx0XHRwbHVnaW4ucHJpb3JpdHkgJiYgKGhhc1ByaW9yaXR5ID0gMSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwdExvb2t1cFtwXSA9IHB0ID0gX2FkZFByb3BUd2Vlbi5jYWxsKHR3ZWVuLCB0YXJnZXQsIHAsIFwiZ2V0XCIsIGNsZWFuVmFyc1twXSwgaW5kZXgsIGZ1bGxUYXJnZXRzLCAwLCB2YXJzLnN0cmluZ0ZpbHRlcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuLl9vcCAmJiB0d2Vlbi5fb3BbaV0gJiYgdHdlZW4ua2lsbCh0YXJnZXQsIHR3ZWVuLl9vcFtpXSk7XG5cdFx0XHRcdGlmIChhdXRvT3ZlcndyaXRlICYmIHR3ZWVuLl9wdCkge1xuXHRcdFx0XHRcdF9vdmVyd3JpdGluZ1R3ZWVuID0gdHdlZW47XG5cdFx0XHRcdFx0X2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXQsIHB0TG9va3VwLCB0d2Vlbi5nbG9iYWxUaW1lKDApKTsgLy9BbHNvIG1ha2Ugc3VyZSB0aGUgb3ZlcndyaXRpbmcgZG9lc24ndCBvdmVyd3JpdGUgVEhJUyB0d2VlbiEhIVxuXHRcdFx0XHRcdG92ZXJ3cml0dGVuID0gIXR3ZWVuLnBhcmVudDtcblx0XHRcdFx0XHRfb3ZlcndyaXRpbmdUd2VlbiA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4uX3B0ICYmIGxhenkgJiYgKF9sYXp5TG9va3VwW2dzRGF0YS5pZF0gPSAxKTtcblx0XHRcdH1cblx0XHRcdGhhc1ByaW9yaXR5ICYmIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkodHdlZW4pO1xuXHRcdFx0dHdlZW4uX29uSW5pdCAmJiB0d2Vlbi5fb25Jbml0KHR3ZWVuKTsgLy9wbHVnaW5zIGxpa2UgUm91bmRQcm9wcyBtdXN0IHdhaXQgdW50aWwgQUxMIG9mIHRoZSBQcm9wVHdlZW5zIGFyZSBpbnN0YW50aWF0ZWQuIEluIHRoZSBwbHVnaW4ncyBpbml0KCkgZnVuY3Rpb24sIGl0IHNldHMgdGhlIF9vbkluaXQgb24gdGhlIHR3ZWVuIGluc3RhbmNlLiBNYXkgbm90IGJlIHByZXR0eS9pbnR1aXRpdmUsIGJ1dCBpdCdzIGZhc3QgYW5kIGtlZXBzIGZpbGUgc2l6ZSBkb3duLlxuXHRcdH1cblx0XHR0d2Vlbi5fb25VcGRhdGUgPSBvblVwZGF0ZTtcblx0XHR0d2Vlbi5faW5pdHRlZCA9ICghdHdlZW4uX29wIHx8IHR3ZWVuLl9wdCkgJiYgIW92ZXJ3cml0dGVuOyAvLyBpZiBvdmVyd3JpdHRlblByb3BzIHJlc3VsdGVkIGluIHRoZSBlbnRpcmUgdHdlZW4gYmVpbmcga2lsbGVkLCBkbyBOT1QgZmxhZyBpdCBhcyBpbml0dGVkIG9yIGVsc2UgaXQgbWF5IHJlbmRlciBmb3Igb25lIHRpY2suXG5cdH0sXG5cdF9hZGRBbGlhc2VzVG9WYXJzID0gKHRhcmdldHMsIHZhcnMpID0+IHtcblx0XHRsZXQgaGFybmVzcyA9IHRhcmdldHNbMF0gPyBfZ2V0Q2FjaGUodGFyZ2V0c1swXSkuaGFybmVzcyA6IDAsXG5cdFx0XHRwcm9wZXJ0eUFsaWFzZXMgPSAoaGFybmVzcyAmJiBoYXJuZXNzLmFsaWFzZXMpLFxuXHRcdFx0Y29weSwgcCwgaSwgYWxpYXNlcztcblx0XHRpZiAoIXByb3BlcnR5QWxpYXNlcykge1xuXHRcdFx0cmV0dXJuIHZhcnM7XG5cdFx0fVxuXHRcdGNvcHkgPSBfbWVyZ2Uoe30sIHZhcnMpO1xuXHRcdGZvciAocCBpbiBwcm9wZXJ0eUFsaWFzZXMpIHtcblx0XHRcdGlmIChwIGluIGNvcHkpIHtcblx0XHRcdFx0YWxpYXNlcyA9IHByb3BlcnR5QWxpYXNlc1twXS5zcGxpdChcIixcIik7XG5cdFx0XHRcdGkgPSBhbGlhc2VzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUoaS0tKSB7XG5cdFx0XHRcdFx0Y29weVthbGlhc2VzW2ldXSA9IGNvcHlbcF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblx0XHRyZXR1cm4gY29weTtcblx0fSxcblx0X3BhcnNlRnVuY09yU3RyaW5nID0gKHZhbHVlLCB0d2VlbiwgaSwgdGFyZ2V0LCB0YXJnZXRzKSA9PiAoX2lzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbCh0d2VlbiwgaSwgdGFyZ2V0LCB0YXJnZXRzKSA6IChfaXNTdHJpbmcodmFsdWUpICYmIH52YWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiKSkgPyBfcmVwbGFjZVJhbmRvbSh2YWx1ZSkgOiB2YWx1ZSksXG5cdF9zdGFnZ2VyVHdlZW5Qcm9wcyA9IF9jYWxsYmFja05hbWVzICsgXCJyZXBlYXQscmVwZWF0RGVsYXkseW95byxyZXBlYXRSZWZyZXNoLHlveW9FYXNlXCIsXG5cdF9zdGFnZ2VyUHJvcHNUb1NraXAgPSAoX3N0YWdnZXJUd2VlblByb3BzICsgXCIsaWQsc3RhZ2dlcixkZWxheSxkdXJhdGlvbixwYXVzZWQsc2Nyb2xsVHJpZ2dlclwiKS5zcGxpdChcIixcIik7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUV0VFTlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5leHBvcnQgY2xhc3MgVHdlZW4gZXh0ZW5kcyBBbmltYXRpb24ge1xuXG5cdGNvbnN0cnVjdG9yKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uLCBza2lwSW5oZXJpdCkge1xuXHRcdGlmICh0eXBlb2YodmFycykgPT09IFwibnVtYmVyXCIpIHtcblx0XHRcdHBvc2l0aW9uLmR1cmF0aW9uID0gdmFycztcblx0XHRcdHZhcnMgPSBwb3NpdGlvbjtcblx0XHRcdHBvc2l0aW9uID0gbnVsbDtcblx0XHR9XG5cdFx0c3VwZXIoc2tpcEluaGVyaXQgPyB2YXJzIDogX2luaGVyaXREZWZhdWx0cyh2YXJzKSk7XG5cdFx0bGV0IHsgZHVyYXRpb24sIGRlbGF5LCBpbW1lZGlhdGVSZW5kZXIsIHN0YWdnZXIsIG92ZXJ3cml0ZSwga2V5ZnJhbWVzLCBkZWZhdWx0cywgc2Nyb2xsVHJpZ2dlciwgeW95b0Vhc2UgfSA9IHRoaXMudmFycyxcblx0XHRcdHBhcmVudCA9IHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSxcblx0XHRcdHBhcnNlZFRhcmdldHMgPSAoX2lzQXJyYXkodGFyZ2V0cykgfHwgX2lzVHlwZWRBcnJheSh0YXJnZXRzKSA/IF9pc051bWJlcih0YXJnZXRzWzBdKSA6IChcImxlbmd0aFwiIGluIHZhcnMpKSA/IFt0YXJnZXRzXSA6IHRvQXJyYXkodGFyZ2V0cyksIC8vIGVkZ2UgY2FzZTogc29tZW9uZSBtaWdodCB0cnkgYW5pbWF0aW5nIHRoZSBcImxlbmd0aFwiIG9mIGFuIG9iamVjdCB3aXRoIGEgXCJsZW5ndGhcIiBwcm9wZXJ0eSB0aGF0J3MgaW5pdGlhbGx5IHNldCB0byAwIHNvIGRvbid0IGludGVycHJldCB0aGF0IGFzIGFuIGVtcHR5IEFycmF5LWxpa2Ugb2JqZWN0LlxuXHRcdFx0dGwsIGksIGNvcHksIGwsIHAsIGN1clRhcmdldCwgc3RhZ2dlckZ1bmMsIHN0YWdnZXJWYXJzVG9NZXJnZTtcblx0XHR0aGlzLl90YXJnZXRzID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGggPyBfaGFybmVzcyhwYXJzZWRUYXJnZXRzKSA6IF93YXJuKFwiR1NBUCB0YXJnZXQgXCIgKyB0YXJnZXRzICsgXCIgbm90IGZvdW5kLiBodHRwczovL2dyZWVuc29jay5jb21cIiwgIV9jb25maWcubnVsbFRhcmdldFdhcm4pIHx8IFtdO1xuXHRcdHRoaXMuX3B0TG9va3VwID0gW107IC8vUHJvcFR3ZWVuIGxvb2t1cC4gQW4gYXJyYXkgY29udGFpbmluZyBhbiBvYmplY3QgZm9yIGVhY2ggdGFyZ2V0LCBoYXZpbmcga2V5cyBmb3IgZWFjaCB0d2VlbmluZyBwcm9wZXJ0eVxuXHRcdHRoaXMuX292ZXJ3cml0ZSA9IG92ZXJ3cml0ZTtcblx0XHRpZiAoa2V5ZnJhbWVzIHx8IHN0YWdnZXIgfHwgX2lzRnVuY09yU3RyaW5nKGR1cmF0aW9uKSB8fCBfaXNGdW5jT3JTdHJpbmcoZGVsYXkpKSB7XG5cdFx0XHR2YXJzID0gdGhpcy52YXJzO1xuXHRcdFx0dGwgPSB0aGlzLnRpbWVsaW5lID0gbmV3IFRpbWVsaW5lKHtkYXRhOlwibmVzdGVkXCIsIGRlZmF1bHRzOmRlZmF1bHRzIHx8IHt9fSk7XG5cdFx0XHR0bC5raWxsKCk7XG5cdFx0XHR0bC5wYXJlbnQgPSB0bC5fZHAgPSB0aGlzO1xuXHRcdFx0dGwuX3N0YXJ0ID0gMDtcblx0XHRcdGlmIChrZXlmcmFtZXMpIHtcblx0XHRcdFx0X3NldERlZmF1bHRzKHRsLnZhcnMuZGVmYXVsdHMsIHtlYXNlOlwibm9uZVwifSk7XG5cdFx0XHRcdHN0YWdnZXIgPyBwYXJzZWRUYXJnZXRzLmZvckVhY2goKHQsIGkpID0+IGtleWZyYW1lcy5mb3JFYWNoKChmcmFtZSwgaikgPT4gdGwudG8odCwgZnJhbWUsIGogPyBcIj5cIiA6IGkgKiBzdGFnZ2VyKSkpIDoga2V5ZnJhbWVzLmZvckVhY2goZnJhbWUgPT4gdGwudG8ocGFyc2VkVGFyZ2V0cywgZnJhbWUsIFwiPlwiKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdHN0YWdnZXJGdW5jID0gc3RhZ2dlciA/IGRpc3RyaWJ1dGUoc3RhZ2dlcikgOiBfZW1wdHlGdW5jO1xuXHRcdFx0XHRpZiAoX2lzT2JqZWN0KHN0YWdnZXIpKSB7IC8vdXNlcnMgY2FuIHBhc3MgaW4gY2FsbGJhY2tzIGxpa2Ugb25TdGFydC9vbkNvbXBsZXRlIGluIHRoZSBzdGFnZ2VyIG9iamVjdC4gVGhlc2Ugc2hvdWxkIGZpcmUgd2l0aCBlYWNoIGluZGl2aWR1YWwgdHdlZW4uXG5cdFx0XHRcdFx0Zm9yIChwIGluIHN0YWdnZXIpIHtcblx0XHRcdFx0XHRcdGlmICh+X3N0YWdnZXJUd2VlblByb3BzLmluZGV4T2YocCkpIHtcblx0XHRcdFx0XHRcdFx0c3RhZ2dlclZhcnNUb01lcmdlIHx8IChzdGFnZ2VyVmFyc1RvTWVyZ2UgPSB7fSk7XG5cdFx0XHRcdFx0XHRcdHN0YWdnZXJWYXJzVG9NZXJnZVtwXSA9IHN0YWdnZXJbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRjb3B5ID0ge307XG5cdFx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0XHRcdGlmIChfc3RhZ2dlclByb3BzVG9Ta2lwLmluZGV4T2YocCkgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdGNvcHlbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5LnN0YWdnZXIgPSAwO1xuXHRcdFx0XHRcdHlveW9FYXNlICYmIChjb3B5LnlveW9FYXNlID0geW95b0Vhc2UpO1xuXHRcdFx0XHRcdHN0YWdnZXJWYXJzVG9NZXJnZSAmJiBfbWVyZ2UoY29weSwgc3RhZ2dlclZhcnNUb01lcmdlKTtcblx0XHRcdFx0XHRjdXJUYXJnZXQgPSBwYXJzZWRUYXJnZXRzW2ldO1xuXHRcdFx0XHRcdC8vZG9uJ3QganVzdCBjb3B5IGR1cmF0aW9uIG9yIGRlbGF5IGJlY2F1c2UgaWYgdGhleSdyZSBhIHN0cmluZyBvciBmdW5jdGlvbiwgd2UnZCBlbmQgdXAgaW4gYW4gaW5maW5pdGUgbG9vcCBiZWNhdXNlIF9pc0Z1bmNPclN0cmluZygpIHdvdWxkIGV2YWx1YXRlIGFzIHRydWUgaW4gdGhlIGNoaWxkIHR3ZWVucywgZW50ZXJpbmcgdGhpcyBsb29wLCBldGMuIFNvIHdlIHBhcnNlIHRoZSB2YWx1ZSBzdHJhaWdodCBmcm9tIHZhcnMgYW5kIGRlZmF1bHQgdG8gMC5cblx0XHRcdFx0XHRjb3B5LmR1cmF0aW9uID0gK19wYXJzZUZ1bmNPclN0cmluZyhkdXJhdGlvbiwgdGhpcywgaSwgY3VyVGFyZ2V0LCBwYXJzZWRUYXJnZXRzKTtcblx0XHRcdFx0XHRjb3B5LmRlbGF5ID0gKCtfcGFyc2VGdW5jT3JTdHJpbmcoZGVsYXksIHRoaXMsIGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cykgfHwgMCkgLSB0aGlzLl9kZWxheTtcblx0XHRcdFx0XHRpZiAoIXN0YWdnZXIgJiYgbCA9PT0gMSAmJiBjb3B5LmRlbGF5KSB7IC8vIGlmIHNvbWVvbmUgZG9lcyBkZWxheTpcInJhbmRvbSgxLCA1KVwiLCByZXBlYXQ6LTEsIGZvciBleGFtcGxlLCB0aGUgZGVsYXkgc2hvdWxkbid0IGJlIGluc2lkZSB0aGUgcmVwZWF0LlxuXHRcdFx0XHRcdFx0dGhpcy5fZGVsYXkgPSBkZWxheSA9IGNvcHkuZGVsYXk7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydCArPSBkZWxheTtcblx0XHRcdFx0XHRcdGNvcHkuZGVsYXkgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bC50byhjdXJUYXJnZXQsIGNvcHksIHN0YWdnZXJGdW5jKGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cykpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRsLmR1cmF0aW9uKCkgPyAoZHVyYXRpb24gPSBkZWxheSA9IDApIDogKHRoaXMudGltZWxpbmUgPSAwKTsgLy8gaWYgdGhlIHRpbWVsaW5lJ3MgZHVyYXRpb24gaXMgMCwgd2UgZG9uJ3QgbmVlZCBhIHRpbWVsaW5lIGludGVybmFsbHkhXG5cdFx0XHR9XG5cdFx0XHRkdXJhdGlvbiB8fCB0aGlzLmR1cmF0aW9uKChkdXJhdGlvbiA9IHRsLmR1cmF0aW9uKCkpKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnRpbWVsaW5lID0gMDsgLy9zcGVlZCBvcHRpbWl6YXRpb24sIGZhc3RlciBsb29rdXBzIChubyBnb2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluKVxuXHRcdH1cblxuXHRcdGlmIChvdmVyd3JpdGUgPT09IHRydWUgJiYgIV9zdXBwcmVzc092ZXJ3cml0ZXMpIHtcblx0XHRcdF9vdmVyd3JpdGluZ1R3ZWVuID0gdGhpcztcblx0XHRcdF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YocGFyc2VkVGFyZ2V0cyk7XG5cdFx0XHRfb3ZlcndyaXRpbmdUd2VlbiA9IDA7XG5cdFx0fVxuXHRcdF9hZGRUb1RpbWVsaW5lKHBhcmVudCwgdGhpcywgcG9zaXRpb24pO1xuXHRcdHZhcnMucmV2ZXJzZWQgJiYgdGhpcy5yZXZlcnNlKCk7XG5cdFx0dmFycy5wYXVzZWQgJiYgdGhpcy5wYXVzZWQodHJ1ZSk7XG5cdFx0aWYgKGltbWVkaWF0ZVJlbmRlciB8fCAoIWR1cmF0aW9uICYmICFrZXlmcmFtZXMgJiYgdGhpcy5fc3RhcnQgPT09IF9yb3VuZChwYXJlbnQuX3RpbWUpICYmIF9pc05vdEZhbHNlKGltbWVkaWF0ZVJlbmRlcikgJiYgX2hhc05vUGF1c2VkQW5jZXN0b3JzKHRoaXMpICYmIHBhcmVudC5kYXRhICE9PSBcIm5lc3RlZFwiKSkge1xuXHRcdFx0dGhpcy5fdFRpbWUgPSAtX3RpbnlOdW07IC8vZm9yY2VzIGEgcmVuZGVyIHdpdGhvdXQgaGF2aW5nIHRvIHNldCB0aGUgcmVuZGVyKCkgXCJmb3JjZVwiIHBhcmFtZXRlciB0byB0cnVlIGJlY2F1c2Ugd2Ugd2FudCB0byBhbGxvdyBsYXp5aW5nIGJ5IGRlZmF1bHQgKHVzaW5nIHRoZSBcImZvcmNlXCIgcGFyYW1ldGVyIGFsd2F5cyBmb3JjZXMgYW4gaW1tZWRpYXRlIGZ1bGwgcmVuZGVyKVxuXHRcdFx0dGhpcy5yZW5kZXIoTWF0aC5tYXgoMCwgLWRlbGF5KSk7IC8vaW4gY2FzZSBkZWxheSBpcyBuZWdhdGl2ZVxuXHRcdH1cblx0XHRzY3JvbGxUcmlnZ2VyICYmIF9zY3JvbGxUcmlnZ2VyKHRoaXMsIHNjcm9sbFRyaWdnZXIpO1xuXHR9XG5cblx0cmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0bGV0IHByZXZUaW1lID0gdGhpcy5fdGltZSxcblx0XHRcdHREdXIgPSB0aGlzLl90RHVyLFxuXHRcdFx0ZHVyID0gdGhpcy5fZHVyLFxuXHRcdFx0dFRpbWUgPSAodG90YWxUaW1lID4gdER1ciAtIF90aW55TnVtICYmIHRvdGFsVGltZSA+PSAwKSA/IHREdXIgOiAodG90YWxUaW1lIDwgX3RpbnlOdW0pID8gMCA6IHRvdGFsVGltZSxcblx0XHRcdHRpbWUsIHB0LCBpdGVyYXRpb24sIGN5Y2xlRHVyYXRpb24sIHByZXZJdGVyYXRpb24sIGlzWW95bywgcmF0aW8sIHRpbWVsaW5lLCB5b3lvRWFzZTtcblx0XHRpZiAoIWR1cikge1xuXHRcdFx0X3JlbmRlclplcm9EdXJhdGlvblR3ZWVuKHRoaXMsIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHR9IGVsc2UgaWYgKHRUaW1lICE9PSB0aGlzLl90VGltZSB8fCAhdG90YWxUaW1lIHx8IGZvcmNlIHx8ICghdGhpcy5faW5pdHRlZCAmJiB0aGlzLl90VGltZSkgfHwgKHRoaXMuX3N0YXJ0QXQgJiYgKHRoaXMuX3pUaW1lIDwgMCkgIT09ICh0b3RhbFRpbWUgPCAwKSkpIHsgLy90aGlzIHNlbnNlcyBpZiB3ZSdyZSBjcm9zc2luZyBvdmVyIHRoZSBzdGFydCB0aW1lLCBpbiB3aGljaCBjYXNlIHdlIG11c3QgcmVjb3JkIF96VGltZSBhbmQgZm9yY2UgdGhlIHJlbmRlciwgYnV0IHdlIGRvIGl0IGluIHRoaXMgbGVuZ3RoeSBjb25kaXRpb25hbCB3YXkgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKHVzdWFsbHkgd2UgY2FuIHNraXAgdGhlIGNhbGN1bGF0aW9ucyk6IHRoaXMuX2luaXR0ZWQgJiYgKHRoaXMuX3pUaW1lIDwgMCkgIT09ICh0b3RhbFRpbWUgPCAwKVxuXHRcdFx0dGltZSA9IHRUaW1lO1xuXHRcdFx0dGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lO1xuXHRcdFx0aWYgKHRoaXMuX3JlcGVhdCkgeyAvL2FkanVzdCB0aGUgdGltZSBmb3IgcmVwZWF0cyBhbmQgeW95b3Ncblx0XHRcdFx0Y3ljbGVEdXJhdGlvbiA9IGR1ciArIHRoaXMuX3JEZWxheTtcblx0XHRcdFx0aWYgKHRoaXMuX3JlcGVhdCA8IC0xICYmIHRvdGFsVGltZSA8IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUoY3ljbGVEdXJhdGlvbiAqIDEwMCArIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aW1lID0gX3JvdW5kKHRUaW1lICUgY3ljbGVEdXJhdGlvbik7IC8vcm91bmQgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzLiAoNCAlIDAuOCBzaG91bGQgYmUgMCBidXQgc29tZSBicm93c2VycyByZXBvcnQgaXQgYXMgMC43OTk5OTk5OSEpXG5cdFx0XHRcdGlmICh0VGltZSA9PT0gdER1cikgeyAvLyB0aGUgdER1ciA9PT0gdFRpbWUgaXMgZm9yIGVkZ2UgY2FzZXMgd2hlcmUgdGhlcmUncyBhIGxlbmd0aHkgZGVjaW1hbCBvbiB0aGUgZHVyYXRpb24gYW5kIGl0IG1heSByZWFjaCB0aGUgdmVyeSBlbmQgYnV0IHRoZSB0aW1lIGlzIHJlbmRlcmVkIGFzIG5vdC1xdWl0ZS10aGVyZSAocmVtZW1iZXIsIHREdXIgaXMgcm91bmRlZCB0byA0IGRlY2ltYWxzIHdoZXJlYXMgZHVyIGlzbid0KVxuXHRcdFx0XHRcdGl0ZXJhdGlvbiA9IHRoaXMuX3JlcGVhdDtcblx0XHRcdFx0XHR0aW1lID0gZHVyO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGl0ZXJhdGlvbiA9IH5+KHRUaW1lIC8gY3ljbGVEdXJhdGlvbik7XG5cdFx0XHRcdFx0aWYgKGl0ZXJhdGlvbiAmJiBpdGVyYXRpb24gPT09IHRUaW1lIC8gY3ljbGVEdXJhdGlvbikge1xuXHRcdFx0XHRcdFx0dGltZSA9IGR1cjtcblx0XHRcdFx0XHRcdGl0ZXJhdGlvbi0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aW1lID4gZHVyICYmICh0aW1lID0gZHVyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpc1lveW8gPSB0aGlzLl95b3lvICYmIChpdGVyYXRpb24gJiAxKTtcblx0XHRcdFx0aWYgKGlzWW95bykge1xuXHRcdFx0XHRcdHlveW9FYXNlID0gdGhpcy5feUVhc2U7XG5cdFx0XHRcdFx0dGltZSA9IGR1ciAtIHRpbWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJldkl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbik7XG5cdFx0XHRcdGlmICh0aW1lID09PSBwcmV2VGltZSAmJiAhZm9yY2UgJiYgdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHRcdC8vY291bGQgYmUgZHVyaW5nIHRoZSByZXBlYXREZWxheSBwYXJ0LiBObyBuZWVkIHRvIHJlbmRlciBhbmQgZmlyZSBjYWxsYmFja3MuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGl0ZXJhdGlvbiAhPT0gcHJldkl0ZXJhdGlvbikge1xuXHRcdFx0XHRcdHRpbWVsaW5lICYmIHRoaXMuX3lFYXNlICYmIF9wcm9wYWdhdGVZb3lvRWFzZSh0aW1lbGluZSwgaXNZb3lvKTtcblx0XHRcdFx0XHQvL3JlcGVhdFJlZnJlc2ggZnVuY3Rpb25hbGl0eVxuXHRcdFx0XHRcdGlmICh0aGlzLnZhcnMucmVwZWF0UmVmcmVzaCAmJiAhaXNZb3lvICYmICF0aGlzLl9sb2NrKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9sb2NrID0gZm9yY2UgPSAxOyAvL2ZvcmNlLCBvdGhlcndpc2UgaWYgbGF6eSBpcyB0cnVlLCB0aGUgX2F0dGVtcHRJbml0VHdlZW4oKSB3aWxsIHJldHVybiBhbmQgd2UnbGwganVtcCBvdXQgYW5kIGdldCBjYXVnaHQgYm91bmNpbmcgb24gZWFjaCB0aWNrLlxuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXIoX3JvdW5kKGN5Y2xlRHVyYXRpb24gKiBpdGVyYXRpb24pLCB0cnVlKS5pbnZhbGlkYXRlKCkuX2xvY2sgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0aWYgKF9hdHRlbXB0SW5pdFR3ZWVuKHRoaXMsIHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiB0aW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMpKSB7XG5cdFx0XHRcdFx0dGhpcy5fdFRpbWUgPSAwOyAvLyBpbiBjb25zdHJ1Y3RvciBpZiBpbW1lZGlhdGVSZW5kZXIgaXMgdHJ1ZSwgd2Ugc2V0IF90VGltZSB0byAtX3RpbnlOdW0gdG8gaGF2ZSB0aGUgcGxheWhlYWQgY3Jvc3MgdGhlIHN0YXJ0aW5nIHBvaW50IGJ1dCB3ZSBjYW4ndCBsZWF2ZSBfdFRpbWUgYXMgYSBuZWdhdGl2ZSBudW1iZXIuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGR1ciAhPT0gdGhpcy5fZHVyKSB7IC8vIHdoaWxlIGluaXR0aW5nLCBhIHBsdWdpbiBsaWtlIEluZXJ0aWFQbHVnaW4gbWlnaHQgYWx0ZXIgdGhlIGR1cmF0aW9uLCBzbyByZXJ1biBmcm9tIHRoZSBzdGFydCB0byBlbnN1cmUgZXZlcnl0aGluZyByZW5kZXJzIGFzIGl0IHNob3VsZC5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3RUaW1lID0gdFRpbWU7XG5cdFx0XHR0aGlzLl90aW1lID0gdGltZTtcblxuXHRcdFx0aWYgKCF0aGlzLl9hY3QgJiYgdGhpcy5fdHMpIHtcblx0XHRcdFx0dGhpcy5fYWN0ID0gMTsgLy9hcyBsb25nIGFzIGl0J3Mgbm90IHBhdXNlZCwgZm9yY2UgaXQgdG8gYmUgYWN0aXZlIHNvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBpbmRlcGVuZGVudCBvZiB0aGUgcGFyZW50IHRpbWVsaW5lLCBpdCdsbCBiZSBmb3JjZWQgdG8gcmUtcmVuZGVyIG9uIHRoZSBuZXh0IHRpY2suXG5cdFx0XHRcdHRoaXMuX2xhenkgPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnJhdGlvID0gcmF0aW8gPSAoeW95b0Vhc2UgfHwgdGhpcy5fZWFzZSkodGltZSAvIGR1cik7XG5cdFx0XHRpZiAodGhpcy5fZnJvbSkge1xuXHRcdFx0XHR0aGlzLnJhdGlvID0gcmF0aW8gPSAxIC0gcmF0aW87XG5cdFx0XHR9XG5cblx0XHRcdHRpbWUgJiYgIXByZXZUaW1lICYmICFzdXBwcmVzc0V2ZW50cyAmJiBfY2FsbGJhY2sodGhpcywgXCJvblN0YXJ0XCIpO1xuXHRcdFx0aWYgKHRpbWUgJiYgIXByZXZUaW1lICYmICFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRfY2FsbGJhY2sodGhpcywgXCJvblN0YXJ0XCIpO1xuXHRcdFx0XHRpZiAodGhpcy5fdFRpbWUgIT09IHRUaW1lKSB7IC8vIGluIGNhc2UgdGhlIG9uU3RhcnQgdHJpZ2dlcmVkIGEgcmVuZGVyIGF0IGEgZGlmZmVyZW50IHNwb3QsIGVqZWN0LiBMaWtlIGlmIHNvbWVvbmUgZGlkIGFuaW1hdGlvbi5wYXVzZSgwLjUpIG9yIHNvbWV0aGluZyBpbnNpZGUgdGhlIG9uU3RhcnQuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cHQgPSB0aGlzLl9wdDtcblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRwdC5yKHJhdGlvLCBwdC5kKTtcblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblxuXHRcdFx0KHRpbWVsaW5lICYmIHRpbWVsaW5lLnJlbmRlcih0b3RhbFRpbWUgPCAwID8gdG90YWxUaW1lIDogIXRpbWUgJiYgaXNZb3lvID8gLV90aW55TnVtIDogdGltZWxpbmUuX2R1ciAqIHJhdGlvLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpKSB8fCAodGhpcy5fc3RhcnRBdCAmJiAodGhpcy5felRpbWUgPSB0b3RhbFRpbWUpKTtcblxuXHRcdFx0aWYgKHRoaXMuX29uVXBkYXRlICYmICFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHR0b3RhbFRpbWUgPCAwICYmIHRoaXMuX3N0YXJ0QXQgJiYgdGhpcy5fc3RhcnRBdC5yZW5kZXIodG90YWxUaW1lLCB0cnVlLCBmb3JjZSk7IC8vbm90ZTogZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIHR1Y2sgdGhpcyBjb25kaXRpb25hbCBsb2dpYyBpbnNpZGUgbGVzcyB0cmF2ZWxlZCBhcmVhcyAobW9zdCB0d2VlbnMgZG9uJ3QgaGF2ZSBhbiBvblVwZGF0ZSkuIFdlJ2QganVzdCBoYXZlIGl0IGF0IHRoZSBlbmQgYmVmb3JlIHRoZSBvbkNvbXBsZXRlLCBidXQgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCBiZWZvcmUgYW55IG9uVXBkYXRlIGlzIGNhbGxlZCwgc28gd2UgQUxTTyBwdXQgaXQgaGVyZSBhbmQgdGhlbiBpZiBpdCdzIG5vdCBjYWxsZWQsIHdlIGRvIHNvIGxhdGVyIG5lYXIgdGhlIG9uQ29tcGxldGUuXG5cdFx0XHRcdF9jYWxsYmFjayh0aGlzLCBcIm9uVXBkYXRlXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9yZXBlYXQgJiYgaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uICYmIHRoaXMudmFycy5vblJlcGVhdCAmJiAhc3VwcHJlc3NFdmVudHMgJiYgdGhpcy5wYXJlbnQgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25SZXBlYXRcIik7XG5cblx0XHRcdGlmICgodFRpbWUgPT09IHRoaXMuX3REdXIgfHwgIXRUaW1lKSAmJiB0aGlzLl90VGltZSA9PT0gdFRpbWUpIHtcblx0XHRcdFx0dG90YWxUaW1lIDwgMCAmJiB0aGlzLl9zdGFydEF0ICYmICF0aGlzLl9vblVwZGF0ZSAmJiB0aGlzLl9zdGFydEF0LnJlbmRlcih0b3RhbFRpbWUsIHRydWUsIHRydWUpO1xuXHRcdFx0XHQodG90YWxUaW1lIHx8ICFkdXIpICYmICgodFRpbWUgPT09IHRoaXMuX3REdXIgJiYgdGhpcy5fdHMgPiAwKSB8fCAoIXRUaW1lICYmIHRoaXMuX3RzIDwgMCkpICYmIF9yZW1vdmVGcm9tUGFyZW50KHRoaXMsIDEpOyAvLyBkb24ndCByZW1vdmUgaWYgd2UncmUgcmVuZGVyaW5nIGF0IGV4YWN0bHkgYSB0aW1lIG9mIDAsIGFzIHRoZXJlIGNvdWxkIGJlIGF1dG9SZXZlcnQgdmFsdWVzIHRoYXQgc2hvdWxkIGdldCBzZXQgb24gdGhlIG5leHQgdGljayAoaWYgdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgYmV5b25kIHRoZSBzdGFydFRpbWUsIG5lZ2F0aXZlIHRvdGFsVGltZSkuIERvbid0IHJlbW92ZSBpZiB0aGUgdGltZWxpbmUgaXMgcmV2ZXJzZWQgYW5kIHRoZSBwbGF5aGVhZCBpc24ndCBhdCAwLCBvdGhlcndpc2UgdGwucHJvZ3Jlc3MoMSkucmV2ZXJzZSgpIHdvbid0IHdvcmsuIE9ubHkgcmVtb3ZlIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCB0aGUgZW5kIGFuZCB0aW1lU2NhbGUgaXMgcG9zaXRpdmUsIG9yIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCAwIGFuZCB0aGUgdGltZVNjYWxlIGlzIG5lZ2F0aXZlLlxuXHRcdFx0ICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgISh0b3RhbFRpbWUgPCAwICYmICFwcmV2VGltZSkgJiYgKHRUaW1lIHx8IHByZXZUaW1lKSkgeyAvLyBpZiBwcmV2VGltZSBhbmQgdFRpbWUgYXJlIHplcm8sIHdlIHNob3VsZG4ndCBmaXJlIHRoZSBvblJldmVyc2VDb21wbGV0ZS4gVGhpcyBjb3VsZCBoYXBwZW4gaWYgeW91IGdzYXAudG8oLi4uIHtwYXVzZWQ6dHJ1ZX0pLnBsYXkoKTtcblx0XHRcdFx0XHRfY2FsbGJhY2sodGhpcywgKHRUaW1lID09PSB0RHVyID8gXCJvbkNvbXBsZXRlXCIgOiBcIm9uUmV2ZXJzZUNvbXBsZXRlXCIpLCB0cnVlKTtcblx0XHRcdFx0XHR0aGlzLl9wcm9tICYmICEodFRpbWUgPCB0RHVyICYmIHRoaXMudGltZVNjYWxlKCkgPiAwKSAmJiB0aGlzLl9wcm9tKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHRhcmdldHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RhcmdldHM7XG5cdH1cblxuXHRpbnZhbGlkYXRlKCkge1xuXHRcdHRoaXMuX3B0ID0gdGhpcy5fb3AgPSB0aGlzLl9zdGFydEF0ID0gdGhpcy5fb25VcGRhdGUgPSB0aGlzLl9sYXp5ID0gdGhpcy5yYXRpbyA9IDA7XG5cdFx0dGhpcy5fcHRMb29rdXAgPSBbXTtcblx0XHR0aGlzLnRpbWVsaW5lICYmIHRoaXMudGltZWxpbmUuaW52YWxpZGF0ZSgpO1xuXHRcdHJldHVybiBzdXBlci5pbnZhbGlkYXRlKCk7XG5cdH1cblxuXHRraWxsKHRhcmdldHMsIHZhcnMgPSBcImFsbFwiKSB7XG5cdFx0aWYgKCF0YXJnZXRzICYmICghdmFycyB8fCB2YXJzID09PSBcImFsbFwiKSkge1xuXHRcdFx0dGhpcy5fbGF6eSA9IHRoaXMuX3B0ID0gMDtcblx0XHRcdHJldHVybiB0aGlzLnBhcmVudCA/IF9pbnRlcnJ1cHQodGhpcykgOiB0aGlzO1xuXHRcdH1cblx0XHRpZiAodGhpcy50aW1lbGluZSkge1xuXHRcdFx0bGV0IHREdXIgPSB0aGlzLnRpbWVsaW5lLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdHRoaXMudGltZWxpbmUua2lsbFR3ZWVuc09mKHRhcmdldHMsIHZhcnMsIF9vdmVyd3JpdGluZ1R3ZWVuICYmIF9vdmVyd3JpdGluZ1R3ZWVuLnZhcnMub3ZlcndyaXRlICE9PSB0cnVlKS5fZmlyc3QgfHwgX2ludGVycnVwdCh0aGlzKTsgLy8gaWYgbm90aGluZyBpcyBsZWZ0IHR3ZWVuaW5nLCBpbnRlcnJ1cHQuXG5cdFx0XHR0aGlzLnBhcmVudCAmJiB0RHVyICE9PSB0aGlzLnRpbWVsaW5lLnRvdGFsRHVyYXRpb24oKSAmJiBfc2V0RHVyYXRpb24odGhpcywgdGhpcy5fZHVyICogdGhpcy50aW1lbGluZS5fdER1ciAvIHREdXIsIDAsIDEpOyAvLyBpZiBhIG5lc3RlZCB0d2VlbiBpcyBraWxsZWQgdGhhdCBjaGFuZ2VzIHRoZSBkdXJhdGlvbiwgaXQgc2hvdWxkIGFmZmVjdCB0aGlzIHR3ZWVuJ3MgZHVyYXRpb24uIFdlIG11c3QgdXNlIHRoZSByYXRpbywgdGhvdWdoLCBiZWNhdXNlIHNvbWV0aW1lcyB0aGUgaW50ZXJuYWwgdGltZWxpbmUgaXMgc3RyZXRjaGVkIGxpa2UgZm9yIGtleWZyYW1lcyB3aGVyZSB0aGV5IGRvbid0IGFsbCBhZGQgdXAgdG8gd2hhdGV2ZXIgdGhlIHBhcmVudCB0d2VlbidzIGR1cmF0aW9uIHdhcyBzZXQgdG8uXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0bGV0IHBhcnNlZFRhcmdldHMgPSB0aGlzLl90YXJnZXRzLFxuXHRcdFx0a2lsbGluZ1RhcmdldHMgPSB0YXJnZXRzID8gdG9BcnJheSh0YXJnZXRzKSA6IHBhcnNlZFRhcmdldHMsXG5cdFx0XHRwcm9wVHdlZW5Mb29rdXAgPSB0aGlzLl9wdExvb2t1cCxcblx0XHRcdGZpcnN0UFQgPSB0aGlzLl9wdCxcblx0XHRcdG92ZXJ3cml0dGVuUHJvcHMsIGN1ckxvb2t1cCwgY3VyT3ZlcndyaXRlUHJvcHMsIHByb3BzLCBwLCBwdCwgaTtcblx0XHRpZiAoKCF2YXJzIHx8IHZhcnMgPT09IFwiYWxsXCIpICYmIF9hcnJheXNNYXRjaChwYXJzZWRUYXJnZXRzLCBraWxsaW5nVGFyZ2V0cykpIHtcblx0XHRcdHZhcnMgPT09IFwiYWxsXCIgJiYgKHRoaXMuX3B0ID0gMCk7XG5cdFx0XHRyZXR1cm4gX2ludGVycnVwdCh0aGlzKTtcblx0XHR9XG5cdFx0b3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX29wID0gdGhpcy5fb3AgfHwgW107XG5cdFx0aWYgKHZhcnMgIT09IFwiYWxsXCIpIHsgLy9zbyBwZW9wbGUgY2FuIHBhc3MgaW4gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lc1xuXHRcdFx0aWYgKF9pc1N0cmluZyh2YXJzKSkge1xuXHRcdFx0XHRwID0ge307XG5cdFx0XHRcdF9mb3JFYWNoTmFtZSh2YXJzLCBuYW1lID0+IHBbbmFtZV0gPSAxKTtcblx0XHRcdFx0dmFycyA9IHA7XG5cdFx0XHR9XG5cdFx0XHR2YXJzID0gX2FkZEFsaWFzZXNUb1ZhcnMocGFyc2VkVGFyZ2V0cywgdmFycyk7XG5cdFx0fVxuXHRcdGkgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAofmtpbGxpbmdUYXJnZXRzLmluZGV4T2YocGFyc2VkVGFyZ2V0c1tpXSkpIHtcblx0XHRcdFx0Y3VyTG9va3VwID0gcHJvcFR3ZWVuTG9va3VwW2ldO1xuXHRcdFx0XHRpZiAodmFycyA9PT0gXCJhbGxcIikge1xuXHRcdFx0XHRcdG92ZXJ3cml0dGVuUHJvcHNbaV0gPSB2YXJzO1xuXHRcdFx0XHRcdHByb3BzID0gY3VyTG9va3VwO1xuXHRcdFx0XHRcdGN1ck92ZXJ3cml0ZVByb3BzID0ge307XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3VyT3ZlcndyaXRlUHJvcHMgPSBvdmVyd3JpdHRlblByb3BzW2ldID0gb3ZlcndyaXR0ZW5Qcm9wc1tpXSB8fCB7fTtcblx0XHRcdFx0XHRwcm9wcyA9IHZhcnM7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChwIGluIHByb3BzKSB7XG5cdFx0XHRcdFx0cHQgPSBjdXJMb29rdXAgJiYgY3VyTG9va3VwW3BdO1xuXHRcdFx0XHRcdGlmIChwdCkge1xuXHRcdFx0XHRcdFx0aWYgKCEoXCJraWxsXCIgaW4gcHQuZCkgfHwgcHQuZC5raWxsKHApID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBwdCwgXCJfcHRcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRkZWxldGUgY3VyTG9va3VwW3BdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoY3VyT3ZlcndyaXRlUHJvcHMgIT09IFwiYWxsXCIpIHtcblx0XHRcdFx0XHRcdGN1ck92ZXJ3cml0ZVByb3BzW3BdID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5faW5pdHRlZCAmJiAhdGhpcy5fcHQgJiYgZmlyc3RQVCAmJiBfaW50ZXJydXB0KHRoaXMpOyAvL2lmIGFsbCB0d2VlbmluZyBwcm9wZXJ0aWVzIGFyZSBraWxsZWQsIGtpbGwgdGhlIHR3ZWVuLiBXaXRob3V0IHRoaXMgbGluZSwgaWYgdGhlcmUncyBhIHR3ZWVuIHdpdGggbXVsdGlwbGUgdGFyZ2V0cyBhbmQgdGhlbiB5b3Uga2lsbFR3ZWVuc09mKCkgZWFjaCB0YXJnZXQgaW5kaXZpZHVhbGx5LCB0aGUgdHdlZW4gd291bGQgdGVjaG5pY2FsbHkgc3RpbGwgcmVtYWluIGFjdGl2ZSBhbmQgZmlyZSBpdHMgb25Db21wbGV0ZSBldmVuIHRob3VnaCB0aGVyZSBhcmVuJ3QgYW55IG1vcmUgcHJvcGVydGllcyB0d2VlbmluZy5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cblx0c3RhdGljIHRvKHRhcmdldHMsIHZhcnMpIHtcblx0XHRyZXR1cm4gbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIGFyZ3VtZW50c1syXSk7XG5cdH1cblxuXHRzdGF0aWMgZnJvbSh0YXJnZXRzLCB2YXJzKSB7XG5cdFx0cmV0dXJuIF9jcmVhdGVUd2VlblR5cGUoMSwgYXJndW1lbnRzKTtcblx0fVxuXG5cdHN0YXRpYyBkZWxheWVkQ2FsbChkZWxheSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpIHtcblx0XHRyZXR1cm4gbmV3IFR3ZWVuKGNhbGxiYWNrLCAwLCB7aW1tZWRpYXRlUmVuZGVyOmZhbHNlLCBsYXp5OmZhbHNlLCBvdmVyd3JpdGU6ZmFsc2UsIGRlbGF5OmRlbGF5LCBvbkNvbXBsZXRlOmNhbGxiYWNrLCBvblJldmVyc2VDb21wbGV0ZTpjYWxsYmFjaywgb25Db21wbGV0ZVBhcmFtczpwYXJhbXMsIG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOnBhcmFtcywgY2FsbGJhY2tTY29wZTpzY29wZX0pO1xuXHR9XG5cblx0c3RhdGljIGZyb21Ubyh0YXJnZXRzLCBmcm9tVmFycywgdG9WYXJzKSB7XG5cdFx0cmV0dXJuIF9jcmVhdGVUd2VlblR5cGUoMiwgYXJndW1lbnRzKTtcblx0fVxuXG5cdHN0YXRpYyBzZXQodGFyZ2V0cywgdmFycykge1xuXHRcdHZhcnMuZHVyYXRpb24gPSAwO1xuXHRcdHZhcnMucmVwZWF0RGVsYXkgfHwgKHZhcnMucmVwZWF0ID0gMCk7XG5cdFx0cmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzKTtcblx0fVxuXG5cdHN0YXRpYyBraWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpIHtcblx0XHRyZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSk7XG5cdH1cbn1cblxuX3NldERlZmF1bHRzKFR3ZWVuLnByb3RvdHlwZSwge190YXJnZXRzOltdLCBfbGF6eTowLCBfc3RhcnRBdDowLCBfb3A6MCwgX29uSW5pdDowfSk7XG5cbi8vYWRkIHRoZSBwZXJ0aW5lbnQgdGltZWxpbmUgbWV0aG9kcyB0byBUd2VlbiBpbnN0YW5jZXMgc28gdGhhdCB1c2VycyBjYW4gY2hhaW4gY29udmVuaWVudGx5IGFuZCBjcmVhdGUgYSB0aW1lbGluZSBhdXRvbWF0aWNhbGx5LiAocmVtb3ZlZCBkdWUgdG8gY29uY2VybnMgdGhhdCBpdCdkIHVsdGltYXRlbHkgYWRkIHRvIG1vcmUgY29uZnVzaW9uIGVzcGVjaWFsbHkgZm9yIGJlZ2lubmVycylcbi8vIF9mb3JFYWNoTmFtZShcInRvLGZyb20sZnJvbVRvLHNldCxjYWxsLGFkZCxhZGRMYWJlbCxhZGRQYXVzZVwiLCBuYW1lID0+IHtcbi8vIFx0VHdlZW4ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4vLyBcdFx0bGV0IHRsID0gbmV3IFRpbWVsaW5lKCk7XG4vLyBcdFx0cmV0dXJuIF9hZGRUb1RpbWVsaW5lKHRsLCB0aGlzKVtuYW1lXS5hcHBseSh0bCwgdG9BcnJheShhcmd1bWVudHMpKTtcbi8vIFx0fVxuLy8gfSk7XG5cbi8vZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIExldmVyYWdlIHRoZSB0aW1lbGluZSBjYWxscy5cbl9mb3JFYWNoTmFtZShcInN0YWdnZXJUbyxzdGFnZ2VyRnJvbSxzdGFnZ2VyRnJvbVRvXCIsIG5hbWUgPT4ge1xuXHRUd2VlbltuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdGxldCB0bCA9IG5ldyBUaW1lbGluZSgpLFxuXHRcdFx0cGFyYW1zID0gX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblx0XHRwYXJhbXMuc3BsaWNlKG5hbWUgPT09IFwic3RhZ2dlckZyb21Ub1wiID8gNSA6IDQsIDAsIDApO1xuXHRcdHJldHVybiB0bFtuYW1lXS5hcHBseSh0bCwgcGFyYW1zKTtcblx0fVxufSk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogUFJPUFRXRUVOXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5sZXQgX3NldHRlclBsYWluID0gKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSA9PiB0YXJnZXRbcHJvcGVydHldID0gdmFsdWUsXG5cdF9zZXR0ZXJGdW5jID0gKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSA9PiB0YXJnZXRbcHJvcGVydHldKHZhbHVlKSxcblx0X3NldHRlckZ1bmNXaXRoUGFyYW0gPSAodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEpID0+IHRhcmdldFtwcm9wZXJ0eV0oZGF0YS5mcCwgdmFsdWUpLFxuXHRfc2V0dGVyQXR0cmlidXRlID0gKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSA9PiB0YXJnZXQuc2V0QXR0cmlidXRlKHByb3BlcnR5LCB2YWx1ZSksXG5cdF9nZXRTZXR0ZXIgPSAodGFyZ2V0LCBwcm9wZXJ0eSkgPT4gX2lzRnVuY3Rpb24odGFyZ2V0W3Byb3BlcnR5XSkgPyBfc2V0dGVyRnVuYyA6IF9pc1VuZGVmaW5lZCh0YXJnZXRbcHJvcGVydHldKSAmJiB0YXJnZXQuc2V0QXR0cmlidXRlID8gX3NldHRlckF0dHJpYnV0ZSA6IF9zZXR0ZXJQbGFpbixcblx0X3JlbmRlclBsYWluID0gKHJhdGlvLCBkYXRhKSA9PiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDAwMCkgLyAxMDAwMDAwLCBkYXRhKSxcblx0X3JlbmRlckJvb2xlYW4gPSAocmF0aW8sIGRhdGEpID0+IGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCAhIShkYXRhLnMgKyBkYXRhLmMgKiByYXRpbyksIGRhdGEpLFxuXHRfcmVuZGVyQ29tcGxleFN0cmluZyA9IGZ1bmN0aW9uKHJhdGlvLCBkYXRhKSB7XG5cdFx0bGV0IHB0ID0gZGF0YS5fcHQsXG5cdFx0XHRzID0gXCJcIjtcblx0XHRpZiAoIXJhdGlvICYmIGRhdGEuYikgeyAvL2IgPSBiZWdpbm5pbmcgc3RyaW5nXG5cdFx0XHRzID0gZGF0YS5iO1xuXHRcdH0gZWxzZSBpZiAocmF0aW8gPT09IDEgJiYgZGF0YS5lKSB7IC8vZSA9IGVuZGluZyBzdHJpbmdcblx0XHRcdHMgPSBkYXRhLmU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRzID0gcHQucCArIChwdC5tID8gcHQubShwdC5zICsgcHQuYyAqIHJhdGlvKSA6IChNYXRoLnJvdW5kKChwdC5zICsgcHQuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwKSkgKyBzOyAvL3dlIHVzZSB0aGUgXCJwXCIgcHJvcGVydHkgZm9yIHRoZSB0ZXh0IGluYmV0d2VlbiAobGlrZSBhIHN1ZmZpeCkuIEFuZCBpbiB0aGUgY29udGV4dCBvZiBhIGNvbXBsZXggc3RyaW5nLCB0aGUgbW9kaWZpZXIgKG0pIGlzIHR5cGljYWxseSBqdXN0IE1hdGgucm91bmQoKSwgbGlrZSBmb3IgUkdCIGNvbG9ycy5cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHMgKz0gZGF0YS5jOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgY2h1bmsgb2Ygbm9uLW51bWVyaWMgdGV4dC5cblx0XHR9XG5cdFx0ZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHMsIGRhdGEpO1xuXHR9LFxuXHRfcmVuZGVyUHJvcFR3ZWVucyA9IGZ1bmN0aW9uKHJhdGlvLCBkYXRhKSB7XG5cdFx0bGV0IHB0ID0gZGF0YS5fcHQ7XG5cdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRwdC5yKHJhdGlvLCBwdC5kKTtcblx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0fVxuXHR9LFxuXHRfYWRkUGx1Z2luTW9kaWZpZXIgPSBmdW5jdGlvbihtb2RpZmllciwgdHdlZW4sIHRhcmdldCwgcHJvcGVydHkpIHtcblx0XHRsZXQgcHQgPSB0aGlzLl9wdCxcblx0XHRcdG5leHQ7XG5cdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRuZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRwdC5wID09PSBwcm9wZXJ0eSAmJiBwdC5tb2RpZmllcihtb2RpZmllciwgdHdlZW4sIHRhcmdldCk7XG5cdFx0XHRwdCA9IG5leHQ7XG5cdFx0fVxuXHR9LFxuXHRfa2lsbFByb3BUd2VlbnNPZiA9IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG5cdFx0bGV0IHB0ID0gdGhpcy5fcHQsXG5cdFx0XHRoYXNOb25EZXBlbmRlbnRSZW1haW5pbmcsIG5leHQ7XG5cdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRuZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRpZiAoKHB0LnAgPT09IHByb3BlcnR5ICYmICFwdC5vcCkgfHwgcHQub3AgPT09IHByb3BlcnR5KSB7XG5cdFx0XHRcdF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBwdCwgXCJfcHRcIik7XG5cdFx0XHR9IGVsc2UgaWYgKCFwdC5kZXApIHtcblx0XHRcdFx0aGFzTm9uRGVwZW5kZW50UmVtYWluaW5nID0gMTtcblx0XHRcdH1cblx0XHRcdHB0ID0gbmV4dDtcblx0XHR9XG5cdFx0cmV0dXJuICFoYXNOb25EZXBlbmRlbnRSZW1haW5pbmc7XG5cdH0sXG5cdF9zZXR0ZXJXaXRoTW9kaWZpZXIgPSAodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEpID0+IHtcblx0XHRkYXRhLm1TZXQodGFyZ2V0LCBwcm9wZXJ0eSwgZGF0YS5tLmNhbGwoZGF0YS50d2VlbiwgdmFsdWUsIGRhdGEubXQpLCBkYXRhKTtcblx0fSxcblx0X3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSA9IHBhcmVudCA9PiB7XG5cdFx0bGV0IHB0ID0gcGFyZW50Ll9wdCxcblx0XHRcdG5leHQsIHB0MiwgZmlyc3QsIGxhc3Q7XG5cdFx0Ly9zb3J0cyB0aGUgUHJvcFR3ZWVuIGxpbmtlZCBsaXN0IGluIG9yZGVyIG9mIHByaW9yaXR5IGJlY2F1c2Ugc29tZSBwbHVnaW5zIG5lZWQgdG8gZG8gdGhlaXIgd29yayBhZnRlciBBTEwgb2YgdGhlIFByb3BUd2VlbnMgd2VyZSBjcmVhdGVkIChsaWtlIFJvdW5kUHJvcHNQbHVnaW4gYW5kIE1vZGlmaWVyc1BsdWdpbilcblx0XHR3aGlsZSAocHQpIHtcblx0XHRcdG5leHQgPSBwdC5fbmV4dDtcblx0XHRcdHB0MiA9IGZpcnN0O1xuXHRcdFx0d2hpbGUgKHB0MiAmJiBwdDIucHIgPiBwdC5wcikge1xuXHRcdFx0XHRwdDIgPSBwdDIuX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKHB0Ll9wcmV2ID0gcHQyID8gcHQyLl9wcmV2IDogbGFzdCkpIHtcblx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZpcnN0ID0gcHQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKHB0Ll9uZXh0ID0gcHQyKSkge1xuXHRcdFx0XHRwdDIuX3ByZXYgPSBwdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxhc3QgPSBwdDtcblx0XHRcdH1cblx0XHRcdHB0ID0gbmV4dDtcblx0XHR9XG5cdFx0cGFyZW50Ll9wdCA9IGZpcnN0O1xuXHR9O1xuXG4vL1Byb3BUd2VlbiBrZXk6IHQgPSB0YXJnZXQsIHAgPSBwcm9wLCByID0gcmVuZGVyZXIsIGQgPSBkYXRhLCBzID0gc3RhcnQsIGMgPSBjaGFuZ2UsIG9wID0gb3ZlcndyaXRlUHJvcGVydHkgKE9OTFkgcG9wdWxhdGVkIHdoZW4gaXQncyBkaWZmZXJlbnQgdGhhbiBwKSwgcHIgPSBwcmlvcml0eSwgX25leHQvX3ByZXYgZm9yIHRoZSBsaW5rZWQgbGlzdCBzaWJsaW5ncywgc2V0ID0gc2V0dGVyLCBtID0gbW9kaWZpZXIsIG1TZXQgPSBtb2RpZmllclNldHRlciAodGhlIG9yaWdpbmFsIHNldHRlciwgYmVmb3JlIGEgbW9kaWZpZXIgd2FzIGFkZGVkKVxuZXhwb3J0IGNsYXNzIFByb3BUd2VlbiB7XG5cblx0Y29uc3RydWN0b3IobmV4dCwgdGFyZ2V0LCBwcm9wLCBzdGFydCwgY2hhbmdlLCByZW5kZXJlciwgZGF0YSwgc2V0dGVyLCBwcmlvcml0eSkge1xuXHRcdHRoaXMudCA9IHRhcmdldDtcblx0XHR0aGlzLnMgPSBzdGFydDtcblx0XHR0aGlzLmMgPSBjaGFuZ2U7XG5cdFx0dGhpcy5wID0gcHJvcDtcblx0XHR0aGlzLnIgPSByZW5kZXJlciB8fCBfcmVuZGVyUGxhaW47XG5cdFx0dGhpcy5kID0gZGF0YSB8fCB0aGlzO1xuXHRcdHRoaXMuc2V0ID0gc2V0dGVyIHx8IF9zZXR0ZXJQbGFpbjtcblx0XHR0aGlzLnByID0gcHJpb3JpdHkgfHwgMDtcblx0XHR0aGlzLl9uZXh0ID0gbmV4dDtcblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5fcHJldiA9IHRoaXM7XG5cdFx0fVxuXHR9XG5cblx0bW9kaWZpZXIoZnVuYywgdHdlZW4sIHRhcmdldCkge1xuXHRcdHRoaXMubVNldCA9IHRoaXMubVNldCB8fCB0aGlzLnNldDsgLy9pbiBjYXNlIGl0IHdhcyBhbHJlYWR5IHNldCAoYSBQcm9wVHdlZW4gY2FuIG9ubHkgaGF2ZSBvbmUgbW9kaWZpZXIpXG5cdFx0dGhpcy5zZXQgPSBfc2V0dGVyV2l0aE1vZGlmaWVyO1xuXHRcdHRoaXMubSA9IGZ1bmM7XG5cdFx0dGhpcy5tdCA9IHRhcmdldDsgLy9tb2RpZmllciB0YXJnZXRcblx0XHR0aGlzLnR3ZWVuID0gdHdlZW47XG5cdH1cbn1cblxuXG5cbi8vSW5pdGlhbGl6YXRpb24gdGFza3Ncbl9mb3JFYWNoTmFtZShfY2FsbGJhY2tOYW1lcyArIFwicGFyZW50LGR1cmF0aW9uLGVhc2UsZGVsYXksb3ZlcndyaXRlLHJ1bkJhY2t3YXJkcyxzdGFydEF0LHlveW8saW1tZWRpYXRlUmVuZGVyLHJlcGVhdCxyZXBlYXREZWxheSxkYXRhLHBhdXNlZCxyZXZlcnNlZCxsYXp5LGNhbGxiYWNrU2NvcGUsc3RyaW5nRmlsdGVyLGlkLHlveW9FYXNlLHN0YWdnZXIsaW5oZXJpdCxyZXBlYXRSZWZyZXNoLGtleWZyYW1lcyxhdXRvUmV2ZXJ0LHNjcm9sbFRyaWdnZXJcIiwgbmFtZSA9PiBfcmVzZXJ2ZWRQcm9wc1tuYW1lXSA9IDEpO1xuX2dsb2JhbHMuVHdlZW5NYXggPSBfZ2xvYmFscy5Ud2VlbkxpdGUgPSBUd2Vlbjtcbl9nbG9iYWxzLlRpbWVsaW5lTGl0ZSA9IF9nbG9iYWxzLlRpbWVsaW5lTWF4ID0gVGltZWxpbmU7XG5fZ2xvYmFsVGltZWxpbmUgPSBuZXcgVGltZWxpbmUoe3NvcnRDaGlsZHJlbjogZmFsc2UsIGRlZmF1bHRzOiBfZGVmYXVsdHMsIGF1dG9SZW1vdmVDaGlsZHJlbjogdHJ1ZSwgaWQ6XCJyb290XCIsIHNtb290aENoaWxkVGltaW5nOiB0cnVlfSk7XG5fY29uZmlnLnN0cmluZ0ZpbHRlciA9IF9jb2xvclN0cmluZ0ZpbHRlcjtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEdTQVBcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbmNvbnN0IF9nc2FwID0ge1xuXHRyZWdpc3RlclBsdWdpbiguLi5hcmdzKSB7XG5cdFx0YXJncy5mb3JFYWNoKGNvbmZpZyA9PiBfY3JlYXRlUGx1Z2luKGNvbmZpZykpO1xuXHR9LFxuXHR0aW1lbGluZSh2YXJzKSB7XG5cdFx0cmV0dXJuIG5ldyBUaW1lbGluZSh2YXJzKTtcblx0fSxcblx0Z2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSkge1xuXHRcdHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSk7XG5cdH0sXG5cdGdldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpIHtcblx0XHRfaXNTdHJpbmcodGFyZ2V0KSAmJiAodGFyZ2V0ID0gdG9BcnJheSh0YXJnZXQpWzBdKTsgLy9pbiBjYXNlIHNlbGVjdG9yIHRleHQgb3IgYW4gYXJyYXkgaXMgcGFzc2VkIGluXG5cdFx0bGV0IGdldHRlciA9IF9nZXRDYWNoZSh0YXJnZXQgfHwge30pLmdldCxcblx0XHRcdGZvcm1hdCA9IHVuaXQgPyBfcGFzc1Rocm91Z2ggOiBfbnVtZXJpY0lmUG9zc2libGU7XG5cdFx0dW5pdCA9PT0gXCJuYXRpdmVcIiAmJiAodW5pdCA9IFwiXCIpO1xuXHRcdHJldHVybiAhdGFyZ2V0ID8gdGFyZ2V0IDogIXByb3BlcnR5ID8gKHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSA9PiBmb3JtYXQoKChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgX3BsdWdpbnNbcHJvcGVydHldLmdldCkgfHwgZ2V0dGVyKSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSkgOiBmb3JtYXQoKChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgX3BsdWdpbnNbcHJvcGVydHldLmdldCkgfHwgZ2V0dGVyKSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSk7XG5cdH0sXG5cdHF1aWNrU2V0dGVyKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHtcblx0XHR0YXJnZXQgPSB0b0FycmF5KHRhcmdldCk7XG5cdFx0aWYgKHRhcmdldC5sZW5ndGggPiAxKSB7XG5cdFx0XHRsZXQgc2V0dGVycyA9IHRhcmdldC5tYXAodCA9PiBnc2FwLnF1aWNrU2V0dGVyKHQsIHByb3BlcnR5LCB1bml0KSksXG5cdFx0XHRcdGwgPSBzZXR0ZXJzLmxlbmd0aDtcblx0XHRcdHJldHVybiB2YWx1ZSA9PiB7XG5cdFx0XHRcdGxldCBpID0gbDtcblx0XHRcdFx0d2hpbGUoaS0tKSB7XG5cdFx0XHRcdFx0c2V0dGVyc1tpXSh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGFyZ2V0ID0gdGFyZ2V0WzBdIHx8IHt9O1xuXHRcdGxldCBQbHVnaW4gPSBfcGx1Z2luc1twcm9wZXJ0eV0sXG5cdFx0XHRjYWNoZSA9IF9nZXRDYWNoZSh0YXJnZXQpLFxuXHRcdFx0cCA9IChjYWNoZS5oYXJuZXNzICYmIChjYWNoZS5oYXJuZXNzLmFsaWFzZXMgfHwge30pW3Byb3BlcnR5XSkgfHwgcHJvcGVydHksIC8vIGluIGNhc2UgaXQncyBhbiBhbGlhcywgbGlrZSBcInJvdGF0ZVwiIGZvciBcInJvdGF0aW9uXCIuXG5cdFx0XHRzZXR0ZXIgPSBQbHVnaW4gPyB2YWx1ZSA9PiB7XG5cdFx0XHRcdGxldCBwID0gbmV3IFBsdWdpbigpO1xuXHRcdFx0XHRfcXVpY2tUd2Vlbi5fcHQgPSAwO1xuXHRcdFx0XHRwLmluaXQodGFyZ2V0LCB1bml0ID8gdmFsdWUgKyB1bml0IDogdmFsdWUsIF9xdWlja1R3ZWVuLCAwLCBbdGFyZ2V0XSk7XG5cdFx0XHRcdHAucmVuZGVyKDEsIHApO1xuXHRcdFx0XHRfcXVpY2tUd2Vlbi5fcHQgJiYgX3JlbmRlclByb3BUd2VlbnMoMSwgX3F1aWNrVHdlZW4pO1xuXHRcdFx0fSA6IGNhY2hlLnNldCh0YXJnZXQsIHApO1xuXHRcdHJldHVybiBQbHVnaW4gPyBzZXR0ZXIgOiB2YWx1ZSA9PiBzZXR0ZXIodGFyZ2V0LCBwLCB1bml0ID8gdmFsdWUgKyB1bml0IDogdmFsdWUsIGNhY2hlLCAxKTtcblx0fSxcblx0aXNUd2VlbmluZyh0YXJnZXRzKSB7XG5cdFx0cmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRUd2VlbnNPZih0YXJnZXRzLCB0cnVlKS5sZW5ndGggPiAwO1xuXHR9LFxuXHRkZWZhdWx0cyh2YWx1ZSkge1xuXHRcdHZhbHVlICYmIHZhbHVlLmVhc2UgJiYgKHZhbHVlLmVhc2UgPSBfcGFyc2VFYXNlKHZhbHVlLmVhc2UsIF9kZWZhdWx0cy5lYXNlKSk7XG5cdFx0cmV0dXJuIF9tZXJnZURlZXAoX2RlZmF1bHRzLCB2YWx1ZSB8fCB7fSk7XG5cdH0sXG5cdGNvbmZpZyh2YWx1ZSkge1xuXHRcdHJldHVybiBfbWVyZ2VEZWVwKF9jb25maWcsIHZhbHVlIHx8IHt9KTtcblx0fSxcblx0cmVnaXN0ZXJFZmZlY3Qoe25hbWUsIGVmZmVjdCwgcGx1Z2lucywgZGVmYXVsdHMsIGV4dGVuZFRpbWVsaW5lfSkge1xuXHRcdChwbHVnaW5zIHx8IFwiXCIpLnNwbGl0KFwiLFwiKS5mb3JFYWNoKHBsdWdpbk5hbWUgPT4gcGx1Z2luTmFtZSAmJiAhX3BsdWdpbnNbcGx1Z2luTmFtZV0gJiYgIV9nbG9iYWxzW3BsdWdpbk5hbWVdICYmIF93YXJuKG5hbWUgKyBcIiBlZmZlY3QgcmVxdWlyZXMgXCIgKyBwbHVnaW5OYW1lICsgXCIgcGx1Z2luLlwiKSk7XG5cdFx0X2VmZmVjdHNbbmFtZV0gPSAodGFyZ2V0cywgdmFycywgdGwpID0+IGVmZmVjdCh0b0FycmF5KHRhcmdldHMpLCBfc2V0RGVmYXVsdHModmFycyB8fCB7fSwgZGVmYXVsdHMpLCB0bCk7XG5cdFx0aWYgKGV4dGVuZFRpbWVsaW5lKSB7XG5cdFx0XHRUaW1lbGluZS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbih0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5hZGQoX2VmZmVjdHNbbmFtZV0odGFyZ2V0cywgX2lzT2JqZWN0KHZhcnMpID8gdmFycyA6IChwb3NpdGlvbiA9IHZhcnMpICYmIHt9LCB0aGlzKSwgcG9zaXRpb24pO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0sXG5cdHJlZ2lzdGVyRWFzZShuYW1lLCBlYXNlKSB7XG5cdFx0X2Vhc2VNYXBbbmFtZV0gPSBfcGFyc2VFYXNlKGVhc2UpO1xuXHR9LFxuXHRwYXJzZUVhc2UoZWFzZSwgZGVmYXVsdEVhc2UpIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IF9wYXJzZUVhc2UoZWFzZSwgZGVmYXVsdEVhc2UpIDogX2Vhc2VNYXA7XG5cdH0sXG5cdGdldEJ5SWQoaWQpIHtcblx0XHRyZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmdldEJ5SWQoaWQpO1xuXHR9LFxuXHRleHBvcnRSb290KHZhcnMgPSB7fSwgaW5jbHVkZURlbGF5ZWRDYWxscykge1xuXHRcdGxldCB0bCA9IG5ldyBUaW1lbGluZSh2YXJzKSxcblx0XHRcdGNoaWxkLCBuZXh0O1xuXHRcdHRsLnNtb290aENoaWxkVGltaW5nID0gX2lzTm90RmFsc2UodmFycy5zbW9vdGhDaGlsZFRpbWluZyk7XG5cdFx0X2dsb2JhbFRpbWVsaW5lLnJlbW92ZSh0bCk7XG5cdFx0dGwuX2RwID0gMDsgLy9vdGhlcndpc2UgaXQnbGwgZ2V0IHJlLWFjdGl2YXRlZCB3aGVuIGFkZGluZyBjaGlsZHJlbiBhbmQgYmUgcmUtaW50cm9kdWNlZCBpbnRvIF9nbG9iYWxUaW1lbGluZSdzIGxpbmtlZCBsaXN0ICh0aGVuIGFkZGVkIHRvIGl0c2VsZikuXG5cdFx0dGwuX3RpbWUgPSB0bC5fdFRpbWUgPSBfZ2xvYmFsVGltZWxpbmUuX3RpbWU7XG5cdFx0Y2hpbGQgPSBfZ2xvYmFsVGltZWxpbmUuX2ZpcnN0O1xuXHRcdHdoaWxlIChjaGlsZCkge1xuXHRcdFx0bmV4dCA9IGNoaWxkLl9uZXh0O1xuXHRcdFx0aWYgKGluY2x1ZGVEZWxheWVkQ2FsbHMgfHwgISghY2hpbGQuX2R1ciAmJiBjaGlsZCBpbnN0YW5jZW9mIFR3ZWVuICYmIGNoaWxkLnZhcnMub25Db21wbGV0ZSA9PT0gY2hpbGQuX3RhcmdldHNbMF0pKSB7XG5cdFx0XHRcdF9hZGRUb1RpbWVsaW5lKHRsLCBjaGlsZCwgY2hpbGQuX3N0YXJ0IC0gY2hpbGQuX2RlbGF5KTtcblx0XHRcdH1cblx0XHRcdGNoaWxkID0gbmV4dDtcblx0XHR9XG5cdFx0X2FkZFRvVGltZWxpbmUoX2dsb2JhbFRpbWVsaW5lLCB0bCwgMCk7XG5cdFx0cmV0dXJuIHRsO1xuXHR9LFxuXHR1dGlsczogeyB3cmFwLCB3cmFwWW95bywgZGlzdHJpYnV0ZSwgcmFuZG9tLCBzbmFwLCBub3JtYWxpemUsIGdldFVuaXQsIGNsYW1wLCBzcGxpdENvbG9yLCB0b0FycmF5LCBzZWxlY3RvciwgbWFwUmFuZ2UsIHBpcGUsIHVuaXRpemUsIGludGVycG9sYXRlLCBzaHVmZmxlIH0sXG5cdGluc3RhbGw6IF9pbnN0YWxsLFxuXHRlZmZlY3RzOiBfZWZmZWN0cyxcblx0dGlja2VyOiBfdGlja2VyLFxuXHR1cGRhdGVSb290OiBUaW1lbGluZS51cGRhdGVSb290LFxuXHRwbHVnaW5zOiBfcGx1Z2lucyxcblx0Z2xvYmFsVGltZWxpbmU6IF9nbG9iYWxUaW1lbGluZSxcblx0Y29yZToge1Byb3BUd2VlbiwgZ2xvYmFsczogX2FkZEdsb2JhbCwgVHdlZW4sIFRpbWVsaW5lLCBBbmltYXRpb24sIGdldENhY2hlOiBfZ2V0Q2FjaGUsIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSwgc3VwcHJlc3NPdmVyd3JpdGVzOiB2YWx1ZSA9PiBfc3VwcHJlc3NPdmVyd3JpdGVzID0gdmFsdWV9XG59O1xuXG5fZm9yRWFjaE5hbWUoXCJ0byxmcm9tLGZyb21UbyxkZWxheWVkQ2FsbCxzZXQsa2lsbFR3ZWVuc09mXCIsIG5hbWUgPT4gX2dzYXBbbmFtZV0gPSBUd2VlbltuYW1lXSk7XG5fdGlja2VyLmFkZChUaW1lbGluZS51cGRhdGVSb290KTtcbl9xdWlja1R3ZWVuID0gX2dzYXAudG8oe30sIHtkdXJhdGlvbjowfSk7XG5cblxuXG5cbi8vIC0tLS0gRVhUUkEgUExVR0lOUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbmxldCBfZ2V0UGx1Z2luUHJvcFR3ZWVuID0gKHBsdWdpbiwgcHJvcCkgPT4ge1xuXHRcdGxldCBwdCA9IHBsdWdpbi5fcHQ7XG5cdFx0d2hpbGUgKHB0ICYmIHB0LnAgIT09IHByb3AgJiYgcHQub3AgIT09IHByb3AgJiYgcHQuZnAgIT09IHByb3ApIHtcblx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0fVxuXHRcdHJldHVybiBwdDtcblx0fSxcblx0X2FkZE1vZGlmaWVycyA9ICh0d2VlbiwgbW9kaWZpZXJzKSA9PiB7XG5cdFx0XHRsZXRcdHRhcmdldHMgPSB0d2Vlbi5fdGFyZ2V0cyxcblx0XHRcdFx0cCwgaSwgcHQ7XG5cdFx0XHRmb3IgKHAgaW4gbW9kaWZpZXJzKSB7XG5cdFx0XHRcdGkgPSB0YXJnZXRzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdHB0ID0gdHdlZW4uX3B0TG9va3VwW2ldW3BdO1xuXHRcdFx0XHRcdGlmIChwdCAmJiAocHQgPSBwdC5kKSkge1xuXHRcdFx0XHRcdFx0aWYgKHB0Ll9wdCkgeyAvLyBpcyBhIHBsdWdpblxuXHRcdFx0XHRcdFx0XHRwdCA9IF9nZXRQbHVnaW5Qcm9wVHdlZW4ocHQsIHApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cHQgJiYgcHQubW9kaWZpZXIgJiYgcHQubW9kaWZpZXIobW9kaWZpZXJzW3BdLCB0d2VlbiwgdGFyZ2V0c1tpXSwgcCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdH0sXG5cdF9idWlsZE1vZGlmaWVyUGx1Z2luID0gKG5hbWUsIG1vZGlmaWVyKSA9PiB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRyYXdWYXJzOiAxLCAvL2Rvbid0IHByZS1wcm9jZXNzIGZ1bmN0aW9uLWJhc2VkIHZhbHVlcyBvciBcInJhbmRvbSgpXCIgc3RyaW5ncy5cblx0XHRcdGluaXQodGFyZ2V0LCB2YXJzLCB0d2Vlbikge1xuXHRcdFx0XHR0d2Vlbi5fb25Jbml0ID0gdHdlZW4gPT4ge1xuXHRcdFx0XHRcdGxldCB0ZW1wLCBwO1xuXHRcdFx0XHRcdGlmIChfaXNTdHJpbmcodmFycykpIHtcblx0XHRcdFx0XHRcdHRlbXAgPSB7fTtcblx0XHRcdFx0XHRcdF9mb3JFYWNoTmFtZSh2YXJzLCBuYW1lID0+IHRlbXBbbmFtZV0gPSAxKTsgLy9pZiB0aGUgdXNlciBwYXNzZXMgaW4gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcyB0byByb3VuZFByb3BzLCBsaWtlIFwieCx5XCIsIHdlIHJvdW5kIHRvIHdob2xlIG51bWJlcnMuXG5cdFx0XHRcdFx0XHR2YXJzID0gdGVtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1vZGlmaWVyKSB7XG5cdFx0XHRcdFx0XHR0ZW1wID0ge307XG5cdFx0XHRcdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRcdFx0XHR0ZW1wW3BdID0gbW9kaWZpZXIodmFyc1twXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXJzID0gdGVtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X2FkZE1vZGlmaWVycyh0d2VlbiwgdmFycyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcblxuLy9yZWdpc3RlciBjb3JlIHBsdWdpbnNcbmV4cG9ydCBjb25zdCBnc2FwID0gX2dzYXAucmVnaXN0ZXJQbHVnaW4oe1xuXHRcdG5hbWU6XCJhdHRyXCIsXG5cdFx0aW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuXHRcdFx0bGV0IHAsIHB0O1xuXHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0cHQgPSB0aGlzLmFkZCh0YXJnZXQsIFwic2V0QXR0cmlidXRlXCIsICh0YXJnZXQuZ2V0QXR0cmlidXRlKHApIHx8IDApICsgXCJcIiwgdmFyc1twXSwgaW5kZXgsIHRhcmdldHMsIDAsIDAsIHApO1xuXHRcdFx0XHRwdCAmJiAocHQub3AgPSBwKTtcblx0XHRcdFx0dGhpcy5fcHJvcHMucHVzaChwKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sIHtcblx0XHRuYW1lOlwiZW5kQXJyYXlcIixcblx0XHRpbml0KHRhcmdldCwgdmFsdWUpIHtcblx0XHRcdGxldCBpID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHR0aGlzLmFkZCh0YXJnZXQsIGksIHRhcmdldFtpXSB8fCAwLCB2YWx1ZVtpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRfYnVpbGRNb2RpZmllclBsdWdpbihcInJvdW5kUHJvcHNcIiwgX3JvdW5kTW9kaWZpZXIpLFxuXHRfYnVpbGRNb2RpZmllclBsdWdpbihcIm1vZGlmaWVyc1wiKSxcblx0X2J1aWxkTW9kaWZpZXJQbHVnaW4oXCJzbmFwXCIsIHNuYXApXG4pIHx8IF9nc2FwOyAvL3RvIHByZXZlbnQgdGhlIGNvcmUgcGx1Z2lucyBmcm9tIGJlaW5nIGRyb3BwZWQgdmlhIGFnZ3Jlc3NpdmUgdHJlZSBzaGFraW5nLCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGUgdmFyaWFibGUgZGVjbGFyYXRpb24gaW4gdGhpcyB3YXkuXG5cblR3ZWVuLnZlcnNpb24gPSBUaW1lbGluZS52ZXJzaW9uID0gZ3NhcC52ZXJzaW9uID0gXCIzLjcuMFwiO1xuX2NvcmVSZWFkeSA9IDE7XG5fd2luZG93RXhpc3RzKCkgJiYgX3dha2UoKTtcblxuZXhwb3J0IGNvbnN0IHsgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjIH0gPSBfZWFzZU1hcDtcbmV4cG9ydCB7IFR3ZWVuIGFzIFR3ZWVuTWF4LCBUd2VlbiBhcyBUd2VlbkxpdGUsIFRpbWVsaW5lIGFzIFRpbWVsaW5lTWF4LCBUaW1lbGluZSBhcyBUaW1lbGluZUxpdGUsIGdzYXAgYXMgZGVmYXVsdCwgd3JhcCwgd3JhcFlveW8sIGRpc3RyaWJ1dGUsIHJhbmRvbSwgc25hcCwgbm9ybWFsaXplLCBnZXRVbml0LCBjbGFtcCwgc3BsaXRDb2xvciwgdG9BcnJheSwgc2VsZWN0b3IsIG1hcFJhbmdlLCBwaXBlLCB1bml0aXplLCBpbnRlcnBvbGF0ZSwgc2h1ZmZsZSB9O1xuLy9leHBvcnQgc29tZSBpbnRlcm5hbCBtZXRob2RzL29yb2plY3RzIGZvciB1c2UgaW4gQ1NTUGx1Z2luIHNvIHRoYXQgd2UgY2FuIGV4dGVybmFsaXplIHRoYXQgZmlsZSBhbmQgYWxsb3cgY3VzdG9tIGJ1aWxkcyB0aGF0IGV4Y2x1ZGUgaXQuXG5leHBvcnQgeyBfZ2V0UHJvcGVydHksIF9udW1FeHAsIF9udW1XaXRoVW5pdEV4cCwgX2lzU3RyaW5nLCBfaXNVbmRlZmluZWQsIF9yZW5kZXJDb21wbGV4U3RyaW5nLCBfcmVsRXhwLCBfc2V0RGVmYXVsdHMsIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSwgX2ZvckVhY2hOYW1lLCBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5LCBfY29sb3JTdHJpbmdGaWx0ZXIsIF9yZXBsYWNlUmFuZG9tLCBfY2hlY2tQbHVnaW4sIF9wbHVnaW5zLCBfdGlja2VyLCBfY29uZmlnLCBfcm91bmRNb2RpZmllciwgX3JvdW5kLCBfbWlzc2luZ1BsdWdpbiwgX2dldFNldHRlciwgX2dldENhY2hlLCBfY29sb3JFeHAgfSIsImltcG9ydCB7IGdzYXAsIFBvd2VyMCwgUG93ZXIxLCBQb3dlcjIsIFBvd2VyMywgUG93ZXI0LCBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgRWxhc3RpYywgQmFjaywgU3RlcHBlZEVhc2UsIEJvdW5jZSwgU2luZSwgRXhwbywgQ2lyYywgVHdlZW5MaXRlLCBUaW1lbGluZUxpdGUsIFRpbWVsaW5lTWF4IH0gZnJvbSBcIi4vZ3NhcC1jb3JlLmpzXCI7XG5pbXBvcnQgeyBDU1NQbHVnaW4gfSBmcm9tIFwiLi9DU1NQbHVnaW4uanNcIjtcblxuY29uc3QgZ3NhcFdpdGhDU1MgPSBnc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbikgfHwgZ3NhcCwgLy8gdG8gcHJvdGVjdCBmcm9tIHRyZWUgc2hha2luZ1xuXHRUd2Vlbk1heFdpdGhDU1MgPSBnc2FwV2l0aENTUy5jb3JlLlR3ZWVuO1xuXG5leHBvcnQge1xuXHRnc2FwV2l0aENTUyBhcyBnc2FwLFxuXHRnc2FwV2l0aENTUyBhcyBkZWZhdWx0LFxuXHRDU1NQbHVnaW4sXG5cdFR3ZWVuTWF4V2l0aENTUyBhcyBUd2Vlbk1heCxcblx0VHdlZW5MaXRlLFxuXHRUaW1lbGluZU1heCxcblx0VGltZWxpbmVMaXRlLFxuXHRQb3dlcjAsXG5cdFBvd2VyMSxcblx0UG93ZXIyLFxuXHRQb3dlcjMsXG5cdFBvd2VyNCxcblx0TGluZWFyLFxuXHRRdWFkLFxuXHRDdWJpYyxcblx0UXVhcnQsXG5cdFF1aW50LFxuXHRTdHJvbmcsXG5cdEVsYXN0aWMsXG5cdEJhY2ssXG5cdFN0ZXBwZWRFYXNlLFxuXHRCb3VuY2UsXG5cdFNpbmUsXG5cdEV4cG8sXG5cdENpcmNcbn07IiwiLyohXG4gKiBwYXRocyAzLjcuMFxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyMSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbmxldCBfc3ZnUGF0aEV4cCA9IC9bYWNobG1xc3R2el18KC0/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT8pWzAtOV0vaWcsXG5cdF9udW1iZXJzRXhwID0gLyg/OigtKT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspPylbMC05XS9pZyxcblx0X3NjaWVudGlmaWMgPSAvW1xcK1xcLV0/XFxkKlxcLj9cXGQrZVtcXCtcXC1dP1xcZCsvaWcsXG5cdF9zZWxlY3RvckV4cCA9IC8oXlsjXFwuXVthLXpdfFthLXldW2Etel0pL2ksXG5cdF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcblx0X1JBRDJERUcgPSAxODAgLyBNYXRoLlBJLFxuXHRfc2luID0gTWF0aC5zaW4sXG5cdF9jb3MgPSBNYXRoLmNvcyxcblx0X2FicyA9IE1hdGguYWJzLFxuXHRfc3FydCA9IE1hdGguc3FydCxcblx0X2F0YW4yID0gTWF0aC5hdGFuMixcblx0X2xhcmdlTnVtID0gMWU4LFxuXHRfaXNTdHJpbmcgPSB2YWx1ZSA9PiB0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiLFxuXHRfaXNOdW1iZXIgPSB2YWx1ZSA9PiB0eXBlb2YodmFsdWUpID09PSBcIm51bWJlclwiLFxuXHRfaXNVbmRlZmluZWQgPSB2YWx1ZSA9PiB0eXBlb2YodmFsdWUpID09PSBcInVuZGVmaW5lZFwiLFxuXHRfdGVtcCA9IHt9LFxuXHRfdGVtcDIgPSB7fSxcblx0X3JvdW5kaW5nTnVtID0gMWU1LFxuXHRfd3JhcFByb2dyZXNzID0gcHJvZ3Jlc3MgPT4gKE1hdGgucm91bmQoKHByb2dyZXNzICsgX2xhcmdlTnVtKSAlIDEgKiBfcm91bmRpbmdOdW0pIC8gX3JvdW5kaW5nTnVtKSB8fCAoKHByb2dyZXNzIDwgMCkgPyAwIDogMSksIC8vaWYgcHJvZ3Jlc3MgbGFuZHMgb24gMSwgdGhlICUgd2lsbCBtYWtlIGl0IDAgd2hpY2ggaXMgd2h5IHdlIHx8IDEsIGJ1dCBub3QgaWYgaXQncyBuZWdhdGl2ZSBiZWNhdXNlIGl0IG1ha2VzIG1vcmUgc2Vuc2UgZm9yIG1vdGlvbiB0byBlbmQgYXQgMCBpbiB0aGF0IGNhc2UuXG5cdF9yb3VuZCA9IHZhbHVlID0+IChNYXRoLnJvdW5kKHZhbHVlICogX3JvdW5kaW5nTnVtKSAvIF9yb3VuZGluZ051bSkgfHwgMCxcblx0X3JvdW5kUHJlY2lzZSA9IHZhbHVlID0+IChNYXRoLnJvdW5kKHZhbHVlICogMWUxMCkgLyAxZTEwKSB8fCAwLFxuXHRfc3BsaXRTZWdtZW50ID0gKHJhd1BhdGgsIHNlZ0luZGV4LCBpLCB0KSA9PiB7XG5cdFx0bGV0IHNlZ21lbnQgPSByYXdQYXRoW3NlZ0luZGV4XSxcblx0XHRcdHNoaWZ0ID0gdCA9PT0gMSA/IDYgOiBzdWJkaXZpZGVTZWdtZW50KHNlZ21lbnQsIGksIHQpO1xuXHRcdGlmIChzaGlmdCAmJiBzaGlmdCArIGkgKyAyIDwgc2VnbWVudC5sZW5ndGgpIHtcblx0XHRcdHJhd1BhdGguc3BsaWNlKHNlZ0luZGV4LCAwLCBzZWdtZW50LnNsaWNlKDAsIGkgKyBzaGlmdCArIDIpKTtcblx0XHRcdHNlZ21lbnQuc3BsaWNlKDAsIGkgKyBzaGlmdCk7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdH0sXG5cdF9yZXZlcnNlUmF3UGF0aCA9IChyYXdQYXRoLCBza2lwT3V0ZXIpID0+IHtcblx0XHRsZXQgaSA9IHJhd1BhdGgubGVuZ3RoO1xuXHRcdHNraXBPdXRlciB8fCByYXdQYXRoLnJldmVyc2UoKTtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRyYXdQYXRoW2ldLnJldmVyc2VkIHx8IHJldmVyc2VTZWdtZW50KHJhd1BhdGhbaV0pO1xuXHRcdH1cblx0fSxcblx0X2NvcHlNZXRhRGF0YSA9IChzb3VyY2UsIGNvcHkpID0+IHtcblx0XHRjb3B5LnRvdGFsTGVuZ3RoID0gc291cmNlLnRvdGFsTGVuZ3RoO1xuXHRcdGlmIChzb3VyY2Uuc2FtcGxlcykgeyAvL3NlZ21lbnRcblx0XHRcdGNvcHkuc2FtcGxlcyA9IHNvdXJjZS5zYW1wbGVzLnNsaWNlKDApO1xuXHRcdFx0Y29weS5sb29rdXAgPSBzb3VyY2UubG9va3VwLnNsaWNlKDApO1xuXHRcdFx0Y29weS5taW5MZW5ndGggPSBzb3VyY2UubWluTGVuZ3RoO1xuXHRcdFx0Y29weS5yZXNvbHV0aW9uID0gc291cmNlLnJlc29sdXRpb247XG5cdFx0fSBlbHNlIGlmIChzb3VyY2UudG90YWxQb2ludHMpIHsgLy9yYXdQYXRoXG5cdFx0XHRjb3B5LnRvdGFsUG9pbnRzID0gc291cmNlLnRvdGFsUG9pbnRzO1xuXHRcdH1cblx0XHRyZXR1cm4gY29weTtcblx0fSxcblx0Ly9wdXNoZXMgYSBuZXcgc2VnbWVudCBpbnRvIGEgcmF3UGF0aCwgYnV0IGlmIGl0cyBzdGFydGluZyB2YWx1ZXMgbWF0Y2ggdGhlIGVuZGluZyB2YWx1ZXMgb2YgdGhlIGxhc3Qgc2VnbWVudCwgaXQnbGwgbWVyZ2UgaXQgaW50byB0aGF0IHNhbWUgc2VnbWVudCAodG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VnbWVudHMpXG5cdF9hcHBlbmRPck1lcmdlID0gKHJhd1BhdGgsIHNlZ21lbnQpID0+IHtcblx0XHRsZXQgaW5kZXggPSByYXdQYXRoLmxlbmd0aCxcblx0XHRcdHByZXZTZWcgPSByYXdQYXRoW2luZGV4IC0gMV0gfHwgW10sXG5cdFx0XHRsID0gcHJldlNlZy5sZW5ndGg7XG5cdFx0aWYgKGluZGV4ICYmIHNlZ21lbnRbMF0gPT09IHByZXZTZWdbbC0yXSAmJiBzZWdtZW50WzFdID09PSBwcmV2U2VnW2wtMV0pIHtcblx0XHRcdHNlZ21lbnQgPSBwcmV2U2VnLmNvbmNhdChzZWdtZW50LnNsaWNlKDIpKTtcblx0XHRcdGluZGV4LS07XG5cdFx0fVxuXHRcdHJhd1BhdGhbaW5kZXhdID0gc2VnbWVudDtcblx0fSxcblx0X2Jlc3REaXN0YW5jZTtcblxuLyogVEVSTUlOT0xPR1lcbiAtIFJhd1BhdGggLSBhbiBhcnJheSBvZiBhcnJheXMsIG9uZSBmb3IgZWFjaCBTZWdtZW50LiBBIHNpbmdsZSBSYXdQYXRoIGNvdWxkIGhhdmUgbXVsdGlwbGUgXCJNXCIgY29tbWFuZHMsIGRlZmluaW5nIFNlZ21lbnRzIChwYXRocyBhcmVuJ3QgYWx3YXlzIGNvbm5lY3RlZCkuXG4gLSBTZWdtZW50IC0gYW4gYXJyYXkgY29udGFpbmluZyBhIHNlcXVlbmNlIG9mIEN1YmljIEJlemllciBjb29yZGluYXRlcyBpbiBhbHRlcm5hdGluZyB4LCB5LCB4LCB5IGZvcm1hdC4gU3RhcnRpbmcgYW5jaG9yLCB0aGVuIGNvbnRyb2wgcG9pbnQgMSwgY29udHJvbCBwb2ludCAyLCBhbmQgZW5kaW5nIGFuY2hvciwgdGhlbiB0aGUgbmV4dCBjb250cm9sIHBvaW50IDEsIGNvbnRyb2wgcG9pbnQgMiwgYW5jaG9yLCBldGMuIFVzZXMgbGVzcyBtZW1vcnkgdGhhbiBhbiBhcnJheSB3aXRoIGEgYnVuY2ggb2Yge3gsIHl9IHBvaW50cy5cbiAtIEJlemllciAtIGEgc2luZ2xlIGN1YmljIEJlemllciB3aXRoIGEgc3RhcnRpbmcgYW5jaG9yLCB0d28gY29udHJvbCBwb2ludHMsIGFuZCBhbiBlbmRpbmcgYW5jaG9yLlxuIC0gdGhlIHZhcmlhYmxlIFwidFwiIGlzIHR5cGljYWxseSB0aGUgcG9zaXRpb24gYWxvbmcgYW4gaW5kaXZpZHVhbCBCZXppZXIgcGF0aCAodGltZSkgYW5kIGl0J3MgTk9UIGxpbmVhciwgbWVhbmluZyBpdCBjb3VsZCBhY2NlbGVyYXRlL2RlY2VsZXJhdGUgYmFzZWQgb24gdGhlIGNvbnRyb2wgcG9pbnRzIHdoZXJlYXMgdGhlIFwicFwiIG9yIFwicHJvZ3Jlc3NcIiB2YWx1ZSBpcyBsaW5lYXJseSBtYXBwZWQgdG8gdGhlIHdob2xlIHBhdGgsIHNvIGl0IHNob3VsZG4ndCByZWFsbHkgYWNjZWxlcmF0ZS9kZWNlbGVyYXRlIGJhc2VkIG9uIGNvbnRyb2wgcG9pbnRzLiBTbyBhIHByb2dyZXNzIG9mIDAuMiB3b3VsZCBiZSBhbG1vc3QgZXhhY3RseSAyMCUgYWxvbmcgdGhlIHBhdGguIFwidFwiIGlzIE9OTFkgaW4gYW4gaW5kaXZpZHVhbCBCZXppZXIgcGllY2UuXG4gKi9cblxuLy9hY2NlcHRzIGJhc2ljIHNlbGVjdG9yIHRleHQsIGEgcGF0aCBpbnN0YW5jZSwgYSBSYXdQYXRoIGluc3RhbmNlLCBvciBhIFNlZ21lbnQgYW5kIHJldHVybnMgYSBSYXdQYXRoIChtYWtlcyBpdCBlYXN5IHRvIGhvbW9nZW5pemUgdGhpbmdzKS4gSWYgYW4gZWxlbWVudCBvciBzZWxlY3RvciB0ZXh0IGlzIHBhc3NlZCBpbiwgaXQnbGwgYWxzbyBjYWNoZSB0aGUgdmFsdWUgc28gdGhhdCBpZiBpdCdzIHF1ZXJpZWQgYWdhaW4sIGl0J2xsIGp1c3QgdGFrZSB0aGUgcGF0aCBkYXRhIGZyb20gdGhlcmUgaW5zdGVhZCBvZiBwYXJzaW5nIGl0IGFsbCBvdmVyIGFnYWluIChhcyBsb25nIGFzIHRoZSBwYXRoIGRhdGEgaXRzZWxmIGhhc24ndCBjaGFuZ2VkIC0gaXQnbGwgY2hlY2spLlxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhd1BhdGgodmFsdWUpIHtcblx0dmFsdWUgPSAoX2lzU3RyaW5nKHZhbHVlKSAmJiBfc2VsZWN0b3JFeHAudGVzdCh2YWx1ZSkpID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih2YWx1ZSkgfHwgdmFsdWUgOiB2YWx1ZTtcblx0bGV0IGUgPSB2YWx1ZS5nZXRBdHRyaWJ1dGUgPyB2YWx1ZSA6IDAsXG5cdFx0cmF3UGF0aDtcblx0aWYgKGUgJiYgKHZhbHVlID0gdmFsdWUuZ2V0QXR0cmlidXRlKFwiZFwiKSkpIHtcblx0XHQvL2ltcGxlbWVudHMgY2FjaGluZ1xuXHRcdGlmICghZS5fZ3NQYXRoKSB7XG5cdFx0XHRlLl9nc1BhdGggPSB7fTtcblx0XHR9XG5cdFx0cmF3UGF0aCA9IGUuX2dzUGF0aFt2YWx1ZV07XG5cdFx0cmV0dXJuIChyYXdQYXRoICYmICFyYXdQYXRoLl9kaXJ0eSkgPyByYXdQYXRoIDogKGUuX2dzUGF0aFt2YWx1ZV0gPSBzdHJpbmdUb1Jhd1BhdGgodmFsdWUpKTtcblx0fVxuXHRyZXR1cm4gIXZhbHVlID8gY29uc29sZS53YXJuKFwiRXhwZWN0aW5nIGEgPHBhdGg+IGVsZW1lbnQgb3IgYW4gU1ZHIHBhdGggZGF0YSBzdHJpbmdcIikgOiBfaXNTdHJpbmcodmFsdWUpID8gc3RyaW5nVG9SYXdQYXRoKHZhbHVlKSA6IChfaXNOdW1iZXIodmFsdWVbMF0pKSA/IFt2YWx1ZV0gOiB2YWx1ZTtcbn1cblxuLy9jb3BpZXMgYSBSYXdQYXRoIFdJVEhPVVQgdGhlIGxlbmd0aCBtZXRhIGRhdGEgKGZvciBzcGVlZClcbmV4cG9ydCBmdW5jdGlvbiBjb3B5UmF3UGF0aChyYXdQYXRoKSB7XG5cdGxldCBhID0gW10sXG5cdFx0aSA9IDA7XG5cdGZvciAoOyBpIDwgcmF3UGF0aC5sZW5ndGg7IGkrKykge1xuXHRcdGFbaV0gPSBfY29weU1ldGFEYXRhKHJhd1BhdGhbaV0sIHJhd1BhdGhbaV0uc2xpY2UoMCkpO1xuXHR9XG5cdHJldHVybiBfY29weU1ldGFEYXRhKHJhd1BhdGgsIGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZVNlZ21lbnQoc2VnbWVudCkge1xuXHRsZXQgaSA9IDAsXG5cdFx0eTtcblx0c2VnbWVudC5yZXZlcnNlKCk7IC8vdGhpcyB3aWxsIGludmVydCB0aGUgb3JkZXIgeSwgeCwgeSwgeCBzbyB3ZSBtdXN0IGZsaXAgaXQgYmFjay5cblx0Zm9yICg7IGkgPCBzZWdtZW50Lmxlbmd0aDsgaSArPSAyKSB7XG5cdFx0eSA9IHNlZ21lbnRbaV07XG5cdFx0c2VnbWVudFtpXSA9IHNlZ21lbnRbaSsxXTtcblx0XHRzZWdtZW50W2krMV0gPSB5O1xuXHR9XG5cdHNlZ21lbnQucmV2ZXJzZWQgPSAhc2VnbWVudC5yZXZlcnNlZDtcbn1cblxuXG5cbmxldCBfY3JlYXRlUGF0aCA9IChlLCBpZ25vcmUpID0+IHtcblx0XHRsZXQgcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicGF0aFwiKSxcblx0XHRcdGF0dHIgPSBbXS5zbGljZS5jYWxsKGUuYXR0cmlidXRlcyksXG5cdFx0XHRpID0gYXR0ci5sZW5ndGgsXG5cdFx0XHRuYW1lO1xuXHRcdGlnbm9yZSA9IFwiLFwiICsgaWdub3JlICsgXCIsXCI7XG5cdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRuYW1lID0gYXR0cltpXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOyAvL2luIE1pY3Jvc29mdCBFZGdlLCBpZiB5b3UgZG9uJ3Qgc2V0IHRoZSBhdHRyaWJ1dGUgd2l0aCBhIGxvd2VyY2FzZSBuYW1lLCBpdCBkb2Vzbid0IHJlbmRlciBjb3JyZWN0bHkhIFN1cGVyIHdlaXJkLlxuXHRcdFx0aWYgKGlnbm9yZS5pbmRleE9mKFwiLFwiICsgbmFtZSArIFwiLFwiKSA8IDApIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBuYW1lLCBhdHRyW2ldLm5vZGVWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBwYXRoO1xuXHR9LFxuXHRfdHlwZUF0dHJzID0ge1xuXHRcdHJlY3Q6XCJyeCxyeSx4LHksd2lkdGgsaGVpZ2h0XCIsXG5cdFx0Y2lyY2xlOlwicixjeCxjeVwiLFxuXHRcdGVsbGlwc2U6XCJyeCxyeSxjeCxjeVwiLFxuXHRcdGxpbmU6XCJ4MSx4Mix5MSx5MlwiXG5cdH0sXG5cdF9hdHRyVG9PYmogPSAoZSwgYXR0cnMpID0+IHtcblx0XHRsZXQgcHJvcHMgPSBhdHRycyA/IGF0dHJzLnNwbGl0KFwiLFwiKSA6IFtdLFxuXHRcdFx0b2JqID0ge30sXG5cdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0b2JqW3Byb3BzW2ldXSA9ICtlLmdldEF0dHJpYnV0ZShwcm9wc1tpXSkgfHwgMDtcblx0XHR9XG5cdFx0cmV0dXJuIG9iajtcblx0fTtcblxuLy9jb252ZXJ0cyBhbiBTVkcgc2hhcGUgbGlrZSA8Y2lyY2xlPiwgPHJlY3Q+LCA8cG9seWdvbj4sIDxwb2x5bGluZT4sIDxlbGxpcHNlPiwgZXRjLiB0byBhIDxwYXRoPiwgc3dhcHBpbmcgaXQgaW4gYW5kIGNvcHlpbmcgdGhlIGF0dHJpYnV0ZXMgdG8gbWF0Y2guXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvUGF0aChlbGVtZW50LCBzd2FwKSB7XG5cdGxldCB0eXBlID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0Y2lyYyA9IDAuNTUyMjg0NzQ5ODMxLFxuXHRcdGRhdGEsIHgsIHksIHIsIHJ5LCBwYXRoLCByY2lyYywgcnljaXJjLCBwb2ludHMsIHcsIGgsIHgyLCB4MywgeDQsIHg1LCB4NiwgeTIsIHkzLCB5NCwgeTUsIHk2LCBhdHRyO1xuXHRpZiAodHlwZSA9PT0gXCJwYXRoXCIgfHwgIWVsZW1lbnQuZ2V0QkJveCkge1xuXHRcdHJldHVybiBlbGVtZW50O1xuXHR9XG5cdHBhdGggPSBfY3JlYXRlUGF0aChlbGVtZW50LCBcIngseSx3aWR0aCxoZWlnaHQsY3gsY3kscngscnkscix4MSx4Mix5MSx5Mixwb2ludHNcIik7XG5cdGF0dHIgPSBfYXR0clRvT2JqKGVsZW1lbnQsIF90eXBlQXR0cnNbdHlwZV0pO1xuXHRpZiAodHlwZSA9PT0gXCJyZWN0XCIpIHtcblx0XHRyID0gYXR0ci5yeDtcblx0XHRyeSA9IGF0dHIucnkgfHwgcjtcblx0XHR4ID0gYXR0ci54O1xuXHRcdHkgPSBhdHRyLnk7XG5cdFx0dyA9IGF0dHIud2lkdGggLSByICogMjtcblx0XHRoID0gYXR0ci5oZWlnaHQgLSByeSAqIDI7XG5cdFx0aWYgKHIgfHwgcnkpIHsgLy9pZiB0aGVyZSBhcmUgcm91bmRlZCBjb3JuZXJzLCByZW5kZXIgY3ViaWMgYmV6aWVyc1xuXHRcdFx0eDIgPSB4ICsgciAqICgxIC0gY2lyYyk7XG5cdFx0XHR4MyA9IHggKyByO1xuXHRcdFx0eDQgPSB4MyArIHc7XG5cdFx0XHR4NSA9IHg0ICsgciAqIGNpcmM7XG5cdFx0XHR4NiA9IHg0ICsgcjtcblx0XHRcdHkyID0geSArIHJ5ICogKDEgLSBjaXJjKTtcblx0XHRcdHkzID0geSArIHJ5O1xuXHRcdFx0eTQgPSB5MyArIGg7XG5cdFx0XHR5NSA9IHk0ICsgcnkgKiBjaXJjO1xuXHRcdFx0eTYgPSB5NCArIHJ5O1xuXHRcdFx0ZGF0YSA9IFwiTVwiICsgeDYgKyBcIixcIiArIHkzICsgXCIgVlwiICsgeTQgKyBcIiBDXCIgKyBbeDYsIHk1LCB4NSwgeTYsIHg0LCB5NiwgeDQgLSAoeDQgLSB4MykgLyAzLCB5NiwgeDMgKyAoeDQgLSB4MykgLyAzLCB5NiwgeDMsIHk2LCB4MiwgeTYsIHgsIHk1LCB4LCB5NCwgeCwgeTQgLSAoeTQgLSB5MykgLyAzLCB4LCB5MyArICh5NCAtIHkzKSAvIDMsIHgsIHkzLCB4LCB5MiwgeDIsIHksIHgzLCB5LCB4MyArICh4NCAtIHgzKSAvIDMsIHksIHg0IC0gKHg0IC0geDMpIC8gMywgeSwgeDQsIHksIHg1LCB5LCB4NiwgeTIsIHg2LCB5M10uam9pbihcIixcIikgKyBcInpcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IFwiTVwiICsgKHggKyB3KSArIFwiLFwiICsgeSArIFwiIHZcIiArIGggKyBcIiBoXCIgKyAoLXcpICsgXCIgdlwiICsgKC1oKSArIFwiIGhcIiArIHcgKyBcInpcIjtcblx0XHR9XG5cblx0fSBlbHNlIGlmICh0eXBlID09PSBcImNpcmNsZVwiIHx8IHR5cGUgPT09IFwiZWxsaXBzZVwiKSB7XG5cdFx0aWYgKHR5cGUgPT09IFwiY2lyY2xlXCIpIHtcblx0XHRcdHIgPSByeSA9IGF0dHIucjtcblx0XHRcdHJ5Y2lyYyA9IHIgKiBjaXJjO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyID0gYXR0ci5yeDtcblx0XHRcdHJ5ID0gYXR0ci5yeTtcblx0XHRcdHJ5Y2lyYyA9IHJ5ICogY2lyYztcblx0XHR9XG5cdFx0eCA9IGF0dHIuY3g7XG5cdFx0eSA9IGF0dHIuY3k7XG5cdFx0cmNpcmMgPSByICogY2lyYztcblx0XHRkYXRhID0gXCJNXCIgKyAoeCtyKSArIFwiLFwiICsgeSArIFwiIENcIiArIFt4K3IsIHkgKyByeWNpcmMsIHggKyByY2lyYywgeSArIHJ5LCB4LCB5ICsgcnksIHggLSByY2lyYywgeSArIHJ5LCB4IC0gciwgeSArIHJ5Y2lyYywgeCAtIHIsIHksIHggLSByLCB5IC0gcnljaXJjLCB4IC0gcmNpcmMsIHkgLSByeSwgeCwgeSAtIHJ5LCB4ICsgcmNpcmMsIHkgLSByeSwgeCArIHIsIHkgLSByeWNpcmMsIHggKyByLCB5XS5qb2luKFwiLFwiKSArIFwielwiO1xuXHR9IGVsc2UgaWYgKHR5cGUgPT09IFwibGluZVwiKSB7XG5cdFx0ZGF0YSA9IFwiTVwiICsgYXR0ci54MSArIFwiLFwiICsgYXR0ci55MSArIFwiIExcIiArIGF0dHIueDIgKyBcIixcIiArIGF0dHIueTI7IC8vcHJldmlvdXNseSwgd2UganVzdCBjb252ZXJ0ZWQgdG8gXCJNeCx5IEx4LHlcIiBidXQgU2FmYXJpIGhhcyBidWdzIHRoYXQgY2F1c2UgdGhhdCBub3QgdG8gcmVuZGVyIHByb3Blcmx5IHdoZW4gdXNpbmcgYSBzdHJva2UtZGFzaGFycmF5IHRoYXQncyBub3QgZnVsbHkgdmlzaWJsZSEgVXNpbmcgYSBjdWJpYyBiZXppZXIgZml4ZXMgdGhhdCBpc3N1ZS5cblx0fSBlbHNlIGlmICh0eXBlID09PSBcInBvbHlsaW5lXCIgfHwgdHlwZSA9PT0gXCJwb2x5Z29uXCIpIHtcblx0XHRwb2ludHMgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJwb2ludHNcIikgKyBcIlwiKS5tYXRjaChfbnVtYmVyc0V4cCkgfHwgW107XG5cdFx0eCA9IHBvaW50cy5zaGlmdCgpO1xuXHRcdHkgPSBwb2ludHMuc2hpZnQoKTtcblx0XHRkYXRhID0gXCJNXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIgTFwiICsgcG9pbnRzLmpvaW4oXCIsXCIpO1xuXHRcdGlmICh0eXBlID09PSBcInBvbHlnb25cIikge1xuXHRcdFx0ZGF0YSArPSBcIixcIiArIHggKyBcIixcIiArIHkgKyBcInpcIjtcblx0XHR9XG5cdH1cblx0cGF0aC5zZXRBdHRyaWJ1dGUoXCJkXCIsIHJhd1BhdGhUb1N0cmluZyhwYXRoLl9nc1Jhd1BhdGggPSBzdHJpbmdUb1Jhd1BhdGgoZGF0YSkpKTtcblx0aWYgKHN3YXAgJiYgZWxlbWVudC5wYXJlbnROb2RlKSB7XG5cdFx0ZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShwYXRoLCBlbGVtZW50KTtcblx0XHRlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG5cdH1cblx0cmV0dXJuIHBhdGg7XG59XG5cblxuXG4vL3JldHVybnMgdGhlIHJvdGF0aW9uIChpbiBkZWdyZWVzKSBhdCBhIHBhcnRpY3VsYXIgcHJvZ3Jlc3Mgb24gYSByYXdQYXRoICh0aGUgc2xvcGUgb2YgdGhlIHRhbmdlbnQpXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um90YXRpb25BdFByb2dyZXNzKHJhd1BhdGgsIHByb2dyZXNzKSB7XG5cdGxldCBkID0gZ2V0UHJvZ3Jlc3NEYXRhKHJhd1BhdGgsIHByb2dyZXNzID49IDEgPyAxIC0gMWUtOSA6IHByb2dyZXNzID8gcHJvZ3Jlc3MgOiAxZS05KTtcblx0cmV0dXJuIGdldFJvdGF0aW9uQXRCZXppZXJUKGQuc2VnbWVudCwgZC5pLCBkLnQpO1xufVxuXG5mdW5jdGlvbiBnZXRSb3RhdGlvbkF0QmV6aWVyVChzZWdtZW50LCBpLCB0KSB7XG5cdGxldCBhID0gc2VnbWVudFtpXSxcblx0XHRiID0gc2VnbWVudFtpKzJdLFxuXHRcdGMgPSBzZWdtZW50W2krNF0sXG5cdFx0eDtcblx0YSArPSAoYiAtIGEpICogdDtcblx0YiArPSAoYyAtIGIpICogdDtcblx0YSArPSAoYiAtIGEpICogdDtcblx0eCA9IGIgKyAoKGMgKyAoc2VnbWVudFtpKzZdIC0gYykgKiB0KSAtIGIpICogdCAtIGE7XG5cdGEgPSBzZWdtZW50W2krMV07XG5cdGIgPSBzZWdtZW50W2krM107XG5cdGMgPSBzZWdtZW50W2krNV07XG5cdGEgKz0gKGIgLSBhKSAqIHQ7XG5cdGIgKz0gKGMgLSBiKSAqIHQ7XG5cdGEgKz0gKGIgLSBhKSAqIHQ7XG5cdHJldHVybiBfcm91bmQoX2F0YW4yKGIgKyAoKGMgKyAoc2VnbWVudFtpKzddIC0gYykgKiB0KSAtIGIpICogdCAtIGEsIHgpICogX1JBRDJERUcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2xpY2VSYXdQYXRoKHJhd1BhdGgsIHN0YXJ0LCBlbmQpIHtcblx0ZW5kID0gX2lzVW5kZWZpbmVkKGVuZCkgPyAxIDogX3JvdW5kUHJlY2lzZShlbmQpIHx8IDA7IC8vIHdlIG11c3Qgcm91bmQgdG8gYXZvaWQgaXNzdWVzIGxpa2UgNC4xNSAvIDggPSAwLjgzMDAwMDAwMDAwMDAwMDEgaW5zdGVhZCBvZiAwLjgzIG9yIDIuOCAvIDUgPSAwLjU1OTk5OTk5OTk5OTk5OTkgaW5zdGVhZCBvZiAwLjU2IGFuZCBpZiBzb21lb25lIGlzIGRvaW5nIGEgbG9vcCBsaWtlIHN0YXJ0OiAyLjggLyAwLjUsIGVuZDogMi44IC8gMC41ICsgMS5cblx0c3RhcnQgPSBfcm91bmRQcmVjaXNlKHN0YXJ0KSB8fCAwO1xuXHRsZXQgbG9vcHMgPSBNYXRoLm1heCgwLCB+fihfYWJzKGVuZCAtIHN0YXJ0KSAtIDFlLTgpKSxcblx0XHRwYXRoID0gY29weVJhd1BhdGgocmF3UGF0aCk7XG5cdGlmIChzdGFydCA+IGVuZCkge1xuXHRcdHN0YXJ0ID0gMSAtIHN0YXJ0O1xuXHRcdGVuZCA9IDEgLSBlbmQ7XG5cdFx0X3JldmVyc2VSYXdQYXRoKHBhdGgpO1xuXHRcdHBhdGgudG90YWxMZW5ndGggPSAwO1xuXHR9XG5cdGlmIChzdGFydCA8IDAgfHwgZW5kIDwgMCkge1xuXHRcdGxldCBvZmZzZXQgPSBNYXRoLmFicyh+fk1hdGgubWluKHN0YXJ0LCBlbmQpKSArIDE7XG5cdFx0c3RhcnQgKz0gb2Zmc2V0O1xuXHRcdGVuZCArPSBvZmZzZXQ7XG5cdH1cblx0cGF0aC50b3RhbExlbmd0aCB8fCBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMocGF0aCk7XG5cdGxldCB3cmFwID0gKGVuZCA+IDEpLFxuXHRcdHMgPSBnZXRQcm9ncmVzc0RhdGEocGF0aCwgc3RhcnQsIF90ZW1wLCB0cnVlKSxcblx0XHRlID0gZ2V0UHJvZ3Jlc3NEYXRhKHBhdGgsIGVuZCwgX3RlbXAyKSxcblx0XHRlU2VnID0gZS5zZWdtZW50LFxuXHRcdHNTZWcgPSBzLnNlZ21lbnQsXG5cdFx0ZVNlZ0luZGV4ID0gZS5zZWdJbmRleCxcblx0XHRzU2VnSW5kZXggPSBzLnNlZ0luZGV4LFxuXHRcdGVpID0gZS5pLFxuXHRcdHNpID0gcy5pLFxuXHRcdHNhbWVTZWdtZW50ID0gKHNTZWdJbmRleCA9PT0gZVNlZ0luZGV4KSxcblx0XHRzYW1lQmV6aWVyID0gKGVpID09PSBzaSAmJiBzYW1lU2VnbWVudCksXG5cdFx0d3JhcHNCZWhpbmQsIHNTaGlmdCwgZVNoaWZ0LCBpLCBjb3B5LCB0b3RhbFNlZ21lbnRzLCBsLCBqO1xuXHRpZiAod3JhcCB8fCBsb29wcykge1xuXHRcdHdyYXBzQmVoaW5kID0gZVNlZ0luZGV4IDwgc1NlZ0luZGV4IHx8IChzYW1lU2VnbWVudCAmJiBlaSA8IHNpKSB8fCAoc2FtZUJlemllciAmJiBlLnQgPCBzLnQpO1xuXHRcdGlmIChfc3BsaXRTZWdtZW50KHBhdGgsIHNTZWdJbmRleCwgc2ksIHMudCkpIHtcblx0XHRcdHNTZWdJbmRleCsrO1xuXHRcdFx0aWYgKCF3cmFwc0JlaGluZCkge1xuXHRcdFx0XHRlU2VnSW5kZXgrKztcblx0XHRcdFx0aWYgKHNhbWVCZXppZXIpIHtcblx0XHRcdFx0XHRlLnQgPSAoZS50IC0gcy50KSAvICgxIC0gcy50KTtcblx0XHRcdFx0XHRlaSA9IDA7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc2FtZVNlZ21lbnQpIHtcblx0XHRcdFx0XHRlaSAtPSBzaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoMSAtIChlbmQgLSBzdGFydCkgPCAxZS01KSB7XG5cdFx0XHRlU2VnSW5kZXggPSBzU2VnSW5kZXggLSAxO1xuXHRcdH0gZWxzZSBpZiAoIWUudCAmJiBlU2VnSW5kZXgpIHtcblx0XHRcdGVTZWdJbmRleC0tO1xuXHRcdH0gZWxzZSBpZiAoX3NwbGl0U2VnbWVudChwYXRoLCBlU2VnSW5kZXgsIGVpLCBlLnQpICYmIHdyYXBzQmVoaW5kKSB7XG5cdFx0XHRzU2VnSW5kZXgrKztcblx0XHR9XG5cdFx0aWYgKHMudCA9PT0gMSkge1xuXHRcdFx0c1NlZ0luZGV4ID0gKHNTZWdJbmRleCArIDEpICUgcGF0aC5sZW5ndGg7XG5cdFx0fVxuXHRcdGNvcHkgPSBbXTtcblx0XHR0b3RhbFNlZ21lbnRzID0gcGF0aC5sZW5ndGg7XG5cdFx0bCA9IDEgKyB0b3RhbFNlZ21lbnRzICogbG9vcHM7XG5cdFx0aiA9IHNTZWdJbmRleDtcblx0XHRsICs9ICgodG90YWxTZWdtZW50cyAtIHNTZWdJbmRleCkgKyBlU2VnSW5kZXgpICUgdG90YWxTZWdtZW50cztcblx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRfYXBwZW5kT3JNZXJnZShjb3B5LCBwYXRoW2orKyAlIHRvdGFsU2VnbWVudHNdKTtcblx0XHR9XG5cdFx0cGF0aCA9IGNvcHk7XG5cdH0gZWxzZSB7XG5cdFx0ZVNoaWZ0ID0gZS50ID09PSAxID8gNiA6IHN1YmRpdmlkZVNlZ21lbnQoZVNlZywgZWksIGUudCk7XG5cdFx0aWYgKHN0YXJ0ICE9PSBlbmQpIHtcblx0XHRcdHNTaGlmdCA9IHN1YmRpdmlkZVNlZ21lbnQoc1NlZywgc2ksIHNhbWVCZXppZXIgPyBzLnQgLyBlLnQgOiBzLnQpO1xuXHRcdFx0c2FtZVNlZ21lbnQgJiYgKGVTaGlmdCArPSBzU2hpZnQpO1xuXHRcdFx0ZVNlZy5zcGxpY2UoZWkgKyBlU2hpZnQgKyAyKTtcblx0XHRcdChzU2hpZnQgfHwgc2kpICYmIHNTZWcuc3BsaWNlKDAsIHNpICsgc1NoaWZ0KTtcblx0XHRcdGkgPSBwYXRoLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0Ly9jaG9wIG9mZiBhbnkgZXh0cmEgc2VnbWVudHNcblx0XHRcdFx0KGkgPCBzU2VnSW5kZXggfHwgaSA+IGVTZWdJbmRleCkgJiZcdHBhdGguc3BsaWNlKGksIDEpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRlU2VnLmFuZ2xlID0gZ2V0Um90YXRpb25BdEJlemllclQoZVNlZywgZWkgKyBlU2hpZnQsIDApOyAvL3JlY29yZCB0aGUgdmFsdWUgYmVmb3JlIHdlIGNob3AgYmVjYXVzZSBpdCdsbCBiZSBpbXBvc3NpYmxlIHRvIGRldGVybWluZSB0aGUgYW5nbGUgYWZ0ZXIgaXRzIGxlbmd0aCBpcyAwIVxuXHRcdFx0ZWkgKz0gZVNoaWZ0O1xuXHRcdFx0cyA9IGVTZWdbZWldO1xuXHRcdFx0ZSA9IGVTZWdbZWkrMV07XG5cdFx0XHRlU2VnLmxlbmd0aCA9IGVTZWcudG90YWxMZW5ndGggPSAwO1xuXHRcdFx0ZVNlZy50b3RhbFBvaW50cyA9IHBhdGgudG90YWxQb2ludHMgPSA4O1xuXHRcdFx0ZVNlZy5wdXNoKHMsIGUsIHMsIGUsIHMsIGUsIHMsIGUpO1xuXHRcdH1cblx0fVxuXHRwYXRoLnRvdGFsTGVuZ3RoID0gMDtcblx0cmV0dXJuIHBhdGg7XG59XG5cbi8vbWVhc3VyZXMgYSBTZWdtZW50IGFjY29yZGluZyB0byBpdHMgcmVzb2x1dGlvbiAoc28gaWYgc2VnbWVudC5yZXNvbHV0aW9uIGlzIDYsIGZvciBleGFtcGxlLCBpdCdsbCB0YWtlIDYgc2FtcGxlcyBlcXVhbGx5IGFjcm9zcyBlYWNoIEJlemllcikgYW5kIGNyZWF0ZS9wb3B1bGF0ZSBhIFwic2FtcGxlc1wiIEFycmF5IHRoYXQgaGFzIHRoZSBsZW5ndGggdXAgdG8gZWFjaCBvZiB0aG9zZSBzYW1wbGUgcG9pbnRzIChhbHdheXMgaW5jcmVhc2luZyBmcm9tIHRoZSBzdGFydCkgYXMgd2VsbCBhcyBhIFwibG9va3VwXCIgYXJyYXkgdGhhdCdzIGJyb2tlbiB1cCBhY2NvcmRpbmcgdG8gdGhlIHNtYWxsZXN0IGRpc3RhbmNlIGJldHdlZW4gMiBzYW1wbGVzLiBUaGlzIGdpdmVzIHVzIGEgdmVyeSBmYXN0IHdheSBvZiBsb29raW5nIHVwIGEgcHJvZ3Jlc3MgcG9zaXRpb24gcmF0aGVyIHRoYW4gbG9vcGluZyB0aHJvdWdoIGFsbCB0aGUgcG9pbnRzL0JlemllcnMuIFlvdSBjYW4gb3B0aW9uYWxseSBoYXZlIGl0IG9ubHkgbWVhc3VyZSBhIHN1YnNldCwgc3RhcnRpbmcgYXQgc3RhcnRJbmRleCBhbmQgZ29pbmcgZm9yIGEgc3BlY2lmaWMgbnVtYmVyIG9mIGJlemllcnMgKHJlbWVtYmVyLCB0aGVyZSBhcmUgMyB4L3kgcGFpcnMgZWFjaCwgZm9yIGEgdG90YWwgb2YgNiBlbGVtZW50cyBmb3IgZWFjaCBCZXppZXIpLiBJdCB3aWxsIGFsc28gcG9wdWxhdGUgYSBcInRvdGFsTGVuZ3RoXCIgcHJvcGVydHksIGJ1dCB0aGF0J3Mgbm90IGdlbmVyYWxseSBzdXBlciBhY2N1cmF0ZSBiZWNhdXNlIGJ5IGRlZmF1bHQgaXQnbGwgb25seSB0YWtlIDYgc2FtcGxlcyBwZXIgQmV6aWVyLiBCdXQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGl0J3MgcGVyZmVjdGx5IGFkZXF1YXRlIGZvciBtZWFzdXJpbmcgcHJvZ3Jlc3MgdmFsdWVzIGFsb25nIHRoZSBwYXRoLiBJZiB5b3UgbmVlZCBhIG1vcmUgYWNjdXJhdGUgdG90YWxMZW5ndGgsIGVpdGhlciBpbmNyZWFzZSB0aGUgcmVzb2x1dGlvbiBvciB1c2UgdGhlIG1vcmUgYWR2YW5jZWQgYmV6aWVyVG9Qb2ludHMoKSBtZXRob2Qgd2hpY2gga2VlcHMgYWRkaW5nIHBvaW50cyB1bnRpbCB0aGV5IGRvbid0IGRldmlhdGUgYnkgbW9yZSB0aGFuIGEgY2VydGFpbiBwcmVjaXNpb24gdmFsdWUuXG5mdW5jdGlvbiBtZWFzdXJlU2VnbWVudChzZWdtZW50LCBzdGFydEluZGV4LCBiZXppZXJRdHkpIHtcblx0c3RhcnRJbmRleCA9IHN0YXJ0SW5kZXggfHwgMDtcblx0aWYgKCFzZWdtZW50LnNhbXBsZXMpIHtcblx0XHRzZWdtZW50LnNhbXBsZXMgPSBbXTtcblx0XHRzZWdtZW50Lmxvb2t1cCA9IFtdO1xuXHR9XG5cdGxldCByZXNvbHV0aW9uID0gfn5zZWdtZW50LnJlc29sdXRpb24gfHwgMTIsXG5cdFx0aW5jID0gMSAvIHJlc29sdXRpb24sXG5cdFx0ZW5kSW5kZXggPSBiZXppZXJRdHkgPyBzdGFydEluZGV4ICsgYmV6aWVyUXR5ICogNiArIDEgOiBzZWdtZW50Lmxlbmd0aCxcblx0XHR4MSA9IHNlZ21lbnRbc3RhcnRJbmRleF0sXG5cdFx0eTEgPSBzZWdtZW50W3N0YXJ0SW5kZXggKyAxXSxcblx0XHRzYW1wbGVzSW5kZXggPSBzdGFydEluZGV4ID8gKHN0YXJ0SW5kZXggLyA2KSAqIHJlc29sdXRpb24gOiAwLFxuXHRcdHNhbXBsZXMgPSBzZWdtZW50LnNhbXBsZXMsXG5cdFx0bG9va3VwID0gc2VnbWVudC5sb29rdXAsXG5cdFx0bWluID0gKHN0YXJ0SW5kZXggPyBzZWdtZW50Lm1pbkxlbmd0aCA6IF9sYXJnZU51bSkgfHwgX2xhcmdlTnVtLFxuXHRcdHByZXZMZW5ndGggPSBzYW1wbGVzW3NhbXBsZXNJbmRleCArIGJlemllclF0eSAqIHJlc29sdXRpb24gLSAxXSxcblx0XHRsZW5ndGggPSBzdGFydEluZGV4ID8gc2FtcGxlc1tzYW1wbGVzSW5kZXgtMV0gOiAwLFxuXHRcdGksIGosIHg0LCB4MywgeDIsIHhkLCB4ZDEsIHk0LCB5MywgeTIsIHlkLCB5ZDEsIGludiwgdCwgbGVuZ3RoSW5kZXgsIGwsIHNlZ0xlbmd0aDtcblx0c2FtcGxlcy5sZW5ndGggPSBsb29rdXAubGVuZ3RoID0gMDtcblx0Zm9yIChqID0gc3RhcnRJbmRleCArIDI7IGogPCBlbmRJbmRleDsgaiArPSA2KSB7XG5cdFx0eDQgPSBzZWdtZW50W2ogKyA0XSAtIHgxO1xuXHRcdHgzID0gc2VnbWVudFtqICsgMl0gLSB4MTtcblx0XHR4MiA9IHNlZ21lbnRbal0gLSB4MTtcblx0XHR5NCA9IHNlZ21lbnRbaiArIDVdIC0geTE7XG5cdFx0eTMgPSBzZWdtZW50W2ogKyAzXSAtIHkxO1xuXHRcdHkyID0gc2VnbWVudFtqICsgMV0gLSB5MTtcblx0XHR4ZCA9IHhkMSA9IHlkID0geWQxID0gMDtcblx0XHRpZiAoX2Ficyh4NCkgPCAxZS01ICYmIF9hYnMoeTQpIDwgMWUtNSAmJiBfYWJzKHgyKSArIF9hYnMoeTIpIDwgMWUtNSkgeyAvL2R1bXAgcG9pbnRzIHRoYXQgYXJlIHN1ZmZpY2llbnRseSBjbG9zZSAoYmFzaWNhbGx5IHJpZ2h0IG9uIHRvcCBvZiBlYWNoIG90aGVyLCBtYWtpbmcgYSBiZXppZXIgc3VwZXIgdGlueSBvciAwIGxlbmd0aClcblx0XHRcdGlmIChzZWdtZW50Lmxlbmd0aCA+IDgpIHtcblx0XHRcdFx0c2VnbWVudC5zcGxpY2UoaiwgNik7XG5cdFx0XHRcdGogLT0gNjtcblx0XHRcdFx0ZW5kSW5kZXggLT0gNjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChpID0gMTsgaSA8PSByZXNvbHV0aW9uOyBpKyspIHtcblx0XHRcdFx0dCA9IGluYyAqIGk7XG5cdFx0XHRcdGludiA9IDEgLSB0O1xuXHRcdFx0XHR4ZCA9IHhkMSAtICh4ZDEgPSAodCAqIHQgKiB4NCArIDMgKiBpbnYgKiAodCAqIHgzICsgaW52ICogeDIpKSAqIHQpO1xuXHRcdFx0XHR5ZCA9IHlkMSAtICh5ZDEgPSAodCAqIHQgKiB5NCArIDMgKiBpbnYgKiAodCAqIHkzICsgaW52ICogeTIpKSAqIHQpO1xuXHRcdFx0XHRsID0gX3NxcnQoeWQgKiB5ZCArIHhkICogeGQpO1xuXHRcdFx0XHRpZiAobCA8IG1pbikge1xuXHRcdFx0XHRcdG1pbiA9IGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGVuZ3RoICs9IGw7XG5cdFx0XHRcdHNhbXBsZXNbc2FtcGxlc0luZGV4KytdID0gbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR4MSArPSB4NDtcblx0XHR5MSArPSB5NDtcblx0fVxuXHRpZiAocHJldkxlbmd0aCkge1xuXHRcdHByZXZMZW5ndGggLT0gbGVuZ3RoO1xuXHRcdGZvciAoOyBzYW1wbGVzSW5kZXggPCBzYW1wbGVzLmxlbmd0aDsgc2FtcGxlc0luZGV4KyspIHtcblx0XHRcdHNhbXBsZXNbc2FtcGxlc0luZGV4XSArPSBwcmV2TGVuZ3RoO1xuXHRcdH1cblx0fVxuXHRpZiAoc2FtcGxlcy5sZW5ndGggJiYgbWluKSB7XG5cdFx0c2VnbWVudC50b3RhbExlbmd0aCA9IHNlZ0xlbmd0aCA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGgtMV0gfHwgMDtcblx0XHRzZWdtZW50Lm1pbkxlbmd0aCA9IG1pbjtcblx0XHRsID0gbGVuZ3RoSW5kZXggPSAwO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdMZW5ndGg7IGkgKz0gbWluKSB7XG5cdFx0XHRsb29rdXBbbCsrXSA9IChzYW1wbGVzW2xlbmd0aEluZGV4XSA8IGkpID8gKytsZW5ndGhJbmRleCA6IGxlbmd0aEluZGV4O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRzZWdtZW50LnRvdGFsTGVuZ3RoID0gc2FtcGxlc1swXSA9IDA7XG5cdH1cblx0cmV0dXJuIHN0YXJ0SW5kZXggPyBsZW5ndGggLSBzYW1wbGVzW3N0YXJ0SW5kZXggLyAyIC0gMV0gOiBsZW5ndGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMocmF3UGF0aCwgcmVzb2x1dGlvbikge1xuXHRsZXQgcGF0aExlbmd0aCwgcG9pbnRzLCBpO1xuXHRmb3IgKGkgPSBwYXRoTGVuZ3RoID0gcG9pbnRzID0gMDsgaSA8IHJhd1BhdGgubGVuZ3RoOyBpKyspIHtcblx0XHRyYXdQYXRoW2ldLnJlc29sdXRpb24gPSB+fnJlc29sdXRpb24gfHwgMTI7IC8vc3RlcHMgcGVyIEJlemllciBjdXJ2ZSAoYW5jaG9yLCAyIGNvbnRyb2wgcG9pbnRzLCB0byBhbmNob3IpXG5cdFx0cG9pbnRzICs9IHJhd1BhdGhbaV0ubGVuZ3RoO1xuXHRcdHBhdGhMZW5ndGggKz0gbWVhc3VyZVNlZ21lbnQocmF3UGF0aFtpXSk7XG5cdH1cblx0cmF3UGF0aC50b3RhbFBvaW50cyA9IHBvaW50cztcblx0cmF3UGF0aC50b3RhbExlbmd0aCA9IHBhdGhMZW5ndGg7XG5cdHJldHVybiByYXdQYXRoO1xufVxuXG4vL2RpdmlkZSBzZWdtZW50W2ldIGF0IHBvc2l0aW9uIHQgKHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgcHJvZ3Jlc3MgYWxvbmcgdGhhdCBwYXJ0aWN1bGFyIGN1YmljIGJlemllciBzZWdtZW50IHRoYXQgc3RhcnRzIGF0IHNlZ21lbnRbaV0pLiBSZXR1cm5zIGhvdyBtYW55IGVsZW1lbnRzIHdlcmUgc3BsaWNlZCBpbnRvIHRoZSBzZWdtZW50IGFycmF5IChlaXRoZXIgMCBvciA2KVxuZXhwb3J0IGZ1bmN0aW9uIHN1YmRpdmlkZVNlZ21lbnQoc2VnbWVudCwgaSwgdCkge1xuXHRpZiAodCA8PSAwIHx8IHQgPj0gMSkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cdGxldCBheCA9IHNlZ21lbnRbaV0sXG5cdFx0YXkgPSBzZWdtZW50W2krMV0sXG5cdFx0Y3AxeCA9IHNlZ21lbnRbaSsyXSxcblx0XHRjcDF5ID0gc2VnbWVudFtpKzNdLFxuXHRcdGNwMnggPSBzZWdtZW50W2krNF0sXG5cdFx0Y3AyeSA9IHNlZ21lbnRbaSs1XSxcblx0XHRieCA9IHNlZ21lbnRbaSs2XSxcblx0XHRieSA9IHNlZ21lbnRbaSs3XSxcblx0XHR4MWEgPSBheCArIChjcDF4IC0gYXgpICogdCxcblx0XHR4MiA9IGNwMXggKyAoY3AyeCAtIGNwMXgpICogdCxcblx0XHR5MWEgPSBheSArIChjcDF5IC0gYXkpICogdCxcblx0XHR5MiA9IGNwMXkgKyAoY3AyeSAtIGNwMXkpICogdCxcblx0XHR4MSA9IHgxYSArICh4MiAtIHgxYSkgKiB0LFxuXHRcdHkxID0geTFhICsgKHkyIC0geTFhKSAqIHQsXG5cdFx0eDJhID0gY3AyeCArIChieCAtIGNwMngpICogdCxcblx0XHR5MmEgPSBjcDJ5ICsgKGJ5IC0gY3AyeSkgKiB0O1xuXHR4MiArPSAoeDJhIC0geDIpICogdDtcblx0eTIgKz0gKHkyYSAtIHkyKSAqIHQ7XG5cdHNlZ21lbnQuc3BsaWNlKGkgKyAyLCA0LFxuXHRcdF9yb3VuZCh4MWEpLCAgICAgICAgICAgICAgICAgIC8vZmlyc3QgY29udHJvbCBwb2ludFxuXHRcdF9yb3VuZCh5MWEpLFxuXHRcdF9yb3VuZCh4MSksICAgICAgICAgICAgICAgICAgIC8vc2Vjb25kIGNvbnRyb2wgcG9pbnRcblx0XHRfcm91bmQoeTEpLFxuXHRcdF9yb3VuZCh4MSArICh4MiAtIHgxKSAqIHQpLCAgIC8vbmV3IGZhYnJpY2F0ZWQgYW5jaG9yIG9uIGxpbmVcblx0XHRfcm91bmQoeTEgKyAoeTIgLSB5MSkgKiB0KSxcblx0XHRfcm91bmQoeDIpLCAgICAgICAgICAgICAgICAgICAvL3RoaXJkIGNvbnRyb2wgcG9pbnRcblx0XHRfcm91bmQoeTIpLFxuXHRcdF9yb3VuZCh4MmEpLCAgICAgICAgICAgICAgICAgIC8vZm91cnRoIGNvbnRyb2wgcG9pbnRcblx0XHRfcm91bmQoeTJhKVxuXHQpO1xuXHRzZWdtZW50LnNhbXBsZXMgJiYgc2VnbWVudC5zYW1wbGVzLnNwbGljZSgoKGkgLyA2KSAqIHNlZ21lbnQucmVzb2x1dGlvbikgfCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcblx0cmV0dXJuIDY7XG59XG5cbi8vIHJldHVybnMgYW4gb2JqZWN0IHtwYXRoLCBzZWdtZW50LCBzZWdJbmRleCwgaSwgdH1cbmZ1bmN0aW9uIGdldFByb2dyZXNzRGF0YShyYXdQYXRoLCBwcm9ncmVzcywgZGVjb3JhdGVlLCBwdXNoVG9OZXh0SWZBdEVuZCkge1xuXHRkZWNvcmF0ZWUgPSBkZWNvcmF0ZWUgfHwge307XG5cdHJhd1BhdGgudG90YWxMZW5ndGggfHwgY2FjaGVSYXdQYXRoTWVhc3VyZW1lbnRzKHJhd1BhdGgpO1xuXHRpZiAocHJvZ3Jlc3MgPCAwIHx8IHByb2dyZXNzID4gMSkge1xuXHRcdHByb2dyZXNzID0gX3dyYXBQcm9ncmVzcyhwcm9ncmVzcyk7XG5cdH1cblx0bGV0IHNlZ0luZGV4ID0gMCxcblx0XHRzZWdtZW50ID0gcmF3UGF0aFswXSxcblx0XHRzYW1wbGVzLCByZXNvbHV0aW9uLCBsZW5ndGgsIG1pbiwgbWF4LCBpLCB0O1xuXHRpZiAoIXByb2dyZXNzKSB7XG5cdFx0dCA9IGkgPSBzZWdJbmRleCA9IDA7XG5cdFx0c2VnbWVudCA9IHJhd1BhdGhbMF07XG5cdH0gZWxzZSBpZiAocHJvZ3Jlc3MgPT09IDEpIHtcblx0XHR0ID0gMTtcblx0XHRzZWdJbmRleCA9IHJhd1BhdGgubGVuZ3RoIC0gMTtcblx0XHRzZWdtZW50ID0gcmF3UGF0aFtzZWdJbmRleF07XG5cdFx0aSA9IHNlZ21lbnQubGVuZ3RoIC0gODtcblx0fSBlbHNlIHtcblx0XHRpZiAocmF3UGF0aC5sZW5ndGggPiAxKSB7IC8vc3BlZWQgb3B0aW1pemF0aW9uOiBtb3N0IG9mIHRoZSB0aW1lLCB0aGVyZSdzIG9ubHkgb25lIHNlZ21lbnQgc28gc2tpcCB0aGUgcmVjdXJzaW9uLlxuXHRcdFx0bGVuZ3RoID0gcmF3UGF0aC50b3RhbExlbmd0aCAqIHByb2dyZXNzO1xuXHRcdFx0bWF4ID0gaSA9IDA7XG5cdFx0XHR3aGlsZSAoKG1heCArPSByYXdQYXRoW2krK10udG90YWxMZW5ndGgpIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdHNlZ0luZGV4ID0gaTtcblx0XHRcdH1cblx0XHRcdHNlZ21lbnQgPSByYXdQYXRoW3NlZ0luZGV4XTtcblx0XHRcdG1pbiA9IG1heCAtIHNlZ21lbnQudG90YWxMZW5ndGg7XG5cdFx0XHRwcm9ncmVzcyA9ICgobGVuZ3RoIC0gbWluKSAvIChtYXggLSBtaW4pKSB8fCAwO1xuXHRcdH1cblx0XHRzYW1wbGVzID0gc2VnbWVudC5zYW1wbGVzO1xuXHRcdHJlc29sdXRpb24gPSBzZWdtZW50LnJlc29sdXRpb247IC8vaG93IG1hbnkgc2FtcGxlcyBwZXIgY3ViaWMgYmV6aWVyIGNodW5rXG5cdFx0bGVuZ3RoID0gc2VnbWVudC50b3RhbExlbmd0aCAqIHByb2dyZXNzO1xuXHRcdGkgPSBzZWdtZW50Lmxvb2t1cFt+fihsZW5ndGggLyBzZWdtZW50Lm1pbkxlbmd0aCldIHx8IDA7XG5cdFx0bWluID0gaSA/IHNhbXBsZXNbaS0xXSA6IDA7XG5cdFx0bWF4ID0gc2FtcGxlc1tpXTtcblx0XHRpZiAobWF4IDwgbGVuZ3RoKSB7XG5cdFx0XHRtaW4gPSBtYXg7XG5cdFx0XHRtYXggPSBzYW1wbGVzWysraV07XG5cdFx0fVxuXHRcdHQgPSAoMSAvIHJlc29sdXRpb24pICogKCgobGVuZ3RoIC0gbWluKSAvIChtYXggLSBtaW4pKSArICgoaSAlIHJlc29sdXRpb24pKSk7XG5cdFx0aSA9IH5+KGkgLyByZXNvbHV0aW9uKSAqIDY7XG5cdFx0aWYgKHB1c2hUb05leHRJZkF0RW5kICYmIHQgPT09IDEpIHtcblx0XHRcdGlmIChpICsgNiA8IHNlZ21lbnQubGVuZ3RoKSB7XG5cdFx0XHRcdGkgKz0gNjtcblx0XHRcdFx0dCA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKHNlZ0luZGV4ICsgMSA8IHJhd1BhdGgubGVuZ3RoKSB7XG5cdFx0XHRcdGkgPSB0ID0gMDtcblx0XHRcdFx0c2VnbWVudCA9IHJhd1BhdGhbKytzZWdJbmRleF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGRlY29yYXRlZS50ID0gdDtcblx0ZGVjb3JhdGVlLmkgPSBpO1xuXHRkZWNvcmF0ZWUucGF0aCA9IHJhd1BhdGg7XG5cdGRlY29yYXRlZS5zZWdtZW50ID0gc2VnbWVudDtcblx0ZGVjb3JhdGVlLnNlZ0luZGV4ID0gc2VnSW5kZXg7XG5cdHJldHVybiBkZWNvcmF0ZWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3NpdGlvbk9uUGF0aChyYXdQYXRoLCBwcm9ncmVzcywgaW5jbHVkZUFuZ2xlLCBwb2ludCkge1xuXHRsZXQgc2VnbWVudCA9IHJhd1BhdGhbMF0sXG5cdFx0cmVzdWx0ID0gcG9pbnQgfHwge30sXG5cdFx0c2FtcGxlcywgcmVzb2x1dGlvbiwgbGVuZ3RoLCBtaW4sIG1heCwgaSwgdCwgYSwgaW52O1xuXHRpZiAocHJvZ3Jlc3MgPCAwIHx8IHByb2dyZXNzID4gMSkge1xuXHRcdHByb2dyZXNzID0gX3dyYXBQcm9ncmVzcyhwcm9ncmVzcyk7XG5cdH1cblx0aWYgKHJhd1BhdGgubGVuZ3RoID4gMSkgeyAvL3NwZWVkIG9wdGltaXphdGlvbjogbW9zdCBvZiB0aGUgdGltZSwgdGhlcmUncyBvbmx5IG9uZSBzZWdtZW50IHNvIHNraXAgdGhlIHJlY3Vyc2lvbi5cblx0XHRsZW5ndGggPSByYXdQYXRoLnRvdGFsTGVuZ3RoICogcHJvZ3Jlc3M7XG5cdFx0bWF4ID0gaSA9IDA7XG5cdFx0d2hpbGUgKChtYXggKz0gcmF3UGF0aFtpKytdLnRvdGFsTGVuZ3RoKSA8IGxlbmd0aCkge1xuXHRcdFx0c2VnbWVudCA9IHJhd1BhdGhbaV07XG5cdFx0fVxuXHRcdG1pbiA9IG1heCAtIHNlZ21lbnQudG90YWxMZW5ndGg7XG5cdFx0cHJvZ3Jlc3MgPSAoKGxlbmd0aCAtIG1pbikgLyAobWF4IC0gbWluKSkgfHwgMDtcblx0fVxuXHRzYW1wbGVzID0gc2VnbWVudC5zYW1wbGVzO1xuXHRyZXNvbHV0aW9uID0gc2VnbWVudC5yZXNvbHV0aW9uO1xuXHRsZW5ndGggPSBzZWdtZW50LnRvdGFsTGVuZ3RoICogcHJvZ3Jlc3M7XG5cdGkgPSBzZWdtZW50Lmxvb2t1cFtwcm9ncmVzcyA8IDEgPyB+fihsZW5ndGggLyBzZWdtZW50Lm1pbkxlbmd0aCkgOiBzZWdtZW50Lmxvb2t1cC5sZW5ndGggLSAxXSB8fCAwO1xuXHRtaW4gPSBpID8gc2FtcGxlc1tpLTFdIDogMDtcblx0bWF4ID0gc2FtcGxlc1tpXTtcblx0aWYgKG1heCA8IGxlbmd0aCkge1xuXHRcdG1pbiA9IG1heDtcblx0XHRtYXggPSBzYW1wbGVzWysraV07XG5cdH1cblx0dCA9ICgoMSAvIHJlc29sdXRpb24pICogKCgobGVuZ3RoIC0gbWluKSAvIChtYXggLSBtaW4pKSArICgoaSAlIHJlc29sdXRpb24pKSkpIHx8IDA7XG5cdGludiA9IDEgLSB0O1xuXHRpID0gfn4oaSAvIHJlc29sdXRpb24pICogNjtcblx0YSA9IHNlZ21lbnRbaV07XG5cdHJlc3VsdC54ID0gX3JvdW5kKCh0ICogdCAqIChzZWdtZW50W2kgKyA2XSAtIGEpICsgMyAqIGludiAqICh0ICogKHNlZ21lbnRbaSArIDRdIC0gYSkgKyBpbnYgKiAoc2VnbWVudFtpICsgMl0gLSBhKSkpICogdCArIGEpO1xuXHRyZXN1bHQueSA9IF9yb3VuZCgodCAqIHQgKiAoc2VnbWVudFtpICsgN10gLSAoYSA9IHNlZ21lbnRbaSsxXSkpICsgMyAqIGludiAqICh0ICogKHNlZ21lbnRbaSArIDVdIC0gYSkgKyBpbnYgKiAoc2VnbWVudFtpICsgM10gLSBhKSkpICogdCArIGEpO1xuXHRpZiAoaW5jbHVkZUFuZ2xlKSB7XG5cdFx0cmVzdWx0LmFuZ2xlID0gc2VnbWVudC50b3RhbExlbmd0aCA/IGdldFJvdGF0aW9uQXRCZXppZXJUKHNlZ21lbnQsIGksIHQgPj0gMSA/IDEgLSAxZS05IDogdCA/IHQgOiAxZS05KSA6IHNlZ21lbnQuYW5nbGUgfHwgMDtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5cblxuLy9hcHBsaWVzIGEgbWF0cml4IHRyYW5zZm9ybSB0byBSYXdQYXRoIChvciBhIHNlZ21lbnQgaW4gYSBSYXdQYXRoKSBhbmQgcmV0dXJucyB3aGF0ZXZlciB3YXMgcGFzc2VkIGluIChpdCB0cmFuc2Zvcm1zIHRoZSB2YWx1ZXMgaW4gdGhlIGFycmF5KHMpLCBub3QgYSBjb3B5KS5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1SYXdQYXRoKHJhd1BhdGgsIGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuXHRsZXQgaiA9IHJhd1BhdGgubGVuZ3RoLFxuXHRcdHNlZ21lbnQsIGwsIGksIHgsIHk7XG5cdHdoaWxlICgtLWogPiAtMSkge1xuXHRcdHNlZ21lbnQgPSByYXdQYXRoW2pdO1xuXHRcdGwgPSBzZWdtZW50Lmxlbmd0aDtcblx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSAyKSB7XG5cdFx0XHR4ID0gc2VnbWVudFtpXTtcblx0XHRcdHkgPSBzZWdtZW50W2krMV07XG5cdFx0XHRzZWdtZW50W2ldID0geCAqIGEgKyB5ICogYyArIHR4O1xuXHRcdFx0c2VnbWVudFtpKzFdID0geCAqIGIgKyB5ICogZCArIHR5O1xuXHRcdH1cblx0fVxuXHRyYXdQYXRoLl9kaXJ0eSA9IDE7XG5cdHJldHVybiByYXdQYXRoO1xufVxuXG5cblxuLy8gdHJhbnNsYXRlcyBTVkcgYXJjIGRhdGEgaW50byBhIHNlZ21lbnQgKGN1YmljIGJlemllcnMpLiBBbmdsZSBpcyBpbiBkZWdyZWVzLlxuZnVuY3Rpb24gYXJjVG9TZWdtZW50KGxhc3RYLCBsYXN0WSwgcngsIHJ5LCBhbmdsZSwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHgsIHkpIHtcblx0aWYgKGxhc3RYID09PSB4ICYmIGxhc3RZID09PSB5KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHJ4ID0gX2FicyhyeCk7XG5cdHJ5ID0gX2FicyhyeSk7XG5cdGxldCBhbmdsZVJhZCA9IChhbmdsZSAlIDM2MCkgKiBfREVHMlJBRCxcblx0XHRjb3NBbmdsZSA9IF9jb3MoYW5nbGVSYWQpLFxuXHRcdHNpbkFuZ2xlID0gX3NpbihhbmdsZVJhZCksXG5cdFx0UEkgPSBNYXRoLlBJLFxuXHRcdFRXT1BJID0gUEkgKiAyLFxuXHRcdGR4MiA9IChsYXN0WCAtIHgpIC8gMixcblx0XHRkeTIgPSAobGFzdFkgLSB5KSAvIDIsXG5cdFx0eDEgPSAoY29zQW5nbGUgKiBkeDIgKyBzaW5BbmdsZSAqIGR5MiksXG5cdFx0eTEgPSAoLXNpbkFuZ2xlICogZHgyICsgY29zQW5nbGUgKiBkeTIpLFxuXHRcdHgxX3NxID0geDEgKiB4MSxcblx0XHR5MV9zcSA9IHkxICogeTEsXG5cdFx0cmFkaWlDaGVjayA9IHgxX3NxIC8gKHJ4ICogcngpICsgeTFfc3EgLyAocnkgKiByeSk7XG5cdGlmIChyYWRpaUNoZWNrID4gMSkge1xuXHRcdHJ4ID0gX3NxcnQocmFkaWlDaGVjaykgKiByeDtcblx0XHRyeSA9IF9zcXJ0KHJhZGlpQ2hlY2spICogcnk7XG5cdH1cblx0bGV0IHJ4X3NxID0gcnggKiByeCxcblx0XHRyeV9zcSA9IHJ5ICogcnksXG5cdFx0c3EgPSAoKHJ4X3NxICogcnlfc3EpIC0gKHJ4X3NxICogeTFfc3EpIC0gKHJ5X3NxICogeDFfc3EpKSAvICgocnhfc3EgKiB5MV9zcSkgKyAocnlfc3EgKiB4MV9zcSkpO1xuXHRpZiAoc3EgPCAwKSB7XG5cdFx0c3EgPSAwO1xuXHR9XG5cdGxldCBjb2VmID0gKChsYXJnZUFyY0ZsYWcgPT09IHN3ZWVwRmxhZykgPyAtMSA6IDEpICogX3NxcnQoc3EpLFxuXHRcdGN4MSA9IGNvZWYgKiAoKHJ4ICogeTEpIC8gcnkpLFxuXHRcdGN5MSA9IGNvZWYgKiAtKChyeSAqIHgxKSAvIHJ4KSxcblx0XHRzeDIgPSAobGFzdFggKyB4KSAvIDIsXG5cdFx0c3kyID0gKGxhc3RZICsgeSkgLyAyLFxuXHRcdGN4ID0gc3gyICsgKGNvc0FuZ2xlICogY3gxIC0gc2luQW5nbGUgKiBjeTEpLFxuXHRcdGN5ID0gc3kyICsgKHNpbkFuZ2xlICogY3gxICsgY29zQW5nbGUgKiBjeTEpLFxuXHRcdHV4ID0gKHgxIC0gY3gxKSAvIHJ4LFxuXHRcdHV5ID0gKHkxIC0gY3kxKSAvIHJ5LFxuXHRcdHZ4ID0gKC14MSAtIGN4MSkgLyByeCxcblx0XHR2eSA9ICgteTEgLSBjeTEpIC8gcnksXG5cdFx0dGVtcCA9IHV4ICogdXggKyB1eSAqIHV5LFxuXHRcdGFuZ2xlU3RhcnQgPSAoKHV5IDwgMCkgPyAtMSA6IDEpICogTWF0aC5hY29zKHV4IC8gX3NxcnQodGVtcCkpLFxuXHRcdGFuZ2xlRXh0ZW50ID0gKCh1eCAqIHZ5IC0gdXkgKiB2eCA8IDApID8gLTEgOiAxKSAqIE1hdGguYWNvcygodXggKiB2eCArIHV5ICogdnkpIC8gX3NxcnQodGVtcCAqICh2eCAqIHZ4ICsgdnkgKiB2eSkpKTtcblx0aXNOYU4oYW5nbGVFeHRlbnQpICYmIChhbmdsZUV4dGVudCA9IFBJKTsgLy9yYXJlIGVkZ2UgY2FzZS4gTWF0aC5jb3MoLTEpIGlzIE5hTi5cblx0aWYgKCFzd2VlcEZsYWcgJiYgYW5nbGVFeHRlbnQgPiAwKSB7XG5cdFx0YW5nbGVFeHRlbnQgLT0gVFdPUEk7XG5cdH0gZWxzZSBpZiAoc3dlZXBGbGFnICYmIGFuZ2xlRXh0ZW50IDwgMCkge1xuXHRcdGFuZ2xlRXh0ZW50ICs9IFRXT1BJO1xuXHR9XG5cdGFuZ2xlU3RhcnQgJT0gVFdPUEk7XG5cdGFuZ2xlRXh0ZW50ICU9IFRXT1BJO1xuXHRsZXQgc2VnbWVudHMgPSBNYXRoLmNlaWwoX2FicyhhbmdsZUV4dGVudCkgLyAoVFdPUEkgLyA0KSksXG5cdFx0cmF3UGF0aCA9IFtdLFxuXHRcdGFuZ2xlSW5jcmVtZW50ID0gYW5nbGVFeHRlbnQgLyBzZWdtZW50cyxcblx0XHRjb250cm9sTGVuZ3RoID0gNCAvIDMgKiBfc2luKGFuZ2xlSW5jcmVtZW50IC8gMikgLyAoMSArIF9jb3MoYW5nbGVJbmNyZW1lbnQgLyAyKSksXG5cdFx0bWEgPSBjb3NBbmdsZSAqIHJ4LFxuXHRcdG1iID0gc2luQW5nbGUgKiByeCxcblx0XHRtYyA9IHNpbkFuZ2xlICogLXJ5LFxuXHRcdG1kID0gY29zQW5nbGUgKiByeSxcblx0XHRpO1xuXHRmb3IgKGkgPSAwOyBpIDwgc2VnbWVudHM7IGkrKykge1xuXHRcdGFuZ2xlID0gYW5nbGVTdGFydCArIGkgKiBhbmdsZUluY3JlbWVudDtcblx0XHR4MSA9IF9jb3MoYW5nbGUpO1xuXHRcdHkxID0gX3NpbihhbmdsZSk7XG5cdFx0dXggPSBfY29zKGFuZ2xlICs9IGFuZ2xlSW5jcmVtZW50KTtcblx0XHR1eSA9IF9zaW4oYW5nbGUpO1xuXHRcdHJhd1BhdGgucHVzaCh4MSAtIGNvbnRyb2xMZW5ndGggKiB5MSwgeTEgKyBjb250cm9sTGVuZ3RoICogeDEsIHV4ICsgY29udHJvbExlbmd0aCAqIHV5LCB1eSAtIGNvbnRyb2xMZW5ndGggKiB1eCwgdXgsIHV5KTtcblx0fVxuXHQvL25vdyB0cmFuc2Zvcm0gYWNjb3JkaW5nIHRvIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGUgZWxsaXBzZS9hcmMgKHRoZSBiZXppZXJzIHdlcmUgbm9yYW1saXplZCwgYmV0d2VlbiAwIGFuZCAxIG9uIGEgY2lyY2xlKS5cblx0Zm9yIChpID0gMDsgaSA8IHJhd1BhdGgubGVuZ3RoOyBpKz0yKSB7XG5cdFx0eDEgPSByYXdQYXRoW2ldO1xuXHRcdHkxID0gcmF3UGF0aFtpKzFdO1xuXHRcdHJhd1BhdGhbaV0gPSB4MSAqIG1hICsgeTEgKiBtYyArIGN4O1xuXHRcdHJhd1BhdGhbaSsxXSA9IHgxICogbWIgKyB5MSAqIG1kICsgY3k7XG5cdH1cblx0cmF3UGF0aFtpLTJdID0geDsgLy9hbHdheXMgc2V0IHRoZSBlbmQgdG8gZXhhY3RseSB3aGVyZSBpdCdzIHN1cHBvc2VkIHRvIGJlXG5cdHJhd1BhdGhbaS0xXSA9IHk7XG5cdHJldHVybiByYXdQYXRoO1xufVxuXG4vL1NwaXRzIGJhY2sgYSBSYXdQYXRoIHdpdGggYWJzb2x1dGUgY29vcmRpbmF0ZXMuIEVhY2ggc2VnbWVudCBzdGFydHMgd2l0aCBhIFwibW92ZVRvXCIgY29tbWFuZCAoeCBjb29yZGluYXRlLCB0aGVuIHkpIGFuZCB0aGVuIDIgY29udHJvbCBwb2ludHMgKHgsIHksIHgsIHkpLCB0aGVuIGFuY2hvci4gVGhlIGdvYWwgaXMgdG8gbWluaW1pemUgbWVtb3J5IGFuZCBtYXhpbWl6ZSBzcGVlZC5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb1Jhd1BhdGgoZCkge1xuXHRsZXQgYSA9IChkICsgXCJcIikucmVwbGFjZShfc2NpZW50aWZpYywgbSA9PiB7IGxldCBuID0gK207IHJldHVybiAobiA8IDAuMDAwMSAmJiBuID4gLTAuMDAwMSkgPyAwIDogbjsgfSkubWF0Y2goX3N2Z1BhdGhFeHApIHx8IFtdLCAvL3NvbWUgYXV0aG9yaW5nIHByb2dyYW1zIHNwaXQgb3V0IHZlcnkgc21hbGwgbnVtYmVycyBpbiBzY2llbnRpZmljIG5vdGF0aW9uIGxpa2UgXCIxZS01XCIsIHNvIG1ha2Ugc3VyZSB3ZSByb3VuZCB0aGF0IGRvd24gdG8gMCBmaXJzdC5cblx0XHRwYXRoID0gW10sXG5cdFx0cmVsYXRpdmVYID0gMCxcblx0XHRyZWxhdGl2ZVkgPSAwLFxuXHRcdHR3b1RoaXJkcyA9IDIgLyAzLFxuXHRcdGVsZW1lbnRzID0gYS5sZW5ndGgsXG5cdFx0cG9pbnRzID0gMCxcblx0XHRlcnJvck1lc3NhZ2UgPSBcIkVSUk9SOiBtYWxmb3JtZWQgcGF0aDogXCIgKyBkLFxuXHRcdGksIGosIHgsIHksIGNvbW1hbmQsIGlzUmVsYXRpdmUsIHNlZ21lbnQsIHN0YXJ0WCwgc3RhcnRZLCBkaWZYLCBkaWZZLCBiZXppZXJzLCBwcmV2Q29tbWFuZCwgZmxhZzEsIGZsYWcyLFxuXHRcdGxpbmUgPSBmdW5jdGlvbihzeCwgc3ksIGV4LCBleSkge1xuXHRcdFx0ZGlmWCA9IChleCAtIHN4KSAvIDM7XG5cdFx0XHRkaWZZID0gKGV5IC0gc3kpIC8gMztcblx0XHRcdHNlZ21lbnQucHVzaChzeCArIGRpZlgsIHN5ICsgZGlmWSwgZXggLSBkaWZYLCBleSAtIGRpZlksIGV4LCBleSk7XG5cdFx0fTtcblx0aWYgKCFkIHx8ICFpc05hTihhWzBdKSB8fCBpc05hTihhWzFdKSkge1xuXHRcdGNvbnNvbGUubG9nKGVycm9yTWVzc2FnZSk7XG5cdFx0cmV0dXJuIHBhdGg7XG5cdH1cblx0Zm9yIChpID0gMDsgaSA8IGVsZW1lbnRzOyBpKyspIHtcblx0XHRwcmV2Q29tbWFuZCA9IGNvbW1hbmQ7XG5cdFx0aWYgKGlzTmFOKGFbaV0pKSB7XG5cdFx0XHRjb21tYW5kID0gYVtpXS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0aXNSZWxhdGl2ZSA9IChjb21tYW5kICE9PSBhW2ldKTsgLy9sb3dlciBjYXNlIG1lYW5zIHJlbGF0aXZlXG5cdFx0fSBlbHNlIHsgLy9jb21tYW5kcyBsaWtlIFwiQ1wiIGNhbiBiZSBzdHJ1bmcgdG9nZXRoZXIgd2l0aG91dCBhbnkgbmV3IGNvbW1hbmQgY2hhcmFjdGVycyBiZXR3ZWVuLlxuXHRcdFx0aS0tO1xuXHRcdH1cblx0XHR4ID0gK2FbaSArIDFdO1xuXHRcdHkgPSArYVtpICsgMl07XG5cdFx0aWYgKGlzUmVsYXRpdmUpIHtcblx0XHRcdHggKz0gcmVsYXRpdmVYO1xuXHRcdFx0eSArPSByZWxhdGl2ZVk7XG5cdFx0fVxuXHRcdGlmICghaSkge1xuXHRcdFx0c3RhcnRYID0geDtcblx0XHRcdHN0YXJ0WSA9IHk7XG5cdFx0fVxuXG5cdFx0Ly8gXCJNXCIgKG1vdmUpXG5cdFx0aWYgKGNvbW1hbmQgPT09IFwiTVwiKSB7XG5cdFx0XHRpZiAoc2VnbWVudCkge1xuXHRcdFx0XHRpZiAoc2VnbWVudC5sZW5ndGggPCA4KSB7IC8vaWYgdGhlIHBhdGggZGF0YSB3YXMgZnVua3kgYW5kIGp1c3QgaGFkIGEgTSB3aXRoIG5vIGFjdHVhbCBkcmF3aW5nIGFueXdoZXJlLCBza2lwIGl0LlxuXHRcdFx0XHRcdHBhdGgubGVuZ3RoIC09IDE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cG9pbnRzICs9IHNlZ21lbnQubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWxhdGl2ZVggPSBzdGFydFggPSB4O1xuXHRcdFx0cmVsYXRpdmVZID0gc3RhcnRZID0geTtcblx0XHRcdHNlZ21lbnQgPSBbeCwgeV07XG5cdFx0XHRwYXRoLnB1c2goc2VnbWVudCk7XG5cdFx0XHRpICs9IDI7XG5cdFx0XHRjb21tYW5kID0gXCJMXCI7IC8vYW4gXCJNXCIgd2l0aCBtb3JlIHRoYW4gMiB2YWx1ZXMgZ2V0cyBpbnRlcnByZXRlZCBhcyBcImxpbmVUb1wiIGNvbW1hbmRzIChcIkxcIikuXG5cblx0XHQvLyBcIkNcIiAoY3ViaWMgYmV6aWVyKVxuXHRcdH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJDXCIpIHtcblx0XHRcdGlmICghc2VnbWVudCkge1xuXHRcdFx0XHRzZWdtZW50ID0gWzAsIDBdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFpc1JlbGF0aXZlKSB7XG5cdFx0XHRcdHJlbGF0aXZlWCA9IHJlbGF0aXZlWSA9IDA7XG5cdFx0XHR9XG5cdFx0XHQvL25vdGU6IFwiKjFcIiBpcyBqdXN0IGEgZmFzdC9zaG9ydCB3YXkgdG8gY2FzdCB0aGUgdmFsdWUgYXMgYSBOdW1iZXIuIFdBQUFZIGZhc3RlciBpbiBDaHJvbWUsIHNsaWdodGx5IHNsb3dlciBpbiBGaXJlZm94LlxuXHRcdFx0c2VnbWVudC5wdXNoKHgsXHR5LCByZWxhdGl2ZVggKyBhW2kgKyAzXSAqIDEsIHJlbGF0aXZlWSArIGFbaSArIDRdICogMSwgKHJlbGF0aXZlWCArPSBhW2kgKyA1XSAqIDEpLFx0KHJlbGF0aXZlWSArPSBhW2kgKyA2XSAqIDEpKTtcblx0XHRcdGkgKz0gNjtcblxuXHRcdC8vIFwiU1wiIChjb250aW51YXRpb24gb2YgY3ViaWMgYmV6aWVyKVxuXHRcdH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJTXCIpIHtcblx0XHRcdGRpZlggPSByZWxhdGl2ZVg7XG5cdFx0XHRkaWZZID0gcmVsYXRpdmVZO1xuXHRcdFx0aWYgKHByZXZDb21tYW5kID09PSBcIkNcIiB8fCBwcmV2Q29tbWFuZCA9PT0gXCJTXCIpIHtcblx0XHRcdFx0ZGlmWCArPSByZWxhdGl2ZVggLSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gNF07XG5cdFx0XHRcdGRpZlkgKz0gcmVsYXRpdmVZIC0gc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDNdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFpc1JlbGF0aXZlKSB7XG5cdFx0XHRcdHJlbGF0aXZlWCA9IHJlbGF0aXZlWSA9IDA7XG5cdFx0XHR9XG5cdFx0XHRzZWdtZW50LnB1c2goZGlmWCwgZGlmWSwgeCxcdHksIChyZWxhdGl2ZVggKz0gYVtpICsgM10gKiAxKSwgKHJlbGF0aXZlWSArPSBhW2kgKyA0XSAqIDEpKTtcblx0XHRcdGkgKz0gNDtcblxuXHRcdC8vIFwiUVwiIChxdWFkcmF0aWMgYmV6aWVyKVxuXHRcdH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJRXCIpIHtcblx0XHRcdGRpZlggPSByZWxhdGl2ZVggKyAoeCAtIHJlbGF0aXZlWCkgKiB0d29UaGlyZHM7XG5cdFx0XHRkaWZZID0gcmVsYXRpdmVZICsgKHkgLSByZWxhdGl2ZVkpICogdHdvVGhpcmRzO1xuXHRcdFx0aWYgKCFpc1JlbGF0aXZlKSB7XG5cdFx0XHRcdHJlbGF0aXZlWCA9IHJlbGF0aXZlWSA9IDA7XG5cdFx0XHR9XG5cdFx0XHRyZWxhdGl2ZVggKz0gYVtpICsgM10gKiAxO1xuXHRcdFx0cmVsYXRpdmVZICs9IGFbaSArIDRdICogMTtcblx0XHRcdHNlZ21lbnQucHVzaChkaWZYLCBkaWZZLCByZWxhdGl2ZVggKyAoeCAtIHJlbGF0aXZlWCkgKiB0d29UaGlyZHMsIHJlbGF0aXZlWSArICh5IC0gcmVsYXRpdmVZKSAqIHR3b1RoaXJkcywgcmVsYXRpdmVYLCByZWxhdGl2ZVkpO1xuXHRcdFx0aSArPSA0O1xuXG5cdFx0Ly8gXCJUXCIgKGNvbnRpbnVhdGlvbiBvZiBxdWFkcmF0aWMgYmV6aWVyKVxuXHRcdH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJUXCIpIHtcblx0XHRcdGRpZlggPSByZWxhdGl2ZVggLSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gNF07XG5cdFx0XHRkaWZZID0gcmVsYXRpdmVZIC0gc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDNdO1xuXHRcdFx0c2VnbWVudC5wdXNoKHJlbGF0aXZlWCArIGRpZlgsIHJlbGF0aXZlWSArIGRpZlksIHggKyAoKHJlbGF0aXZlWCArIGRpZlggKiAxLjUpIC0geCkgKiB0d29UaGlyZHMsIHkgKyAoKHJlbGF0aXZlWSArIGRpZlkgKiAxLjUpIC0geSkgKiB0d29UaGlyZHMsIChyZWxhdGl2ZVggPSB4KSwgKHJlbGF0aXZlWSA9IHkpKTtcblx0XHRcdGkgKz0gMjtcblxuXHRcdC8vIFwiSFwiIChob3Jpem9udGFsIGxpbmUpXG5cdFx0fSBlbHNlIGlmIChjb21tYW5kID09PSBcIkhcIikge1xuXHRcdFx0bGluZShyZWxhdGl2ZVgsIHJlbGF0aXZlWSwgKHJlbGF0aXZlWCA9IHgpLCByZWxhdGl2ZVkpO1xuXHRcdFx0aSArPSAxO1xuXG5cdFx0Ly8gXCJWXCIgKHZlcnRpY2FsIGxpbmUpXG5cdFx0fSBlbHNlIGlmIChjb21tYW5kID09PSBcIlZcIikge1xuXHRcdFx0Ly9hZGp1c3QgdmFsdWVzIGJlY2F1c2UgdGhlIGZpcnN0IChhbmQgb25seSBvbmUpIGlzbid0IHggaW4gdGhpcyBjYXNlLCBpdCdzIHkuXG5cdFx0XHRsaW5lKHJlbGF0aXZlWCwgcmVsYXRpdmVZLCByZWxhdGl2ZVgsIChyZWxhdGl2ZVkgPSB4ICsgKGlzUmVsYXRpdmUgPyByZWxhdGl2ZVkgLSByZWxhdGl2ZVggOiAwKSkpO1xuXHRcdFx0aSArPSAxO1xuXG5cdFx0Ly8gXCJMXCIgKGxpbmUpIG9yIFwiWlwiIChjbG9zZSlcblx0XHR9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiTFwiIHx8IGNvbW1hbmQgPT09IFwiWlwiKSB7XG5cdFx0XHRpZiAoY29tbWFuZCA9PT0gXCJaXCIpIHtcblx0XHRcdFx0eCA9IHN0YXJ0WDtcblx0XHRcdFx0eSA9IHN0YXJ0WTtcblx0XHRcdFx0c2VnbWVudC5jbG9zZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbW1hbmQgPT09IFwiTFwiIHx8IF9hYnMocmVsYXRpdmVYIC0geCkgPiAwLjUgfHwgX2FicyhyZWxhdGl2ZVkgLSB5KSA+IDAuNSkge1xuXHRcdFx0XHRsaW5lKHJlbGF0aXZlWCwgcmVsYXRpdmVZLCB4LCB5KTtcblx0XHRcdFx0aWYgKGNvbW1hbmQgPT09IFwiTFwiKSB7XG5cdFx0XHRcdFx0aSArPSAyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWxhdGl2ZVggPSB4O1xuXHRcdFx0cmVsYXRpdmVZID0geTtcblxuXHRcdC8vIFwiQVwiIChhcmMpXG5cdFx0fSBlbHNlIGlmIChjb21tYW5kID09PSBcIkFcIikge1xuXHRcdFx0ZmxhZzEgPSBhW2krNF07XG5cdFx0XHRmbGFnMiA9IGFbaSs1XTtcblx0XHRcdGRpZlggPSBhW2krNl07XG5cdFx0XHRkaWZZID0gYVtpKzddO1xuXHRcdFx0aiA9IDc7XG5cdFx0XHRpZiAoZmxhZzEubGVuZ3RoID4gMSkgeyAvLyBmb3IgY2FzZXMgd2hlbiB0aGUgZmxhZ3MgYXJlIG1lcmdlZCwgbGlrZSBcImE4IDggMCAwMTggOFwiICh0aGUgMCBhbmQgMSBmbGFncyBhcmUgV0lUSCB0aGUgeCB2YWx1ZSBvZiA4LCBidXQgaXQgY291bGQgYWxzbyBiZSBcImE4IDggMCAwMS04IDhcIiBzbyBpdCBtYXkgaW5jbHVkZSB4IG9yIG5vdClcblx0XHRcdFx0aWYgKGZsYWcxLmxlbmd0aCA8IDMpIHtcblx0XHRcdFx0XHRkaWZZID0gZGlmWDtcblx0XHRcdFx0XHRkaWZYID0gZmxhZzI7XG5cdFx0XHRcdFx0ai0tO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRpZlkgPSBmbGFnMjtcblx0XHRcdFx0XHRkaWZYID0gZmxhZzEuc3Vic3RyKDIpO1xuXHRcdFx0XHRcdGotPTI7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZmxhZzIgPSBmbGFnMS5jaGFyQXQoMSk7XG5cdFx0XHRcdGZsYWcxID0gZmxhZzEuY2hhckF0KDApO1xuXHRcdFx0fVxuXHRcdFx0YmV6aWVycyA9IGFyY1RvU2VnbWVudChyZWxhdGl2ZVgsIHJlbGF0aXZlWSwgK2FbaSsxXSwgK2FbaSsyXSwgK2FbaSszXSwgK2ZsYWcxLCArZmxhZzIsIChpc1JlbGF0aXZlID8gcmVsYXRpdmVYIDogMCkgKyBkaWZYKjEsIChpc1JlbGF0aXZlID8gcmVsYXRpdmVZIDogMCkgKyBkaWZZKjEpO1xuXHRcdFx0aSArPSBqO1xuXHRcdFx0aWYgKGJlemllcnMpIHtcblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGJlemllcnMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRzZWdtZW50LnB1c2goYmV6aWVyc1tqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlbGF0aXZlWCA9IHNlZ21lbnRbc2VnbWVudC5sZW5ndGgtMl07XG5cdFx0XHRyZWxhdGl2ZVkgPSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoLTFdO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUubG9nKGVycm9yTWVzc2FnZSk7XG5cdFx0fVxuXHR9XG5cdGkgPSBzZWdtZW50Lmxlbmd0aDtcblx0aWYgKGkgPCA2KSB7IC8vaW4gY2FzZSB0aGVyZSdzIG9kZCBTVkcgbGlrZSBhIE0wLDAgY29tbWFuZCBhdCB0aGUgdmVyeSBlbmQuXG5cdFx0cGF0aC5wb3AoKTtcblx0XHRpID0gMDtcblx0fSBlbHNlIGlmIChzZWdtZW50WzBdID09PSBzZWdtZW50W2ktMl0gJiYgc2VnbWVudFsxXSA9PT0gc2VnbWVudFtpLTFdKSB7XG5cdFx0c2VnbWVudC5jbG9zZWQgPSB0cnVlO1xuXHR9XG5cdHBhdGgudG90YWxQb2ludHMgPSBwb2ludHMgKyBpO1xuXHRyZXR1cm4gcGF0aDtcbn1cblxuLy9wb3B1bGF0ZXMgdGhlIHBvaW50cyBhcnJheSBpbiBhbHRlcm5hdGluZyB4L3kgdmFsdWVzIChsaWtlIFt4LCB5LCB4LCB5Li4uXSBpbnN0ZWFkIG9mIGluZGl2aWR1YWwgcG9pbnQgb2JqZWN0cyBbe3gsIHl9LCB7eCwgeX0uLi5dIHRvIGNvbnNlcnZlIG1lbW9yeSBhbmQgc3RheSBpbiBsaW5lIHdpdGggaG93IHdlJ3JlIGhhbmRsaW5nIHNlZ21lbnQgYXJyYXlzXG5leHBvcnQgZnVuY3Rpb24gYmV6aWVyVG9Qb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB0aHJlc2hvbGQsIHBvaW50cywgaW5kZXgpIHtcblx0bGV0IHgxMiA9ICh4MSArIHgyKSAvIDIsXG5cdFx0eTEyID0gKHkxICsgeTIpIC8gMixcblx0XHR4MjMgPSAoeDIgKyB4MykgLyAyLFxuXHRcdHkyMyA9ICh5MiArIHkzKSAvIDIsXG5cdFx0eDM0ID0gKHgzICsgeDQpIC8gMixcblx0XHR5MzQgPSAoeTMgKyB5NCkgLyAyLFxuXHRcdHgxMjMgPSAoeDEyICsgeDIzKSAvIDIsXG5cdFx0eTEyMyA9ICh5MTIgKyB5MjMpIC8gMixcblx0XHR4MjM0ID0gKHgyMyArIHgzNCkgLyAyLFxuXHRcdHkyMzQgPSAoeTIzICsgeTM0KSAvIDIsXG5cdFx0eDEyMzQgPSAoeDEyMyArIHgyMzQpIC8gMixcblx0XHR5MTIzNCA9ICh5MTIzICsgeTIzNCkgLyAyLFxuXHRcdGR4ID0geDQgLSB4MSxcblx0XHRkeSA9IHk0IC0geTEsXG5cdFx0ZDIgPSBfYWJzKCh4MiAtIHg0KSAqIGR5IC0gKHkyIC0geTQpICogZHgpLFxuXHRcdGQzID0gX2FicygoeDMgLSB4NCkgKiBkeSAtICh5MyAtIHk0KSAqIGR4KSxcblx0XHRsZW5ndGg7XG5cdGlmICghcG9pbnRzKSB7XG5cdFx0cG9pbnRzID0gW3gxLCB5MSwgeDQsIHk0XTtcblx0XHRpbmRleCA9IDI7XG5cdH1cblx0cG9pbnRzLnNwbGljZShpbmRleCB8fCBwb2ludHMubGVuZ3RoIC0gMiwgMCwgeDEyMzQsIHkxMjM0KTtcblx0aWYgKChkMiArIGQzKSAqIChkMiArIGQzKSA+IHRocmVzaG9sZCAqIChkeCAqIGR4ICsgZHkgKiBkeSkpIHtcblx0XHRsZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuXHRcdGJlemllclRvUG9pbnRzKHgxLCB5MSwgeDEyLCB5MTIsIHgxMjMsIHkxMjMsIHgxMjM0LCB5MTIzNCwgdGhyZXNob2xkLCBwb2ludHMsIGluZGV4KTtcblx0XHRiZXppZXJUb1BvaW50cyh4MTIzNCwgeTEyMzQsIHgyMzQsIHkyMzQsIHgzNCwgeTM0LCB4NCwgeTQsIHRocmVzaG9sZCwgcG9pbnRzLCBpbmRleCArIDIgKyAocG9pbnRzLmxlbmd0aCAtIGxlbmd0aCkpO1xuXHR9XG5cdHJldHVybiBwb2ludHM7XG59XG5cbi8qXG5mdW5jdGlvbiBnZXRBbmdsZUJldHdlZW5Qb2ludHMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MikgeyAvL2FuZ2xlIGJldHdlZW4gMyBwb2ludHMgaW4gcmFkaWFuc1xuXHR2YXIgZHgxID0geDEgLSB4MCxcblx0XHRkeTEgPSB5MSAtIHkwLFxuXHRcdGR4MiA9IHgyIC0geDEsXG5cdFx0ZHkyID0geTIgLSB5MSxcblx0XHRkeDMgPSB4MiAtIHgwLFxuXHRcdGR5MyA9IHkyIC0geTAsXG5cdFx0YSA9IGR4MSAqIGR4MSArIGR5MSAqIGR5MSxcblx0XHRiID0gZHgyICogZHgyICsgZHkyICogZHkyLFxuXHRcdGMgPSBkeDMgKiBkeDMgKyBkeTMgKiBkeTM7XG5cdHJldHVybiBNYXRoLmFjb3MoIChhICsgYiAtIGMpIC8gX3NxcnQoNCAqIGEgKiBiKSApO1xufSxcbiovXG5cbi8vcG9pbnRzVG9TZWdtZW50KCkgZG9lc24ndCBoYW5kbGUgZmxhdCBjb29yZGluYXRlcyAod2hlcmUgeSBpcyBhbHdheXMgMCkgdGhlIHdheSB3ZSBuZWVkICh0aGUgcmVzdWx0aW5nIGNvbnRyb2wgcG9pbnRzIGFyZSBhbHdheXMgcmlnaHQgb24gdG9wIG9mIHRoZSBhbmNob3JzKSwgc28gdGhpcyBmdW5jdGlvbiBiYXNpY2FsbHkgbWFrZXMgdGhlIGNvbnRyb2wgcG9pbnRzIGdvIGRpcmVjdGx5IHVwIGFuZCBkb3duLCB2YXJ5aW5nIGluIGxlbmd0aCBiYXNlZCBvbiB0aGUgY3VydmluZXNzIChtb3JlIGN1cnZ5LCBmdXJ0aGVyIGNvbnRyb2wgcG9pbnRzKVxuZXhwb3J0IGZ1bmN0aW9uIGZsYXRQb2ludHNUb1NlZ21lbnQocG9pbnRzLCBjdXJ2aW5lc3M9MSkge1xuXHRsZXQgeCA9IHBvaW50c1swXSxcblx0XHR5ID0gMCxcblx0XHRzZWdtZW50ID0gW3gsIHldLFxuXHRcdGkgPSAyO1xuXHRmb3IgKDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrPTIpIHtcblx0XHRzZWdtZW50LnB1c2goXG5cdFx0XHR4LFxuXHRcdFx0eSxcblx0XHRcdHBvaW50c1tpXSxcblx0XHRcdCh5ID0gKHBvaW50c1tpXSAtIHgpICogY3VydmluZXNzIC8gMiksXG5cdFx0XHQoeCA9IHBvaW50c1tpXSksXG5cdFx0XHQteVxuXHRcdCk7XG5cdH1cblx0cmV0dXJuIHNlZ21lbnQ7XG59XG5cbi8vcG9pbnRzIGlzIGFuIGFycmF5IG9mIHgveSBwb2ludHMsIGxpa2UgW3gsIHksIHgsIHksIHgsIHldXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRzVG9TZWdtZW50KHBvaW50cywgY3VydmluZXNzLCBjb3JuZXJUaHJlc2hvbGQpIHtcblx0Ly9wb2ludHMgPSBzaW1wbGlmeVBvaW50cyhwb2ludHMsIHRvbGVyYW5jZSk7XG5cdF9hYnMocG9pbnRzWzBdIC0gcG9pbnRzWzJdKSA8IDFlLTQgJiYgX2Ficyhwb2ludHNbMV0gLSBwb2ludHNbM10pIDwgMWUtNCAmJiAocG9pbnRzID0gcG9pbnRzLnNsaWNlKDIpKTsgLy8gaWYgdGhlIGZpcnN0IHR3byBwb2ludHMgYXJlIHN1cGVyIGNsb3NlLCBkdW1wIHRoZSBmaXJzdCBvbmUuXG5cdGxldCBsID0gcG9pbnRzLmxlbmd0aC0yLFxuXHRcdHggPSArcG9pbnRzWzBdLFxuXHRcdHkgPSArcG9pbnRzWzFdLFxuXHRcdG5leHRYID0gK3BvaW50c1syXSxcblx0XHRuZXh0WSA9ICtwb2ludHNbM10sXG5cdFx0c2VnbWVudCA9IFt4LCB5LCB4LCB5XSxcblx0XHRkeDIgPSBuZXh0WCAtIHgsXG5cdFx0ZHkyID0gbmV4dFkgLSB5LFxuXHRcdGNsb3NlZCA9IE1hdGguYWJzKHBvaW50c1tsXSAtIHgpIDwgMC4wMDEgJiYgTWF0aC5hYnMocG9pbnRzW2wrMV0gLSB5KSA8IDAuMDAxLFxuXHRcdHByZXZYLCBwcmV2WSwgYW5nbGUsIHNsb3BlLCBpLCBkeDEsIGR4MywgZHkxLCBkeTMsIGQxLCBkMiwgYSwgYiwgYztcblx0aWYgKGlzTmFOKGNvcm5lclRocmVzaG9sZCkpIHtcblx0XHRjb3JuZXJUaHJlc2hvbGQgPSBNYXRoLlBJIC8gMTA7XG5cdH1cblx0aWYgKGNsb3NlZCkgeyAvLyBpZiB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgYXJlIGJhc2ljYWxseSBvbiB0b3Agb2YgZWFjaCBvdGhlciwgY2xvc2UgdGhlIHNlZ21lbnQgYnkgYWRkaW5nIHRoZSAybmQgcG9pbnQgdG8gdGhlIGVuZCwgYW5kIHRoZSAybmQtdG8tbGFzdCBwb2ludCB0byB0aGUgYmVnaW5uaW5nICh3ZSdsbCByZW1vdmUgdGhlbSBhdCB0aGUgZW5kLCBidXQgdGhpcyBhbGxvd3MgdGhlIGN1cnZhdHVyZSB0byBsb29rIHBlcmZlY3QpXG5cdFx0cG9pbnRzLnB1c2gobmV4dFgsIG5leHRZKTtcblx0XHRuZXh0WCA9IHg7XG5cdFx0bmV4dFkgPSB5O1xuXHRcdHggPSBwb2ludHNbbC0yXTtcblx0XHR5ID0gcG9pbnRzW2wtMV07XG5cdFx0cG9pbnRzLnVuc2hpZnQoeCwgeSk7XG5cdFx0bCs9NDtcblx0fVxuXHRjdXJ2aW5lc3MgPSAoY3VydmluZXNzIHx8IGN1cnZpbmVzcyA9PT0gMCkgPyArY3VydmluZXNzIDogMTtcblx0Zm9yIChpID0gMjsgaSA8IGw7IGkrPTIpIHtcblx0XHRwcmV2WCA9IHg7XG5cdFx0cHJldlkgPSB5O1xuXHRcdHggPSBuZXh0WDtcblx0XHR5ID0gbmV4dFk7XG5cdFx0bmV4dFggPSArcG9pbnRzW2krMl07XG5cdFx0bmV4dFkgPSArcG9pbnRzW2krM107XG5cdFx0aWYgKHggPT09IG5leHRYICYmIHkgPT09IG5leHRZKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0ZHgxID0gZHgyO1xuXHRcdGR5MSA9IGR5Mjtcblx0XHRkeDIgPSBuZXh0WCAtIHg7XG5cdFx0ZHkyID0gbmV4dFkgLSB5O1xuXHRcdGR4MyA9IG5leHRYIC0gcHJldlg7XG5cdFx0ZHkzID0gbmV4dFkgLSBwcmV2WTtcblx0XHRhID0gZHgxICogZHgxICsgZHkxICogZHkxO1xuXHRcdGIgPSBkeDIgKiBkeDIgKyBkeTIgKiBkeTI7XG5cdFx0YyA9IGR4MyAqIGR4MyArIGR5MyAqIGR5Mztcblx0XHRhbmdsZSA9IE1hdGguYWNvcyggKGEgKyBiIC0gYykgLyBfc3FydCg0ICogYSAqIGIpICk7IC8vYW5nbGUgYmV0d2VlbiB0aGUgMyBwb2ludHNcblx0XHRkMiA9IChhbmdsZSAvIE1hdGguUEkpICogY3VydmluZXNzOyAvL3RlbXBvcmFyeSBwcmVjYWxjdWxhdGlvbiBmb3Igc3BlZWQgKHJldXNpbmcgZDIgdmFyaWFibGUpXG5cdFx0ZDEgPSBfc3FydChhKSAqIGQyOyAvL3RoZSB0aWdodGVyIHRoZSBhbmdsZSwgdGhlIHNob3J0ZXIgd2UgbWFrZSB0aGUgaGFuZGxlcyBpbiBwcm9wb3J0aW9uLlxuXHRcdGQyICo9IF9zcXJ0KGIpO1xuXHRcdGlmICh4ICE9PSBwcmV2WCB8fCB5ICE9PSBwcmV2WSkge1xuXHRcdFx0aWYgKGFuZ2xlID4gY29ybmVyVGhyZXNob2xkKSB7XG5cdFx0XHRcdHNsb3BlID0gX2F0YW4yKGR5MywgZHgzKTtcblx0XHRcdFx0c2VnbWVudC5wdXNoKFxuXHRcdFx0XHRcdF9yb3VuZCh4IC0gX2NvcyhzbG9wZSkgKiBkMSksICAgLy9maXJzdCBjb250cm9sIHBvaW50XG5cdFx0XHRcdFx0X3JvdW5kKHkgLSBfc2luKHNsb3BlKSAqIGQxKSxcblx0XHRcdFx0XHRfcm91bmQoeCksICAgICAgICAgICAgICAgICAgICAgIC8vYW5jaG9yXG5cdFx0XHRcdFx0X3JvdW5kKHkpLFxuXHRcdFx0XHRcdF9yb3VuZCh4ICsgX2NvcyhzbG9wZSkgKiBkMiksICAgLy9zZWNvbmQgY29udHJvbCBwb2ludFxuXHRcdFx0XHRcdF9yb3VuZCh5ICsgX3NpbihzbG9wZSkgKiBkMilcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNsb3BlID0gX2F0YW4yKGR5MSwgZHgxKTtcblx0XHRcdFx0c2VnbWVudC5wdXNoKFxuXHRcdFx0XHRcdF9yb3VuZCh4IC0gX2NvcyhzbG9wZSkgKiBkMSksICAgLy9maXJzdCBjb250cm9sIHBvaW50XG5cdFx0XHRcdFx0X3JvdW5kKHkgLSBfc2luKHNsb3BlKSAqIGQxKSk7XG5cdFx0XHRcdHNsb3BlID0gX2F0YW4yKGR5MiwgZHgyKTtcblx0XHRcdFx0c2VnbWVudC5wdXNoKFxuXHRcdFx0XHRcdF9yb3VuZCh4KSwgICAgICAgICAgICAgICAgICAgICAgLy9hbmNob3Jcblx0XHRcdFx0XHRfcm91bmQoeSksXG5cdFx0XHRcdFx0X3JvdW5kKHggKyBfY29zKHNsb3BlKSAqIGQyKSwgICAvL3NlY29uZCBjb250cm9sIHBvaW50XG5cdFx0XHRcdFx0X3JvdW5kKHkgKyBfc2luKHNsb3BlKSAqIGQyKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHR4ICE9PSBuZXh0WCB8fCB5ICE9PSBuZXh0WSB8fCBzZWdtZW50Lmxlbmd0aCA8IDQgPyBzZWdtZW50LnB1c2goX3JvdW5kKG5leHRYKSwgX3JvdW5kKG5leHRZKSwgX3JvdW5kKG5leHRYKSwgX3JvdW5kKG5leHRZKSkgOiBzZWdtZW50Lmxlbmd0aCAtPSAyO1xuXHRpZiAoY2xvc2VkKSB7XG5cdFx0c2VnbWVudC5zcGxpY2UoMCwgNik7XG5cdFx0c2VnbWVudC5sZW5ndGggPSBzZWdtZW50Lmxlbmd0aCAtIDY7XG5cdH1cblx0cmV0dXJuIHNlZ21lbnQ7XG59XG5cbi8vcmV0dXJucyB0aGUgc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGFuIHgveSBjb29yZGluYXRlIGFuZCBhIHNlZ21lbnQgYmV0d2VlbiB4MS95MSBhbmQgeDIveTJcbmZ1bmN0aW9uIHBvaW50VG9TZWdEaXN0KHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG5cdGxldCBkeCA9IHgyIC0geDEsXG5cdFx0ZHkgPSB5MiAtIHkxLFxuXHRcdHQ7XG5cdGlmIChkeCB8fCBkeSkge1xuXHRcdHQgPSAoKHggLSB4MSkgKiBkeCArICh5IC0geTEpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHRpZiAodCA+IDEpIHtcblx0XHRcdHgxID0geDI7XG5cdFx0XHR5MSA9IHkyO1xuXHRcdH0gZWxzZSBpZiAodCA+IDApIHtcblx0XHRcdHgxICs9IGR4ICogdDtcblx0XHRcdHkxICs9IGR5ICogdDtcblx0XHR9XG5cdH1cblx0cmV0dXJuICh4IC0geDEpICoqIDIgKyAoeSAtIHkxKSAqKiAyO1xufVxuXG5mdW5jdGlvbiBzaW1wbGlmeVN0ZXAocG9pbnRzLCBmaXJzdCwgbGFzdCwgdG9sZXJhbmNlLCBzaW1wbGlmaWVkKSB7XG5cdGxldCBtYXhTcURpc3QgPSB0b2xlcmFuY2UsXG5cdFx0Zmlyc3RYID0gcG9pbnRzW2ZpcnN0XSxcblx0XHRmaXJzdFkgPSBwb2ludHNbZmlyc3QrMV0sXG5cdFx0bGFzdFggPSBwb2ludHNbbGFzdF0sXG5cdFx0bGFzdFkgPSBwb2ludHNbbGFzdCsxXSxcblx0XHRpbmRleCwgaSwgZDtcblx0Zm9yIChpID0gZmlyc3QgKyAyOyBpIDwgbGFzdDsgaSArPSAyKSB7XG5cdFx0ZCA9IHBvaW50VG9TZWdEaXN0KHBvaW50c1tpXSwgcG9pbnRzW2krMV0sIGZpcnN0WCwgZmlyc3RZLCBsYXN0WCwgbGFzdFkpO1xuXHRcdGlmIChkID4gbWF4U3FEaXN0KSB7XG5cdFx0XHRpbmRleCA9IGk7XG5cdFx0XHRtYXhTcURpc3QgPSBkO1xuXHRcdH1cblx0fVxuXHRpZiAobWF4U3FEaXN0ID4gdG9sZXJhbmNlKSB7XG5cdFx0aW5kZXggLSBmaXJzdCA+IDIgJiYgc2ltcGxpZnlTdGVwKHBvaW50cywgZmlyc3QsIGluZGV4LCB0b2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuXHRcdHNpbXBsaWZpZWQucHVzaChwb2ludHNbaW5kZXhdLCBwb2ludHNbaW5kZXgrMV0pO1xuXHRcdGxhc3QgLSBpbmRleCA+IDIgJiYgc2ltcGxpZnlTdGVwKHBvaW50cywgaW5kZXgsIGxhc3QsIHRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG5cdH1cbn1cblxuLy9wb2ludHMgaXMgYW4gYXJyYXkgb2YgeC95IHZhbHVlcyBsaWtlIFt4LCB5LCB4LCB5LCB4LCB5XVxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsaWZ5UG9pbnRzKHBvaW50cywgdG9sZXJhbmNlKSB7XG5cdGxldCBwcmV2WCA9IHBhcnNlRmxvYXQocG9pbnRzWzBdKSxcblx0XHRwcmV2WSA9IHBhcnNlRmxvYXQocG9pbnRzWzFdKSxcblx0XHR0ZW1wID0gW3ByZXZYLCBwcmV2WV0sXG5cdFx0bCA9IHBvaW50cy5sZW5ndGggLSAyLFxuXHRcdGksIHgsIHksIGR4LCBkeSwgcmVzdWx0LCBsYXN0O1xuXHR0b2xlcmFuY2UgPSAodG9sZXJhbmNlIHx8IDEpICoqIDI7XG5cdGZvciAoaSA9IDI7IGkgPCBsOyBpICs9IDIpIHtcblx0XHR4ID0gcGFyc2VGbG9hdChwb2ludHNbaV0pO1xuXHRcdHkgPSBwYXJzZUZsb2F0KHBvaW50c1tpKzFdKTtcblx0XHRkeCA9IHByZXZYIC0geDtcblx0XHRkeSA9IHByZXZZIC0geTtcblx0XHRpZiAoZHggKiBkeCArIGR5ICogZHkgPiB0b2xlcmFuY2UpIHtcblx0XHRcdHRlbXAucHVzaCh4LCB5KTtcblx0XHRcdHByZXZYID0geDtcblx0XHRcdHByZXZZID0geTtcblx0XHR9XG5cdH1cblx0dGVtcC5wdXNoKHBhcnNlRmxvYXQocG9pbnRzW2xdKSwgcGFyc2VGbG9hdChwb2ludHNbbCsxXSkpO1xuXHRsYXN0ID0gdGVtcC5sZW5ndGggLSAyO1xuXHRyZXN1bHQgPSBbdGVtcFswXSwgdGVtcFsxXV07XG5cdHNpbXBsaWZ5U3RlcCh0ZW1wLCAwLCBsYXN0LCB0b2xlcmFuY2UsIHJlc3VsdCk7XG5cdHJlc3VsdC5wdXNoKHRlbXBbbGFzdF0sIHRlbXBbbGFzdCsxXSk7XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldENsb3Nlc3RQcm9ncmVzc09uQmV6aWVyKGl0ZXJhdGlvbnMsIHB4LCBweSwgc3RhcnQsIGVuZCwgc2xpY2VzLCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcblx0bGV0IGluYyA9IChlbmQgLSBzdGFydCkgLyBzbGljZXMsXG5cdFx0YmVzdCA9IDAsXG5cdFx0dCA9IHN0YXJ0LFxuXHRcdHgsIHksIGQsIGR4LCBkeSwgaW52O1xuXHRfYmVzdERpc3RhbmNlID0gX2xhcmdlTnVtO1xuXHR3aGlsZSAodCA8PSBlbmQpIHtcblx0XHRpbnYgPSAxIC0gdDtcblx0XHR4ID0gaW52ICogaW52ICogaW52ICogeDAgKyAzICogaW52ICogaW52ICogdCAqIHgxICsgMyAqIGludiAqIHQgKiB0ICogeDIgKyB0ICogdCAqIHQgKiB4Mztcblx0XHR5ID0gaW52ICogaW52ICogaW52ICogeTAgKyAzICogaW52ICogaW52ICogdCAqIHkxICsgMyAqIGludiAqIHQgKiB0ICogeTIgKyB0ICogdCAqIHQgKiB5Mztcblx0XHRkeCA9IHggLSBweDtcblx0XHRkeSA9IHkgLSBweTtcblx0XHRkID0gZHggKiBkeCArIGR5ICogZHk7XG5cdFx0aWYgKGQgPCBfYmVzdERpc3RhbmNlKSB7XG5cdFx0XHRfYmVzdERpc3RhbmNlID0gZDtcblx0XHRcdGJlc3QgPSB0O1xuXHRcdH1cblx0XHR0ICs9IGluYztcblx0fVxuXHRyZXR1cm4gKGl0ZXJhdGlvbnMgPiAxKSA/IGdldENsb3Nlc3RQcm9ncmVzc09uQmV6aWVyKGl0ZXJhdGlvbnMgLSAxLCBweCwgcHksIE1hdGgubWF4KGJlc3QgLSBpbmMsIDApLCBNYXRoLm1pbihiZXN0ICsgaW5jLCAxKSwgc2xpY2VzLCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIDogYmVzdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENsb3Nlc3REYXRhKHJhd1BhdGgsIHgsIHksIHNsaWNlcykgeyAvL3JldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGNsb3Nlc3QgaiwgaSwgYW5kIHQgKGogaXMgdGhlIHNlZ21lbnQgaW5kZXgsIGkgaXMgdGhlIGluZGV4IG9mIHRoZSBwb2ludCBpbiB0aGF0IHNlZ21lbnQsIGFuZCB0IGlzIHRoZSB0aW1lL3Byb2dyZXNzIGFsb25nIHRoYXQgYmV6aWVyKVxuXHRsZXQgY2xvc2VzdCA9IHtqOjAsIGk6MCwgdDowfSxcblx0XHRiZXN0RGlzdGFuY2UgPSBfbGFyZ2VOdW0sXG5cdFx0aSwgaiwgdCwgc2VnbWVudDtcblx0Zm9yIChqID0gMDsgaiA8IHJhd1BhdGgubGVuZ3RoOyBqKyspIHtcblx0XHRzZWdtZW50ID0gcmF3UGF0aFtqXTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgc2VnbWVudC5sZW5ndGg7IGkrPTYpIHtcblx0XHRcdHQgPSBnZXRDbG9zZXN0UHJvZ3Jlc3NPbkJlemllcigxLCB4LCB5LCAwLCAxLCBzbGljZXMgfHwgMjAsIHNlZ21lbnRbaV0sIHNlZ21lbnRbaSsxXSwgc2VnbWVudFtpKzJdLCBzZWdtZW50W2krM10sIHNlZ21lbnRbaSs0XSwgc2VnbWVudFtpKzVdLCBzZWdtZW50W2krNl0sIHNlZ21lbnRbaSs3XSk7XG5cdFx0XHRpZiAoYmVzdERpc3RhbmNlID4gX2Jlc3REaXN0YW5jZSkge1xuXHRcdFx0XHRiZXN0RGlzdGFuY2UgPSBfYmVzdERpc3RhbmNlO1xuXHRcdFx0XHRjbG9zZXN0LmogPSBqO1xuXHRcdFx0XHRjbG9zZXN0LmkgPSBpO1xuXHRcdFx0XHRjbG9zZXN0LnQgPSB0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gY2xvc2VzdDtcbn1cblxuLy9zdWJkaXZpZGUgYSBTZWdtZW50IGNsb3Nlc3QgdG8gYSBzcGVjaWZpYyB4LHkgY29vcmRpbmF0ZVxuZXhwb3J0IGZ1bmN0aW9uIHN1YmRpdmlkZVNlZ21lbnROZWFyKHgsIHksIHNlZ21lbnQsIHNsaWNlcywgaXRlcmF0aW9ucykge1xuXHRsZXQgbCA9IHNlZ21lbnQubGVuZ3RoLFxuXHRcdGJlc3REaXN0YW5jZSA9IF9sYXJnZU51bSxcblx0XHRiZXN0VCA9IDAsXG5cdFx0YmVzdFNlZ21lbnRJbmRleCA9IDAsXG5cdFx0dCwgaTtcblx0c2xpY2VzID0gc2xpY2VzIHx8IDIwO1xuXHRpdGVyYXRpb25zID0gaXRlcmF0aW9ucyB8fCAzO1xuXHRmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSA2KSB7XG5cdFx0dCA9IGdldENsb3Nlc3RQcm9ncmVzc09uQmV6aWVyKDEsIHgsIHksIDAsIDEsIHNsaWNlcywgc2VnbWVudFtpXSwgc2VnbWVudFtpKzFdLCBzZWdtZW50W2krMl0sIHNlZ21lbnRbaSszXSwgc2VnbWVudFtpKzRdLCBzZWdtZW50W2krNV0sIHNlZ21lbnRbaSs2XSwgc2VnbWVudFtpKzddKTtcblx0XHRpZiAoYmVzdERpc3RhbmNlID4gX2Jlc3REaXN0YW5jZSkge1xuXHRcdFx0YmVzdERpc3RhbmNlID0gX2Jlc3REaXN0YW5jZTtcblx0XHRcdGJlc3RUID0gdDtcblx0XHRcdGJlc3RTZWdtZW50SW5kZXggPSBpO1xuXHRcdH1cblx0fVxuXHR0ID0gZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIoaXRlcmF0aW9ucywgeCwgeSwgYmVzdFQgLSAwLjA1LCBiZXN0VCArIDAuMDUsIHNsaWNlcywgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4XSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4KzFdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXgrMl0sIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleCszXSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4KzRdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXgrNV0sIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleCs2XSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4KzddKTtcblx0c3ViZGl2aWRlU2VnbWVudChzZWdtZW50LCBiZXN0U2VnbWVudEluZGV4LCB0KTtcblx0cmV0dXJuIGJlc3RTZWdtZW50SW5kZXggKyA2O1xufVxuXG4vKlxuVGFrZXMgYW55IG9mIHRoZSBmb2xsb3dpbmcgYW5kIGNvbnZlcnRzIGl0IHRvIGFuIGFsbCBDdWJpYyBCZXppZXIgU1ZHIGRhdGEgc3RyaW5nOlxuLSBBIDxwYXRoPiBkYXRhIHN0cmluZyBsaWtlIFwiTTAsMCBMMiw0IHYyMCwxNSBIMTAwXCJcbi0gQSBSYXdQYXRoLCBsaWtlIFtbeCwgeSwgeCwgeSwgeCwgeSwgeCwgeV1bW3gsIHksIHgsIHksIHgsIHksIHgsIHldXVxuLSBBIFNlZ21lbnQsIGxpa2UgW3gsIHksIHgsIHksIHgsIHksIHgsIHldXG5cbk5vdGU6IGFsbCBudW1iZXJzIGFyZSByb3VuZGVkIGRvd24gdG8gdGhlIGNsb3Nlc3QgMC4wMDEgdG8gbWluaW1pemUgbWVtb3J5LCBtYXhpbWl6ZSBzcGVlZCwgYW5kIGF2b2lkIG9kZCBudW1iZXJzIGxpa2UgMWUtMTNcbiovXG5leHBvcnQgZnVuY3Rpb24gcmF3UGF0aFRvU3RyaW5nKHJhd1BhdGgpIHtcblx0aWYgKF9pc051bWJlcihyYXdQYXRoWzBdKSkgeyAvL2luIGNhc2UgYSBzZWdtZW50IGlzIHBhc3NlZCBpbiBpbnN0ZWFkXG5cdFx0cmF3UGF0aCA9IFtyYXdQYXRoXTtcblx0fVxuXHRsZXQgcmVzdWx0ID0gXCJcIixcblx0XHRsID0gcmF3UGF0aC5sZW5ndGgsXG5cdFx0c2wsIHMsIGksIHNlZ21lbnQ7XG5cdGZvciAocyA9IDA7IHMgPCBsOyBzKyspIHtcblx0XHRzZWdtZW50ID0gcmF3UGF0aFtzXTtcblx0XHRyZXN1bHQgKz0gXCJNXCIgKyBfcm91bmQoc2VnbWVudFswXSkgKyBcIixcIiArIF9yb3VuZChzZWdtZW50WzFdKSArIFwiIENcIjtcblx0XHRzbCA9IHNlZ21lbnQubGVuZ3RoO1xuXHRcdGZvciAoaSA9IDI7IGkgPCBzbDsgaSsrKSB7XG5cdFx0XHRyZXN1bHQgKz0gX3JvdW5kKHNlZ21lbnRbaSsrXSkgKyBcIixcIiArIF9yb3VuZChzZWdtZW50W2krK10pICsgXCIgXCIgKyBfcm91bmQoc2VnbWVudFtpKytdKSArIFwiLFwiICsgX3JvdW5kKHNlZ21lbnRbaSsrXSkgKyBcIiBcIiArIF9yb3VuZChzZWdtZW50W2krK10pICsgXCIsXCIgKyBfcm91bmQoc2VnbWVudFtpXSkgKyBcIiBcIjtcblx0XHR9XG5cdFx0aWYgKHNlZ21lbnQuY2xvc2VkKSB7XG5cdFx0XHRyZXN1bHQgKz0gXCJ6XCI7XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qXG4vLyB0YWtlcyBhIHNlZ21lbnQgd2l0aCBjb29yZGluYXRlcyBbeCwgeSwgeCwgeSwgLi4uXSBhbmQgY29udmVydHMgdGhlIGNvbnRyb2wgcG9pbnRzIGludG8gYW5nbGVzIGFuZCBsZW5ndGhzIFt4LCB5LCBhbmdsZSwgbGVuZ3RoLCBhbmdsZSwgbGVuZ3RoLCB4LCB5LCBhbmdsZSwgbGVuZ3RoLCAuLi5dIHNvIHRoYXQgaXQgYW5pbWF0ZXMgbW9yZSBjbGVhbmx5IGFuZCBhdm9pZHMgb2RkIGJyZWFrcy9raW5rcy4gRm9yIGV4YW1wbGUsIGlmIHlvdSBhbmltYXRlIGZyb20gMSBvJ2Nsb2NrIHRvIDYgbydjbG9jaywgaXQnZCBqdXN0IGdvIGRpcmVjdGx5L2xpbmVhcmx5IHJhdGhlciB0aGFuIGFyb3VuZC4gU28gdGhlIGxlbmd0aCB3b3VsZCBiZSB2ZXJ5IHNob3J0IGluIHRoZSBtaWRkbGUgb2YgdGhlIHR3ZWVuLlxuZXhwb3J0IGZ1bmN0aW9uIGNwQ29vcmRzVG9BbmdsZXMoc2VnbWVudCwgY29weSkge1xuXHR2YXIgcmVzdWx0ID0gY29weSA/IHNlZ21lbnQuc2xpY2UoMCkgOiBzZWdtZW50LFxuXHRcdHgsIHksIGk7XG5cdGZvciAoaSA9IDA7IGkgPCBzZWdtZW50Lmxlbmd0aDsgaSs9Nikge1xuXHRcdHggPSBzZWdtZW50W2krMl0gLSBzZWdtZW50W2ldO1xuXHRcdHkgPSBzZWdtZW50W2krM10gLSBzZWdtZW50W2krMV07XG5cdFx0cmVzdWx0W2krMl0gPSBNYXRoLmF0YW4yKHksIHgpO1xuXHRcdHJlc3VsdFtpKzNdID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdHggPSBzZWdtZW50W2krNl0gLSBzZWdtZW50W2krNF07XG5cdFx0eSA9IHNlZ21lbnRbaSs3XSAtIHNlZ21lbnRbaSs1XTtcblx0XHRyZXN1bHRbaSs0XSA9IE1hdGguYXRhbjIoeSwgeCk7XG5cdFx0cmVzdWx0W2krNV0gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gdGFrZXMgYSBzZWdtZW50IHRoYXQgd2FzIGNvbnZlcnRlZCB3aXRoIGNwQ29vcmRzVG9BbmdsZXMoKSB0byBoYXZlIGFuZ2xlcyBhbmQgbGVuZ3RocyBpbnN0ZWFkIG9mIGNvb3JkaW5hdGVzIGZvciB0aGUgY29udHJvbCBwb2ludHMsIGFuZCBjb252ZXJ0cyBpdCBCQUNLIGludG8gY29vcmRpbmF0ZXMuXG5leHBvcnQgZnVuY3Rpb24gY3BBbmdsZXNUb0Nvb3JkcyhzZWdtZW50LCBjb3B5KSB7XG5cdHZhciByZXN1bHQgPSBjb3B5ID8gc2VnbWVudC5zbGljZSgwKSA6IHNlZ21lbnQsXG5cdFx0bGVuZ3RoID0gc2VnbWVudC5sZW5ndGgsXG5cdFx0cm5kID0gMTAwMCxcblx0XHRhbmdsZSwgbCwgaSwgajtcblx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSs9Nikge1xuXHRcdGFuZ2xlID0gc2VnbWVudFtpKzJdO1xuXHRcdGwgPSBzZWdtZW50W2krM107IC8vbGVuZ3RoXG5cdFx0cmVzdWx0W2krMl0gPSAoKChzZWdtZW50W2ldICsgTWF0aC5jb3MoYW5nbGUpICogbCkgKiBybmQpIHwgMCkgLyBybmQ7XG5cdFx0cmVzdWx0W2krM10gPSAoKChzZWdtZW50W2krMV0gKyBNYXRoLnNpbihhbmdsZSkgKiBsKSAqIHJuZCkgfCAwKSAvIHJuZDtcblx0XHRhbmdsZSA9IHNlZ21lbnRbaSs0XTtcblx0XHRsID0gc2VnbWVudFtpKzVdOyAvL2xlbmd0aFxuXHRcdHJlc3VsdFtpKzRdID0gKCgoc2VnbWVudFtpKzZdIC0gTWF0aC5jb3MoYW5nbGUpICogbCkgKiBybmQpIHwgMCkgLyBybmQ7XG5cdFx0cmVzdWx0W2krNV0gPSAoKChzZWdtZW50W2krN10gLSBNYXRoLnNpbihhbmdsZSkgKiBsKSAqIHJuZCkgfCAwKSAvIHJuZDtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vL2FkZHMgYW4gXCJpc1Ntb290aFwiIGFycmF5IHRvIGVhY2ggc2VnbWVudCBhbmQgcG9wdWxhdGVzIGl0IHdpdGggYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgaXQncyBzbW9vdGggKHRoZSBjb250cm9sIHBvaW50cyBoYXZlIGJhc2ljYWxseSB0aGUgc2FtZSBzbG9wZSkuIEZvciBhbnkgc21vb3RoIGNvbnRyb2wgcG9pbnRzLCBpdCBjb252ZXJ0cyB0aGUgY29vcmRpbmF0ZXMgaW50byBhbmdsZSAoeCwgaW4gcmFkaWFucykgYW5kIGxlbmd0aCAoeSkgYW5kIHB1dHMgdGhlbSBpbnRvIHRoZSBzYW1lIGluZGV4IHZhbHVlIGluIGEgc21vb3RoRGF0YSBhcnJheS5cbmV4cG9ydCBmdW5jdGlvbiBwb3B1bGF0ZVNtb290aERhdGEocmF3UGF0aCkge1xuXHRsZXQgaiA9IHJhd1BhdGgubGVuZ3RoLFxuXHRcdHNtb290aCwgc2VnbWVudCwgeCwgeSwgeDIsIHkyLCBpLCBsLCBhLCBhMiwgaXNTbW9vdGgsIHNtb290aERhdGE7XG5cdHdoaWxlICgtLWogPiAtMSkge1xuXHRcdHNlZ21lbnQgPSByYXdQYXRoW2pdO1xuXHRcdGlzU21vb3RoID0gc2VnbWVudC5pc1Ntb290aCA9IHNlZ21lbnQuaXNTbW9vdGggfHwgWzAsIDAsIDAsIDBdO1xuXHRcdHNtb290aERhdGEgPSBzZWdtZW50LnNtb290aERhdGEgPSBzZWdtZW50LnNtb290aERhdGEgfHwgWzAsIDAsIDAsIDBdO1xuXHRcdGlzU21vb3RoLmxlbmd0aCA9IDQ7XG5cdFx0bCA9IHNlZ21lbnQubGVuZ3RoIC0gMjtcblx0XHRmb3IgKGkgPSA2OyBpIDwgbDsgaSArPSA2KSB7XG5cdFx0XHR4ID0gc2VnbWVudFtpXSAtIHNlZ21lbnRbaSAtIDJdO1xuXHRcdFx0eSA9IHNlZ21lbnRbaSArIDFdIC0gc2VnbWVudFtpIC0gMV07XG5cdFx0XHR4MiA9IHNlZ21lbnRbaSArIDJdIC0gc2VnbWVudFtpXTtcblx0XHRcdHkyID0gc2VnbWVudFtpICsgM10gLSBzZWdtZW50W2kgKyAxXTtcblx0XHRcdGEgPSBfYXRhbjIoeSwgeCk7XG5cdFx0XHRhMiA9IF9hdGFuMih5MiwgeDIpO1xuXHRcdFx0c21vb3RoID0gKE1hdGguYWJzKGEgLSBhMikgPCAwLjA5KTtcblx0XHRcdGlmIChzbW9vdGgpIHtcblx0XHRcdFx0c21vb3RoRGF0YVtpIC0gMl0gPSBhO1xuXHRcdFx0XHRzbW9vdGhEYXRhW2kgKyAyXSA9IGEyO1xuXHRcdFx0XHRzbW9vdGhEYXRhW2kgLSAxXSA9IF9zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdFx0XHRzbW9vdGhEYXRhW2kgKyAzXSA9IF9zcXJ0KHgyICogeDIgKyB5MiAqIHkyKTtcblx0XHRcdH1cblx0XHRcdGlzU21vb3RoLnB1c2goc21vb3RoLCBzbW9vdGgsIDAsIDAsIHNtb290aCwgc21vb3RoKTtcblx0XHR9XG5cdFx0Ly9pZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnRzIGFyZSBpZGVudGljYWwsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgc21vb3RoIHRyYW5zaXRpb24uIFdlIG11c3QgaGFuZGxlIHRoaXMgYSBiaXQgZGlmZmVyZW50bHkgZHVlIHRvIHRoZWlyIHBvc2l0aW9ucyBpbiB0aGUgYXJyYXkuXG5cdFx0aWYgKHNlZ21lbnRbbF0gPT09IHNlZ21lbnRbMF0gJiYgc2VnbWVudFtsKzFdID09PSBzZWdtZW50WzFdKSB7XG5cdFx0XHR4ID0gc2VnbWVudFswXSAtIHNlZ21lbnRbbC0yXTtcblx0XHRcdHkgPSBzZWdtZW50WzFdIC0gc2VnbWVudFtsLTFdO1xuXHRcdFx0eDIgPSBzZWdtZW50WzJdIC0gc2VnbWVudFswXTtcblx0XHRcdHkyID0gc2VnbWVudFszXSAtIHNlZ21lbnRbMV07XG5cdFx0XHRhID0gX2F0YW4yKHksIHgpO1xuXHRcdFx0YTIgPSBfYXRhbjIoeTIsIHgyKTtcblx0XHRcdGlmIChNYXRoLmFicyhhIC0gYTIpIDwgMC4wOSkge1xuXHRcdFx0XHRzbW9vdGhEYXRhW2wtMl0gPSBhO1xuXHRcdFx0XHRzbW9vdGhEYXRhWzJdID0gYTI7XG5cdFx0XHRcdHNtb290aERhdGFbbC0xXSA9IF9zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdFx0XHRzbW9vdGhEYXRhWzNdID0gX3NxcnQoeDIgKiB4MiArIHkyICogeTIpO1xuXHRcdFx0XHRpc1Ntb290aFtsLTJdID0gaXNTbW9vdGhbbC0xXSA9IHRydWU7IC8vZG9uJ3QgY2hhbmdlIGluZGV4ZXMgMiBhbmQgMyBiZWNhdXNlIHdlJ2xsIHRyaWdnZXIgZXZlcnl0aGluZyBmcm9tIHRoZSBFTkQsIGFuZCB0aGlzIHdpbGwgb3B0aW1pemUgZmlsZSBzaXplIGEgYml0LlxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmF3UGF0aDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb2ludFRvU2NyZWVuKHN2Z0VsZW1lbnQsIHBvaW50KSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgeyAvL2J5IGRlZmF1bHQsIHRha2UgdGhlIGZpcnN0IHNldCBvZiBjb29yZGluYXRlcyBpbiB0aGUgcGF0aCBhcyB0aGUgcG9pbnRcblx0XHRsZXQgcmF3UGF0aCA9IGdldFJhd1BhdGgoc3ZnRWxlbWVudCk7XG5cdFx0cG9pbnQgPSBzdmdFbGVtZW50Lm93bmVyU1ZHRWxlbWVudC5jcmVhdGVTVkdQb2ludCgpO1xuXHRcdHBvaW50LnggPSByYXdQYXRoWzBdWzBdO1xuXHRcdHBvaW50LnkgPSByYXdQYXRoWzBdWzFdO1xuXHR9XG5cdHJldHVybiBwb2ludC5tYXRyaXhUcmFuc2Zvcm0oc3ZnRWxlbWVudC5nZXRTY3JlZW5DVE0oKSk7XG59XG5cbiovIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9CYW5uZXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWEyZmVhMTQ4XCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vQmFubmVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9CYW5uZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vQmFubmVyLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWEyZmVhMTQ4Jmxhbmc9c2Nzc1wiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCJTOlxcXFxDb2RlUHJvamVjdHNcXFxccGVyc29uYWxTaXRlXFxcXG5vZGVfbW9kdWxlc1xcXFx2dWUtaG90LXJlbG9hZC1hcGlcXFxcZGlzdFxcXFxpbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghYXBpLmlzUmVjb3JkZWQoJ2EyZmVhMTQ4JykpIHtcbiAgICAgIGFwaS5jcmVhdGVSZWNvcmQoJ2EyZmVhMTQ4JywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZWxvYWQoJ2EyZmVhMTQ4JywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9CYW5uZXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWEyZmVhMTQ4XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignYTJmZWExNDgnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0Jhbm5lci52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTEudXNlIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQmFubmVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTEudXNlIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQmFubmVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvbG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTIudXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9CYW5uZXIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9YTJmZWExNDgmbGFuZz1zY3NzXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/cnVsZVNldFsxXS5ydWxlc1syXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0Jhbm5lci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YTJmZWExNDhcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vQmlvLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wZmFlNDFmMFwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0Jpby52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vQmlvLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL0Jpby52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0wZmFlNDFmMCZsYW5nPXNjc3NcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiUzpcXFxcQ29kZVByb2plY3RzXFxcXHBlcnNvbmFsU2l0ZVxcXFxub2RlX21vZHVsZXNcXFxcdnVlLWhvdC1yZWxvYWQtYXBpXFxcXGRpc3RcXFxcaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCcwZmFlNDFmMCcpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCcwZmFlNDFmMCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCcwZmFlNDFmMCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vQmlvLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wZmFlNDFmMFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzBmYWU0MWYwJywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9CaW8udnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0Jpby52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0Jpby52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0yLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQmlvLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTBmYWU0MWYwJmxhbmc9c2Nzc1wiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2UhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9CaW8udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTBmYWU0MWYwXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0NvbnRhY3QudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWNmNjU3M2MwXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vQ29udGFjdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vQ29udGFjdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9Db250YWN0LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWNmNjU3M2MwJmxhbmc9c2Nzc1wiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCJTOlxcXFxDb2RlUHJvamVjdHNcXFxccGVyc29uYWxTaXRlXFxcXG5vZGVfbW9kdWxlc1xcXFx2dWUtaG90LXJlbG9hZC1hcGlcXFxcZGlzdFxcXFxpbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghYXBpLmlzUmVjb3JkZWQoJ2NmNjU3M2MwJykpIHtcbiAgICAgIGFwaS5jcmVhdGVSZWNvcmQoJ2NmNjU3M2MwJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZWxvYWQoJ2NmNjU3M2MwJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9Db250YWN0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1jZjY1NzNjMFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJ2NmNjU3M2MwJywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9Db250YWN0LnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2UhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Db250YWN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTEudXNlIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQ29udGFjdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0yLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQ29udGFjdC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1jZjY1NzNjMCZsYW5nPXNjc3NcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTEudXNlIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQ29udGFjdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9Y2Y2NTczYzBcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vR2VvbWV0cnkudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTZkZmFjMGJjXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vR2VvbWV0cnkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL0dlb21ldHJ5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL0dlb21ldHJ5LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTZkZmFjMGJjJmxhbmc9c2Nzc1wiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCJTOlxcXFxDb2RlUHJvamVjdHNcXFxccGVyc29uYWxTaXRlXFxcXG5vZGVfbW9kdWxlc1xcXFx2dWUtaG90LXJlbG9hZC1hcGlcXFxcZGlzdFxcXFxpbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghYXBpLmlzUmVjb3JkZWQoJzZkZmFjMGJjJykpIHtcbiAgICAgIGFwaS5jcmVhdGVSZWNvcmQoJzZkZmFjMGJjJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZWxvYWQoJzZkZmFjMGJjJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9HZW9tZXRyeS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NmRmYWMwYmNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCc2ZGZhYzBiYycsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvR2VvbWV0cnkudnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0dlb21ldHJ5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTEudXNlIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vR2VvbWV0cnkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMi51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0dlb21ldHJ5LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTZkZmFjMGJjJmxhbmc9c2Nzc1wiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2UhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9HZW9tZXRyeS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NmRmYWMwYmNcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vUG9ydGZvbGlvTGlzdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MTNhMGQ3MDZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9Qb3J0Zm9saW9MaXN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9Qb3J0Zm9saW9MaXN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL1BvcnRmb2xpb0xpc3QudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MTNhMGQ3MDYmbGFuZz1zY3NzXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIlM6XFxcXENvZGVQcm9qZWN0c1xcXFxwZXJzb25hbFNpdGVcXFxcbm9kZV9tb2R1bGVzXFxcXHZ1ZS1ob3QtcmVsb2FkLWFwaVxcXFxkaXN0XFxcXGluZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnMTNhMGQ3MDYnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnMTNhMGQ3MDYnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnMTNhMGQ3MDYnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL1BvcnRmb2xpb0xpc3QudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTEzYTBkNzA2XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignMTNhMGQ3MDYnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL1BvcnRmb2xpb0xpc3QudnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1BvcnRmb2xpb0xpc3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2UhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Qb3J0Zm9saW9MaXN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvbG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTIudXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Qb3J0Zm9saW9MaXN0LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTEzYTBkNzA2Jmxhbmc9c2Nzc1wiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2UhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Qb3J0Zm9saW9MaXN0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xM2EwZDcwNlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9Db2RlUGVuQ2FyZC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MWIxMmY4NTVcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9Db2RlUGVuQ2FyZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vQ29kZVBlbkNhcmQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vQ29kZVBlbkNhcmQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MWIxMmY4NTUmbGFuZz1zY3NzXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIlM6XFxcXENvZGVQcm9qZWN0c1xcXFxwZXJzb25hbFNpdGVcXFxcbm9kZV9tb2R1bGVzXFxcXHZ1ZS1ob3QtcmVsb2FkLWFwaVxcXFxkaXN0XFxcXGluZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnMWIxMmY4NTUnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnMWIxMmY4NTUnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnMWIxMmY4NTUnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL0NvZGVQZW5DYXJkLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xYjEyZjg1NVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzFiMTJmODU1Jywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9wb3J0Zm9saW8vQ29kZVBlbkNhcmQudnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0NvZGVQZW5DYXJkLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTEudXNlIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQ29kZVBlbkNhcmQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMi51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0NvZGVQZW5DYXJkLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTFiMTJmODU1Jmxhbmc9c2Nzc1wiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2UhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Db2RlUGVuQ2FyZC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MWIxMmY4NTVcIiIsInZhciByZW5kZXIsIHN0YXRpY1JlbmRlckZuc1xuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9Hc2FwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9Hc2FwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCJTOlxcXFxDb2RlUHJvamVjdHNcXFxccGVyc29uYWxTaXRlXFxcXG5vZGVfbW9kdWxlc1xcXFx2dWUtaG90LXJlbG9hZC1hcGlcXFxcZGlzdFxcXFxpbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghYXBpLmlzUmVjb3JkZWQoJzZkYTJiNmNmJykpIHtcbiAgICAgIGFwaS5jcmVhdGVSZWNvcmQoJzZkYTJiNmNmJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZWxvYWQoJzZkYTJiNmNmJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfVxuICAgIFxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9taXhpbnMvR3NhcC52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTEudXNlIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vR3NhcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0dzYXAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJ2YXIgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnNcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vY3NzVmFyaWFibGVzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9jc3NWYXJpYWJsZXMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIlM6XFxcXENvZGVQcm9qZWN0c1xcXFxwZXJzb25hbFNpdGVcXFxcbm9kZV9tb2R1bGVzXFxcXHZ1ZS1ob3QtcmVsb2FkLWFwaVxcXFxkaXN0XFxcXGluZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnN2FmMTdhNzAnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnN2FmMTdhNzAnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnN2FmMTdhNzAnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL21peGlucy9jc3NWYXJpYWJsZXMudnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2Nzc1ZhcmlhYmxlcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2Nzc1ZhcmlhYmxlcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsInZhciByZW5kZXIsIHN0YXRpY1JlbmRlckZuc1xuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi91dGlscy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vdXRpbHMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIlM6XFxcXENvZGVQcm9qZWN0c1xcXFxwZXJzb25hbFNpdGVcXFxcbm9kZV9tb2R1bGVzXFxcXHZ1ZS1ob3QtcmVsb2FkLWFwaVxcXFxkaXN0XFxcXGluZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnMTIyOTRhNjYnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnMTIyOTRhNjYnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnMTIyOTRhNjYnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL21peGlucy91dGlscy52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTEudXNlIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vdXRpbHMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2UhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi91dGlscy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsIid1c2Ugc3RyaWN0J1xyXG5pbXBvcnQgQXhpb3MgZnJvbSAnYXhpb3MnO1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvdW50cmllc0FsbCh7c3RhdGUsIGNvbW1pdCwgcm9vdFN0YXRlfSwgZGF0YSkge1xyXG5cdHRyeSB7XHJcblx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IEF4aW9zKHtcclxuXHRcdFx0bWV0aG9kOiAnZ2V0JyxcclxuXHRcdFx0dXJsOiAnaHR0cDovL3Jlc3Rjb3VudHJpZXMuZXUvcmVzdC92Mi9hbGwnXHJcblx0XHR9KTtcclxuXHRcdGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5kYXRhKSB7XHJcblx0XHRcdGNvbW1pdCgnVVBEQVRFX0NPVU5UUklFU19BTEwnLCByZXNwb25zZS5kYXRhKTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdGNvbnNvbGUubG9nKCdBUEkgY2FsbCBlcnInLCBlcnIpO1xyXG5cdH1cclxufSIsImltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSAnLi9hY3Rpb25zJztcclxuaW1wb3J0IFZ1ZXggZnJvbSAndnVleCc7XHJcbmltcG9ydCBWdWUgZnJvbSAndnVlJztcclxuXHJcblZ1ZS51c2UoVnVleCk7XHJcblxyXG5jb25zdCBzdG9yZSA9IG5ldyBWdWV4LlN0b3JlKHtcclxuXHRzdGF0ZToge1xyXG5cdFx0Y291bnRyaWVzQWxsOiBudWxsXHJcblx0fSxcclxuXHRtdXRhdGlvbnM6IHtcclxuXHRcdFVQREFURV9DT1VOVFJJRVNfQUxMKHN0YXRlLCBwYXlsb2FkKSB7XHJcblx0XHRcdHN0YXRlLmNvdW50cmllc0FsbCA9IHBheWxvYWQ7XHJcblx0XHR9XHJcblx0fSxcclxuXHRnZXR0ZXJzOiB7XHJcblx0XHRjb3VudHJpZXNBbGw6IHN0YXRlID0+IHN0YXRlLmNvdW50cmllc0FsbFxyXG5cdH0sXHJcblx0YWN0aW9ucyxcclxuXHRtb2R1bGVzOiB7fVxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHN0b3JlOyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL0pvcmRhbktsYWVycy9cIjsiLCIndXNlIHN0cmljdCc7XHJcbmltcG9ydCBWdWUgZnJvbSAndnVlJztcclxuaW1wb3J0IEFwcCBmcm9tICcuL0FwcCc7XHJcbmltcG9ydCBzdG9yZSBmcm9tICdfc3RvcmVfL3N0b3JlJztcclxuXHJcbmltcG9ydCB1dGlscyBmcm9tICdfbWl4aW5zXy91dGlscyc7XHJcbmltcG9ydCBfZ3NhcCBmcm9tICdfbWl4aW5zXy9Hc2FwJztcclxuXHJcblZ1ZS5taXhpbih1dGlscyk7XHJcblZ1ZS5taXhpbihfZ3NhcCk7XHJcbm5ldyBWdWUoe1xyXG5cdGVsOiAnI2NyYXp5YXBwJyxcclxuXHRjb21wb25lbnRzOiB7IEFwcCB9LFxyXG5cdHN0b3JlLFxyXG5cdHJlbmRlcjogZnVuY3Rpb24oY3JlYXRlRWxlbWVudCkge1xyXG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoQXBwKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgc3RvcmU7Il0sIm5hbWVzIjpbIkJpbyIsIkJhbm5lciIsIkdlb21ldHJ5IiwiUG9ydGZvbGlvTGlzdCIsIkNvbnRhY3QiLCJDdXN0b21FYXNlIiwibmFtZSIsImNvbXBvbmVudHMiLCJkYXRhIiwiYmlvQW5pbWF0aW9uIiwiYmlvVHJpZ2dlciIsInRyaWdnZXIiLCJzY3J1YiIsInN0YXJ0IiwiZW5kIiwic25hcCIsInNuYXBUbyIsImR1cmF0aW9uIiwibWluIiwibWF4IiwiZGVsYXkiLCJjb250ZW50IiwiY29udGVudFBsYWNlSG9sZGVyIiwiY29tcHV0ZWQiLCJtb3VudGVkIiwiJGRhdGEiLCJfZ3NhcCIsIlRpbWVsaW5lTWF4Iiwic2Nyb2xsVHJpZ2dlciIsImFkZExhYmVsIiwiZnJvbVRvIiwib3BhY2l0eSIsInJvdGF0aW9uWCIsInNjYWxlIiwieSIsInoiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJlYXNlIiwiY3JlYXRlIiwiaGVpZ2h0IiwibWV0aG9kcyIsInVwZGF0ZUN1cnJlbnRDb250ZW50IiwiY29uc29sZSIsImxvZyIsInNldENvbnRlbnQiLCJ2YWwiLCJkZWJvdW5jZSIsInRocm90dGxlIiwiY3NzVmFyaWFibGVzIiwibWl4aW5zIiwiY2xpY2tIYW5kbGVyIiwidG9nZ2xlTW9kZSIsIndpbmRvd1Jlc2l6ZVNjYWxlSGFuZGxlciIsInNldFNjYWxlIiwibW91c2Vtb3ZlSGFuZGxlciIsIm1vdXNlQXZvaWRBbmltYXRpb25IYW5kbGVyIiwiYWN0aXZlTW9kZSIsImluYWN0aXZlTW9kZSIsImJlZm9yZU1vdW50Iiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImRvY3VtZW50IiwiYm9keSIsInNldEF0dHJpYnV0ZSIsIkFycmF5IiwiZnJvbSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiZWwiLCJjbGFzc0xpc3QiLCJ0b2dnbGUiLCJtYXAiLCJ4IiwiaW5fbWluIiwiaW5fbWF4Iiwib3V0X21pbiIsIm91dF9tYXgiLCJzdHlsZXMiLCJnZXRFbGVtZW50QnlJZCIsInN0eWxlIiwiZ2xvYmFsU2NhbGUiLCJNYXRoIiwiaW5uZXJXaWR0aCIsInNldFByb3BlcnR5IiwiYmlvU2NhbGUiLCJjb25jYXQiLCJldmVudCIsIl90aGlzIiwic3F1YXJlMkRTdHlsZXMiLCJyaWdodFZhbHVlIiwiY2xpZW50WCIsImN1cnZlMUNTdHlsZXMiLCJjdXJ2ZTFDUm90YXRlVmFsdWUiLCJzcXVhcmUyQ1N0eWxlcyIsInNxdWFyZTJDUm90YXRlWFZhbHVlIiwic3F1YXJlMkNUcmFuc2xhdGVZVmFsdWUiLCJpc0ludGVybmV0RXhwbG9yZXIiLCJxdWVyeVNlbGVjdG9yIiwiY2xpZW50WSIsImlubmVySGVpZ2h0Iiwic3F1YXJlMUJTdHlsZXMiLCJzcXVhcmUxQlJvdGF0ZVZhbHVlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2F0Y2giLCJ0b3BPZlBhZ2VUaW1lbGluZSIsInByb3BzIiwidHlwZSIsIkZ1bmN0aW9uIiwicGF0aCIsImN1cnZlRWxlbWVudHMiLCJpZCIsImRlZ3JlZSIsInN0YXJ0RGVncmVlIiwic2V0Q2xpcFBhdGgiLCJmbG9vciIsImNsb3N1cmVQb2ludHMiLCJzbGljZSIsImpvaW4iLCJzZXRDbGlwUGF0aFNWRyIsImFzQ2xpcFBhdGhPbmx5IiwicmVwbGFjZSIsInJhZGl1cyIsInNpbiIsIlBJIiwiY29zIiwiQ29kZVBlbkNhcmQiLCJBbmlhbXRpb25EZW1vIiwiQnJpZ2h0bGFuZCIsInN1bW1hcnlUcmlnZ2VyIiwiT2JqZWN0IiwiY29kZVBlbkNhcmRzIiwibW9kdWxlIiwidXJsIiwiaW1nVXJsIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsInNjcm9sbFRyaWdnZXJzIiwibGlnaHRUcmFjZXJTcXVhcmVzIiwiZGFya1RyYWNlclNxdWFyZXMiLCJ1cEFycm93cyIsImRvd25BcnJvd3MiLCIkcmVmcyIsInNlY3Rpb25zIiwic2VjdGlvbiIsImluZGV4IiwicHVzaCIsImNyZWF0ZVNjcm9sbFRyYWNlckFuaW1hdGlvbiIsImNyZWF0ZUFycm93SW5kaWNhdG9yQW5pbWF0aW9uIiwidGltZWxpbmUiLCJ0byIsImxlbmd0aCIsInRvcEFycm93RWwiLCJib3R0b21BcnJvd0VsIiwiYm90dG9tQXJyb3dUaW1lbGluZSIsInRvcEFycm93VGltZWxpbmUiLCJTdHJpbmciLCJpc0xhc3RNb2R1bGUiLCJCb29sZWFuIiwic2Nyb2xsRGlyZWN0aW9uIiwidG9nZ2xlQWN0aXZDbGFzc0hhbmRsZXIiLCJ0b2dnbGVBY3RpdmVDbGFzcyIsInRsIiwicGF1c2VkIiwiZGVzY3JpcHRpb25IZWlnaHQiLCJjb252ZXJ0UGl4ZWxzVG9SZW0iLCJnZXRDb21wdXRlZFN0eWxlIiwiYmFja2dyb3VuZEhlaWdodCIsImhvdmVyU2NhbGUiLCJ3aWR0aCIsInRvcCIsIiRlbCIsInBsYXkiLCJyZXZlcnNlIiwic2VsZiIsInByb2dyZXNzIiwiYWRkIiwicmVtb3ZlIiwiU2Nyb2xsVHJpZ2dlciIsIkNTU1J1bGVQbHVnaW4iLCJDU1NQbHVnaW4iLCJnc2FwIiwicmVnaXN0ZXJQbHVnaW4iLCJfb2JqZWN0U3ByZWFkIiwiX3Njcm9sbFRyaWdnZXIiLCJfY3VzdG9tRWFzZSIsIl9jc3NSdWxlUGx1Z2luIiwibGlnaHQiLCJkYXJrIiwiYWN0aXZlIiwiaW5hY3RpdmUiLCJpc1NhbWVEb21haW4iLCJzdHlsZVNoZWV0IiwiaHJlZiIsImluZGV4T2YiLCJsb2NhdGlvbiIsIm9yaWdpbiIsImdldENTU0N1c3RvbVByb3BJbmRleCIsInRoYXQiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJzdHlsZVNoZWV0cyIsImZpbHRlciIsInJlZHVjZSIsImZpbmFsQXJyIiwic2hlZXQiLCJjc3NSdWxlcyIsInByb3BWYWxBcnIiLCJydWxlIiwicHJvcE5hbWUiLCJ0cmltIiwiZ2V0UHJvcGVydHlWYWx1ZSIsIl9yZWYiLCJfcmVmMiIsIl9zbGljZWRUb0FycmF5IiwiZ2V0Q1NTQ3VzdG9tUHJvcEluZGV4RmFsbEJhY2siLCJ1YSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIm1zaWUiLCJ0cmlkZW50IiwicnYiLCJjb252ZXJ0UmVtVG9QaXhlbHMiLCJyZW0iLCJwYXJzZUZsb2F0IiwiZG9jdW1lbnRFbGVtZW50IiwiZm9udFNpemUiLCJweCIsImluY2x1ZGVzIiwicGFyc2VJbnQiLCJyZW5kZXIiLCJfdm0iLCJfYyIsIl9zZWxmIiwic3RhdGljQ2xhc3MiLCJhdHRycyIsIl92Iiwib24iLCJfZSIsInN0YXRpY1JlbmRlckZucyIsIl93aXRoU3RyaXBwZWQiLCJjbGljayIsIl9zIiwicmVmIiwidmlld0JveCIsInN0cm9rZSIsImZpbGwiLCJkIiwidGFyZ2V0IiwieG1sbnMiLCJfbSIsInNyYyIsInNyY3NldCIsImFsdCIsIl9sIiwiY3VydmUiLCJrZXkiLCJjYXJkIiwiYXBwbHkiLCJyZWZJbkZvciIsInRhZyIsInN0YXRpY1N0eWxlIiwicmVsIiwiX2dldFByb3BlcnR5IiwiX251bUV4cCIsIl9udW1XaXRoVW5pdEV4cCIsImdldFVuaXQiLCJfaXNTdHJpbmciLCJfaXNVbmRlZmluZWQiLCJfcmVuZGVyQ29tcGxleFN0cmluZyIsIl9yZWxFeHAiLCJfZm9yRWFjaE5hbWUiLCJfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5IiwiX2NvbG9yU3RyaW5nRmlsdGVyIiwiX2NoZWNrUGx1Z2luIiwiX3JlcGxhY2VSYW5kb20iLCJfcGx1Z2lucyIsIkdTQ2FjaGUiLCJQcm9wVHdlZW4iLCJfY29uZmlnIiwiX3RpY2tlciIsIl9yb3VuZCIsIl9taXNzaW5nUGx1Z2luIiwiX2dldFNldHRlciIsIl9nZXRDYWNoZSIsIl9jb2xvckV4cCIsIl9zZXREZWZhdWx0cyIsIl9yZW1vdmVMaW5rZWRMaXN0SXRlbSIsIl93aW4iLCJfZG9jIiwiX2RvY0VsZW1lbnQiLCJfcGx1Z2luSW5pdHRlZCIsIl90ZW1wRGl2IiwiX3RlbXBEaXZTdHlsZXIiLCJfcmVjZW50U2V0dGVyUGx1Z2luIiwiX3dpbmRvd0V4aXN0cyIsIl90cmFuc2Zvcm1Qcm9wcyIsIl9SQUQyREVHIiwiX0RFRzJSQUQiLCJfYXRhbjIiLCJhdGFuMiIsIl9iaWdOdW0iLCJfY2Fwc0V4cCIsIl9ob3Jpem9udGFsRXhwIiwiX2NvbXBsZXhFeHAiLCJfcHJvcGVydHlBbGlhc2VzIiwiYXV0b0FscGhhIiwiYWxwaGEiLCJfcmVuZGVyQ1NTUHJvcCIsInJhdGlvIiwic2V0IiwidCIsInAiLCJyb3VuZCIsInMiLCJjIiwidSIsIl9yZW5kZXJQcm9wV2l0aEVuZCIsImUiLCJfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmciLCJiIiwiX3JlbmRlclJvdW5kZWRDU1NQcm9wIiwidmFsdWUiLCJfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZSIsIl9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kIiwiX3NldHRlckNTU1N0eWxlIiwicHJvcGVydHkiLCJfc2V0dGVyQ1NTUHJvcCIsIl9zZXR0ZXJUcmFuc2Zvcm0iLCJfc2V0dGVyU2NhbGUiLCJzY2FsZVgiLCJzY2FsZVkiLCJfc2V0dGVyU2NhbGVXaXRoUmVuZGVyIiwiY2FjaGUiLCJyZW5kZXJUcmFuc2Zvcm0iLCJfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlciIsIl90cmFuc2Zvcm1Qcm9wIiwiX3RyYW5zZm9ybU9yaWdpblByb3AiLCJfc3VwcG9ydHMzRCIsIl9jcmVhdGVFbGVtZW50IiwibnMiLCJjcmVhdGVFbGVtZW50TlMiLCJjcmVhdGVFbGVtZW50IiwiX2dldENvbXB1dGVkUHJvcGVydHkiLCJza2lwUHJlZml4RmFsbGJhY2siLCJjcyIsInRvTG93ZXJDYXNlIiwiX2NoZWNrUHJvcFByZWZpeCIsIl9wcmVmaXhlcyIsInNwbGl0IiwiZWxlbWVudCIsInByZWZlclByZWZpeCIsImkiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInN1YnN0ciIsIl9pbml0Q29yZSIsImNzc1RleHQiLCJfZ2V0QkJveEhhY2siLCJzd2FwSWZQb3NzaWJsZSIsInN2ZyIsIm93bmVyU1ZHRWxlbWVudCIsImdldEF0dHJpYnV0ZSIsIm9sZFBhcmVudCIsInBhcmVudE5vZGUiLCJvbGRTaWJsaW5nIiwibmV4dFNpYmxpbmciLCJvbGRDU1MiLCJiYm94IiwiYXBwZW5kQ2hpbGQiLCJkaXNwbGF5IiwiZ2V0QkJveCIsIl9nc2FwQkJveCIsImluc2VydEJlZm9yZSIsInJlbW92ZUNoaWxkIiwiX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyIsImF0dHJpYnV0ZXNBcnJheSIsImhhc0F0dHJpYnV0ZSIsIl9nZXRCQm94IiwiYm91bmRzIiwiZXJyb3IiLCJjYWxsIiwiX2lzU1ZHIiwiZ2V0Q1RNIiwiX3JlbW92ZVByb3BlcnR5IiwicmVtb3ZlUHJvcGVydHkiLCJyZW1vdmVBdHRyaWJ1dGUiLCJfYWRkTm9uVHdlZW5pbmdQVCIsInBsdWdpbiIsImJlZ2lubmluZyIsIm9ubHlTZXRBdEVuZCIsInB0IiwiX3B0IiwiX3Byb3BzIiwiX25vbkNvbnZlcnRpYmxlVW5pdHMiLCJkZWciLCJyYWQiLCJ0dXJuIiwiX2NvbnZlcnRUb1VuaXQiLCJ1bml0IiwiY3VyVmFsdWUiLCJjdXJVbml0IiwiaG9yaXpvbnRhbCIsInRlc3QiLCJpc1Jvb3RTVkciLCJ0YWdOYW1lIiwibWVhc3VyZVByb3BlcnR5IiwiYW1vdW50IiwidG9QaXhlbHMiLCJ0b1BlcmNlbnQiLCJwYXJlbnQiLCJpc1NWRyIsInRpbWUiLCJwb3NpdGlvbiIsIl9nZXQiLCJ1bmNhY2hlIiwiX3BhcnNlVHJhbnNmb3JtIiwiX2ZpcnN0VHdvT25seSIsInpPcmlnaW4iLCJfc3BlY2lhbFByb3BzIiwiX3R3ZWVuQ29tcGxleENTU1N0cmluZyIsInByb3AiLCJtYXRjaEluZGV4IiwiYSIsInJlc3VsdCIsInN0YXJ0VmFsdWVzIiwic3RhcnROdW0iLCJjb2xvciIsInN0YXJ0VmFsdWUiLCJlbmRWYWx1ZSIsImVuZE51bSIsImNodW5rIiwiZW5kVW5pdCIsInN0YXJ0VW5pdCIsInJlbGF0aXZlIiwiZW5kVmFsdWVzIiwibWF0Y2giLCJleGVjIiwic3Vic3RyaW5nIiwibGFzdEluZGV4IiwidW5pdHMiLCJfbmV4dCIsIm0iLCJyIiwiX2tleXdvcmRUb1BlcmNlbnQiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJjZW50ZXIiLCJfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyIsIl9yZW5kZXJDbGVhclByb3BzIiwidHdlZW4iLCJfdGltZSIsIl9kdXIiLCJjbGVhclRyYW5zZm9ybXMiLCJjbGVhclByb3BzIiwicHIiLCJfaWRlbnRpdHkyRE1hdHJpeCIsIl9yb3RhdGlvbmFsUHJvcGVydGllcyIsIl9pc051bGxUcmFuc2Zvcm0iLCJfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5IiwibWF0cml4U3RyaW5nIiwiX2dldE1hdHJpeCIsImZvcmNlMkQiLCJtYXRyaXgiLCJ0ZW1wIiwiYWRkZWRUb0RPTSIsInRyYW5zZm9ybSIsImJhc2VWYWwiLCJjb25zb2xpZGF0ZSIsImYiLCJvZmZzZXRQYXJlbnQiLCJfYXBwbHlTVkdPcmlnaW4iLCJvcmlnaW5Jc0Fic29sdXRlIiwic21vb3RoIiwibWF0cml4QXJyYXkiLCJwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbyIsInhPcmlnaW5PbGQiLCJ4T3JpZ2luIiwieU9yaWdpbk9sZCIsInlPcmlnaW4iLCJ4T2Zmc2V0T2xkIiwieE9mZnNldCIsInlPZmZzZXRPbGQiLCJ5T2Zmc2V0IiwidHgiLCJ0eSIsIm9yaWdpblNwbGl0IiwiZGV0ZXJtaW5hbnQiLCJpbnZlcnRlZFNjYWxlWCIsInJvdGF0aW9uIiwicm90YXRpb25ZIiwic2tld1giLCJza2V3WSIsInBlcnNwZWN0aXZlIiwiYW5nbGUiLCJhMTIiLCJhMjIiLCJ0MSIsInQyIiwidDMiLCJhMTMiLCJhMjMiLCJhMzMiLCJhNDIiLCJhNDMiLCJhMzIiLCJzcXJ0IiwiYWJzIiwiZm9yY2VDU1MiLCJ4UGVyY2VudCIsIm9mZnNldFdpZHRoIiwieVBlcmNlbnQiLCJvZmZzZXRIZWlnaHQiLCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZSIsImZvcmNlM0QiLCJfcmVuZGVyU1ZHVHJhbnNmb3JtcyIsIl9yZW5kZXJDU1NUcmFuc2Zvcm1zIiwiX3JlbmRlck5vbjNEVHJhbnNmb3JtcyIsIl9hZGRQeFRyYW5zbGF0ZSIsIl96ZXJvRGVnIiwiX3plcm9QeCIsIl9lbmRQYXJlbnRoZXNpcyIsInRyYW5zZm9ybXMiLCJ1c2UzRCIsImExMSIsImEyMSIsInRhbiIsIl9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuIiwiY2FwIiwiaXNTdHJpbmciLCJjaGFuZ2UiLCJmaW5hbFZhbHVlIiwiZGlyZWN0aW9uIiwiX2Fzc2lnbiIsInNvdXJjZSIsIl9hZGRSYXdUcmFuc2Zvcm1QVHMiLCJzdGFydENhY2hlIiwiZXhjbHVkZSIsImVuZENhY2hlIiwibCIsInNpZGUiLCJ2YXJzIiwiYXJndW1lbnRzIiwiaW5pdCIsInJlZ2lzdGVyIiwidGFyZ2V0VGVzdCIsIm5vZGVUeXBlIiwidGFyZ2V0cyIsInN0YXJ0QXQiLCJzcGVjaWFsUHJvcCIsImlzVHJhbnNmb3JtUmVsYXRlZCIsInRyYW5zZm9ybVByb3BUd2VlbiIsImhhc1ByaW9yaXR5IiwiX3R5cGVvZiIsInBhcnNlVHJhbnNmb3JtIiwic21vb3RoT3JpZ2luIiwiZGVwIiwiYXV0b1JvdW5kIiwiZ2V0IiwiYWxpYXNlcyIsImdldFNldHRlciIsImNvcmUiLCJ1dGlscyIsImNoZWNrUHJlZml4IiwicG9zaXRpb25BbmRTY2FsZSIsIm90aGVycyIsImFsbCIsImRlZmF1bHQiLCJfY29yZUluaXR0ZWQiLCJfZ2V0R1NBUCIsIl9jaGVja1JlZ2lzdGVyIiwid2FybiIsInBsdWdpbnMiLCJjc3MiLCJ2ZXJzaW9uIiwiZGl2IiwiX2dzUHJveHkiLCJzcyIsInByb3RvdHlwZSIsImdldFJ1bGUiLCJzZWxlY3RvciIsInJ1bGVQcm9wIiwicHNldWRvIiwiaiIsImN1clNTIiwic2VsZWN0b3JUZXh0Iiwic3RyaW5nVG9SYXdQYXRoIiwicmF3UGF0aFRvU3RyaW5nIiwidHJhbnNmb3JtUmF3UGF0aCIsInJlZ2lzdGVyRWFzZSIsIl9ib251c1ZhbGlkYXRlZCIsIl9uZWVkc1BhcnNpbmdFeHAiLCJfZmluZE1pbmltdW0iLCJ2YWx1ZXMiLCJfbm9ybWFsaXplIiwib3JpZ2luWSIsInN4Iiwic3kiLCJfYmV6aWVyVG9Qb2ludHMiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIngzIiwieTMiLCJ4NCIsInk0IiwidGhyZXNob2xkIiwicG9pbnRzIiwieDEyIiwieTEyIiwieDIzIiwieTIzIiwieDM0IiwieTM0IiwieDEyMyIsInkxMjMiLCJ4MjM0IiwieTIzNCIsIngxMjM0IiwieTEyMzQiLCJkeCIsImR5IiwiZDIiLCJkMyIsInNwbGljZSIsImNvbmZpZyIsIl9jbGFzc0NhbGxDaGVjayIsInNldERhdGEiLCJfY3JlYXRlQ2xhc3MiLCJjbG9zZXN0IiwibG9va3VwIiwicHJlY2lzaW9uIiwiZmFzdCIsImExIiwiYTIiLCJpbmMiLCJwb2ludCIsInByZXZQb2ludCIsInVuc2hpZnQiLCJzZWdtZW50IiwiY3giLCJjeSIsIm4iLCJueCIsImN1c3RvbSIsImdldFNWR0RhdGEiLCJwYXJzZUVhc2UiLCJ0b0FycmF5Iiwic2xvcGUiLCJwcmV2WCIsInByZXZZIiwiaW52ZXJ0IiwiX2RvY0VsIiwiX2JvZHkiLCJfcm9vdCIsIl9yZXNpemVEZWxheSIsIl9yYWYiLCJfcmVxdWVzdCIsIl90b0FycmF5IiwiX2NsYW1wIiwiX3RpbWUyIiwiX3N5bmNJbnRlcnZhbCIsIl9yZWZyZXNoaW5nIiwiX3BvaW50ZXJJc0Rvd24iLCJfaSIsIl9wcmV2V2lkdGgiLCJfcHJldkhlaWdodCIsIl9hdXRvUmVmcmVzaCIsIl9zb3J0IiwiX3N1cHByZXNzT3ZlcndyaXRlcyIsIl9pZ25vcmVSZXNpemUiLCJfbGltaXRDYWxsYmFja3MiLCJfc3RhcnR1cCIsIl9wcm94aWVzIiwiX3Njcm9sbGVycyIsIl9nZXRUaW1lIiwiRGF0ZSIsIm5vdyIsIl90aW1lMSIsIl9sYXN0U2Nyb2xsVGltZSIsIl9lbmFibGVkIiwiX3Bhc3NUaHJvdWdoIiwidiIsIl9pc1ZpZXdwb3J0IiwiX2dldFByb3h5UHJvcCIsIl9nZXRTY3JvbGxGdW5jIiwic2MiLCJvZmZzZXQiLCJfdmVydGljYWwiLCJfZ2V0Qm91bmRzRnVuYyIsIl93aW5PZmZzZXRzIiwiX2dldEJvdW5kcyIsIl9nZXRTaXplRnVuYyIsInNjcm9sbGVyIiwiaXNWaWV3cG9ydCIsIl9nZXRPZmZzZXRzRnVuYyIsIl9tYXhTY3JvbGwiLCJfcmVmMyIsIl9pdGVyYXRlQXV0b1JlZnJlc2giLCJmdW5jIiwiZXZlbnRzIiwiX2lzRnVuY3Rpb24iLCJfaXNOdW1iZXIiLCJfaXNPYmplY3QiLCJfY2FsbElmRnVuYyIsIl9jb21iaW5lRnVuYyIsImYxIiwiZjIiLCJyZXN1bHQxIiwicmVzdWx0MiIsIl9hYnMiLCJfc2Nyb2xsTGVmdCIsIl9zY3JvbGxUb3AiLCJfbGVmdCIsIl90b3AiLCJfcmlnaHQiLCJfYm90dG9tIiwiX3dpZHRoIiwiX2hlaWdodCIsIl9SaWdodCIsIl9MZWZ0IiwiX1RvcCIsIl9Cb3R0b20iLCJfcGFkZGluZyIsIl9tYXJnaW4iLCJfV2lkdGgiLCJfSGVpZ2h0IiwiX3B4IiwiX2hvcml6b250YWwiLCJwMiIsIm9zIiwib3MyIiwic2Nyb2xsVG8iLCJwYWdlWE9mZnNldCIsIm9wIiwicGFnZVlPZmZzZXQiLCJfZ2V0Q29tcHV0ZWRTdHlsZSIsIl9tYWtlUG9zaXRpb25hYmxlIiwib2JqIiwiZGVmYXVsdHMiLCJ3aXRob3V0VHJhbnNmb3JtcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImtpbGwiLCJfZ2V0U2l6ZSIsIl9yZWY0IiwiX2dldExhYmVsUmF0aW9BcnJheSIsImxhYmVscyIsIl9nZXRDbG9zZXN0TGFiZWwiLCJhbmltYXRpb24iLCJfZ2V0TGFiZWxBdERpcmVjdGlvbiIsInN0Iiwic29ydCIsInBvcCIsIl9tdWx0aUxpc3RlbmVyIiwidHlwZXMiLCJjYWxsYmFjayIsIl9hZGRMaXN0ZW5lciIsInBhc3NpdmUiLCJfcmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiX21hcmtlckRlZmF1bHRzIiwic3RhcnRDb2xvciIsImVuZENvbG9yIiwiaW5kZW50IiwiZm9udFdlaWdodCIsIl9kZWZhdWx0cyIsInRvZ2dsZUFjdGlvbnMiLCJhbnRpY2lwYXRlUGluIiwiX2tleXdvcmRzIiwiX29mZnNldFRvUHgiLCJzaXplIiwiZXFJbmRleCIsIl9jcmVhdGVNYXJrZXIiLCJjb250YWluZXIiLCJfcmVmNSIsIm1hdGNoV2lkdGhFbCIsInVzZUZpeGVkUG9zaXRpb24iLCJpc1Njcm9sbGVyIiwiaXNTdGFydCIsIl9pc1N0YXJ0IiwiaW5uZXJUZXh0IiwiY2hpbGRyZW4iLCJfb2Zmc2V0IiwiX3Bvc2l0aW9uTWFya2VyIiwibWFya2VyIiwiZmxpcHBlZCIsIm9wcG9zaXRlU2lkZSIsIl9pc0ZsaXBwZWQiLCJfdHJpZ2dlcnMiLCJfaWRzIiwiX3N5bmMiLCJfdXBkYXRlQWxsIiwiX29uU2Nyb2xsIiwiX2Rpc3BhdGNoIiwiX29uUmVzaXplIiwiZnVsbHNjcmVlbkVsZW1lbnQiLCJyZXN0YXJ0IiwiX2xpc3RlbmVycyIsIl9lbXB0eUFycmF5IiwiX21lZGlhIiwiX2NyZWF0aW5nTWVkaWEiLCJfbGFzdE1lZGlhVGljayIsIl9vbk1lZGlhQ2hhbmdlIiwidGljayIsInRpY2tlciIsImZyYW1lIiwibWF0Y2hlcyIsIl9yZXZlcnRBbGwiLCJtYXRjaE1lZGlhIiwiX3JldmVydFJlY29yZGVkIiwiX3JlZnJlc2hBbGwiLCJfc29mdFJlZnJlc2giLCJfc2F2ZWRTdHlsZXMiLCJtZWRpYSIsInJldmVydCIsImZvcmNlIiwic2tpcFJldmVydCIsInJlZnJlc2hJbml0cyIsInJlZnJlc2giLCJyZWMiLCJwYXVzZSIsIl9sYXN0U2Nyb2xsIiwiX2RpcmVjdGlvbiIsInJlY29yZFZlbG9jaXR5Iiwic2Nyb2xsIiwidXBkYXRlIiwiX3Byb3BOYW1lc1RvQ29weSIsIl9zdGF0ZVByb3BzIiwiX3N3YXBQaW5PdXQiLCJwaW4iLCJzcGFjZXIiLCJzdGF0ZSIsIl9zZXRTdGF0ZSIsIl9zd2FwUGluSW4iLCJzcGFjZXJTdGF0ZSIsInNwYWNlclN0eWxlIiwicGluU3R5bGUiLCJvdmVyZmxvdyIsImJveFNpemluZyIsImdldENhY2hlIiwiX2dldFN0YXRlIiwiX2NvcHlTdGF0ZSIsIm92ZXJyaWRlIiwib21pdE9mZnNldHMiLCJfcGFyc2VQb3NpdGlvbiIsInNjcm9sbGVyU2l6ZSIsIm1hcmtlclNjcm9sbGVyIiwic2Nyb2xsZXJCb3VuZHMiLCJib3JkZXJXaWR0aCIsInNjcm9sbGVyTWF4Iiwib2Zmc2V0cyIsImxvY2FsT2Zmc2V0IiwiZ2xvYmFsT2Zmc2V0IiwiX3ByZWZpeEV4cCIsIl9yZXBhcmVudCIsIl9zdE9yaWciLCJfZ2V0VHdlZW5DcmVhdG9yIiwiZ2V0U2Nyb2xsIiwibGFzdFNjcm9sbDEiLCJsYXN0U2Nyb2xsMiIsImdldFR3ZWVuIiwiaW5pdGlhbFZhbHVlIiwiY2hhbmdlMSIsImNoYW5nZTIiLCJvbkNvbXBsZXRlIiwibW9kaWZpZXJzIiwiX3ZhcnMiLCJvblVwZGF0ZSIsInRvZ2dsZUNsYXNzIiwib25Ub2dnbGUiLCJvblJlZnJlc2giLCJwaW5TcGFjaW5nIiwiaW52YWxpZGF0ZU9uUmVmcmVzaCIsIm9uU2NydWJDb21wbGV0ZSIsIm9uU25hcENvbXBsZXRlIiwib25jZSIsInBpblJlcGFyZW50IiwiaXNUb2dnbGUiLCJzY3JvbGxlckNhY2hlIiwicGluVHlwZSIsImNhbGxiYWNrcyIsIm9uRW50ZXIiLCJvbkxlYXZlIiwib25FbnRlckJhY2siLCJvbkxlYXZlQmFjayIsIm1hcmtlcnMiLCJvblJlZnJlc2hJbml0IiwiZ2V0U2Nyb2xsZXJTaXplIiwiZ2V0U2Nyb2xsZXJPZmZzZXRzIiwibGFzdFNuYXAiLCJ0d2VlblRvIiwicGluQ2FjaGUiLCJzbmFwRnVuYyIsInNjcm9sbDEiLCJzY3JvbGwyIiwibWFya2VyU3RhcnQiLCJtYXJrZXJFbmQiLCJtYXJrZXJTdGFydFRyaWdnZXIiLCJtYXJrZXJFbmRUcmlnZ2VyIiwibWFya2VyVmFycyIsInBpbk9yaWdpbmFsU3RhdGUiLCJwaW5BY3RpdmVTdGF0ZSIsInBpblN0YXRlIiwicGluR2V0dGVyIiwicGluU2V0dGVyIiwicGluU3RhcnQiLCJwaW5DaGFuZ2UiLCJzcGFjaW5nU3RhcnQiLCJtYXJrZXJTdGFydFNldHRlciIsIm1hcmtlckVuZFNldHRlciIsInNuYXAxIiwic25hcDIiLCJzY3J1YlR3ZWVuIiwic2NydWJTbW9vdGgiLCJzbmFwRHVyQ2xhbXAiLCJzbmFwRGVsYXllZENhbGwiLCJwcmV2UHJvZ3Jlc3MiLCJwcmV2U2Nyb2xsIiwicHJldkFuaW1Qcm9ncmVzcyIsInR3ZWVuU2Nyb2xsIiwibGF6eSIsIl9pbml0dGVkIiwiaW1tZWRpYXRlUmVuZGVyIiwic2Nyb2xsQmVoYXZpb3IiLCJkZWxheWVkQ2FsbCIsImdldFZlbG9jaXR5IiwidG90YWxQcm9ncmVzcyIsInZlbG9jaXR5IiwiY2xhbXAiLCJuYXR1cmFsRW5kIiwiaW5lcnRpYSIsImVuZFNjcm9sbCIsIl9zbmFwIiwib25TdGFydCIsIm9uSW50ZXJydXB0IiwiaXNBY3RpdmUiLCJjbGFzc05hbWUiLCJnZXRQcm9wZXJ0eSIsInF1aWNrU2V0dGVyIiwiZW5hYmxlZCIsInByZXZSZWZyZXNoaW5nIiwiaXNSZXZlcnRlZCIsInNvZnQiLCJpbnZhbGlkYXRlIiwib3RoZXJQaW5PZmZzZXQiLCJwYXJzZWRFbmQiLCJwYXJzZWRFbmRUcmlnZ2VyIiwiZW5kVHJpZ2dlciIsInBhcnNlZFN0YXJ0IiwicGlubmVkQ29udGFpbmVyIiwidHJpZ2dlckluZGV4IiwiaXNWZXJ0aWNhbCIsImN1clRyaWdnZXIiLCJjdXJQaW4iLCJvcHBvc2l0ZVNjcm9sbCIsImluaXR0ZWQiLCJyZXZlcnRlZFBpbnMiLCJfcGluUHVzaCIsImNlaWwiLCJfcGluT2Zmc2V0IiwicmVzZXQiLCJjbGlwcGVkIiwid2FzQWN0aXZlIiwidG9nZ2xlU3RhdGUiLCJhY3Rpb24iLCJzdGF0ZUNoYW5nZWQiLCJ0b2dnbGVkIiwiZW5hYmxlIiwiZGlzYWJsZSIsImFsbG93QW5pbWF0aW9uIiwic3VwcHJlc3NPdmVyd3JpdGVzIiwiZ2xvYmFscyIsInNldFRpbWVvdXQiLCJib2R5U3R5bGUiLCJib3JkZXIiLCJib3JkZXJUb3AiLCJzZXRJbnRlcnZhbCIsInciLCJoIiwiaGlkZGVuIiwibGltaXRDYWxsYmFja3MiLCJtcyIsInN5bmNJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJhdXRvUmVmcmVzaEV2ZW50cyIsInNjcm9sbGVyUHJveHkiLCJtcSIsImFkZExpc3RlbmVyIiwiY2xlYXJNYXRjaE1lZGlhIiwicXVlcnkiLCJzYXZlU3R5bGVzIiwic2FmZSIsIm1heFNjcm9sbCIsImdldFNjcm9sbEZ1bmMiLCJnZXRCeUlkIiwiZ2V0QWxsIiwiaXNTY3JvbGxpbmciLCJiYXRjaCIsInZhcnNDb3B5IiwiaW50ZXJ2YWwiLCJiYXRjaE1heCIsInByb3h5Q2FsbGJhY2siLCJlbGVtZW50cyIsInRyaWdnZXJzIiwicmVmcmVzaFByaW9yaXR5IiwiYXV0b1NsZWVwIiwibnVsbFRhcmdldFdhcm4iLCJsaW5lSGVpZ2h0Iiwib3ZlcndyaXRlIiwiX3RpbnlOdW0iLCJfMlBJIiwiX0hBTEZfUEkiLCJfZ3NJRCIsIl9zcXJ0IiwiX2NvcyIsIl9zaW4iLCJfaXNOb3RGYWxzZSIsIl9pc0Z1bmNPclN0cmluZyIsIl9pc1R5cGVkQXJyYXkiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsIl9pc0FycmF5IiwiaXNBcnJheSIsIl9zdHJpY3ROdW1FeHAiLCJfY29tcGxleFN0cmluZ051bUV4cCIsIl9kZWxpbWl0ZWRWYWx1ZUV4cCIsIl91bml0RXhwIiwiX2dsb2JhbFRpbWVsaW5lIiwiX2dsb2JhbHMiLCJfaW5zdGFsbFNjb3BlIiwiX2NvcmVSZWFkeSIsIl9pbnN0YWxsIiwic2NvcGUiLCJfbWVyZ2UiLCJfd2FybiIsIm1lc3NhZ2UiLCJzdXBwcmVzcyIsIl9hZGRHbG9iYWwiLCJfZW1wdHlGdW5jIiwiX3Jlc2VydmVkUHJvcHMiLCJfbGF6eVR3ZWVucyIsIl9sYXp5TG9va3VwIiwiX2xhc3RSZW5kZXJlZEZyYW1lIiwiX2VmZmVjdHMiLCJfbmV4dEdDRnJhbWUiLCJfaGFybmVzc1BsdWdpbnMiLCJfY2FsbGJhY2tOYW1lcyIsIl9oYXJuZXNzIiwiaGFybmVzc1BsdWdpbiIsImhhcm5lc3MiLCJuYW1lcyIsIl9hcnJheUNvbnRhaW5zQW55IiwidG9TZWFyY2giLCJ0b0ZpbmQiLCJfbGF6eVJlbmRlciIsIl9sYXp5IiwiX2xhenlTYWZlUmVuZGVyIiwic3VwcHJlc3NFdmVudHMiLCJfbnVtZXJpY0lmUG9zc2libGUiLCJfc2V0S2V5ZnJhbWVEZWZhdWx0cyIsImJhc2UiLCJ0b01lcmdlIiwiX21lcmdlRGVlcCIsIl9jb3B5RXhjbHVkaW5nIiwiZXhjbHVkaW5nIiwiY29weSIsIl9pbmhlcml0RGVmYXVsdHMiLCJrZXlmcmFtZXMiLCJpbmhlcml0IiwiX2RwIiwiX2FycmF5c01hdGNoIiwiX2FkZExpbmtlZExpc3RJdGVtIiwiY2hpbGQiLCJmaXJzdFByb3AiLCJ1bmRlZmluZWQiLCJsYXN0UHJvcCIsInNvcnRCeSIsInByZXYiLCJfcHJldiIsIm5leHQiLCJfcmVtb3ZlRnJvbVBhcmVudCIsIm9ubHlJZlBhcmVudEhhc0F1dG9SZW1vdmUiLCJhdXRvUmVtb3ZlQ2hpbGRyZW4iLCJfYWN0IiwiX3VuY2FjaGUiLCJfZW5kIiwiX3N0YXJ0IiwiX2RpcnR5IiwiX3JlY2FjaGVBbmNlc3RvcnMiLCJ0b3RhbER1cmF0aW9uIiwiX2hhc05vUGF1c2VkQW5jZXN0b3JzIiwiX3RzIiwiX2VsYXBzZWRDeWNsZUR1cmF0aW9uIiwiX3JlcGVhdCIsIl9hbmltYXRpb25DeWNsZSIsIl90VGltZSIsIl9yRGVsYXkiLCJ0VGltZSIsImN5Y2xlRHVyYXRpb24iLCJ3aG9sZSIsIl9wYXJlbnRUb0NoaWxkVG90YWxUaW1lIiwicGFyZW50VGltZSIsIl90RHVyIiwiX3NldEVuZCIsIl9ydHMiLCJfYWxpZ25QbGF5aGVhZCIsInRvdGFsVGltZSIsInNtb290aENoaWxkVGltaW5nIiwiX3Bvc3RBZGRDaGVja3MiLCJyYXdUaW1lIiwiX3pUaW1lIiwiX2FkZFRvVGltZWxpbmUiLCJza2lwQ2hlY2tzIiwiX2RlbGF5IiwidGltZVNjYWxlIiwiX2lzRnJvbU9yRnJvbVN0YXJ0IiwiX3JlY2VudCIsIl9hdHRlbXB0SW5pdFR3ZWVuIiwiX2luaXRUd2VlbiIsIl9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQiLCJfbG9jayIsIl9yZW5kZXJaZXJvRHVyYXRpb25Ud2VlbiIsInByZXZSYXRpbyIsInJlcGVhdERlbGF5IiwiaXRlcmF0aW9uIiwicHJldkl0ZXJhdGlvbiIsIl95b3lvIiwicmVwZWF0UmVmcmVzaCIsIl9mcm9tIiwiX3N0YXJ0QXQiLCJfb25VcGRhdGUiLCJfY2FsbGJhY2siLCJfcHJvbSIsIl9maW5kTmV4dFBhdXNlVHdlZW4iLCJwcmV2VGltZSIsIl9maXJzdCIsIl9sYXN0IiwiX3NldER1cmF0aW9uIiwic2tpcFVuY2FjaGUiLCJsZWF2ZVBsYXloZWFkIiwicmVwZWF0IiwiZHVyIiwiX29uVXBkYXRlVG90YWxEdXJhdGlvbiIsIlRpbWVsaW5lIiwiX3plcm9Qb3NpdGlvbiIsImVuZFRpbWUiLCJwZXJjZW50QW5pbWF0aW9uIiwicmVjZW50IiwiY2xpcHBlZER1cmF0aW9uIiwiaXNQZXJjZW50IiwiaXNOYU4iLCJfY3JlYXRlVHdlZW5UeXBlIiwicGFyYW1zIiwiaXNMZWdhY3kiLCJ2YXJzSW5kZXgiLCJpclZhcnMiLCJydW5CYWNrd2FyZHMiLCJUd2VlbiIsIl9jb25kaXRpb25hbFJldHVybiIsIl9zbGljZSIsIl9pc0FycmF5TGlrZSIsIm5vbkVtcHR5IiwiX2ZsYXR0ZW4iLCJhciIsImxlYXZlU3RyaW5ncyIsImFjY3VtdWxhdG9yIiwiX3dha2UiLCJjdXJyZW50IiwibmF0aXZlRWxlbWVudCIsInNodWZmbGUiLCJyYW5kb20iLCJkaXN0cmlidXRlIiwiZWFjaCIsIl9wYXJzZUVhc2UiLCJpc0RlY2ltYWwiLCJyYXRpb3MiLCJheGlzIiwicmF0aW9YIiwicmF0aW9ZIiwiZWRnZXMiLCJkaXN0YW5jZXMiLCJvcmlnaW5YIiwid3JhcEF0IiwiZ3JpZCIsIl9pbnZlcnRFYXNlIiwiX3JvdW5kTW9kaWZpZXIiLCJwb3ciLCJyYXciLCJpczJEIiwiaW5jcmVtZW50Iiwicm91bmRpbmdJbmNyZW1lbnQiLCJyZXR1cm5GdW5jdGlvbiIsInBpcGUiLCJfbGVuIiwiZnVuY3Rpb25zIiwiX2tleSIsInVuaXRpemUiLCJub3JtYWxpemUiLCJtYXBSYW5nZSIsIl93cmFwQXJyYXkiLCJ3cmFwcGVyIiwid3JhcCIsInJhbmdlIiwid3JhcFlveW8iLCJ0b3RhbCIsIm51bXMiLCJpbk1pbiIsImluTWF4Iiwib3V0TWluIiwib3V0TWF4IiwiaW5SYW5nZSIsIm91dFJhbmdlIiwiaW50ZXJwb2xhdGUiLCJtdXRhdGUiLCJtYXN0ZXIiLCJpbnRlcnBvbGF0b3JzIiwiaWwiLCJfYWRkUHJvcFR3ZWVuIiwiX3JlbmRlclByb3BUd2VlbnMiLCJfZ2V0TGFiZWxJbkRpcmVjdGlvbiIsImZyb21UaW1lIiwiYmFja3dhcmQiLCJkaXN0YW5jZSIsImxhYmVsIiwiZXhlY3V0ZUxhenlGaXJzdCIsImNhbGxiYWNrU2NvcGUiLCJfaW50ZXJydXB0IiwiX3F1aWNrVHdlZW4iLCJfY3JlYXRlUGx1Z2luIiwiaXNGdW5jIiwiUGx1Z2luIiwiaW5zdGFuY2VEZWZhdWx0cyIsIl9raWxsUHJvcFR3ZWVuc09mIiwibW9kaWZpZXIiLCJfYWRkUGx1Z2luTW9kaWZpZXIiLCJyYXdWYXJzIiwic3RhdGljcyIsIl8yNTUiLCJfY29sb3JMb29rdXAiLCJhcXVhIiwibGltZSIsInNpbHZlciIsImJsYWNrIiwibWFyb29uIiwidGVhbCIsImJsdWUiLCJuYXZ5Iiwid2hpdGUiLCJvbGl2ZSIsInllbGxvdyIsIm9yYW5nZSIsImdyYXkiLCJwdXJwbGUiLCJncmVlbiIsInJlZCIsInBpbmsiLCJjeWFuIiwidHJhbnNwYXJlbnQiLCJfaHVlIiwibTEiLCJtMiIsInNwbGl0Q29sb3IiLCJ0b0hTTCIsImZvcmNlQWxwaGEiLCJnIiwid2FzSFNMIiwiTnVtYmVyIiwiX2NvbG9yT3JkZXJEYXRhIiwiX2Zvcm1hdENvbG9ycyIsIm9yZGVyTWF0Y2hEYXRhIiwiY29sb3JzIiwic2hlbGwiLCJzaGlmdCIsIlJlZ0V4cCIsIl9oc2xFeHAiLCJjb21iaW5lZCIsIl90aWNrZXJBY3RpdmUiLCJfbGFnVGhyZXNob2xkIiwiX2FkanVzdGVkTGFnIiwiX3N0YXJ0VGltZSIsIl9sYXN0VXBkYXRlIiwiX2dhcCIsIl9uZXh0VGltZSIsIl9pZCIsIl9yZXEiLCJfZGVsdGEiLCJfdGljayIsImVsYXBzZWQiLCJtYW51YWwiLCJvdmVybGFwIiwiZGlzcGF0Y2giLCJkZWx0YVJhdGlvIiwiZnBzIiwid2FrZSIsImdzYXBWZXJzaW9ucyIsIkdyZWVuU29ja0dsb2JhbHMiLCJzbGVlcCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY2xlYXJUaW1lb3V0IiwibGFnU21vb3RoaW5nIiwiYWRqdXN0ZWRMYWciLCJfZWFzZU1hcCIsIl9jdXN0b21FYXNlRXhwIiwiX3F1b3Rlc0V4cCIsIl9wYXJzZU9iamVjdEluU3RyaW5nIiwicGFyc2VkVmFsIiwibGFzdEluZGV4T2YiLCJfdmFsdWVJblBhcmVudGhlc2VzIiwib3BlbiIsImNsb3NlIiwibmVzdGVkIiwiX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nIiwiX0NFIiwiX3Byb3BhZ2F0ZVlveW9FYXNlIiwiaXNZb3lvIiwieW95b0Vhc2UiLCJfZWFzZSIsIl95RWFzZSIsImRlZmF1bHRFYXNlIiwiX2luc2VydEVhc2UiLCJlYXNlSW4iLCJlYXNlT3V0IiwiZWFzZUluT3V0IiwibG93ZXJjYXNlTmFtZSIsIl9lYXNlSW5PdXRGcm9tT3V0IiwiX2NvbmZpZ0VsYXN0aWMiLCJhbXBsaXR1ZGUiLCJwZXJpb2QiLCJwMSIsInAzIiwiYXNpbiIsIl9jb25maWdCYWNrIiwib3ZlcnNob290IiwicG93ZXIiLCJMaW5lYXIiLCJlYXNlTm9uZSIsIm5vbmUiLCJuMSIsIm4yIiwibjMiLCJTdGVwcGVkRWFzZSIsInN0ZXBzIiwiaW1tZWRpYXRlU3RhcnQiLCJBbmltYXRpb24iLCJJbmZpbml0eSIsInlveW8iLCJzdGFydFRpbWUiLCJfcHRMb29rdXAiLCJfcFRpbWUiLCJfcHMiLCJpbmNsdWRlUmVwZWF0cyIsIndyYXBSZXBlYXRzIiwiZ2xvYmFsVGltZSIsInNlZWsiLCJpbmNsdWRlRGVsYXkiLCJyZXZlcnNlZCIsImF0VGltZSIsInJlc3VtZSIsImV2ZW50Q2FsbGJhY2siLCJ0aGVuIiwib25GdWxmaWxsZWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsIl9yZXNvbHZlIiwiX3RoZW4iLCJfQW5pbWF0aW9uIiwiX2NhbGxTdXBlciIsInNvcnRDaGlsZHJlbiIsIl9pbmhlcml0cyIsImZyb21WYXJzIiwidG9WYXJzIiwic3RhZ2dlclRvIiwic3RhZ2dlciIsIm9uQ29tcGxldGVBbGwiLCJvbkNvbXBsZXRlQWxsUGFyYW1zIiwib25Db21wbGV0ZVBhcmFtcyIsInN0YWdnZXJGcm9tIiwic3RhZ2dlckZyb21UbyIsInREdXIiLCJjcm9zc2luZ1N0YXJ0IiwicHJldlBhdXNlZCIsInBhdXNlVHdlZW4iLCJwcmV2U3RhcnQiLCJyZXdpbmRpbmciLCJkb2VzV3JhcCIsIm9uUmVwZWF0IiwiX2hhc1BhdXNlIiwiX2ZvcmNpbmciLCJhZGp1c3RlZFRpbWUiLCJfdGhpczIiLCJnZXRDaGlsZHJlbiIsInR3ZWVucyIsInRpbWVsaW5lcyIsImlnbm9yZUJlZm9yZVRpbWUiLCJhbmltYXRpb25zIiwicmVtb3ZlTGFiZWwiLCJraWxsVHdlZW5zT2YiLCJfc3VwZXJQcm9wR2V0IiwiYWRkUGF1c2UiLCJyZW1vdmVQYXVzZSIsIm9ubHlBY3RpdmUiLCJnZXRUd2VlbnNPZiIsIl9vdmVyd3JpdGluZ1R3ZWVuIiwicGFyc2VkVGFyZ2V0cyIsImlzR2xvYmFsVGltZSIsIl90YXJnZXRzIiwib25TdGFydFBhcmFtcyIsInR3ZWVuRnJvbVRvIiwiZnJvbVBvc2l0aW9uIiwidG9Qb3NpdGlvbiIsIm5leHRMYWJlbCIsImFmdGVyVGltZSIsInByZXZpb3VzTGFiZWwiLCJiZWZvcmVUaW1lIiwiY3VycmVudExhYmVsIiwic2hpZnRDaGlsZHJlbiIsImFkanVzdExhYmVscyIsImNsZWFyIiwiaW5jbHVkZUxhYmVscyIsInVwZGF0ZVJvb3QiLCJfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2VlbiIsInNldHRlciIsInN0cmluZ0ZpbHRlciIsImZ1bmNQYXJhbSIsInN0YXJ0TnVtcyIsImhhc1JhbmRvbSIsImZwIiwiY3VycmVudFZhbHVlIiwiX3NldHRlclBsYWluIiwiX3NldHRlckZ1bmNXaXRoUGFyYW0iLCJfc2V0dGVyRnVuYyIsIl9yZW5kZXJCb29sZWFuIiwiX3JlbmRlclBsYWluIiwiX3Byb2Nlc3NWYXJzIiwiX3BhcnNlRnVuY09yU3RyaW5nIiwicHRMb29rdXAiLCJwcmlvcml0eSIsIm9uVXBkYXRlUGFyYW1zIiwiYXV0b1JldmVydCIsInByZXZTdGFydEF0IiwiZnVsbFRhcmdldHMiLCJhdXRvT3ZlcndyaXRlIiwiX292ZXJ3cml0ZSIsImNsZWFuVmFycyIsImdzRGF0YSIsImhhcm5lc3NWYXJzIiwib3ZlcndyaXR0ZW4iLCJfb3AiLCJfb25Jbml0IiwiX2FkZEFsaWFzZXNUb1ZhcnMiLCJwcm9wZXJ0eUFsaWFzZXMiLCJfc3RhZ2dlclR3ZWVuUHJvcHMiLCJfc3RhZ2dlclByb3BzVG9Ta2lwIiwiX0FuaW1hdGlvbjIiLCJza2lwSW5oZXJpdCIsIl90aGlzMyIsIl90aGlzMyR2YXJzIiwiY3VyVGFyZ2V0Iiwic3RhZ2dlckZ1bmMiLCJzdGFnZ2VyVmFyc1RvTWVyZ2UiLCJraWxsaW5nVGFyZ2V0cyIsInByb3BUd2Vlbkxvb2t1cCIsImZpcnN0UFQiLCJvdmVyd3JpdHRlblByb3BzIiwiY3VyTG9va3VwIiwiY3VyT3ZlcndyaXRlUHJvcHMiLCJvblJldmVyc2VDb21wbGV0ZSIsIm9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zIiwiX3NldHRlckF0dHJpYnV0ZSIsImhhc05vbkRlcGVuZGVudFJlbWFpbmluZyIsIl9zZXR0ZXJXaXRoTW9kaWZpZXIiLCJtU2V0IiwibXQiLCJwdDIiLCJmaXJzdCIsImxhc3QiLCJyZW5kZXJlciIsIlR3ZWVuTWF4IiwiVHdlZW5MaXRlIiwiVGltZWxpbmVMaXRlIiwiX2xlbjIiLCJhcmdzIiwiX2tleTIiLCJnZXR0ZXIiLCJmb3JtYXQiLCJzZXR0ZXJzIiwiaXNUd2VlbmluZyIsInJlZ2lzdGVyRWZmZWN0IiwiZWZmZWN0IiwiZXh0ZW5kVGltZWxpbmUiLCJwbHVnaW5OYW1lIiwiZXhwb3J0Um9vdCIsImluY2x1ZGVEZWxheWVkQ2FsbHMiLCJpbnN0YWxsIiwiZWZmZWN0cyIsImdsb2JhbFRpbWVsaW5lIiwiX2dldFBsdWdpblByb3BUd2VlbiIsIl9hZGRNb2RpZmllcnMiLCJfYnVpbGRNb2RpZmllclBsdWdpbiIsIlBvd2VyMCIsIlBvd2VyMSIsIlBvd2VyMiIsIlBvd2VyMyIsIlBvd2VyNCIsIlF1YWQiLCJDdWJpYyIsIlF1YXJ0IiwiUXVpbnQiLCJTdHJvbmciLCJFbGFzdGljIiwiQmFjayIsIkJvdW5jZSIsIlNpbmUiLCJFeHBvIiwiQ2lyYyIsImdzYXBXaXRoQ1NTIiwiVHdlZW5NYXhXaXRoQ1NTIiwiX3N2Z1BhdGhFeHAiLCJfbnVtYmVyc0V4cCIsIl9zY2llbnRpZmljIiwiX3NlbGVjdG9yRXhwIiwiX2xhcmdlTnVtIiwiX3RlbXAiLCJfdGVtcDIiLCJfcm91bmRpbmdOdW0iLCJfd3JhcFByb2dyZXNzIiwiX3JvdW5kUHJlY2lzZSIsIl9zcGxpdFNlZ21lbnQiLCJyYXdQYXRoIiwic2VnSW5kZXgiLCJzdWJkaXZpZGVTZWdtZW50IiwiX3JldmVyc2VSYXdQYXRoIiwic2tpcE91dGVyIiwicmV2ZXJzZVNlZ21lbnQiLCJfY29weU1ldGFEYXRhIiwidG90YWxMZW5ndGgiLCJzYW1wbGVzIiwibWluTGVuZ3RoIiwicmVzb2x1dGlvbiIsInRvdGFsUG9pbnRzIiwiX2FwcGVuZE9yTWVyZ2UiLCJwcmV2U2VnIiwiX2Jlc3REaXN0YW5jZSIsImdldFJhd1BhdGgiLCJfZ3NQYXRoIiwiY29weVJhd1BhdGgiLCJfY3JlYXRlUGF0aCIsImlnbm9yZSIsImF0dHIiLCJhdHRyaWJ1dGVzIiwibm9kZU5hbWUiLCJzZXRBdHRyaWJ1dGVOUyIsIm5vZGVWYWx1ZSIsIl90eXBlQXR0cnMiLCJyZWN0IiwiY2lyY2xlIiwiZWxsaXBzZSIsImxpbmUiLCJfYXR0clRvT2JqIiwiY29udmVydFRvUGF0aCIsInN3YXAiLCJjaXJjIiwicnkiLCJyY2lyYyIsInJ5Y2lyYyIsIng1IiwieDYiLCJ5NSIsInk2IiwicngiLCJfZ3NSYXdQYXRoIiwiZ2V0Um90YXRpb25BdFByb2dyZXNzIiwiZ2V0UHJvZ3Jlc3NEYXRhIiwiZ2V0Um90YXRpb25BdEJlemllclQiLCJzbGljZVJhd1BhdGgiLCJsb29wcyIsImNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyIsImVTZWciLCJzU2VnIiwiZVNlZ0luZGV4Iiwic1NlZ0luZGV4IiwiZWkiLCJzaSIsInNhbWVTZWdtZW50Iiwic2FtZUJlemllciIsIndyYXBzQmVoaW5kIiwic1NoaWZ0IiwiZVNoaWZ0IiwidG90YWxTZWdtZW50cyIsIm1lYXN1cmVTZWdtZW50Iiwic3RhcnRJbmRleCIsImJlemllclF0eSIsImVuZEluZGV4Iiwic2FtcGxlc0luZGV4IiwicHJldkxlbmd0aCIsInhkIiwieGQxIiwieWQiLCJ5ZDEiLCJpbnYiLCJsZW5ndGhJbmRleCIsInNlZ0xlbmd0aCIsInBhdGhMZW5ndGgiLCJheCIsImF5IiwiY3AxeCIsImNwMXkiLCJjcDJ4IiwiY3AyeSIsImJ4IiwiYnkiLCJ4MWEiLCJ5MWEiLCJ4MmEiLCJ5MmEiLCJkZWNvcmF0ZWUiLCJwdXNoVG9OZXh0SWZBdEVuZCIsImdldFBvc2l0aW9uT25QYXRoIiwiaW5jbHVkZUFuZ2xlIiwiYXJjVG9TZWdtZW50IiwibGFzdFgiLCJsYXN0WSIsImxhcmdlQXJjRmxhZyIsInN3ZWVwRmxhZyIsImFuZ2xlUmFkIiwiY29zQW5nbGUiLCJzaW5BbmdsZSIsIlRXT1BJIiwiZHgyIiwiZHkyIiwieDFfc3EiLCJ5MV9zcSIsInJhZGlpQ2hlY2siLCJyeF9zcSIsInJ5X3NxIiwic3EiLCJjb2VmIiwiY3gxIiwiY3kxIiwic3gyIiwic3kyIiwidXgiLCJ1eSIsInZ4IiwidnkiLCJhbmdsZVN0YXJ0IiwiYWNvcyIsImFuZ2xlRXh0ZW50Iiwic2VnbWVudHMiLCJhbmdsZUluY3JlbWVudCIsImNvbnRyb2xMZW5ndGgiLCJtYSIsIm1iIiwibWMiLCJtZCIsInJlbGF0aXZlWCIsInJlbGF0aXZlWSIsInR3b1RoaXJkcyIsImVycm9yTWVzc2FnZSIsImNvbW1hbmQiLCJpc1JlbGF0aXZlIiwic3RhcnRYIiwic3RhcnRZIiwiZGlmWCIsImRpZlkiLCJiZXppZXJzIiwicHJldkNvbW1hbmQiLCJmbGFnMSIsImZsYWcyIiwiZXgiLCJleSIsImNsb3NlZCIsImJlemllclRvUG9pbnRzIiwiZmxhdFBvaW50c1RvU2VnbWVudCIsImN1cnZpbmVzcyIsInBvaW50c1RvU2VnbWVudCIsImNvcm5lclRocmVzaG9sZCIsIm5leHRYIiwibmV4dFkiLCJkeDEiLCJkeDMiLCJkeTEiLCJkeTMiLCJkMSIsInBvaW50VG9TZWdEaXN0Iiwic2ltcGxpZnlTdGVwIiwidG9sZXJhbmNlIiwic2ltcGxpZmllZCIsIm1heFNxRGlzdCIsImZpcnN0WCIsImZpcnN0WSIsInNpbXBsaWZ5UG9pbnRzIiwiZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIiLCJpdGVyYXRpb25zIiwicHkiLCJzbGljZXMiLCJ4MCIsInkwIiwiYmVzdCIsImdldENsb3Nlc3REYXRhIiwiYmVzdERpc3RhbmNlIiwic3ViZGl2aWRlU2VnbWVudE5lYXIiLCJiZXN0VCIsImJlc3RTZWdtZW50SW5kZXgiLCJzbCIsIl9hc3luY1RvR2VuZXJhdG9yIiwiX3JlZ2VuZXJhdG9yUnVudGltZSIsIkF4aW9zIiwiZ2V0Q291bnRyaWVzQWxsIiwiX3giLCJfeDIiLCJfZ2V0Q291bnRyaWVzQWxsIiwibWFyayIsIl9jYWxsZWUiLCJjb21taXQiLCJyb290U3RhdGUiLCJyZXNwb25zZSIsIl90IiwiX2NvbnRleHQiLCJtZXRob2QiLCJzZW50Iiwic3RvcCIsImFjdGlvbnMiLCJWdWV4IiwiVnVlIiwidXNlIiwic3RvcmUiLCJTdG9yZSIsImNvdW50cmllc0FsbCIsIm11dGF0aW9ucyIsIlVQREFURV9DT1VOVFJJRVNfQUxMIiwicGF5bG9hZCIsImdldHRlcnMiLCJtb2R1bGVzIiwiQXBwIiwibWl4aW4iXSwic291cmNlUm9vdCI6IiJ9